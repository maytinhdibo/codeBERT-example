{"code": "function(primitive){\n          completed++;\n          if ( primitive ){\n            var geometry = new Terraformer.Primitive(primitive.geometry);\n            if (shapeGeometryTest(geometry, shape)){\n              if (self._stream) {\n                if (completed === found.length) {\n                  if (operationName == \"within\") {\n                    self._stream.emit(\"done\", primitive);\n                  } else {\n                    self._stream.emit(\"data\", primitive);\n                  }\n                  self._stream.emit(\"end\");\n                } else {\n                  self._stream.emit(\"data\", primitive);\n                }\n              } else {\n                results.push(primitive);\n              }\n            }\n\n            if(completed >= found.length){\n              if(!errors){\n                if (self._stream) {\n                  self._stream = null;\n                } else if (callback) {\n                  callback( null, results );\n                }\n              } else {\n                if (callback) {\n                  callback(\"Could not get all geometries\", null);\n                }\n              }\n            }\n          }\n        }", "label": 3}
{"code": "function SubStream(stream, name, options) {\n    if (!(this instanceof SubStream)) return new SubStream(stream, name, options);\n\n    options = options || {};\n\n    this.readyState = stream.readyState;  // Copy the current readyState.\n    this.stream = stream;                 // The underlaying stream.\n    this.name = name;                     // The stream namespace/name.\n    this.primus = options.primus;         // Primus reference.\n\n    //\n    // Register the SubStream on the socket.\n    //\n    if (!stream.streams) stream.streams = {};\n    if (!stream.streams[name]) stream.streams[name] = this;\n\n    Stream.call(this);\n\n    //\n    // No need to continue with the execution if we don't have any events that\n    // need to be proxied.\n    //\n    if (!options.proxy) return;\n\n    for (var i = 0, l = options.proxy.length, event; i < l; i++) {\n      event = options.proxy[i];\n      this.stream.on(event, this.emits(event));\n    }\n  }", "label": 3}
{"code": "public function show(string $package, string $path, Dashboard $dashboard)\n    {\n        $dir = $dashboard\n            ->getPublicDirectory()\n            ->get($package);\n\n        abort_if(is_null($dir), 404);\n\n        $resources = (new Finder())\n            ->ignoreUnreadableDirs()\n            ->followLinks()\n            ->in($dir)\n            ->files()\n            ->path(dirname($path))\n            ->name(basename($path));\n\n        $iterator = tap($resources->getIterator())\n            ->rewind();\n\n        $this->resource = $iterator->current();\n\n        abort_if(is_null($this->resource), 404);\n\n        $mime = new MimeTypes();\n        $mime = $mime->getMimeType($this->resource->getExtension());\n\n        return response()->file($this->resource->getRealPath(), [\n            'Content-Type'  => $mime ?? 'text/plain',\n            'Cache-Control' => 'public, max-age=31536000',\n        ]);\n    }", "label": 2}
{"code": "function parseConfigFileTextToJson(fileName, jsonText, stripComments) {\n        if (stripComments === void 0) { stripComments = true; }\n        try {\n            var jsonTextToParse = stripComments ? removeComments(jsonText) : jsonText;\n            return { config: /\\S/.test(jsonTextToParse) ? JSON.parse(jsonTextToParse) : {} };\n        }\n        catch (e) {\n            return { error: ts.createCompilerDiagnostic(ts.Diagnostics.Failed_to_parse_file_0_Colon_1, fileName, e.message) };\n        }\n    }", "label": 3}
{"code": "def from_file(file_path, incl_pot=True):\n    \"\"\"\n    Load catchment object from a ``.CD3`` or ``.xml`` file.\n\n    If there is also a corresponding ``.AM`` file (annual maximum flow data) or\n    a ``.PT`` file (peaks over threshold data) in the same folder as the CD3 file, these datasets will also be loaded.\n\n    :param file_path: Location of CD3 or xml file\n    :type file_path: str\n    :return: Catchment object with the :attr:`amax_records` and :attr:`pot_dataset` attributes set (if data available).\n    :rtype: :class:`.entities.Catchment`\n    :param incl_pot: Whether to load the POT (peaks-over-threshold) data. Default: ``True``.\n    :type incl_pot: bool\n    \"\"\"\n    filename, ext = os.path.splitext(file_path)\n    am_file_path = filename + '.AM'\n    pot_file_path = filename + '.PT'\n    parser_by_ext = {\n        '.cd3': parsers.Cd3Parser,\n        '.xml': parsers.XmlCatchmentParser\n    }\n    catchment = parser_by_ext[ext.lower()]().parse(file_path)\n\n    # AMAX records\n    try:\n        catchment.amax_records = parsers.AmaxParser().parse(am_file_path)\n    except FileNotFoundError:\n        catchment.amax_records = []\n\n    # POT records\n    if incl_pot:\n        try:\n            catchment.pot_dataset = parsers.PotParser().parse(pot_file_path)\n        except FileNotFoundError:\n            pass\n\n    return catchment", "label": 1}
{"code": "public LuaPreparedScript endPreparedScript(LuaScriptConfig config) {\n        if (!endsWithReturnStatement()) {\n            add(new LuaAstReturnStatement());\n        }\n        String scriptText = buildScriptText();\n        ArrayList<LuaKeyArgument> keyList = new ArrayList<>(keyArg2AstArg.keySet());\n        ArrayList<LuaValueArgument> argvList = new ArrayList<>(valueArg2AstArg.keySet());\n        if (config.isThreadSafe()) {\n            return new ThreadSafeLuaPreparedScript(scriptText, keyList, argvList, config);\n        } else {\n            return new BasicLuaPreparedScript(scriptText, keyList, argvList, config);\n        }\n    }", "label": 0}
{"code": "function child_nodes(node) {\n  var properties = NODE_TYPES[node[\"type\"]];\n\n  if (properties === undefined) {\n    console.error(\"FATAL\".red + \": Unknown node type: \" + node[\"type\"]);\n    console.trace();\n    process.exit(1);\n  }\n\n   var x = properties.map(function(p) {\n     return node[p];\n   });\n\n   return _.flatten(_.compact(x));\n}", "label": 3}
{"code": "def compute_filterrific_params(model_class, filterrific_params, opts, persistence_id)\n      opts = { \"sanitize_params\" => true }.merge(opts.stringify_keys)\n      r = (\n        filterrific_params.presence || # start with passed in params\n        (persistence_id && session[persistence_id].presence) || # then try session persisted params if persistence_id is present\n        opts['default_filter_params'] || # then use passed in opts\n        model_class.filterrific_default_filter_params # finally use model_class defaults\n      ).stringify_keys\n      r.slice!(*opts['available_filters'].map(&:to_s))  if opts['available_filters']\n      # Sanitize params to prevent reflected XSS attack\n      if opts[\"sanitize_params\"]\n        r.each { |k,v| r[k] = sanitize_filterrific_param(r[k]) }\n      end\n      r\n    end", "label": 4}
{"code": "public function setHttpRequest($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Logging\\Type\\HttpRequest::class);\n        $this->http_request = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function(callback) {\n      var queue;\n\n      if (exportedFunctionsNames.length === 0) {\n        callback();\n        return;\n      }\n\n      function taskFunc(task, callback) {\n        var setUpFunc = task.setUpFunc, tearDownFunc = task.tearDownFunc;\n\n        async.waterfall([\n          function runSetUp(callback) {\n            if (!setUpFunc) {\n              callback();\n              return;\n            }\n\n            var test = new Test(constants.SETUP_FUNCTION_NAME, setUpFunc,\n                                self._scopeLeaks);\n            test.run(onTestDone.bind(null, test, callback));\n          },\n\n          function runTest(callback) {\n            var test = task.test;\n            self._runningTest = test;\n            test.run(onTestDone.bind(null, test, callback));\n          },\n\n          function runTearDown(callback) {\n           if (!tearDownFunc) {\n              callback();\n              return;\n            }\n\n            var test = new Test(constants.TEARDOWN_FUNCTION_NAME, tearDownFunc,\n                                self._scopeLeaks);\n            test.run(onTestDone.bind(null, test, callback));\n          }\n        ], callback);\n      }\n\n      function onDrain() {\n        callback();\n      }\n\n      queue = async.queue(taskFunc, self._concurrency);\n      queue.drain = onDrain;\n\n      for (i = 0; i < testsLen; i++) {\n        testName = exportedFunctionsNames[i];\n        testFunc = exportedFunctions[testName];\n\n        if (!gex(self._pattern).on(testName)) {\n          continue;\n        }\n\n        test = new Test(testName, testFunc, self._scopeLeaks);\n        queue.push({'test': test, 'setUpFunc': setUpFunc, 'tearDownFunc': tearDownFunc});\n      }\n\n      if (queue.length() === 0) {\n        // No test matched the provided pattern\n        callback();\n      }\n    }", "label": 3}
{"code": "public void combine(CRFClassifier<IN> crf, double weight) {\r\n    Timing timer = new Timing();\r\n\r\n    // Check the CRFClassifiers are compatible\r\n    if (!this.pad.equals(crf.pad)) {\r\n      throw new RuntimeException(\"Incompatible CRFClassifier: pad does not match\");\r\n    }\r\n    if (this.windowSize != crf.windowSize) {\r\n      throw new RuntimeException(\"Incompatible CRFClassifier: windowSize does not match\");\r\n    }\r\n    if (this.labelIndices.length != crf.labelIndices.length) {\r\n      // Should match since this should be same as the windowSize\r\n      throw new RuntimeException(\"Incompatible CRFClassifier: labelIndices length does not match\");\r\n    }\r\n    this.classIndex.addAll(crf.classIndex.objectsList());\r\n\r\n    // Combine weights of the other classifier with this classifier,\r\n    // weighing the other classifier's weights by weight\r\n    // First merge the feature indicies\r\n    int oldNumFeatures1 = this.featureIndex.size();\r\n    int oldNumFeatures2 = crf.featureIndex.size();\r\n    int oldNumWeights1 = this.getNumWeights();\r\n    int oldNumWeights2 = crf.getNumWeights();\r\n    this.featureIndex.addAll(crf.featureIndex.objectsList());\r\n    this.knownLCWords.addAll(crf.knownLCWords);\r\n    assert (weights.length == oldNumFeatures1);\r\n\r\n    // Combine weights of this classifier with other classifier\r\n    for (int i = 0; i < labelIndices.length; i++) {\r\n      this.labelIndices[i].addAll(crf.labelIndices[i].objectsList());\r\n    }\r\n    System.err.println(\"Combining weights: will automatically match labelIndices\");\r\n    combineWeights(crf, weight);\r\n\r\n    int numFeatures = featureIndex.size();\r\n    int numWeights = getNumWeights();\r\n    long elapsedMs = timer.stop();\r\n    System.err.println(\"numFeatures: orig1=\" + oldNumFeatures1 + \", orig2=\" + oldNumFeatures2 + \", combined=\"\r\n        + numFeatures);\r\n    System.err\r\n        .println(\"numWeights: orig1=\" + oldNumWeights1 + \", orig2=\" + oldNumWeights2 + \", combined=\" + numWeights);\r\n    System.err.println(\"Time to combine CRFClassifier: \" + Timing.toSecondsString(elapsedMs) + \" seconds\");\r\n  }", "label": 0}
{"code": "def typed_fields(cls):\n        \"\"\"Return a tuple of this entity's TypedFields.\"\"\"\n\n        # Checking cls._typed_fields could return a superclass _typed_fields\n        # value. So we check our class __dict__ which does not include\n        # inherited attributes.\n        klassdict = cls.__dict__\n\n        try:\n            return klassdict[\"_typed_fields\"]\n        except KeyError:\n            fields = cls.typed_fields_with_attrnames()\n            cls._typed_fields = tuple(field for _, field in fields)\n        return cls._typed_fields", "label": 1}
{"code": "func readByte(conn net.Conn) (byte, error) {\n\tb := make([]byte, 1)\n\t_, err := io.ReadFull(conn, b)\n\tif err != nil {\n\t\treturn 0, trace.Wrap(err)\n\t}\n\n\treturn b[0], nil\n}", "label": 5}
{"code": "def find(path, type, setting)\n      value = nil\n      old_scope = nil\n\n      matching_sets(path, type).each do |set|\n        if set[\"values\"].key?(setting) && has_precedence?(old_scope, set[\"scope\"])\n          value = set[\"values\"][setting]\n          old_scope = set[\"scope\"]\n        end\n      end\n      value\n    end", "label": 4}
{"code": "function(entity, time, callback) {\n            var collection = new mongodb.Collection(this.db, \"__msg__\" + entity);\n            time = parseInt(time);\n            if (time || time === 0) {\n                collection.ensureIndex(\n                    { time: 1, id: 1 },\n                    { unique:true, background:true, w:1 },\n                    function(err, indexName) {\n                        var cursor = collection.find({ time: { $gt: time } });\n                        var id, lastMsg;\n                        cursor.sort([['id', 1], ['time', 1]]).each(function(err, msg) {\n                            if (msg && msg.id) {\n                                // the same id, merge document\n                                if (id && id === msg.id) {\n                                    if (lastMsg) {\n                                        msg = rest.mergeMessage(lastMsg, msg);\n                                    }\n                                } else if (lastMsg) {\n                                    // send the document to the client\n                                    callback(lastMsg);\n                                }\n                                lastMsg = msg;\n                                id = msg.id;\n                            } else {\n                                if (lastMsg) {\n                                    callback(lastMsg);\n                                }\n                                callback(null);\n                            }\n                        });\n                    }\n                );\n            } else {\n                callback(null);\n            }\n        }", "label": 3}
{"code": "func GetListenerFile(listener net.Listener) (*os.File, error) {\n\tswitch t := listener.(type) {\n\tcase *net.TCPListener:\n\t\treturn t.File()\n\tcase *net.UnixListener:\n\t\treturn t.File()\n\t}\n\treturn nil, trace.BadParameter(\"unsupported listener: %T\", listener)\n}", "label": 5}
{"code": "public static String padOrTrim(String str, int num) {\r\n    if (str == null) {\r\n      str = \"null\";\r\n    }\r\n    int leng = str.length();\r\n    if (leng < num) {\r\n      StringBuilder sb = new StringBuilder(str);\r\n      for (int i = 0; i < num - leng; i++) {\r\n        sb.append(' ');\r\n      }\r\n      return sb.toString();\r\n    } else if (leng > num) {\r\n      return str.substring(0, num);\r\n    } else {\r\n      return str;\r\n    }\r\n  }", "label": 0}
{"code": "public function subUnit($unit, $value = 1, $overflow = null)\n    {\n        return $this->addUnit($unit, -$value, $overflow);\n    }", "label": 2}
{"code": "def attach_file(file, filename: nil, spoiler: nil)\n      raise ArgumentError, 'Argument is not a file!' unless file.is_a?(File)\n\n      @file = file\n      @filename = filename\n      @file_spoiler = spoiler\n      nil\n    end", "label": 4}
{"code": "func (c *ChainInfo) Remove() error {\n\t// Ignore errors - This could mean the chains were never set up\n\tif c.Table == Nat {\n\t\tc.Prerouting(Delete, \"-m\", \"addrtype\", \"--dst-type\", \"LOCAL\", \"-j\", c.Name)\n\t\tc.Output(Delete, \"-m\", \"addrtype\", \"--dst-type\", \"LOCAL\", \"!\", \"--dst\", \"127.0.0.0/8\", \"-j\", c.Name)\n\t\tc.Output(Delete, \"-m\", \"addrtype\", \"--dst-type\", \"LOCAL\", \"-j\", c.Name) // Created in versions <= 0.1.6\n\n\t\tc.Prerouting(Delete)\n\t\tc.Output(Delete)\n\t}\n\tRaw(\"-t\", string(c.Table), \"-F\", c.Name)\n\tRaw(\"-t\", string(c.Table), \"-X\", c.Name)\n\treturn nil\n}", "label": 5}
{"code": "function() {\n                var i, thingName,\n                    names = arguments;\n                for ( i = 0, namesCount = names.length; i < namesCount; i += 1 ) {\n                    thingName = names[i]\n                    if ( thingName in STATE.methods ) {\n                        delete STATE.methods[thingName]\n                    }\n                }\n                return P\n            }", "label": 3}
{"code": "function extractLiterals(stats, args) {\n    if (stats.getType() != null && (stats.getType() === \"installed\" || stats.getType() === \"builtin\")) {\n        extractLiteralFromInstalled(stats, args);\n    }\n\n    if (stats.getType() != null && stats.getType() === \"def\") {\n        extractLiteralFromDef(stats, args[0]);\n    }\n\n    if (stats.getType() != null && (stats.getType() === \"main\" || stats.getType() === \"remap\")) {\n        extractLiteralFromMain(stats, args[0]);\n    }\n}", "label": 3}
{"code": "def determine_check_cron_time(check)\n      cron_parser = CronParser.new(check[:cron])\n      current_time = Time.now\n      next_cron_time = cron_parser.next(current_time)\n      next_cron_time - current_time\n    end", "label": 4}
{"code": "public static base_response add(nitro_service client, nsip6 resource) throws Exception {\n\t\tnsip6 addresource = new nsip6();\n\t\taddresource.ipv6address = resource.ipv6address;\n\t\taddresource.scope = resource.scope;\n\t\taddresource.type = resource.type;\n\t\taddresource.vlan = resource.vlan;\n\t\taddresource.nd = resource.nd;\n\t\taddresource.icmp = resource.icmp;\n\t\taddresource.vserver = resource.vserver;\n\t\taddresource.telnet = resource.telnet;\n\t\taddresource.ftp = resource.ftp;\n\t\taddresource.gui = resource.gui;\n\t\taddresource.ssh = resource.ssh;\n\t\taddresource.snmp = resource.snmp;\n\t\taddresource.mgmtaccess = resource.mgmtaccess;\n\t\taddresource.restrictaccess = resource.restrictaccess;\n\t\taddresource.dynamicrouting = resource.dynamicrouting;\n\t\taddresource.hostroute = resource.hostroute;\n\t\taddresource.ip6hostrtgw = resource.ip6hostrtgw;\n\t\taddresource.metric = resource.metric;\n\t\taddresource.vserverrhilevel = resource.vserverrhilevel;\n\t\taddresource.ospf6lsatype = resource.ospf6lsatype;\n\t\taddresource.ospfarea = resource.ospfarea;\n\t\taddresource.state = resource.state;\n\t\taddresource.map = resource.map;\n\t\taddresource.ownernode = resource.ownernode;\n\t\taddresource.td = resource.td;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public function getPaginators()\n    {\n        if (!isset($this->paginators)) {\n            $res = call_user_func(\n                $this->apiProvider,\n                'paginator',\n                $this->serviceName,\n                $this->apiVersion\n            );\n            $this->paginators = isset($res['pagination'])\n                ? $res['pagination']\n                : [];\n        }\n\n        return $this->paginators;\n    }", "label": 2}
{"code": "def upload_screenshot(app_version, upload_image, device, is_messages)\n      raise \"app_version is required\" unless app_version\n      raise \"upload_image is required\" unless upload_image\n      raise \"device is required\" unless device\n\n      du_client.upload_screenshot(app_version, upload_image, content_provider_id, sso_token_for_image, device, is_messages)\n    end", "label": 4}
{"code": "func (a *Agent) run() {\n\tdefer a.setState(agentStateDisconnected)\n\n\tif len(a.DiscoverProxies) != 0 {\n\t\ta.setStateAndPrincipals(agentStateDiscovering, nil)\n\t} else {\n\t\ta.setStateAndPrincipals(agentStateConnecting, nil)\n\t}\n\n\t// Try and connect to remote cluster.\n\tconn, err := a.connect()\n\tif err != nil || conn == nil {\n\t\ta.Warningf(\"Failed to create remote tunnel: %v, conn: %v.\", err, conn)\n\t\treturn\n\t}\n\n\t// Successfully connected to remote cluster.\n\ta.Infof(\"Connected to %s\", conn.RemoteAddr())\n\tif len(a.DiscoverProxies) != 0 {\n\t\t// If not connected to a proxy in the discover list (which means we\n\t\t// connected to a proxy we already have a connection to), try again.\n\t\tif !a.connectedToRightProxy() {\n\t\t\ta.Debugf(\"Missed, connected to %v instead of %v.\", a.getPrincipalsList(), Proxies(a.DiscoverProxies))\n\n\t\t\tconn.Close()\n\t\t\treturn\n\t\t}\n\t\ta.setState(agentStateDiscovered)\n\t} else {\n\t\ta.setState(agentStateConnected)\n\t}\n\n\t// Notify waiters that the agent has connected.\n\tif a.EventsC != nil {\n\t\tselect {\n\t\tcase a.EventsC <- ConnectedEvent:\n\t\tcase <-a.ctx.Done():\n\t\t\ta.Debug(\"Context is closing.\")\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t}\n\n\t// A connection has been established start processing requests. Note that\n\t// this function blocks while the connection is up. It will unblock when\n\t// the connection is closed either due to intermittent connectivity issues\n\t// or permanent loss of a proxy.\n\terr = a.processRequests(conn)\n\tif err != nil {\n\t\ta.Warnf(\"Unable to continue processesing requests: %v.\", err)\n\t\treturn\n\t}\n}", "label": 5}
{"code": "func (p *defaultModules) PrintVersion() {\n\tvar buf bytes.Buffer\n\n\tbuf.WriteString(fmt.Sprintf(\"Teleport v%s \", teleport.Version))\n\tbuf.WriteString(fmt.Sprintf(\"git:%s \", teleport.Gitref))\n\tbuf.WriteString(runtime.Version())\n\n\tfmt.Println(buf.String())\n}", "label": 5}
{"code": "function tryExtractTypeScriptExtension(fileName) {\n        return ts.find(ts.supportedTypescriptExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });\n    }", "label": 3}
{"code": "def update_channel(data)\n      channel = Channel.new(data, self)\n      old_channel = @channels[channel.id]\n      return unless old_channel\n\n      old_channel.update_from(channel)\n    end", "label": 4}
{"code": "def gsub(pat, rep)\n      inject(self.class.new) { |res, fn| res << fn.gsub(pat, rep) }\n    end", "label": 4}
{"code": "protected function processResults($results, $object = false)\n    {\n        $processor = new DataProcessor(\n            $results,\n            $this->getColumnsDefinition(),\n            $this->templates,\n            $this->request->input('start')\n        );\n\n        return $processor->process($object);\n    }", "label": 2}
{"code": "def load!(path, environment = nil)\n      settings = Environment.load_yaml(path, environment)\n      if settings.present?\n        Clients.disconnect\n        Clients.clear\n        load_configuration(settings)\n      end\n      settings\n    end", "label": 4}
{"code": "public function getWriteHash(): string\n    {\n        $hash = hash_final($this->write_hash, true);\n        if ($this->rev) {\n            $hash = strrev($hash);\n        }\n        $this->write_hash = null;\n        $this->write_check_after = 0;\n        $this->write_check_pos = 0;\n\n        return $hash;\n    }", "label": 2}
{"code": "function _gpfInterfaceQueryThroughIUnknown(interfaceSpecifier, queriedObject) {\n        var result = queriedObject.queryInterface(interfaceSpecifier);\n        _gpfAssert(result === null || _gpfInterfaceIsImplementedBy(interfaceSpecifier, result), \"Invalid result of queryInterface (must be null or an object implementing the interface)\");\n        return result;\n    }", "label": 3}
{"code": "function deepExtend(target, source) {\n  _.each(source, function(value, key) {\n    if (_.has(target, key) && isObject(target[key]) && isObject(source[key])) {\n      deepExtend(target[key], source[key]);\n    } else {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}", "label": 3}
{"code": "def debug(cls, name, message, *args):\n        \"\"\"\n        Convenience function to log a message at the DEBUG level.\n\n        :param name:    The name of the logger instance in the VSG namespace (VSG.<name>)\n        :param message: A message format string.\n        :param args:    The arguments that are are merged into msg using the string formatting operator.\n        :..note:        The native logger's `kwargs` are not used in this function.\n        \"\"\"\n        cls.getLogger(name).debug(message, *args)", "label": 1}
{"code": "def apply_default(name)\n      unless attributes.key?(name)\n        if field = fields[name]\n          default = field.eval_default(self)\n          unless default.nil? || field.lazy?\n            attribute_will_change!(name)\n            attributes[name] = default\n          end\n        end\n      end\n    end", "label": 4}
{"code": "def next(self):\n        \"\"\"\n        Returns the next result from the chained iterables given ``\"stride\"``.\n        \n        \"\"\"\n        if self.s:\n            self.s -= 1\n        else:\n            self.s = self.stride - 1\n            self.i = (self.i + 1) % self.l # new iterable\n        return self.iterables[self.i].next()", "label": 1}
{"code": "function (obj) {\n            var funcNameRegex = /function (.{1,})\\(/;\n            var results = (funcNameRegex).exec((obj).constructor.toString());\n            var typeName = (results && results.length > 1) ? results[1] : \"\";\n\n            return 'views/' + typeName;\n        }", "label": 3}
{"code": "public static base_responses add(nitro_service client, gslbservice resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tgslbservice addresources[] = new gslbservice[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new gslbservice();\n\t\t\t\taddresources[i].servicename = resources[i].servicename;\n\t\t\t\taddresources[i].cnameentry = resources[i].cnameentry;\n\t\t\t\taddresources[i].ip = resources[i].ip;\n\t\t\t\taddresources[i].servername = resources[i].servername;\n\t\t\t\taddresources[i].servicetype = resources[i].servicetype;\n\t\t\t\taddresources[i].port = resources[i].port;\n\t\t\t\taddresources[i].publicip = resources[i].publicip;\n\t\t\t\taddresources[i].publicport = resources[i].publicport;\n\t\t\t\taddresources[i].maxclient = resources[i].maxclient;\n\t\t\t\taddresources[i].healthmonitor = resources[i].healthmonitor;\n\t\t\t\taddresources[i].sitename = resources[i].sitename;\n\t\t\t\taddresources[i].state = resources[i].state;\n\t\t\t\taddresources[i].cip = resources[i].cip;\n\t\t\t\taddresources[i].cipheader = resources[i].cipheader;\n\t\t\t\taddresources[i].sitepersistence = resources[i].sitepersistence;\n\t\t\t\taddresources[i].cookietimeout = resources[i].cookietimeout;\n\t\t\t\taddresources[i].siteprefix = resources[i].siteprefix;\n\t\t\t\taddresources[i].clttimeout = resources[i].clttimeout;\n\t\t\t\taddresources[i].svrtimeout = resources[i].svrtimeout;\n\t\t\t\taddresources[i].maxbandwidth = resources[i].maxbandwidth;\n\t\t\t\taddresources[i].downstateflush = resources[i].downstateflush;\n\t\t\t\taddresources[i].maxaaausers = resources[i].maxaaausers;\n\t\t\t\taddresources[i].monthreshold = resources[i].monthreshold;\n\t\t\t\taddresources[i].hashid = resources[i].hashid;\n\t\t\t\taddresources[i].comment = resources[i].comment;\n\t\t\t\taddresources[i].appflowlog = resources[i].appflowlog;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function getPropertyName(parentName, parent, indexer) {\r\n\t\tvar propertyName = parentName || \"\";\r\n\t\tif (exports.getType(parent) === \"array\") {\r\n\t\t\tif (parentName) {\r\n\t\t\t\tpropertyName += \"[\" + indexer + \"]\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (parentName) {\r\n\t\t\t\tpropertyName += \".\";\r\n\t\t\t}\r\n\t\t\tpropertyName += indexer;\r\n\t\t}\r\n\t\treturn propertyName;\r\n\t}", "label": 3}
{"code": "public function accept()\n    {\n        $candidate = $this->getInnerIterator()->current();\n\n        // Check that the candidate file (a full file path) ends in the pattern we are searching for.\n        return strrpos($candidate, $this->file) === strlen($candidate) - strlen($this->file);\n    }", "label": 2}
{"code": "func (l *LogAction) Log(level, format string, args ...interface{}) predicate.BoolPredicate {\n\treturn func() bool {\n\t\tilevel, err := log.ParseLevel(level)\n\t\tif err != nil {\n\t\t\tilevel = log.DebugLevel\n\t\t}\n\t\tvar writer io.Writer\n\t\tif l.writer != nil {\n\t\t\twriter = l.writer\n\t\t} else {\n\t\t\twriter = log.StandardLogger().WriterLevel(ilevel)\n\t\t}\n\t\twriter.Write([]byte(fmt.Sprintf(format, args...)))\n\t\treturn true\n\t}\n}", "label": 5}
{"code": "def renew(token, increment = 0, options = {})\n      headers = extract_headers!(options)\n      json = client.put(\"/v1/auth/token/renew\", JSON.fast_generate(\n        token: token,\n        increment: increment,\n      ), headers)\n      return Secret.decode(json)\n    end", "label": 4}
{"code": "public static base_response add(nitro_service client, authenticationradiusaction resource) throws Exception {\n\t\tauthenticationradiusaction addresource = new authenticationradiusaction();\n\t\taddresource.name = resource.name;\n\t\taddresource.serverip = resource.serverip;\n\t\taddresource.serverport = resource.serverport;\n\t\taddresource.authtimeout = resource.authtimeout;\n\t\taddresource.radkey = resource.radkey;\n\t\taddresource.radnasip = resource.radnasip;\n\t\taddresource.radnasid = resource.radnasid;\n\t\taddresource.radvendorid = resource.radvendorid;\n\t\taddresource.radattributetype = resource.radattributetype;\n\t\taddresource.radgroupsprefix = resource.radgroupsprefix;\n\t\taddresource.radgroupseparator = resource.radgroupseparator;\n\t\taddresource.passencoding = resource.passencoding;\n\t\taddresource.ipvendorid = resource.ipvendorid;\n\t\taddresource.ipattributetype = resource.ipattributetype;\n\t\taddresource.accounting = resource.accounting;\n\t\taddresource.pwdvendorid = resource.pwdvendorid;\n\t\taddresource.pwdattributetype = resource.pwdattributetype;\n\t\taddresource.defaultauthenticationgroup = resource.defaultauthenticationgroup;\n\t\taddresource.callingstationid = resource.callingstationid;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "function getForInVariableSymbol(node) {\n            var initializer = node.initializer;\n            if (initializer.kind === 219 /* VariableDeclarationList */) {\n                var variable = initializer.declarations[0];\n                if (variable && !ts.isBindingPattern(variable.name)) {\n                    return getSymbolOfNode(variable);\n                }\n            }\n            else if (initializer.kind === 69 /* Identifier */) {\n                return getResolvedSymbol(initializer);\n            }\n            return undefined;\n        }", "label": 3}
{"code": "def compare_clades(pw):\n    \"\"\"\n    print min. pident within each clade and then matrix of between-clade max.\n    \"\"\"\n    names = sorted(set([i for i in pw]))\n    for i in range(0, 4):\n        wi, bt = {}, {}\n        for a in names:\n            for b in pw[a]:\n                if ';' not in a or ';' not in b:\n                    continue\n                pident = pw[a][b]\n                cA, cB = a.split(';')[i], b.split(';')[i]\n                if i == 0 and '_' in cA and '_' in cB:\n                    cA = cA.rsplit('_', 1)[1]\n                    cB = cB.rsplit('_', 1)[1]\n                elif '>' in cA or '>' in cB:\n                    cA = cA.split('>')[1]\n                    cB = cB.split('>')[1]\n                if cA == cB:\n                    if cA not in wi:\n                        wi[cA] = []\n                    wi[cA].append(pident)\n                else:\n                    if cA not in bt:\n                        bt[cA] = {}\n                    if cB not in bt[cA]:\n                        bt[cA][cB] = []\n                    bt[cA][cB].append(pident)\n        print('\\n# min. within')\n        for clade, pidents in list(wi.items()):\n            print('\\t'.join(['wi:%s' % str(i), clade, str(min(pidents))]))\n        # print matrix of maximum between groups\n        comps = []\n        print('\\n# max. between')\n        for comp in print_pairwise(bt):\n            if comp is not None:\n                print('\\t'.join(['bt:%s' % str(i)] + [str(j) for j in comp]))\n                if comp[0] != '#':\n                    comps.extend([j for j in comp[1:] if j != '-'])\n        print_comps(comps)\n        # print matrix of median between groups\n        comps = []\n        print('\\n# median between')\n        for comp in print_pairwise(bt, median = True):\n            if comp is not None:\n                print('\\t'.join(['bt:%s' % str(i)] + [str(j) for j in comp]))\n                if comp[0] != '#':\n                    comps.extend([j for j in comp[1:] if j != '-'])\n        print_comps(comps)", "label": 1}
{"code": "public static auditsyslogpolicy_aaauser_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauditsyslogpolicy_aaauser_binding obj = new auditsyslogpolicy_aaauser_binding();\n\t\tobj.set_name(name);\n\t\tauditsyslogpolicy_aaauser_binding response[] = (auditsyslogpolicy_aaauser_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def from_error(exc_info, json_encoder, debug_url=None):\n        \"\"\"Wraps another Exception in an InternalError.\n\n        :param exc_info: The exception info for the wrapped exception\n        :type exc_info: (type, object, traceback)\n        :type json_encoder: json.JSONEncoder\n        :type debug_url: str | None\n        :rtype: InternalError\n\n        .. versionadded:: 0.1.0\n        .. versionchanged:: 0.2.0\n            Stringifies non-JSON-serializable objects\n        \"\"\"\n        exc = exc_info[1]\n        data = exc.__dict__.copy()\n        for key, value in data.items():\n            try:\n                json_encoder.encode(value)\n            except TypeError:\n                data[key] = repr(value)\n        data[\"traceback\"] = \"\".join(traceback.format_exception(*exc_info))\n        if debug_url is not None:\n            data[\"debug_url\"] = debug_url\n        return InternalError(data)", "label": 1}
{"code": "public static vpath_stats get(nitro_service service) throws Exception{\n\t\tvpath_stats obj = new vpath_stats();\n\t\tvpath_stats[] response = (vpath_stats[])obj.stat_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def write_bus_data(self, file):\n        \"\"\" Writes bus data to a ReST table.\n        \"\"\"\n        report = CaseReport(self.case)\n        buses = self.case.buses\n\n        col_width = 8\n        col_width_2 = col_width * 2 + 1\n        col1_width = 6\n\n        sep = \"=\" * 6 + \" \" + (\"=\" * col_width + \" \") * 6 + \"\\n\"\n\n        file.write(sep)\n        # Line one of column headers\n        file.write(\"Name\".center(col1_width) + \" \")\n        file.write(\"Voltage (pu)\".center(col_width_2) + \" \")\n        file.write(\"Generation\".center(col_width_2) + \" \")\n        file.write(\"Load\".center(col_width_2) + \" \")\n        file.write(\"\\n\")\n\n        file.write(\"-\" * col1_width +\" \"+ (\"-\" * col_width_2 + \" \") * 3 + \"\\n\")\n\n        # Line two of column header\n        file.write(\"..\".ljust(col1_width) + \" \")\n        file.write(\"Amp\".center(col_width) + \" \")\n        file.write(\"Phase\".center(col_width) + \" \")\n        file.write(\"P (MW)\".center(col_width) + \" \")\n        file.write(\"Q (MVAr)\".center(col_width) + \" \")\n        file.write(\"P (MW)\".center(col_width) + \" \")\n        file.write(\"Q (MVAr)\".center(col_width) + \" \")\n        file.write(\"\\n\")\n\n        file.write(sep)\n\n        # Bus rows\n        for bus in buses:\n            file.write(bus.name[:col1_width].ljust(col1_width))\n            file.write(\" %8.3f\" % bus.v_magnitude)\n            file.write(\" %8.3f\" % bus.v_angle)\n            file.write(\" %8.2f\" % self.case.s_supply(bus).real)\n            file.write(\" %8.2f\" % self.case.s_supply(bus).imag)\n            file.write(\" %8.2f\" % self.case.s_demand(bus).real)\n            file.write(\" %8.2f\" % self.case.s_demand(bus).imag)\n            file.write(\"\\n\")\n\n        # Totals\n#        file.write(\"..\".ljust(col1_width) + \" \")\n#        file.write((\"..\".ljust(col_width) + \" \")*2)\n#        file.write((\"_\"*col_width + \" \")*4 + \"\\n\")\n        file.write(\"..\".ljust(col1_width) + \" \" + \"..\".ljust(col_width) + \" \")\n        file.write(\"*Total:*\".rjust(col_width) + \" \")\n        ptot = report.actual_pgen\n        qtot = report.actual_qgen\n        file.write(\"%8.2f \" % ptot)\n        file.write(\"%8.2f \" % qtot)\n        file.write(\"%8.2f \" % report.p_demand)\n        file.write(\"%8.2f \" % report.q_demand)\n        file.write(\"\\n\")\n        file.write(sep)\n        del report", "label": 1}
{"code": "def load_balancer(service)\n      load_balancer = service.load_balancers.first\n      return unless load_balancer\n\n      resp = elb.describe_target_groups(\n        target_group_arns: [load_balancer.target_group_arn]\n      )\n      target_group = resp.target_groups.first\n      load_balancer_arn = target_group.load_balancer_arns.first # assume first only\n\n      resp = elb.describe_load_balancers(load_balancer_arns: [load_balancer_arn])\n      resp.load_balancers.first\n    end", "label": 4}
{"code": "def check_valid_bs_range(date):\n    \"\"\"\n    Checks if the nepali date is in valid range for conversion\n    \"\"\"\n    ERR_MSG = \"%s out of range\" % str(date)\n\n    if date.year < values.START_NP_YEAR or date.year > values.END_NP_YEAR:\n        raise ValueError(ERR_MSG)\n    if date.month < 1 or date.month > 12:\n        raise ValueError(ERR_MSG)\n    if date.day < 1 or date.day > values.NEPALI_MONTH_DAY_DATA[date.year][date.month - 1]:\n        raise ValueError(ERR_MSG)\n    return True", "label": 1}
{"code": "def count_lines_of_code(self, fname=''):\n        \"\"\" counts non blank lines \"\"\"\n        if fname == '':\n            fname = self.fullname\n        loc = 0    \n        try:\n            with open(fname) as f:\n                for l in f:\n                    if l.strip() != '':\n                        loc += 1\n            return loc    \n        except Exception as ex:\n            print('cant count lines of code in \"', fname, '\":', str(ex))\n            return 0", "label": 1}
{"code": "function (source, target, res) {\n        if (!module.exports.operations.canDiff || !module.exports.operations.diff) {\n            log.warn('Difference operation not implemented by application');\n            Utils.sendMessage(res, HttpStatus.NOT_IMPLEMENTED, JSON.stringify({ error: 'operation not implemented' }));\n        } else if (Utils.isNullOrEmpty(target)) {\n            log.error('Target state not provided');\n            Utils.sendMessage(res, HttpStatus.BAD_REQUEST, JSON.stringify({ error: 'invalid states' }));\n        } else if (!module.exports.operations.canDiff(source, target)) {\n            log.error('Unable to get difference from source:', source, 'to target:', target);\n            Utils.sendMessage(res, HttpStatus.BAD_REQUEST, JSON.stringify({ error: 'invalid states' }));\n        } else {\n            const result = module.exports.operations.diff(source, target);\n            log.debug('Successfully computed difference', result, 'from source:', source, 'to target:', target);\n            Utils.sendMessage(res, HttpStatus.OK, JSON.stringify(result));\n        }\n    }", "label": 3}
{"code": "public PreparedStatement getInsertStatement(ClassDescriptor cds) throws PersistenceBrokerSQLException, PersistenceBrokerException\r\n    {\r\n        try\r\n        {\r\n            return cds.getStatementsForClass(m_conMan).getInsertStmt(m_conMan.getConnection());\r\n        }\r\n        catch (SQLException e)\r\n        {\r\n            throw new PersistenceBrokerSQLException(\"Could not build statement ask for\", e);\r\n        }\r\n        catch (LookupException e)\r\n        {\r\n            throw new PersistenceBrokerException(\"Used ConnectionManager instance could not obtain a connection\", e);\r\n        }\r\n    }", "label": 0}
{"code": "function (routeConfig, methodValue) {\n        var rateLimits = [];\n        var environment = Shared.config(\"environment\");\n        var globalRateLimit = environment.rateLimit;\n        if (globalRateLimit) {\n            if (globalRateLimit.interval && _.isNumber(globalRateLimit.interval) && parseInt(globalRateLimit.interval) > 0 && globalRateLimit.maxRequests && _.isNumber(globalRateLimit.maxRequests) && parseInt(globalRateLimit.maxRequests) > 0) {\n                rateLimits.push(globalRateLimit);\n            }\n            else {\n                throw new Error('Global rate limit config invalid' + \". Provide parameters 'interval' and 'maxRequests' with Int value\");\n            }\n        }\n        if (routeConfig && routeConfig.rateLimit) {\n            if (routeConfig.rateLimit.interval && _.isNumber(routeConfig.rateLimit.interval) && parseInt(routeConfig.rateLimit.interval) > 0 && routeConfig.rateLimit.maxRequests && _.isNumber(routeConfig.rateLimit.maxRequests) && parseInt(routeConfig.rateLimit.maxRequests) > 0) {\n                rateLimits.push(routeConfig.rateLimit);\n            }\n            else {\n                throw new Error('Rate limit config invalid for route file ' + routeConfig.prefix + \". Provide parameters 'interval' and 'maxRequests' with Int value\");\n            }\n        }\n        if (methodValue && methodValue.rateLimit) {\n            if (methodValue.rateLimit.interval && _.isNumber(methodValue.rateLimit.interval) && parseInt(methodValue.rateLimit.interval) > 0 && methodValue.rateLimit.maxRequests && _.isNumber(methodValue.rateLimit.maxRequests) && parseInt(methodValue.rateLimit.maxRequests) > 0) {\n                rateLimits.push(methodValue.rateLimit);\n            }\n            else {\n                throw new Error('Rate limit config invalid for route ' + methodValue.identity + ' in route file ' + routeConfig.prefix + \". Provide parameters 'interval' and 'maxRequests' with Int value\");\n            }\n        }\n\n        if (!_.isEmpty(rateLimits) && !Shared.memcached()) {\n            throw new Error(\"Rate limits set but memcached not configured. Provide settings for memcached in environment config file\");\n        }\n\n        return rateLimits;\n    }", "label": 3}
{"code": "public static dnsnsrec[] get(nitro_service service) throws Exception{\n\t\tdnsnsrec obj = new dnsnsrec();\n\t\tdnsnsrec[] response = (dnsnsrec[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def to_bytes(s):\n    '''Return s as a bytes type, using utf-8 encoding if necessary.\n    @param s string or bytes\n    @return bytes\n    '''\n    if isinstance(s, six.binary_type):\n        return s\n    if isinstance(s, six.string_types):\n        return s.encode('utf-8')\n    raise TypeError('want string or bytes, got {}', type(s))", "label": 1}
{"code": "private void bindProcedure(PreparedStatement stmt, ClassDescriptor cld, Object obj, ProcedureDescriptor proc)\r\n            throws SQLException\r\n    {\r\n        int valueSub = 0;\r\n\r\n        // Figure out if we are using a callable statement.  If we are, then we\r\n        // will need to register one or more output parameters.\r\n        CallableStatement callable = null;\r\n        try\r\n        {\r\n            callable = (CallableStatement) stmt;\r\n        }\r\n        catch(Exception e)\r\n        {\r\n            m_log.error(\"Error while bind values for class '\" + (cld != null ? cld.getClassNameOfObject() : null)\r\n                    + \"', using stored procedure: \"+ proc, e);\r\n            if(e instanceof SQLException)\r\n            {\r\n                throw (SQLException) e;\r\n            }\r\n            else\r\n            {\r\n                throw new PersistenceBrokerException(\"Unexpected error while bind values for class '\"\r\n                        + (cld != null ? cld.getClassNameOfObject() : null) + \"', using stored procedure: \"+ proc);\r\n            }\r\n        }\r\n\r\n        // If we have a return value, then register it.\r\n        if ((proc.hasReturnValue()) && (callable != null))\r\n        {\r\n            int jdbcType = proc.getReturnValueFieldRef().getJdbcType().getType();\r\n            m_platform.setNullForStatement(stmt, valueSub + 1, jdbcType);\r\n            callable.registerOutParameter(valueSub + 1, jdbcType);\r\n            valueSub++;\r\n        }\r\n\r\n        // Process all of the arguments.\r\n        Iterator iterator = proc.getArguments().iterator();\r\n        while (iterator.hasNext())\r\n        {\r\n            ArgumentDescriptor arg = (ArgumentDescriptor) iterator.next();\r\n            Object val = arg.getValue(obj);\r\n            int jdbcType = arg.getJdbcType();\r\n            setObjectForStatement(stmt, valueSub + 1, val, jdbcType);\r\n            if ((arg.getIsReturnedByProcedure()) && (callable != null))\r\n            {\r\n                callable.registerOutParameter(valueSub + 1, jdbcType);\r\n            }\r\n            valueSub++;\r\n        }\r\n    }", "label": 0}
{"code": "func GetBoolean(data []byte, keys ...string) (val bool, err error) {\n\tv, t, _, e := Get(data, keys...)\n\n\tif e != nil {\n\t\treturn false, e\n\t}\n\n\tif t != Boolean {\n\t\treturn false, fmt.Errorf(\"Value is not a boolean: %s\", string(v))\n\t}\n\n\treturn ParseBoolean(v)\n}", "label": 5}
{"code": "function loadingStateGetter() {\n\tif (Object.keys(this._syncers).length > 0) {\n\t\treturn some(this._syncers, syncer => {\n\t\t\treturn syncer.loading\n\t\t})\n\t}\n\treturn false\n}", "label": 3}
{"code": "public final void end() {\n    final Thread thread = threadRef;\n    if (thread != null) {\n      thread.interrupt();\n      try {\n        thread.join();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n    this.threadRef = null;\n  }", "label": 0}
{"code": "def _update_property_keys(cls):\n        \"\"\"Set unspecified property_keys for each ConfigProperty to the name of the class attr\"\"\"\n        for attr_name, config_prop in cls._iter_config_props():\n            if config_prop.property_key is None:\n                config_prop.property_key = attr_name", "label": 1}
{"code": "def process_configured_plugins\n      return if !Vagrant.plugins_enabled?\n      errors = vagrantfile.config.vagrant.validate(nil)\n      if !errors[\"vagrant\"].empty?\n        raise Errors::ConfigInvalid,\n          errors: Util::TemplateRenderer.render(\n            \"config/validation_failed\",\n            errors: errors)\n      end\n      # Check if defined plugins are installed\n      installed = Plugin::Manager.instance.installed_plugins\n      needs_install = []\n      config_plugins = vagrantfile.config.vagrant.plugins\n      config_plugins.each do |name, info|\n        if !installed[name]\n          needs_install << name\n        end\n      end\n      if !needs_install.empty?\n        ui.warn(I18n.t(\"vagrant.plugins.local.uninstalled_plugins\",\n          plugins: needs_install.sort.join(\", \")))\n        if !Vagrant.auto_install_local_plugins?\n          answer = nil\n          until [\"y\", \"n\"].include?(answer)\n            answer = ui.ask(I18n.t(\"vagrant.plugins.local.request_plugin_install\") + \" [N]: \")\n            answer = answer.strip.downcase\n            answer = \"n\" if answer.to_s.empty?\n          end\n          if answer == \"n\"\n            raise Errors::PluginMissingLocalError,\n              plugins: needs_install.sort.join(\", \")\n          end\n        end\n        needs_install.each do |name|\n          pconfig = Util::HashWithIndifferentAccess.new(config_plugins[name])\n          ui.info(I18n.t(\"vagrant.commands.plugin.installing\", name: name))\n\n          options = {sources: Vagrant::Bundler::DEFAULT_GEM_SOURCES.dup, env_local: true}\n          options[:sources] = pconfig[:sources] if pconfig[:sources]\n          options[:require] = pconfig[:entry_point] if pconfig[:entry_point]\n          options[:version] = pconfig[:version] if pconfig[:version]\n\n          spec = Plugin::Manager.instance.install_plugin(name, options)\n\n          ui.info(I18n.t(\"vagrant.commands.plugin.installed\",\n            name: spec.name, version: spec.version.to_s))\n        end\n        ui.info(\"\\n\")\n        # Force halt after installation and require command to be run again. This\n        # will proper load any new locally installed plugins which are now available.\n        ui.warn(I18n.t(\"vagrant.plugins.local.install_rerun_command\"))\n        exit(-1)\n      end\n      Vagrant::Plugin::Manager.instance.local_file.installed_plugins\n    end", "label": 4}
{"code": "func (c *Manager) CreateTag(ctx context.Context, tag *Tag) (string, error) {\n\t// create avoids the annoyance of CreateTag requiring a \"description\" key to be included in the request,\n\t// even though the field value can be empty.\n\ttype create struct {\n\t\tName        string `json:\"name\"`\n\t\tDescription string `json:\"description\"`\n\t\tCategoryID  string `json:\"category_id\"`\n\t}\n\tspec := struct {\n\t\tTag create `json:\"create_spec\"`\n\t}{\n\t\tTag: create{\n\t\t\tName:        tag.Name,\n\t\t\tDescription: tag.Description,\n\t\t\tCategoryID:  tag.CategoryID,\n\t\t},\n\t}\n\tif isName(tag.CategoryID) {\n\t\tcat, err := c.GetCategory(ctx, tag.CategoryID)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tspec.Tag.CategoryID = cat.ID\n\t}\n\turl := internal.URL(c, internal.TagPath)\n\tvar res string\n\treturn res, c.Do(ctx, url.Request(http.MethodPost, spec), &res)\n}", "label": 5}
{"code": "public function setSecurityMarks($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\SecurityCenter\\V1\\SecurityMarks::class);\n        $this->security_marks = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def debug(*messages)\n      longest = messages.max_by(&:length).size\n      width = TTY::Screen.width - longest\n      print cursor.save\n      messages.each_with_index do |msg, i|\n        print cursor.move_to(width, i)\n        print cursor.clear_line_after\n        print msg\n      end\n      print cursor.restore\n    end", "label": 4}
{"code": "public static base_response create(nitro_service client, systembackup resource) throws Exception {\n\t\tsystembackup createresource = new systembackup();\n\t\tcreateresource.filename = resource.filename;\n\t\tcreateresource.level = resource.level;\n\t\tcreateresource.comment = resource.comment;\n\t\treturn createresource.perform_operation(client,\"create\");\n\t}", "label": 0}
{"code": "public static function urlMatches($urlRegexp)\n    {\n        return new static(\n            function (WebDriver $driver) use ($urlRegexp) {\n                return (bool) preg_match($urlRegexp, $driver->getCurrentURL());\n            }\n        );\n    }", "label": 2}
{"code": "public void add(ServiceReference<D> declarationSRef) {\n        D declaration = getDeclaration(declarationSRef);\n        boolean matchFilter = declarationFilter.matches(declaration.getMetadata());\n        declarations.put(declarationSRef, matchFilter);\n    }", "label": 0}
{"code": "func New(cfgOptions ...config.Option) (NetworkController, error) {\n\tc := &controller{\n\t\tid:               stringid.GenerateRandomID(),\n\t\tcfg:              config.ParseConfigOptions(cfgOptions...),\n\t\tsandboxes:        sandboxTable{},\n\t\tsvcRecords:       make(map[string]svcInfo),\n\t\tserviceBindings:  make(map[serviceKey]*service),\n\t\tagentInitDone:    make(chan struct{}),\n\t\tnetworkLocker:    locker.New(),\n\t\tDiagnosticServer: diagnostic.New(),\n\t}\n\tc.DiagnosticServer.Init()\n\n\tif err := c.initStores(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tdrvRegistry, err := drvregistry.New(c.getStore(datastore.LocalScope), c.getStore(datastore.GlobalScope), c.RegisterDriver, nil, c.cfg.PluginGetter)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, i := range getInitializers(c.cfg.Daemon.Experimental) {\n\t\tvar dcfg map[string]interface{}\n\n\t\t// External plugins don't need config passed through daemon. They can\n\t\t// bootstrap themselves\n\t\tif i.ntype != \"remote\" {\n\t\t\tdcfg = c.makeDriverConfig(i.ntype)\n\t\t}\n\n\t\tif err := drvRegistry.AddDriver(i.ntype, i.fn, dcfg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err = initIPAMDrivers(drvRegistry, nil, c.getStore(datastore.GlobalScope), c.cfg.Daemon.DefaultAddressPool); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.drvRegistry = drvRegistry\n\n\tif c.cfg != nil && c.cfg.Cluster.Watcher != nil {\n\t\tif err := c.initDiscovery(c.cfg.Cluster.Watcher); err != nil {\n\t\t\t// Failing to initialize discovery is a bad situation to be in.\n\t\t\t// But it cannot fail creating the Controller\n\t\t\tlogrus.Errorf(\"Failed to Initialize Discovery : %v\", err)\n\t\t}\n\t}\n\n\tc.WalkNetworks(populateSpecial)\n\n\t// Reserve pools first before doing cleanup. Otherwise the\n\t// cleanups of endpoint/network and sandbox below will\n\t// generate many unnecessary warnings\n\tc.reservePools()\n\n\t// Cleanup resources\n\tc.sandboxCleanup(c.cfg.ActiveSandboxes)\n\tc.cleanupLocalEndpoints()\n\tc.networkCleanup()\n\n\tif err := c.startExternalKeyListener(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c, nil\n}", "label": 5}
{"code": "def upvote\n      begin\n        client.post(\"/cards/#{id}/membersVoted\", {\n          value: me.id\n        })\n      rescue Trello::Error => e\n        fail e unless e.message =~ /has already voted/i\n      end\n\n      self\n    end", "label": 4}
{"code": "public static function addSettings(array $defaults)\n    {\n        return [\n            'up' => function (Builder $schema) use ($defaults) {\n                $settings = new DatabaseSettingsRepository(\n                    $schema->getConnection()\n                );\n\n                foreach ($defaults as $key => $value) {\n                    $settings->set($key, $value);\n                }\n            },\n            'down' => function (Builder $schema) use ($defaults) {\n                $settings = new DatabaseSettingsRepository(\n                    $schema->getConnection()\n                );\n\n                foreach (array_keys($defaults) as $key) {\n                    $settings->delete($key);\n                }\n            }\n        ];\n    }", "label": 2}
{"code": "func (l *LoadBalancer) ListenAndServe() error {\n\tif err := l.Listen(); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\treturn l.Serve()\n}", "label": 5}
{"code": "def created(self):\n        \"\"\"Return creation date\n\n        :rtype: datetime\n        :raises ResourceNotFound: resource not found on the API\n        \"\"\"\n        if 'id_perms' not in self:\n            self.fetch()\n        created = self['id_perms']['created']\n        return datetime.strptime(created, '%Y-%m-%dT%H:%M:%S.%f')", "label": 1}
{"code": "def _clipPrices(self):\n        \"\"\" Clip cleared prices according to guarantees and limits.\n        \"\"\"\n        # Guarantee that cleared offer prices are >= offers.\n        if self.guaranteeOfferPrice:\n            for offer in self.offers:\n                if offer.accepted and offer.clearedPrice < offer.price:\n                    offer.clearedPrice = offer.price\n\n        # Guarantee that cleared bid prices are <= bids.\n        if self.guaranteeBidPrice:\n            for bid in self.bids:\n                if bid.accepted and bid.clearedPrice > bid.price:\n                    bid.clearedPrice = bid.price\n\n        # Clip cleared offer prices.\n        if self.limits.has_key(\"maxClearedOffer\"):\n            maxClearedOffer = self.limits[\"maxClearedOffer\"]\n\n            for offer in self.offers:\n                if offer.clearedPrice > maxClearedOffer:\n                    offer.clearedPrice = maxClearedOffer\n\n        # Clip cleared bid prices.\n        if self.limits.has_key(\"minClearedBid\"):\n            minClearedBid = self.limits[\"minClearedBid\"]\n\n            for bid in self.bids:\n                if bid.clearedPrice < minClearedBid:\n                    bid.clearedPrice = minClearedBid\n\n        # Make prices uniform across all offers/bids for each generator after\n        # clipping (except for discrim auction) since clipping may only affect\n        # a single block of a multi-block generator.\n        if self.auctionType != DISCRIMINATIVE:\n            for g in self.case.generators:\n                gOffers = [of for of in self.offers if of.generator == g]\n                if gOffers:\n                    uniformPrice = max([of.clearedPrice for of in gOffers])\n                    for of in gOffers:\n                        of.clearedPrice = uniformPrice\n\n                gBids = [bid for bid in self.bids if bid.vLoad == g]\n                if gBids:\n                    uniformPrice = min([bid.cleared_price for bid in gBids])\n                    for bid in gBids:\n                        bid.clearedPrice = uniformPrice", "label": 1}
{"code": "function getWebpackRunnableLambda(slsWebpack, stats, functionName) {\n  const handler = slsWebpack.loadHandler(stats, functionName, true)\n  const context = slsWebpack.getContext(functionName)\n  return wrapHandler(handler, context)\n}", "label": 3}
{"code": "protected function mergeTypeExtensions(DocumentAST $document): DocumentAST\n    {\n        $document->objectTypeDefinitions()->each(\n            function (ObjectTypeDefinitionNode $objectType) use ($document) {\n                $name = $objectType->name->value;\n\n                $objectType = $document\n                    ->extensionsForType($name)\n                    ->reduce(\n                        function (ObjectTypeDefinitionNode $relatedObjectType, ObjectTypeExtensionNode $typeExtension): ObjectTypeDefinitionNode {\n                            $relatedObjectType->fields = ASTHelper::mergeUniqueNodeList(\n                                $relatedObjectType->fields,\n                                $typeExtension->fields\n                            );\n\n                            return $relatedObjectType;\n                        },\n                        $objectType\n                    );\n\n                // Modify the original document by overwriting the definition with the merged one\n                $document->setDefinition($objectType);\n            }\n        );\n\n        return $document;\n    }", "label": 2}
{"code": "function DupToPbn(opts) {\n    if (!(this instanceof DupToPbn)) return new DupToPbn(opts);\n\n    opts = opts || {};\n    this.needDirectives = true;\n    this.boardNumber = opts.boardNumber || 1;\n\n    stream.Transform.call(this, opts);\n}", "label": 3}
{"code": "def wait_for_socket\n      return unless Jets.rack?\n\n      retries = 0\n      max_retries = 30 # 15 seconds at a delay of 0.5s\n      delay = 0.5\n      if ENV['C9_USER'] # overrides for local testing\n        max_retries = 3\n        delay = 3\n      end\n      begin\n        server = TCPSocket.new('localhost', 9292)\n        server.close\n      rescue Errno::ECONNREFUSED\n        puts \"Unable to connect to localhost:9292. Delay for #{delay} and will try to connect again.\"  if ENV['JETS_DEBUG']\n        sleep(delay)\n        retries += 1\n        if retries < max_retries\n          retry\n        else\n          puts \"Giving up on trying to connect to localhost:9292\"\n          return false\n        end\n      end\n      puts \"Connected to localhost:9292 successfully\"\n      true\n    end", "label": 4}
{"code": "def ignore?(buf)\n      return true if /^\\s*$/ =~ buf\n      return false if Readline::HISTORY.empty?\n\n      buffer[Readline::HISTORY.length - 1] == buf\n    end", "label": 4}
{"code": "public Class<? extends com.vividsolutions.jts.geom.Geometry> toInternal(LayerType layerType) {\n\t\tswitch (layerType) {\n\t\t\tcase GEOMETRY:\n\t\t\t\treturn com.vividsolutions.jts.geom.Geometry.class;\n\t\t\tcase LINESTRING:\n\t\t\t\treturn LineString.class;\n\t\t\tcase MULTILINESTRING:\n\t\t\t\treturn MultiLineString.class;\n\t\t\tcase POINT:\n\t\t\t\treturn Point.class;\n\t\t\tcase MULTIPOINT:\n\t\t\t\treturn MultiPoint.class;\n\t\t\tcase POLYGON:\n\t\t\t\treturn Polygon.class;\n\t\t\tcase MULTIPOLYGON:\n\t\t\t\treturn MultiPolygon.class;\n\t\t\tcase RASTER:\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(\"Don't know how to handle layer type \" + layerType);\n\t\t}\n\t}", "label": 0}
{"code": "def inspect\n      inspected = super\n\n      # mask password\n      inspected.gsub! @password, '*******' if @password\n      inspected.gsub! @management_console_password, '*******' if @management_console_password\n      inspected.gsub! @bearer_token, '********' if @bearer_token\n      # Only show last 4 of token, secret\n      inspected.gsub! @access_token, \"#{'*'*36}#{@access_token[36..-1]}\" if @access_token\n      inspected.gsub! @client_secret, \"#{'*'*36}#{@client_secret[36..-1]}\" if @client_secret\n\n      inspected\n    end", "label": 4}
{"code": "def correct_word(word_string):\n    '''\n    Finds all valid one and two letter corrections for word_string, returning the word\n    with the highest relative probability as type str.\n    '''\n    if word_string is None:\n        return \"\"\n    elif isinstance(word_string, str):\n        return max(find_candidates(word_string), key=find_word_prob)\n    else:\n        raise InputError(\"string or none type variable not passed as argument to correct_word\")", "label": 1}
{"code": "private void verityLicenseIsConflictFree(final DbLicense newComer) {\n        if(newComer.getRegexp() == null || newComer.getRegexp().isEmpty()) {\n            return;\n        }\n\n        final DbLicense existing = repoHandler.getLicense(newComer.getName());\n        final List<DbLicense> licenses = repoHandler.getAllLicenses();\n\n        if(null == existing) {\n            licenses.add(newComer);\n        } else {\n            existing.setRegexp(newComer.getRegexp());\n        }\n\n\n        final Optional<Report> reportOp = ReportsRegistry.findById(MULTIPLE_LICENSE_MATCHING_STRINGS);\n        if (reportOp.isPresent()) {\n            final Report reportDef = reportOp.get();\n            ReportRequest reportRequest = new ReportRequest();\n            reportRequest.setReportId(reportDef.getId());\n\n            Map<String, String> params = new HashMap<>();\n\n            //\n            // TODO: Make the organization come as an external parameter from the client side.\n            // This may have impact on the UI, as when the user will update a license he will\n            // have to specify which organization he's editing the license for (in case there\n            // are more organizations defined in the collection).\n            //\n            params.put(\"organization\", \"Axway\");\n            reportRequest.setParamValues(params);\n\n            final RepositoryHandler wrapped = wrapperBuilder\n                    .start(repoHandler)\n                    .replaceGetMethod(\"getAllLicenses\", licenses)\n                    .build();\n\n            final ReportExecution execution = reportDef.execute(wrapped, reportRequest);\n\n            List<String[]> data = execution.getData();\n\n            final Optional<String[]> first = data\n                    .stream()\n                    .filter(strings -> strings[2].contains(newComer.getName()))\n                    .findFirst();\n\n            if(first.isPresent()) {\n                final String[] strings = first.get();\n                final String message = String.format(\n                        \"Pattern conflict for string entry %s matching multiple licenses: %s\",\n                        strings[1], strings[2]);\n                LOG.info(message);\n                throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                        .entity(message)\n                        .build());\n            } else {\n                if(!data.isEmpty() && !data.get(0)[2].isEmpty()) {\n                    LOG.info(\"There are remote conflicts between existing licenses and artifact strings\");\n                }\n            }\n        } else {\n            if(LOG.isWarnEnabled()) {\n                LOG.warn(String.format(\"Cannot find report by id %s\", MULTIPLE_LICENSE_MATCHING_STRINGS));\n            }\n        }\n    }", "label": 0}
{"code": "func (mr *MockEmbedMockRecorder) ImplicitPackage(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ImplicitPackage\", reflect.TypeOf((*MockEmbed)(nil).ImplicitPackage), arg0, arg1, arg2, arg3, arg4)\n}", "label": 5}
{"code": "public function sendData($data)\n    {\n        if ($this->isConnected()) {\n            if (socket_write($this->socket, $data, strlen($data)) === false) {\n                $this->eventManager()->fire('onClose',\n                   [\n                        $this->phoneNumber,\n                        'Connection closed!',\n                    ]\n              );\n            }\n        }\n    }", "label": 2}
{"code": "public static long count(nitro_service service, String sitepath) throws Exception{\n\t\twisite_translationinternalip_binding obj = new wisite_translationinternalip_binding();\n\t\tobj.set_sitepath(sitepath);\n\t\toptions option = new options();\n\t\toption.set_count(true);\n\t\twisite_translationinternalip_binding response[] = (wisite_translationinternalip_binding[]) obj.get_resources(service,option);\n\t\tif (response != null) {\n\t\t\treturn response[0].__count;\n\t\t}\n\t\treturn 0;\n\t}", "label": 0}
{"code": "public function beginTransaction($projectId, array $optionalArgs = [])\n    {\n        $request = new BeginTransactionRequest();\n        $request->setProjectId($projectId);\n        if (isset($optionalArgs['transactionOptions'])) {\n            $request->setTransactionOptions($optionalArgs['transactionOptions']);\n        }\n\n        $requestParams = new RequestParamsHeaderDescriptor([\n          'project_id' => $request->getProjectId(),\n        ]);\n        $optionalArgs['headers'] = isset($optionalArgs['headers'])\n            ? array_merge($requestParams->getHeader(), $optionalArgs['headers'])\n            : $requestParams->getHeader();\n\n        return $this->startCall(\n            'BeginTransaction',\n            BeginTransactionResponse::class,\n            $optionalArgs,\n            $request\n        )->wait();\n    }", "label": 2}
{"code": "def print_known_info\n      rows = []\n      rows += method_values_for_plugin_hashes(core_dsl_attributes)\n      rows << [\"---\", \"---\"]\n      rows += method_values_for_plugin_hashes(external_dsl_attributes)\n      rows << [\"---\", \"---\"]\n      rows << [\"SCM\", env.scm.class]\n      rows << [\"Source\", env.ci_source.class]\n      rows << [\"Requests\", env.request_source.class]\n      rows << [\"Base Commit\", env.meta_info_for_base]\n      rows << [\"Head Commit\", env.meta_info_for_head]\n\n      params = {}\n      params[:rows] = rows.each { |current| current[0] = current[0].yellow }\n      params[:title] = \"Danger v#{Danger::VERSION}\\nDSL Attributes\".green\n\n      ui.section(\"Info:\") do\n        ui.puts\n        table = Terminal::Table.new(params)\n        table.align_column(0, :right)\n        ui.puts table\n        ui.puts\n      end\n    end", "label": 4}
{"code": "def convert(self, amount: Number, currency: str, to: str, reverse: bool=False) -> Number:\n        \"\"\"Convert amount to another currency\"\"\"\n        rate = self.get_rate_for(currency, to, reverse)\n        if self.return_decimal:\n            amount = Decimal(amount)\n        return amount * rate", "label": 1}
{"code": "private function updateComponentVersions(array $release)\n    {\n        foreach ($release as $key => $releaseComponent)\n        {\n            $component = $this->getComponentComposer($this->rootPath(), $key);\n\n            $this->addToComponentManifest($releaseComponent['version'], $component);\n            foreach ((array) $component['entry'] as $entry) {\n                $entryUpdated = $this->updateComponentVersionConstant(\n                    $releaseComponent['version'],\n                    $component['path'],\n                    $entry\n                );\n            }\n\n            if ($component['id'] !== 'google-cloud') {\n                $this->updateComponentVersionFile($releaseComponent['version'], $component);\n                $this->updateComposerReplacesVersion($releaseComponent['version'], $component);\n            }\n        }\n    }", "label": 2}
{"code": "def check_hook_name_format(hash)\n      errors = []\n\n      Overcommit::Utils.supported_hook_type_classes.each do |hook_type|\n        hash.fetch(hook_type) { {} }.each_key do |hook_name|\n          next if hook_name == 'ALL'\n\n          unless hook_name.match?(/\\A[A-Za-z0-9]+\\z/)\n            errors << \"#{hook_type}::#{hook_name} has an invalid name \" \\\n                      \"#{hook_name}. It must contain only alphanumeric \" \\\n                      'characters (no underscores or dashes, etc.)'\n          end\n        end\n      end\n\n      if errors.any?\n        if @log\n          @log.error errors.join(\"\\n\")\n          @log.newline\n        end\n        raise Overcommit::Exceptions::ConfigurationError,\n              'One or more hooks had invalid names'\n      end\n    end", "label": 4}
{"code": "private function get_aliases_data( $config, $alias ) {\n\n\t\t$global_config_path = WP_CLI::get_runner()->get_global_config_path();\n\t\t$global_aliases     = Spyc::YAMLLoad( $global_config_path );\n\n\t\t$project_config_path = WP_CLI::get_runner()->get_project_config_path();\n\t\t$project_aliases     = Spyc::YAMLLoad( $project_config_path );\n\n\t\tif ( 'global' === $config ) {\n\t\t\t$config_path = $global_config_path;\n\t\t\t$aliases     = $global_aliases;\n\t\t} elseif ( 'project' === $config ) {\n\t\t\t$config_path = $project_config_path;\n\t\t\t$aliases     = $project_aliases;\n\t\t} else {\n\n\t\t\t$is_global_alias  = array_key_exists( $alias, $global_aliases );\n\t\t\t$is_project_alias = array_key_exists( $alias, $project_aliases );\n\n\t\t\tif ( $is_global_alias && $is_project_alias ) {\n\t\t\t\tWP_CLI::error( \"Key '{$alias}' found in more than one path. Please pass --config param.\" );\n\t\t\t} elseif ( $is_global_alias ) {\n\t\t\t\t$config_path = $global_config_path;\n\t\t\t\t$aliases     = $global_aliases;\n\t\t\t} else {\n\t\t\t\t$config_path = $project_config_path;\n\t\t\t\t$aliases     = $project_aliases;\n\t\t\t}\n\t\t}\n\n\t\treturn array( $config_path, $aliases );\n\n\t}", "label": 2}
{"code": "function oauth(httpRequest, httpResponse){\n        var code = httpRequest.query.code,\n            redirectUrl = _.has(grasshopper.config.identities, 'google') ? grasshopper.config.identities.google.redirectUrl : 'defaultRoute';\n\n\n        grasshopper.auth('Google', { code: code })\n            .then(function(token) {\n\n                httpRequest.session.token = new Buffer(token).toString('base64');\n                httpRequest.session.save(function() {\n                    httpResponse.redirect(redirectUrl+'/'+ httpRequest.session.token);\n                });\n\n\n            })\n            .fail(function(err){\n                httpResponse.redirect(redirectUrl+'/error='+ err.message);\n            });\n    }", "label": 3}
{"code": "function assertDeprecations(object, path, properties) {\n  let errors = [];\n\n  (properties || []).forEach(({ property, use }) => {\n    if (get(object, property, undefined) !== undefined) {\n      errors = [\n        ...errors,\n        {\n          path,\n          id: object.id,\n          error: `${object.type} is using the '${property}' property. It's deprecated and will be removed.${use ? ` Use '${use}' instead` : ''}.`,\n        },\n      ];\n    }\n  });\n\n  return errors;\n}", "label": 3}
{"code": "def read_json_numeric_chars\n      str = \"\"\n      while (true)\n        ch = @reader.peek\n        if (!is_json_numeric(ch))\n          break;\n        end\n        ch = @reader.read\n        str += ch\n      end\n      return str\n    end", "label": 4}
{"code": "def get_column_metadata(conn, table: str, schema='public'):\n    \"\"\"Returns column data following db.Column parameter specification.\"\"\"\n    query = \"\"\"\\\nSELECT\n  attname as name,\n  format_type(atttypid, atttypmod) AS data_type,\n  NOT attnotnull AS nullable\nFROM pg_catalog.pg_attribute\nWHERE attrelid=%s::regclass\n  AND attnum > 0 AND NOT attisdropped\nORDER BY attnum;\"\"\"\n\n    qualified_name = compile_qualified_name(table, schema=schema)\n\n    for record in select_dict(conn, query, params=(qualified_name,)):\n        yield record", "label": 1}
{"code": "def connection\n      @connection ||= self.class.connection_class.connect(\n        url: config.solr.url,\n        read_timeout: config.solr.read_timeout,\n        open_timeout: config.solr.open_timeout,\n        proxy: config.solr.proxy,\n        update_format: config.solr.update_format || :xml\n      )\n    end", "label": 4}
{"code": "def parse_options(metadata):\n    \"\"\"Parse argument options.\"\"\"\n    parser = argparse.ArgumentParser(description='%(prog)s usage:',\n                                     prog=__prog__)\n    setoption(parser, metadata=metadata)\n    return parser", "label": 1}
{"code": "def page_execute_form(params)\n      params = prepare_params(params)\n\n      html = %Q(<form id='alipaysubmit' name='alipaysubmit' action='#{@url}' method='POST'>)\n      params.each do |key, value|\n        html << %Q(<input type='hidden' name='#{key}' value='#{value.gsub(\"'\", \"&apos;\")}'/>)\n      end\n      html << \"<input type='submit' value='ok' style='display:none'></form>\"\n      html << \"<script>document.forms['alipaysubmit'].submit();</script>\"\n      html\n    end", "label": 4}
{"code": "public function requestEmailChange($email)\n    {\n        if ($email !== $this->email) {\n            $this->raise(new EmailChangeRequested($this, $email));\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "def read(table, ids, options = {}, &blk)\n      if ids.respond_to?(:each)\n        batch_get_item({ table => ids }, options, &blk)\n      else\n        get_item(table, ids, options)\n      end\n    end", "label": 4}
{"code": "public static snmpoption get(nitro_service service) throws Exception{\n\t\tsnmpoption obj = new snmpoption();\n\t\tsnmpoption[] response = (snmpoption[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "public static int cudnnConvolutionBackwardBias(\n        cudnnHandle handle, \n        Pointer alpha, \n        cudnnTensorDescriptor dyDesc, \n        Pointer dy, \n        Pointer beta, \n        cudnnTensorDescriptor dbDesc, \n        Pointer db)\n    {\n        return checkResult(cudnnConvolutionBackwardBiasNative(handle, alpha, dyDesc, dy, beta, dbDesc, db));\n    }", "label": 0}
{"code": "def prune_empty_groups\n      @channels.each_value do |channel|\n        channel.leave_group if channel.group? && channel.recipients.empty?\n      end\n    end", "label": 4}
{"code": "func NewCredentialsClient(proxyAddr string, insecure bool, pool *x509.CertPool) (*CredentialsClient, error) {\n\tlog := logrus.WithFields(logrus.Fields{\n\t\ttrace.Component: teleport.ComponentClient,\n\t})\n\tlog.Debugf(\"HTTPS client init(proxyAddr=%v, insecure=%v)\", proxyAddr, insecure)\n\n\t// validate proxyAddr:\n\thost, port, err := net.SplitHostPort(proxyAddr)\n\tif err != nil || host == \"\" || port == \"\" {\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\t\treturn nil, trace.BadParameter(\"'%v' is not a valid proxy address\", proxyAddr)\n\t}\n\tproxyAddr = \"https://\" + net.JoinHostPort(host, port)\n\tu, err := url.Parse(proxyAddr)\n\tif err != nil {\n\t\treturn nil, trace.BadParameter(\"'%v' is not a valid proxy address\", proxyAddr)\n\t}\n\n\tvar opts []roundtrip.ClientParam\n\n\tif insecure {\n\t\t// Skip https cert verification, print a warning that this is insecure.\n\t\tfmt.Printf(\"WARNING: You are using insecure connection to SSH proxy %v\\n\", proxyAddr)\n\t\topts = append(opts, roundtrip.HTTPClient(NewInsecureWebClient()))\n\t} else if pool != nil {\n\t\t// use custom set of trusted CAs\n\t\topts = append(opts, roundtrip.HTTPClient(newClientWithPool(pool)))\n\t}\n\n\tclt, err := NewWebClient(proxyAddr, opts...)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn &CredentialsClient{\n\t\tlog: log,\n\t\tclt: clt,\n\t\turl: u,\n\t}, nil\n}", "label": 5}
{"code": "private function assertClient(ClientInterface $client)\n    {\n        if ($client->getConnection() instanceof AggregateConnectionInterface) {\n            throw new NotSupportedException(\n                'Cannot initialize a MULTI/EXEC transaction over aggregate connections.'\n            );\n        }\n\n        if (!$client->getProfile()->supportsCommands(array('MULTI', 'EXEC', 'DISCARD'))) {\n            throw new NotSupportedException(\n                'The current profile does not support MULTI, EXEC and DISCARD.'\n            );\n        }\n    }", "label": 2}
{"code": "public static authorizationpolicy_binding get(nitro_service service, String name) throws Exception{\n\t\tauthorizationpolicy_binding obj = new authorizationpolicy_binding();\n\t\tobj.set_name(name);\n\t\tauthorizationpolicy_binding response = (authorizationpolicy_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def _init_report(self):\n        \"\"\"create the report directory and return the directory name\"\"\"\n        self.sections = []\n        self.section_names = []\n\n\n        # if the directory already exists, print a warning\n        try:\n            if os.path.isdir(self.directory) is False:\n                if self.verbose:\n                    print(\"Created directory {}\".format(self.directory))\n                os.mkdir(self.directory)\n            # list of directories created in the constructor\n            for this in self._to_create:\n                try:\n                    os.mkdir(self.directory + os.sep + this)\n                except:\n                    pass # already created ?\n        except Exception:\n            pass\n        finally:\n            # Once the main directory is created, copy files required\n            temp_path = easydev.get_package_location(\"reports\")\n            temp_path += os.sep + \"reports\" + os.sep + \"resources\"\n\n            # Copy the CSS from reports/resources/css\n            filenames = glob.glob(os.sep.join([temp_path, \"css\", \"*.css\"]))\n\n            # If there are CSS in the directory with JINJA templates, use them\n            # as well\n            filenames += glob.glob(os.sep.join([self.searchpath, '*.css']))\n\n\n            # In addition, the user may also provide his own CSS as a list\n            filenames += self.extra_css_list\n            for filename in filenames:\n                target = os.sep.join([self.directory, 'css' ])\n                if os.path.isfile(target) is False:\n                    shutil.copy(filename, target)\n\n            # We copy all javascript from reports resources\n            for filename in ['sorttable.js', 'highlight.pack.js', \"jquery-1.12.3.min.js\"]:\n                target = os.sep.join([self.directory, 'js', filename ])\n                if os.path.isfile(target) is False:\n                    filename = os.sep.join([temp_path, \"javascript\", filename])\n                    shutil.copy(filename, target)\n            for filename in self.extra_js_list:\n                basename = os.path.basename(filename)\n                target = os.sep.join([self.directory, 'js', basename ])\n                if os.path.isfile(target) is False:\n                    shutil.copy(filename, target)", "label": 1}
{"code": "public RedwoodConfiguration stdout(){\r\n    LogRecordHandler visibility = new VisibilityHandler();\r\n    LogRecordHandler console = Redwood.ConsoleHandler.out();\r\n    return this\r\n        .rootHandler(visibility)\r\n        .handler(visibility, console);\r\n  }", "label": 0}
{"code": "def get_maps_stats(self):\n        \"\"\"\n        calculates basic stats on the MapRule elements of the maps\n        to give a quick overview.\n        \"\"\"\n        tpes = {}\n        for m in self.maps:\n            if m.tpe in tpes:\n                tpes[m.tpe] += 1\n            else:\n                tpes[m.tpe] = 1\n        return tpes", "label": 1}
{"code": "public function listen()\n    {\n        try {\n            $isVerificationRequest = $this->verifyServices();\n\n            if (! $isVerificationRequest) {\n                $this->fireDriverEvents();\n\n                if ($this->firedDriverEvents === false) {\n                    $this->loadActiveConversation();\n\n                    if ($this->loadedConversation === false) {\n                        $this->callMatchingMessages();\n                    }\n\n                    /*\n                     * If the driver has a  \"messagesHandled\" method, call it.\n                     * This method can be used to trigger driver methods\n                     * once the messages are handles.\n                     */\n                    if (method_exists($this->getDriver(), 'messagesHandled')) {\n                        $this->getDriver()->messagesHandled();\n                    }\n                }\n\n                $this->firedDriverEvents = false;\n                $this->message = new IncomingMessage('', '', '');\n            }\n        } catch (\\Throwable $e) {\n            $this->exceptionHandler->handleException($e, $this);\n        }\n    }", "label": 2}
{"code": "func PgAuthMemberByMemberRoleid(db XODB, member pgtypes.Oid, roleid pgtypes.Oid) (*PgAuthMember, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, ctid, roleid, member, grantor, admin_option ` +\n\t\t`FROM pg_catalog.pg_auth_members ` +\n\t\t`WHERE member = $1 AND roleid = $2`\n\n\t// run query\n\tXOLog(sqlstr, member, roleid)\n\tpam := PgAuthMember{}\n\n\terr = db.QueryRow(sqlstr, member, roleid).Scan(&pam.Tableoid, &pam.Cmax, &pam.Xmax, &pam.Cmin, &pam.Xmin, &pam.Ctid, &pam.Roleid, &pam.Member, &pam.Grantor, &pam.AdminOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pam, nil\n}", "label": 5}
{"code": "public static lbvserver_stats get(nitro_service service, String name) throws Exception{\n\t\tlbvserver_stats obj = new lbvserver_stats();\n\t\tobj.set_name(name);\n\t\tlbvserver_stats response = (lbvserver_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function checkCredentials()\n  {\n      if (!$phone = $this->dissectPhone()) {\n          throw new Exception('The provided phone number is not valid.');\n      }\n\n      $countryCode = ($phone['ISO3166'] != '') ? $phone['ISO3166'] : 'US';\n      $langCode = ($phone['ISO639'] != '') ? $phone['ISO639'] : 'en';\n\n      // Build the url.\n      $host = 'https://'.Constants::WHATSAPP_CHECK_HOST;\n      $query = [\n      'cc'                 => $phone['cc'],\n      'in'                 => $phone['phone'],\n      'lg'                 => $langCode,\n      'lc'                 => $countryCode,\n      'id'                 => $this->identity,\n      'mistyped'           => '6',\n      'network_radio_type' => '1',\n      'simnum'             => '1',\n      's'                  => '',\n      'copiedrc'           => '1',\n      'hasinrc'            => '1',\n      'rcmatch'            => '1',\n      'pid'                => mt_rand(100, 9999),\n      //'rchash' => hash('sha256', openssl_random_pseudo_bytes(20)),\n      //'anhash' => md5(openssl_random_pseudo_bytes(20)),\n      'extexist' => '1',\n      'extstate' => '1',\n      ];\n\n      $this->debugPrint($query);\n\n      $response = $this->getResponse($host, $query);\n\n      $this->debugPrint($response);\n      \n      if ($response->status != 'ok') {\n          $this->eventManager()->fire('onCredentialsBad',\n            [\n                $this->phoneNumber,\n                $response->status,\n                $response->reason,\n            ]);\n\n          throw new Exception('There was a problem trying to request the code.');\n      } else {\n          $this->eventManager()->fire('onCredentialsGood',\n            [\n                $this->phoneNumber,\n                $response->login,\n                $response->pw,\n                $response->type,\n                $response->expiration,\n                $response->kind,\n                $response->price,\n                $response->cost,\n                $response->currency,\n                $response->price_expiration,\n            ]);\n      }\n\n      return $response;\n  }", "label": 2}
{"code": "def index():\n    \"\"\"Basic test view.\"\"\"\n    identity = g.identity\n    actions = {}\n    for action in access.actions.values():\n        actions[action.value] = DynamicPermission(action).allows(identity)\n\n    if current_user.is_anonymous:\n        return render_template(\"invenio_access/open.html\",\n                               actions=actions,\n                               identity=identity)\n    else:\n        return render_template(\"invenio_access/limited.html\",\n                               message='',\n                               actions=actions,\n                               identity=identity)", "label": 1}
{"code": "def override_plasticity_state(self, new_plasticity_state):\n        \"\"\"\n        Temporarily disable plasticity of internal state.\n\n        This function should be implemented by all subclasses so that\n        after a call, the output should always be the same for any\n        given input pattern, and no call should have any effect that\n        persists after restore_plasticity_state() is called.\n\n        By default, simply saves a copy of the 'plastic' parameter to\n        an internal stack (so that it can be restored by\n        restore_plasticity_state()), and then sets the plastic\n        parameter to the given value (True or False).\n        \"\"\"\n        self._plasticity_setting_stack.append(self.plastic)\n        self.plastic=new_plasticity_state", "label": 1}
{"code": "func NewClient(ctx context.Context) (*govmomi.Client, error) {\n\tflag.Parse()\n\n\t// Parse URL from string\n\tu, err := soap.ParseURL(*urlFlag)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Override username and/or password as required\n\tprocessOverride(u)\n\n\t// Connect and log in to ESX or vCenter\n\treturn govmomi.NewClient(ctx, u, *insecureFlag)\n}", "label": 5}
{"code": "def valid_sets\n      sets = @site.config[\"defaults\"]\n      return [] unless sets.is_a?(Array)\n\n      sets.map do |set|\n        if valid?(set)\n          ensure_time!(update_deprecated_types(set))\n        else\n          Jekyll.logger.warn \"Defaults:\", \"An invalid front-matter default set was found:\"\n          Jekyll.logger.warn set.to_s\n          nil\n        end\n      end.compact\n    end", "label": 4}
{"code": "def exporters_for_asset(asset)\n        exporters = [Exporters::FileExporter]\n\n        environment.exporters.each do |mime_type, exporter_list|\n          next unless asset.content_type\n          next unless environment.match_mime_type? asset.content_type, mime_type\n          exporter_list.each do |exporter|\n            exporters << exporter\n          end\n        end\n\n        exporters.uniq!\n\n        exporters.each do |exporter|\n          yield exporter.new(asset: asset, environment: environment, directory: dir)\n        end\n      end", "label": 4}
{"code": "function(method, path, data) {\n        const pendingReq = new ExpectedRequest(method, path, data);\n        this.expectedRequests.push(pendingReq);\n        return pendingReq;\n    }", "label": 3}
{"code": "def guess_external_url(local_host, port):\n    \"\"\"Return a URL that is most likely to route to `local_host` from outside.\n\n    The point is that we may be running on a remote host from the user's\n    point of view, so they can't access `local_host` from a Web browser just\n    by typing ``http://localhost:12345/``.\n    \"\"\"\n    if local_host in ['0.0.0.0', '::']:\n        # The server is listening on all interfaces, but we have to pick one.\n        # The system's FQDN should give us a hint.\n        local_host = socket.getfqdn()\n\n        # https://github.com/vfaronov/turq/issues/9\n        match = IPV4_REVERSE_DNS.match(local_host)\n        if match:\n            local_host = '.'.join(reversed(match.groups()))\n        else:\n            match = IPV6_REVERSE_DNS.match(local_host)\n            if match:\n                address_as_int = int(''.join(reversed(match.groups())), 16)\n                local_host = str(IPv6Address(address_as_int))\n\n    if ':' in local_host:\n        # Looks like an IPv6 literal. Has to be wrapped in brackets in a URL.\n        # Also, an IPv6 address can have a zone ID tacked on the end,\n        # like \"%3\". RFC 6874 allows encoding them in URLs as well,\n        # but in my experiments on Windows 8.1, I had more success\n        # removing the zone ID altogether. After all this is just a guess.\n        local_host = '[%s]' % local_host.rsplit('%', 1)[0]\n\n    return 'http://%s:%d/' % (local_host, port)", "label": 1}
{"code": "def run(self):\n        \"\"\"Collector main loop.\"\"\"\n        while True:\n            data = self.queue.get()\n            if data is None:\n                Logger.get_logger(__name__).info(\"Stopping collector process ...\")\n                break\n\n            # updating the report data\n            self.store.update(data)\n            # writing the report\n            generate(self.store, 'html', os.getcwd())", "label": 1}
{"code": "function assert(value, schema, message, vars) {\n\treturn assertion(value, schema, message, vars, (internals.debug ? null : assert));\n}", "label": 3}
{"code": "def _dispatch_change_event(self, object, trait_name, old, new, handler):\n    \"\"\" Prepare and dispatch a trait change event to a listener. \"\"\"\n\n    # Extract the arguments needed from the handler.\n    args = self.argument_transform(object, trait_name, old, new)\n\n    # Send a description of the event to the change event tracer.\n    if tnotifier._pre_change_event_tracer is not None:\n        tnotifier._pre_change_event_tracer(object, trait_name, old, new, handler)\n\n    # Dispatch the event to the listener.\n    from automate.common import SystemNotReady\n    try:\n        self.dispatch(handler, *args)\n    except SystemNotReady:\n        pass\n    except Exception as e:\n        if tnotifier._post_change_event_tracer is not None:\n            tnotifier._post_change_event_tracer(object, trait_name, old, new,\n                                                handler, exception=e)\n        # This call needs to be made inside the `except` block in case\n        # the handler wants to re-raise the exception.\n        tnotifier.handle_exception(object, trait_name, old, new)\n    else:\n        if tnotifier._post_change_event_tracer is not None:\n            tnotifier._post_change_event_tracer(object, trait_name, old, new,\n                                                handler, exception=None)", "label": 1}
{"code": "protected function buildRelationsFromModels(string $relationName, Closure $relationConstraints): Collection\n    {\n        return $this->models->toBase()->map(\n            function (Model $model) use ($relationName, $relationConstraints) {\n                $relation = $this->getRelationInstance($relationName);\n\n                $relation->addEagerConstraints([$model]);\n\n                // Call the constraints\n                $relationConstraints($relation, $model);\n\n                if (method_exists($relation, 'shouldSelect')) {\n                    $shouldSelect = new ReflectionMethod(get_class($relation), 'shouldSelect');\n                    $shouldSelect->setAccessible(true);\n                    $select = $shouldSelect->invoke($relation, ['*']);\n\n                    $relation->addSelect($select);\n                } elseif (method_exists($relation, 'getSelectColumns')) {\n                    $getSelectColumns = new ReflectionMethod(get_class($relation), 'getSelectColumns');\n                    $getSelectColumns->setAccessible(true);\n                    $select = $getSelectColumns->invoke($relation, ['*']);\n\n                    $relation->addSelect($select);\n                }\n\n                $relation->initRelation([$model], $relationName);\n\n                return $relation;\n            }\n        );\n    }", "label": 2}
{"code": "function(opts) {\n  if (!opts) opts = {};\n\n  this.port_offset        = opts.port_offset ? parseInt(opts.port_offset) : 10001;\n  this.task_list          = {};\n  this.can_accept_queries = false;\n  this.can_local_compute  = true;\n  this.app_folder         = opts.app_folder;\n\n  var pm2_opts = {};\n\n  if (process.env.NODE_ENV == 'test') {\n    pm2_opts = {\n      independent : true,\n      daemon_mode : true\n    };\n  }\n\n  this.pm2 = new PM2.custom(pm2_opts);\n\n  // Defaults values\n  this.task_meta   = {\n    instances   : 0,\n    json_conf   : null,\n    task_folder : 'tasks',\n    env         : {}\n  };\n\n  if (opts.task_meta)\n    this.task_meta = opts.task_meta;\n\n  this.controller = Controller;\n}", "label": 3}
{"code": "function newRandomKey(coll, key, currentKey){\n      var randKey;\n      do {\n        randKey = coll[Math.floor(coll.length * Math.random())][key];\n      } while (randKey == currentKey);\n      return randKey;\n    }", "label": 3}
{"code": "func (this *summaryMetricsSource) getSystemContainerName(c *stats.ContainerStats) string {\n\tif legacyName, ok := systemNameMap[c.Name]; ok {\n\t\treturn legacyName\n\t}\n\treturn c.Name\n}", "label": 5}
{"code": "func (self *realKubeFramework) ParseServiceAccount(filePath string) (*v1.ServiceAccount, error) {\n\tobj, err := self.loadObject(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsa, ok := obj.(*v1.ServiceAccount)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"Failed to cast serviceaccount: %v\", obj)\n\t}\n\treturn sa, nil\n}", "label": 5}
{"code": "def process_tree(tags, property, content, **opts)\n      method = case content\n               when Hash\n                 :process_hash\n               when Array\n                 :process_array\n               else\n                 :render_tag\n               end\n      __send__(method, tags, property, content, **opts)\n    end", "label": 4}
{"code": "function(element, event, callback) {\n\n    const eventStack = ChuiEventCache.elements[element.id]\n    if (!eventStack) return\n    let deleteOrder = []\n\n    if (!event) {\n      deleteOrder = []\n      eventStack.forEach(function(evt, idx) {\n        element.removeEventListener(evt.event, evt.callback, evt.capturePhase)\n        deleteOrder.push(idx)\n      })\n\n      deleteFromEventStack(deleteOrder, eventStack)\n\n    } else if (!!event && !callback) {\n      deleteOrder = []\n      eventStack.forEach(function(evt, idx) {\n        if (evt.event === event) {\n          element.removeEventListener(evt.event, evt.callback, evt.capturePhase)\n          deleteOrder.push(idx)\n        }\n      })\n\n      deleteFromEventStack(deleteOrder, eventStack)\n\n    } else if (callback) {\n      deleteOrder = []\n      eventStack.forEach(function(evt, idx) {\n        if (callback === evt.callback) {\n          element.removeEventListener(evt.event, evt.callback, evt.capturePhase)\n          deleteOrder.push(idx)\n        }\n      })\n      deleteFromEventStack(deleteOrder, eventStack)\n    }\n  }", "label": 3}
{"code": "def rectangle(upper_left_x, upper_left_y, lower_right_x, lower_right_y)\n      primitive 'rectangle ' + format('%g,%g %g,%g',\n                                      upper_left_x, upper_left_y, lower_right_x, lower_right_y)\n    end", "label": 4}
{"code": "function walkDir(file, callback, options) {\n  file = path.resolve(file);\n  if (!_.isFunction(callback)) throw new Error('You must provide a callback function');\n  options = _.opts(options, {followSymLinks: false, maxDepth: Infinity});\n  const prefix = options.prefix || file;\n\n  function _walkDir(f, depth) {\n    const type = fileType(f);\n    const relativePath = stripPathPrefix(f, prefix);\n    const metaData = {type: type, file: relativePath};\n    if (file === f) metaData.topDir = true;\n\n    const result = callback(f, metaData);\n    if (result === false) return false;\n    if (type === 'directory' || (type === 'link' && options.followSymLinks && isDirectory(f, options.followSymLinks))) {\n      let shouldContinue = true;\n      if (depth >= options.maxDepth) {\n        return;\n      }\n      _.each(fs.readdirSync(f), (elem) => {\n        shouldContinue = _walkDir(path.join(f, elem), depth + 1);\n        return shouldContinue;\n      });\n    }\n  }\n  _walkDir(file, 0);\n}", "label": 3}
{"code": "private static function get_aliases( $subcommands ) {\n\t\t$aliases = array();\n\n\t\tforeach ( $subcommands as $name => $subcommand ) {\n\t\t\t$alias = $subcommand->get_alias();\n\t\t\tif ( $alias ) {\n\t\t\t\t$aliases[ $alias ] = $name;\n\t\t\t}\n\t\t}\n\n\t\treturn $aliases;\n\t}", "label": 2}
{"code": "def can?(action, subject, attribute = nil, *extra_args)\n      match = extract_subjects(subject).lazy.map do |a_subject|\n        relevant_rules_for_match(action, a_subject).detect do |rule|\n          rule.matches_conditions?(action, a_subject, attribute, *extra_args) && rule.matches_attributes?(attribute)\n        end\n      end.reject(&:nil?).first\n      match ? match.base_behavior : false\n    end", "label": 4}
{"code": "public static void startTrack(final Object... args){\r\n    if(isClosed){ return; }\r\n    //--Create Record\r\n    final int len = args.length == 0 ? 0 : args.length-1;\r\n    final Object content = args.length == 0 ? \"\" : args[len];\r\n    final Object[] tags = new Object[len];\r\n    final StackTraceElement ste = getStackTrace();\r\n    final long timestamp = System.currentTimeMillis();\r\n    System.arraycopy(args,0,tags,0,len);\r\n    //--Create Task\r\n    final long threadID = Thread.currentThread().getId();\r\n    final Runnable startTrack = new Runnable(){\r\n      public void run(){\r\n        assert !isThreaded || control.isHeldByCurrentThread();\r\n        Record toPass = new Record(content,tags,depth,ste,timestamp);\r\n        depth += 1;\r\n        titleStack.push(args.length == 0 ? \"\" : args[len].toString());\r\n        handlers.process(toPass, MessageType.START_TRACK, depth, toPass.timesstamp);\r\n        assert !isThreaded || control.isHeldByCurrentThread();\r\n      }\r\n    };\r\n    //--Run Task\r\n    if(isThreaded){\r\n      //(case: multithreaded)\r\n      long threadId = Thread.currentThread().getId();\r\n      attemptThreadControl( threadId, startTrack );\r\n    } else {\r\n      //(case: no threading)\r\n      startTrack.run();\r\n    }\r\n  }", "label": 0}
{"code": "public static authenticationvserver_auditnslogpolicy_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauthenticationvserver_auditnslogpolicy_binding obj = new authenticationvserver_auditnslogpolicy_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationvserver_auditnslogpolicy_binding response[] = (authenticationvserver_auditnslogpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public UseCase selectUseCase()\r\n    {\r\n        displayUseCases();\r\n        System.out.println(\"type in number to select a use case\");\r\n        String in = readLine();\r\n        int index = Integer.parseInt(in);\r\n        return (UseCase) useCases.get(index);\r\n    }", "label": 0}
{"code": "@SuppressWarnings(\"unchecked\")\r\n\tpublic <T> T convertElement(ConversionContext context, Object source,\r\n\t\t\tTypeReference<T> destinationType) throws ConverterException {\r\n\t\treturn (T) elementConverter.convert(context, source, destinationType);\r\n\t}", "label": 0}
{"code": "def extractDates(inp, tz=None, now=None):\n    \"\"\"Extract semantic date information from an input string.\n    This is a convenience method which would only be used if\n    you'd rather not initialize a DateService object.\n\n    Args:\n        inp (str): The input string to be parsed.\n        tz: An optional Pytz timezone. All datetime objects returned will\n            be relative to the supplied timezone, or timezone-less if none\n            is supplied.\n        now: The time to which all returned datetime objects should be\n            relative. For example, if the text is \"In 5 hours\", the\n            datetime returned will be now + datetime.timedelta(hours=5).\n            Uses datetime.datetime.now() if none is supplied.\n\n    Returns:\n        A list of datetime objects extracted from input.\n    \"\"\"\n    service = DateService(tz=tz, now=now)\n    return service.extractDates(inp)", "label": 1}
{"code": "func (l *Forwarder) WaitForDelivery(ctx context.Context) error {\n\treturn l.ForwardTo.WaitForDelivery(ctx)\n}", "label": 5}
{"code": "def reload_embedded_document\n      extract_embedded_attributes({}.merge(\n        collection(_root).find(_id: _root._id).read(mode: :primary).first\n      ))\n    end", "label": 4}
{"code": "def _wrapper_enabled?\n        return false unless request.has_content_type?\n\n        ref = request.content_mime_type.ref\n        _wrapper_formats.include?(ref) && _wrapper_key && !request.parameters.key?(_wrapper_key)\n      end", "label": 4}
{"code": "def run_mutation_aggregator(job, fusion_output, radia_output, mutect_output, indel_output,\n                            univ_options):\n    \"\"\"\n    This module will aggregate all the mutations called in the previous steps and will then call\n    snpeff on the results.\n\n    ARGUMENTS\n    1. fusion_output: <JSid for vcf generated by the fusion caller>\n    2. radia_output: <JSid for vcf generated by radia>\n    3. mutect_output: <JSid for vcf generated by mutect>\n    4. indel_output: <JSid for vcf generated by the indel caller>\n\n    RETURN VALUES\n    1. output_file: <JSid for merged vcf>\n\n    This module corresponds to node 15 on the tree\n    \"\"\"\n    job.fileStore.logToMaster('Aggregating mutations for %s' % univ_options['patient'])\n    work_dir = job.fileStore.getLocalTempDir()\n    input_files = {\n        'mutect.vcf': mutect_output,\n        'radia.vcf': radia_output['radia_parsed_filter_passing_calls.vcf'],\n        'indel.vcf': indel_output,\n        'fusion.vcf': fusion_output}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n    # Modify these once INDELs and Fusions are implemented\n    input_files.pop('indel.vcf')\n    input_files.pop('fusion.vcf')\n    # read files into memory\n    vcf_file = defaultdict()\n    mutcallers = input_files.keys()\n    with open(''.join([work_dir, '/', univ_options['patient'], '_merged_mutations.vcf']),\n              'w') as merged_mut_file:\n        for mut_caller in mutcallers:\n            caller = mut_caller.rstrip('.vcf')\n            vcf_file[caller] = defaultdict()\n            with open(input_files[mut_caller], 'r') as mutfile:\n                for line in mutfile:\n                    if line.startswith('#'):\n                        if caller == 'radia':\n                            print(line.strip(), file=merged_mut_file)\n                        continue\n                    line = line.strip().split()\n                    vcf_file[caller][(line[0], line[1], line[3], line[4])] = line\n    # This method can be changed in the future to incorporate more callers and\n    # fancier integration methods\n    merge_vcfs(vcf_file, merged_mut_file.name)\n    export_results(merged_mut_file.name, univ_options)\n    output_file = job.fileStore.writeGlobalFile(merged_mut_file.name)\n    return output_file", "label": 1}
{"code": "def cumulate(self, axis):\n        \"\"\"Returns new histogram with all data cumulated along axis.\"\"\"\n        axis = self.get_axis_number(axis)\n        return Histdd.from_histogram(np.cumsum(self.histogram, axis=axis),\n                                     bin_edges=self.bin_edges,\n                                     axis_names=self.axis_names)", "label": 1}
{"code": "public function getRootAliases()\n    {\n        $aliases = [];\n\n        foreach ($this->dqlParts['from'] as &$fromClause) {\n            if (is_string($fromClause)) {\n                $spacePos = strrpos($fromClause, ' ');\n                $from     = substr($fromClause, 0, $spacePos);\n                $alias    = substr($fromClause, $spacePos + 1);\n\n                $fromClause = new Query\\Expr\\From($from, $alias);\n            }\n\n            $aliases[] = $fromClause->getAlias();\n        }\n\n        return $aliases;\n    }", "label": 2}
{"code": "private function sendBroadcast()\n    {\n        if (isset($this->inputs['action']) && trim($this->inputs['action']) == 'sendBroadcast') {\n            $this->connectToWhatsApp();\n            if (isset($this->inputs['message']) && trim($this->inputs['message'] !== '')) {\n                $this->wa->sendBroadcastMessage($this->inputs['to'], $this->inputs['message']);\n            }\n            if (isset($this->inputs['image']) && $this->inputs['image'] !== false) {\n                $this->wa->sendBroadcastImage($this->inputs['to'], $this->inputs['image']);\n            }\n            if (isset($this->inputs['audio']) && $this->inputs['audio'] !== false) {\n                $this->wa->sendBroadcastAudio($this->inputs['to'], $this->inputs['audio']);\n            }\n            if (isset($this->inputs['video']) && $this->inputs['video'] !== false) {\n                $this->wa->sendBroadcastVideo($this->inputs['to'], $this->inputs['video']);\n            }\n            if (isset($this->inputs['locationname']) && trim($this->inputs['locationname'] !== '')) {\n                $this->wa->sendBroadcastPlace($this->inputs['to'], $this->inputs['userlong'], $this->inputs['userlat'], $this->inputs['locationname'], null);\n            }\n            exit(json_encode([\n                'success'  => true,\n                'data'     => 'Broadcast Message Sent!',\n                'messages' => $this->messages,\n            ]));\n        }\n    }", "label": 2}
{"code": "public SqlStatement getPreparedInsertStatement(ClassDescriptor cld)\r\n    {\r\n        SqlStatement sql;\r\n        SqlForClass sfc = getSqlForClass(cld);\r\n        sql = sfc.getInsertSql();\r\n        if(sql == null)\r\n        {\r\n            ProcedureDescriptor pd = cld.getInsertProcedure();\r\n\r\n            if(pd == null)\r\n            {\r\n                sql = new SqlInsertStatement(cld, logger);\r\n            }\r\n            else\r\n            {\r\n                sql = new SqlProcedureStatement(pd, logger);\r\n            }\r\n            // set the sql string\r\n            sfc.setInsertSql(sql);\r\n\r\n            if(logger.isDebugEnabled())\r\n            {\r\n                logger.debug(\"SQL:\" + sql.getStatement());\r\n            }\r\n        }\r\n        return sql;\r\n    }", "label": 0}
{"code": "def reset_case(self):\n        \"\"\" Returns the case to its original state.\n        \"\"\"\n        for bus in self.market.case.buses:\n            bus.p_demand = self.pdemand[bus]\n        for task in self.tasks:\n            for g in task.env.generators:\n                g.p = task.env._g0[g][\"p\"]\n                g.p_max = task.env._g0[g][\"p_max\"]\n                g.p_min = task.env._g0[g][\"p_min\"]\n                g.q = task.env._g0[g][\"q\"]\n                g.q_max = task.env._g0[g][\"q_max\"]\n                g.q_min = task.env._g0[g][\"q_min\"]\n                g.p_cost = task.env._g0[g][\"p_cost\"]\n                g.pcost_model = task.env._g0[g][\"pcost_model\"]\n                g.q_cost = task.env._g0[g][\"q_cost\"]\n                g.qcost_model = task.env._g0[g][\"qcost_model\"]\n                g.c_startup = task.env._g0[g][\"startup\"]\n                g.c_shutdown = task.env._g0[g][\"shutdown\"]", "label": 1}
{"code": "def new_module(name):\n    \"\"\"\n    Do all of the gruntwork associated with creating a new module.\n\n    \"\"\"\n    parent = None\n    if '.' in name:\n        parent_name = name.rsplit('.', 1)[0]\n        parent = __import__(parent_name, fromlist=[''])\n\n    module = imp.new_module(name)\n    sys.modules[name] = module\n    if parent:\n        setattr(parent, name.rsplit('.', 1)[1], module)\n    return module", "label": 1}
{"code": "public static responderpolicy[] get(nitro_service service) throws Exception{\n\t\tresponderpolicy obj = new responderpolicy();\n\t\tresponderpolicy[] response = (responderpolicy[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function parallel(list, iterator, callback)\n{\n  var state = initState(list);\n\n  while (state.index < (state['keyedList'] || list).length)\n  {\n    iterate(list, iterator, state, function(error, result)\n    {\n      if (error)\n      {\n        callback(error, result);\n        return;\n      }\n\n      // looks like it's the last one\n      if (Object.keys(state.jobs).length === 0)\n      {\n        callback(null, state.results);\n        return;\n      }\n    });\n\n    state.index++;\n  }\n\n  return terminator.bind(state, callback);\n}", "label": 3}
{"code": "func (ds *DjangoSession) Delete(db XODB) error {\n\tvar err error\n\n\t// if doesn't exist, bail\n\tif !ds._exists {\n\t\treturn nil\n\t}\n\n\t// if deleted, bail\n\tif ds._deleted {\n\t\treturn nil\n\t}\n\n\t// sql query\n\tconst sqlstr = `DELETE FROM django.django_session WHERE session_key = :1`\n\n\t// run query\n\tXOLog(sqlstr, ds.SessionKey)\n\t_, err = db.Exec(sqlstr, ds.SessionKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set deleted\n\tds._deleted = true\n\n\treturn nil\n}", "label": 5}
{"code": "func (uw *UnitWriter) AppSocketUnit(appName types.ACName, binPath string, streamName string, opts ...*unit.UnitOption) {\n\topts = append(opts, []*unit.UnitOption{\n\t\tunit.NewUnitOption(\"Unit\", \"Description\", fmt.Sprintf(\"%s socket for %s\", streamName, appName)),\n\t\tunit.NewUnitOption(\"Unit\", \"DefaultDependencies\", \"no\"),\n\t\tunit.NewUnitOption(\"Unit\", \"StopWhenUnneeded\", \"yes\"),\n\t\tunit.NewUnitOption(\"Unit\", \"RefuseManualStart\", \"yes\"),\n\t\tunit.NewUnitOption(\"Unit\", \"RefuseManualStop\", \"yes\"),\n\t\tunit.NewUnitOption(\"Unit\", \"BindsTo\", fmt.Sprintf(\"%s.service\", appName)),\n\t\tunit.NewUnitOption(\"Socket\", \"RemoveOnStop\", \"yes\"),\n\t\tunit.NewUnitOption(\"Socket\", \"Service\", fmt.Sprintf(\"%s.service\", appName)),\n\t\tunit.NewUnitOption(\"Socket\", \"FileDescriptorName\", streamName),\n\t\tunit.NewUnitOption(\"Socket\", \"ListenFIFO\", filepath.Join(\"/rkt/iottymux\", appName.String(), \"stage2-\"+streamName)),\n\t}...)\n\n\tuw.WriteUnit(\n\t\tTypedUnitPath(uw.p.Root, appName.String()+\"-\"+streamName, \"socket\"),\n\t\tfmt.Sprintf(\"failed to write %s socket for %q service\", streamName, appName),\n\t\topts...,\n\t)\n}", "label": 5}
{"code": "function getUnionSignatures(types, kind) {\n            var signatureLists = ts.map(types, function (t) { return getSignaturesOfType(t, kind); });\n            var result = undefined;\n            for (var i = 0; i < signatureLists.length; i++) {\n                for (var _i = 0, _a = signatureLists[i]; _i < _a.length; _i++) {\n                    var signature = _a[_i];\n                    // Only process signatures with parameter lists that aren't already in the result list\n                    if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreThisTypes*/ true, /*ignoreReturnTypes*/ true)) {\n                        var unionSignatures = findMatchingSignatures(signatureLists, signature, i);\n                        if (unionSignatures) {\n                            var s = signature;\n                            // Union the result types when more than one signature matches\n                            if (unionSignatures.length > 1) {\n                                s = cloneSignature(signature);\n                                if (ts.forEach(unionSignatures, function (sig) { return sig.thisParameter; })) {\n                                    var thisType = getUnionType(ts.map(unionSignatures, function (sig) { return getTypeOfSymbol(sig.thisParameter) || anyType; }), /*subtypeReduction*/ true);\n                                    s.thisParameter = createTransientSymbol(signature.thisParameter, thisType);\n                                }\n                                // Clear resolved return type we possibly got from cloneSignature\n                                s.resolvedReturnType = undefined;\n                                s.unionSignatures = unionSignatures;\n                            }\n                            (result || (result = [])).push(s);\n                        }\n                    }\n                }\n            }\n            return result || emptyArray;\n        }", "label": 3}
{"code": "public function snapshots(array $options = [])\n    {\n        $resultLimit = $this->pluck('resultLimit', $options, false);\n\n        return new ItemIterator(\n            new PageIterator(\n                function (array $snapshot) {\n                    return new Snapshot(\n                        $this->connection,\n                        $this->projectId,\n                        $this->pluckName('snapshot', $snapshot['name']),\n                        $this->encode,\n                        $snapshot\n                    );\n                },\n                [$this->connection, 'listSnapshots'],\n                ['project' => $this->formatName('project', $this->projectId)] + $options,\n                [\n                    'itemsKey' => 'snapshots',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "def color_methods\n      colors.each do |key|\n        next if key == :default\n\n        define_method key do\n          colorize(:color => key)\n        end\n\n        define_method \"on_#{key}\" do\n          colorize(:background => key)\n        end\n      end\n    end", "label": 4}
{"code": "public function setCategories($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Language\\V1\\ClassificationCategory::class);\n        $this->categories = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function resource($name, $controller, array $options = [])\n    {\n        if ($this->container->bound(ResourceRegistrar::class)) {\n            $registrar = $this->container->make(ResourceRegistrar::class);\n        } else {\n            $registrar = new ResourceRegistrar($this);\n        }\n\n        $registrar->register($name, $controller, $options);\n    }", "label": 2}
{"code": "def dns scope: nil, retries: nil, timeout: nil\n      Google::Cloud.dns @project, @keyfile, scope: scope,\n                                            retries: (retries || @retries),\n                                            timeout: (timeout || @timeout)\n    end", "label": 4}
{"code": "function(target) {\n                // Only store the `module` in the local cache since `module.exports` may not be accurate\n                // if there was a circular dependency\n                var module = localCache[target] || (localCache[target] = requireModule(target, dirname));\n                return module.exports;\n            }", "label": 3}
{"code": "func GetFreeTCPPorts(n int, offset ...int) (PortList, error) {\n\tlist := make(PortList, 0, n)\n\tstart := PortStartingNumber\n\tif len(offset) != 0 {\n\t\tstart = offset[0]\n\t}\n\tfor i := start; i < start+n; i++ {\n\t\tlist = append(list, strconv.Itoa(i))\n\t}\n\treturn list, nil\n}", "label": 5}
{"code": "public function getAsset(Extension $extension, $path)\n    {\n        return $this->app->publicPath().'/assets/extensions/'.$extension->getId().$path;\n    }", "label": 2}
{"code": "public function setResults($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Speech\\V1\\SpeechRecognitionResult::class);\n        $this->results = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def download_logdir_archive(self, id, format='zip', exclude_captures=False): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Download logdir archive in tgz or zip format.\n\n        :param id: Result ID as an int.\n        :param format: (optional) Format to download, must be string `zip` or `tgz`.\n        :param exclude_captures: If bool `True`, don't include capture files\n        :rtype: tuple `(io.BytesIO, 'filename')`\n        \"\"\"\n        resp = self.service.get(self.base+str(id)+'/logdir/', params={'format': format, 'exclude_captures': exclude_captures}, stream=True)\n        b = io.BytesIO()\n        stream.stream_response_to_file(resp, path=b)\n        resp.close()\n        b.seek(0)\n        return (b, self.service.filename(resp))", "label": 1}
{"code": "function write(file, text, options) {\n  options = _.sanitize(options, {encoding: 'utf-8', retryOnENOENT: true});\n  file = normalize(file);\n  try {\n    fs.writeFileSync(file, text, options);\n  } catch (e) {\n    if (e.code === 'ENOENT' && options.retryOnENOENT) {\n      // If trying to create the parent failed, there is no point on retrying\n      try {\n        mkdir(path.dirname(file));\n      } catch (emkdir) {\n        throw e;\n      }\n      write(file, text, _.opts(options, {retryOnENOENT: false}, {mode: 'overwite'}));\n    } else {\n      throw e;\n    }\n  }\n}", "label": 3}
{"code": "func NewLabelCopier(separator string, storedLabels, ignoredLabels []string) (*LabelCopier, error) {\n\treturn &LabelCopier{\n\t\tlabelSeparator: separator,\n\t\tstoredLabels:   makeStoredLabels(storedLabels),\n\t\tignoredLabels:  makeIgnoredLabels(ignoredLabels),\n\t}, nil\n}", "label": 5}
{"code": "public static function generateSmtpPassword(CredentialsInterface $creds)\n    {\n        static $version = \"\\x02\";\n        static $algo = 'sha256';\n        static $message = 'SendRawEmail';\n        $signature = hash_hmac($algo, $message, $creds->getSecretKey(), true);\n\n        return base64_encode($version . $signature);\n    }", "label": 2}
{"code": "protected function getFileResponses(array $tags)\n    {\n        // avoid \"holes\" in the keys of the filtered array, by using array_values on the filtered array\n        $responseFileTags = array_values(\n            array_filter($tags, function ($tag) {\n                return $tag instanceof Tag && strtolower($tag->getName()) === 'responsefile';\n            })\n        );\n\n        if (empty($responseFileTags)) {\n            return;\n        }\n\n        return array_map(function (Tag $responseFileTag) {\n            preg_match('/^(\\d{3})?\\s?([\\S]*[\\s]*?)(\\{.*\\})?$/', $responseFileTag->getContent(), $result);\n            $status = $result[1] ?: 200;\n            $content = $result[2] ? file_get_contents(storage_path(trim($result[2])), true) : '{}';\n            $json = ! empty($result[3]) ? str_replace(\"'\", '\"', $result[3]) : '{}';\n            $merged = array_merge(json_decode($content, true), json_decode($json, true));\n\n            return new JsonResponse($merged, (int) $status);\n        }, $responseFileTags);\n    }", "label": 2}
{"code": "func MergeMounts(mounts []schema.Mount, appMounts []schema.Mount) []schema.Mount {\n\tml := append(appMounts, mounts...)\n\treturn deduplicateMPs(ml)\n}", "label": 5}
{"code": "function get(path, defaultValue, opts) {\n  let obj;\n  const args = [].slice.call(arguments);\n  path = args.shift();\n  if (typeof args[args.length - 1] === 'object') {\n    opts = args.pop();\n  } else {\n    opts = {};\n  }\n  defaultValue = args.pop();\n\n  keys(path, opts)\n    .sort((a, b) => a.length - b.length)\n    .forEach(key => {\n      let dotp = toDot(key, opts);\n      if (!opts.caseSensitive) {\n        dotp = dotp.toLowerCase();\n      }\n      const val = parse(process.env[key], opts);\n      if (dotp === '') {\n        obj = val;\n      } else {\n        if (typeof obj !== 'object') {\n          obj = {};\n        }\n        dotProp.set(obj, dotp, val);\n      }\n    });\n\n  let prefix = path;\n  if (!opts.caseSensitive) {\n    prefix = prefix.toLowerCase();\n  }\n  if (path === '') {\n    return obj;\n  }\n  return dotProp.get(obj, prefix, defaultValue);\n}", "label": 3}
{"code": "async def get_creds_by_id(self, proof_req_json: str, cred_ids: set) -> str:\n        \"\"\"\n        Get creds structure from HolderProver wallet by credential identifiers.\n\n        :param proof_req_json: proof request as per get_creds() above\n        :param cred_ids: set of credential identifiers of interest\n        :return: json with cred(s) for input credential identifier(s)\n        \"\"\"\n\n        LOGGER.debug('HolderProver.get_creds_by_id >>> proof_req_json: %s, cred_ids: %s', proof_req_json, cred_ids)\n\n        creds_json = await anoncreds.prover_get_credentials_for_proof_req(self.wallet.handle, proof_req_json)\n\n        # retain only creds of interest: find corresponding referents\n        rv_json = prune_creds_json(json.loads(creds_json), cred_ids)\n        LOGGER.debug('HolderProver.get_cred_by_referent <<< %s', rv_json)\n        return rv_json", "label": 1}
{"code": "function _gpfPathMatch (pattern, path) {\n    var parts = _gpfPathDecompose(path),\n        matchers = _gpfPathMatchCompilePatterns(pattern),\n        scope = {\n            parts: parts\n        };\n    matchers.every(_gpfPathMatchApply, scope);\n    return scope.result;\n}", "label": 3}
{"code": "def smart_merge(parent, child)\n      parent.merge(child) do |_key, old, new|\n        case old\n        when Hash\n          smart_merge(old, new)\n        else\n          new\n        end\n      end\n    end", "label": 4}
{"code": "func (tc *TeleportClient) Play(ctx context.Context, namespace, sessionId string) (err error) {\n\tif namespace == \"\" {\n\t\treturn trace.BadParameter(auth.MissingNamespaceError)\n\t}\n\tsid, err := session.ParseID(sessionId)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"'%v' is not a valid session ID (must be GUID)\", sid)\n\t}\n\t// connect to the auth server (site) who made the recording\n\tproxyClient, err := tc.ConnectToProxy(ctx)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tsite, err := proxyClient.ConnectToCurrentCluster(ctx, false)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t// request events for that session (to get timing data)\n\tsessionEvents, err := site.GetSessionEvents(namespace, *sid, 0, true)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\t// read the stream into a buffer:\n\tvar stream []byte\n\tfor err == nil {\n\t\ttmp, err := site.GetSessionChunk(namespace, *sid, len(stream), events.MaxChunkBytes)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tif len(tmp) == 0 {\n\t\t\terr = io.EOF\n\t\t\tbreak\n\t\t}\n\t\tstream = append(stream, tmp...)\n\t}\n\n\t// configure terminal for direct unbuffered echo-less input:\n\tif term.IsTerminal(0) {\n\t\tstate, err := term.SetRawTerminal(0)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tdefer term.RestoreTerminal(0, state)\n\t}\n\tplayer := newSessionPlayer(sessionEvents, stream)\n\t// keys:\n\tconst (\n\t\tkeyCtrlC = 3\n\t\tkeyCtrlD = 4\n\t\tkeySpace = 32\n\t\tkeyLeft  = 68\n\t\tkeyRight = 67\n\t\tkeyUp    = 65\n\t\tkeyDown  = 66\n\t)\n\t// playback control goroutine\n\tgo func() {\n\t\tdefer player.Stop()\n\t\tkey := make([]byte, 1)\n\t\tfor {\n\t\t\t_, err = os.Stdin.Read(key)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tswitch key[0] {\n\t\t\t// Ctrl+C or Ctrl+D\n\t\t\tcase keyCtrlC, keyCtrlD:\n\t\t\t\treturn\n\t\t\t// Space key\n\t\t\tcase keySpace:\n\t\t\t\tplayer.TogglePause()\n\t\t\t// <- arrow\n\t\t\tcase keyLeft, keyDown:\n\t\t\t\tplayer.Rewind()\n\t\t\t// -> arrow\n\t\t\tcase keyRight, keyUp:\n\t\t\t\tplayer.Forward()\n\t\t\t}\n\t\t}\n\t}()\n\n\t// player starts playing in its own goroutine\n\tplayer.Play()\n\n\t// wait for keypresses loop to end\n\t<-player.stopC\n\tfmt.Println(\"\\n\\nend of session playback\")\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "public function setReferenceImages($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\ReferenceImage::class);\n        $this->reference_images = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public String[] getReportSamples() {\n         final Map<String, String> sampleValues = new HashMap<>();\n         sampleValues.put(\"name1\", \"Secure Transpiler Mars\");\n         sampleValues.put(\"version1\", \"4.7.0\");\n         sampleValues.put(\"name2\", \"Secure Transpiler Bounty\");\n         sampleValues.put(\"version2\", \"5.0.0\");\n         sampleValues.put(\"license\", \"CDDL-1.1\");\n         sampleValues.put(\"name\", \"Secure Pretender\");\n         sampleValues.put(\"version\", \"2.7.0\");\n         sampleValues.put(\"organization\", \"Axway\");\n\n         return ReportsRegistry.allReports()\n                 .stream()\n                 .map(report -> ReportUtils.generateSampleRequest(report, sampleValues))\n                 .map(request -> {\n                     try {\n                         String desc = \"\";\n                         final Optional<Report> byId = ReportsRegistry.findById(request.getReportId());\n\n                         if(byId.isPresent()) {\n                            desc = byId.get().getDescription() + \"<br/><br/>\";\n                         }\n\n                         return String.format(TWO_PLACES, desc, JsonUtils.serialize(request));\n                     } catch(IOException e) {\n                         return \"Error \" + e.getMessage();\n                     }\n                 })\n                 .collect(Collectors.toList())\n                 .toArray(new String[] {});\n     }", "label": 0}
{"code": "def create(*args)\n      arguments(args, required: [:user, :repo]) do\n        permit VALID_TAG_PARAM_NAMES\n        assert_values VALID_TAG_PARAM_VALUES\n      end\n\n      post_request(\"/repos/#{arguments.user}/#{arguments.repo}/git/tags\", arguments.params)\n    end", "label": 4}
{"code": "function (id) {\n\t\t\n\t\tLOG.warn('server started: ' + server_type, l_name);\n    \n\t\t// check if we should notify start server request\n\t\tfor (var i=0; i < l_pendingStart.length; i++) {\n\t\t\n\t\t\tvar task = l_pendingStart[i];\n\t\t\n\t\t\tif (task.server_type !== server_type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLOG.warn('pending type matched: ' + task.server_type, l_name);\n\n\t\t\t// record server id, check for return\n\t\t\ttask.servers.push(id);\n\t\t\ttask.curr++;\n\t\t\t\n\t\t\t// store this process id\n\t\t\tif (l_started.hasOwnProperty(server_type) === false)\n\t\t\t\tl_started[server_type] = [];\n\t\t\t\n\t\t\t// NOTE: we currently do not maintain this id, should we?\n\t\t\tl_started[server_type].push(id);\n\t\t\t\n\t\t\t// check if all servers of a particular type are started\n\t\t\tif (task.curr === task.total) {\n\t\t\t\tUTIL.safeCall(task.onDone, null, task.servers);\n\t\t\t\t\n\t\t\t\t// remove this item until app servers have also reported back\n\t\t\t\tl_pendingStart.splice(i, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// delete log\n\t\tl_deleteStartedServer({\n\t\t\towner: args.owner,\n\t\t\tproject: args.project,\n\t\t\tname: args.name\n\t\t});\n\n\t\t// log started server\n\t\tl_getServerInfo({\n\t\t\towner: args.owner,\n\t\t\tproject: args.project,\n\t\t\tname: args.name,\n\t\t\tsize: args.size\n\t\t}, 1);\n\t}", "label": 3}
{"code": "public function serialize($value): string\n    {\n        if ($value instanceof Carbon) {\n            return $value->toDateString();\n        }\n\n        return $this->tryParsingDate($value, InvariantViolation::class)\n            ->toDateString();\n    }", "label": 2}
{"code": "def _finalize_namespaces(self, ns_dict=None):\n        \"\"\"Returns a dictionary of namespaces to be exported with an XML\n        document.\n\n        This loops over all the namespaces that were discovered and built\n        during the execution of ``collect()`` and\n        ``_parse_collected_classes()`` and attempts to merge them all.\n\n        Raises:\n            .namespaces.DuplicatePrefixError: If namespace prefix was\n                mapped to more than one namespace.\n            .namespaces.NoPrefixError: If a namespace was collected that is\n                not mapped to a prefix.\n        \"\"\"\n        if ns_dict:\n            # Add the user's entries to our set\n            for ns, alias in six.iteritems(ns_dict):\n                self._collected_namespaces.add_namespace_uri(ns, alias)\n\n        # Add the ID namespaces\n        self._collected_namespaces.add_namespace_uri(\n            ns_uri=idgen.get_id_namespace(),\n            prefix=idgen.get_id_namespace_alias()\n        )\n\n        # Remap the example namespace to the one expected by the APIs if the\n        # sample example namespace is found.\n        self._fix_example_namespace()\n\n        # Add _input_namespaces\n        for prefix, uri in six.iteritems(self._input_namespaces):\n            self._collected_namespaces.add_namespace_uri(uri, prefix)\n\n        # Add some default XML namespaces to make sure they're there.\n        self._collected_namespaces.import_from(namespaces.XML_NAMESPACES)\n\n        # python-stix's generateDS-generated binding classes can't handle\n        # default namespaces.  So make sure there are no preferred defaults in\n        # the set.  Get prefixes from the global namespace set if we have to.\n        for ns_uri in self._collected_namespaces.namespace_uris:\n            preferred_prefix = self._collected_namespaces.preferred_prefix_for_namespace(ns_uri)\n\n            if preferred_prefix:\n                continue\n\n            # No preferred prefix set for namespace. Try to assign one.\n            prefixes = self._collected_namespaces.get_prefixes(ns_uri)\n\n            if prefixes:\n                prefix = next(iter(prefixes))\n            else:\n                prefix = namespaces.lookup_name(ns_uri)\n\n            if prefix is None:\n                raise namespaces.NoPrefixesError(ns_uri)\n\n            self._collected_namespaces.set_preferred_prefix_for_namespace(\n                ns_uri=ns_uri,\n                prefix=prefix,\n                add_if_not_exist=True\n            )", "label": 1}
{"code": "def site=(new_site)\n      if new_site\n        if !new_site.respond_to?(:to_str)\n          raise TypeError, \"Can't convert #{new_site.class} into String.\"\n        end\n        new_site = new_site.to_str\n        # These two regular expressions derived from the primary parsing\n        # expression\n        self.scheme = new_site[/^(?:([^:\\/?#]+):)?(?:\\/\\/(?:[^\\/?#]*))?$/, 1]\n        self.authority = new_site[\n          /^(?:(?:[^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?$/, 1\n        ]\n      else\n        self.scheme = nil\n        self.authority = nil\n      end\n    end", "label": 4}
{"code": "public static function findingName($organization, $source, $finding)\n    {\n        return self::getFindingNameTemplate()->render([\n            'organization' => $organization,\n            'source' => $source,\n            'finding' => $finding,\n        ]);\n    }", "label": 2}
{"code": "def start(builtins=False, profile_threads=True):\n    \"\"\"\n    Start profiler.\n    \"\"\"\n    if profile_threads:\n        threading.setprofile(_callback)\n    _yappi.start(builtins, profile_threads)", "label": 1}
{"code": "private Integer getReleaseId() {\n\t\tfinal String[] versionParts = stringVersion.split(\"-\");\n\t\t\n\t\tif(isBranch() && versionParts.length >= 3){\n\t\t\treturn Integer.valueOf(versionParts[2]);\n\t\t}\n\t\telse if(versionParts.length >= 2){\n\t\t\treturn Integer.valueOf(versionParts[1]);\n\t\t}\n\n\t\treturn 0;\n\t}", "label": 0}
{"code": "def say_with_time(message)\n      say(message)\n      result = nil\n      time = Benchmark.measure { result = yield }\n      say \"%.4fs\" % time.real, :subitem\n      say(\"#{result} rows\", :subitem) if result.is_a?(Integer)\n      result\n    end", "label": 4}
{"code": "private void handleIncomingRequestMessage(SerialMessage incomingMessage) {\n\t\tlogger.debug(\"Message type = REQUEST\");\n\t\tswitch (incomingMessage.getMessageClass()) {\n\t\t\tcase ApplicationCommandHandler:\n\t\t\t\thandleApplicationCommandRequest(incomingMessage);\n\t\t\t\tbreak;\n\t\t\tcase SendData:\n\t\t\t\thandleSendDataRequest(incomingMessage);\n\t\t\t\tbreak;\n\t\t\tcase ApplicationUpdate:\n\t\t\t\thandleApplicationUpdateRequest(incomingMessage);\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger.warn(String.format(\"TODO: Implement processing of Request Message = %s (0x%02X)\",\n\t\t\t\t\tincomingMessage.getMessageClass().getLabel(),\n\t\t\t\t\tincomingMessage.getMessageClass().getKey()));\n\t\t\tbreak;\t\n\t\t}\n\t}", "label": 0}
{"code": "function json (program, callback) {\n    var formatterRedux = formatter(jsonRedux())\n    parse(program.stdin, program.stderr, printer(formatterRedux, program.stdout, program.stderr), callback)\n}", "label": 3}
{"code": "def expand(mapping, processor=nil, normalize_values=true)\n      result = self.pattern.dup\n      mapping = normalize_keys(mapping)\n      result.gsub!( EXPRESSION ) do |capture|\n        transform_capture(mapping, capture, processor, normalize_values)\n      end\n      return Addressable::URI.parse(result)\n    end", "label": 4}
{"code": "def get(cls, user_id, client_id, token_type='', access_token=None):\n        \"\"\"Get RemoteToken for user.\n\n        :param user_id: The user id.\n        :param client_id: The client id.\n        :param token_type: The token type. (Default: ``''``)\n        :param access_token: If set, will filter also by access token.\n            (Default: ``None``)\n        :returns: A :class:`invenio_oauthclient.models.RemoteToken` instance.\n        \"\"\"\n        args = [\n            RemoteAccount.id == RemoteToken.id_remote_account,\n            RemoteAccount.user_id == user_id,\n            RemoteAccount.client_id == client_id,\n            RemoteToken.token_type == token_type,\n        ]\n\n        if access_token:\n            args.append(RemoteToken.access_token == access_token)\n\n        return cls.query.options(\n            db.joinedload('remote_account')\n        ).filter(*args).first()", "label": 1}
{"code": "func eventFilterSelf(event types.BaseEvent, self types.ManagedObjectReference) bool {\n\treturn doEntityEventArgument(event, func(ref types.ManagedObjectReference, _ *types.EntityEventArgument) bool {\n\t\treturn self == ref\n\t})\n}", "label": 5}
{"code": "func (a *AuthServer) runPeriodicOperations() {\n\t// run periodic functions with a semi-random period\n\t// to avoid contention on the database in case if there are multiple\n\t// auth servers running - so they don't compete trying\n\t// to update the same resources.\n\tr := rand.New(rand.NewSource(a.GetClock().Now().UnixNano()))\n\tperiod := defaults.HighResPollingPeriod + time.Duration(r.Intn(int(defaults.HighResPollingPeriod/time.Second)))*time.Second\n\tlog.Debugf(\"Ticking with period: %v.\", period)\n\tticker := time.NewTicker(period)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-a.closeCtx.Done():\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\terr := a.autoRotateCertAuthorities()\n\t\t\tif err != nil {\n\t\t\t\tif trace.IsCompareFailed(err) {\n\t\t\t\t\tlog.Debugf(\"Cert authority has been updated concurrently: %v.\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Errorf(\"Failed to perform cert rotation check: %v.\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "label": 5}
{"code": "def sort_bamfile(job, bamfile, sample_type, univ_options, samtools_options):\n    \"\"\"\n    Sort `bamfile` using samtools\n\n    :param toil.fileStore.FileID bamfile: fsID for the bam file\n    :param str sample_type: Description of the sample to inject into the filename\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict samtools_options: Options specific to samtools\n    :return: fsID for the sorted bamfile\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    work_dir = os.getcwd()\n    in_bamfile = ''.join([sample_type, '.bam'])\n    out_bamfile = '_'.join([sample_type, 'sorted.bam'])\n    input_files = {\n        in_bamfile: bamfile}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=True)\n    parameters = ['sort',\n                  '-o', docker_path(out_bamfile),\n                  '-O', 'bam',\n                  '-T', 'temp_sorted',\n                  '-@', str(samtools_options['n']),\n                  input_files[in_bamfile]]\n    docker_call(tool='samtools', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], tool_version=samtools_options['version'])\n    job.fileStore.deleteGlobalFile(bamfile)\n    job.fileStore.logToMaster('Ran samtools-sort on %s:%s successfully'\n                              % (univ_options['patient'], sample_type))\n    return job.fileStore.writeGlobalFile(out_bamfile)", "label": 1}
{"code": "public function setTable($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\Admin\\V2\\Table::class);\n        $this->table = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "protected function applySecurityRules()\n    {\n        $maxQueryComplexity = config('graphql.security.query_max_complexity');\n        if ($maxQueryComplexity !== null) {\n            /** @var QueryComplexity $queryComplexity */\n            $queryComplexity = DocumentValidator::getRule('QueryComplexity');\n            $queryComplexity->setMaxQueryComplexity($maxQueryComplexity);\n        }\n\n        $maxQueryDepth = config('graphql.security.query_max_depth');\n        if ($maxQueryDepth !== null) {\n            /** @var QueryDepth $queryDepth */\n            $queryDepth = DocumentValidator::getRule('QueryDepth');\n            $queryDepth->setMaxQueryDepth($maxQueryDepth);\n        }\n\n        $disableIntrospection = config('graphql.security.disable_introspection');\n        if ($disableIntrospection === true) {\n            /** @var DisableIntrospection $disableIntrospection */\n            $disableIntrospection = DocumentValidator::getRule('DisableIntrospection');\n            $disableIntrospection->setEnabled(DisableIntrospection::ENABLED);\n        }\n    }", "label": 2}
{"code": "public function setResourceOwners($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->resource_owners = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def _get_reference_index(self, case):\n        \"\"\" Returns the index of the reference bus.\n        \"\"\"\n        refs = [bus._i for bus in case.connected_buses if bus.type == REFERENCE]\n        if len(refs) == 1:\n            return refs [0]\n        else:\n            logger.error(\"Single swing bus required for DCPF.\")\n            return -1", "label": 1}
{"code": "private String toSQLClause(FieldCriteria c, ClassDescriptor cld)\r\n    {\r\n        String colName = toSqlClause(c.getAttribute(), cld);\r\n        return colName + c.getClause() + c.getValue();\r\n    }", "label": 0}
{"code": "func (m *Manager) ParseDescriptor(ctx context.Context, ovfDescriptor string, pdp types.OvfParseDescriptorParams) (*types.OvfParseDescriptorResult, error) {\n\treq := types.ParseDescriptor{\n\t\tThis:          m.Reference(),\n\t\tOvfDescriptor: ovfDescriptor,\n\t\tPdp:           pdp,\n\t}\n\n\tres, err := methods.ParseDescriptor(ctx, m.c, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &res.Returnval, nil\n}", "label": 5}
{"code": "function addMethod (char, method) {\n  var keyIsBound = hasKeybinding(char);\n  var listener = keyupHandler.bind(null, char, method);\n\n  bindings[char] = bindings[char] || {methods: [], listeners: []};\n\n  if (keyIsBound) window.removeEventListener('keyup', bindings[char].listeners[0]);\n\n  bindings[char].methods.unshift(method);\n  bindings[char].listeners.unshift(listener);\n  window.addEventListener('keyup', listener);\n}", "label": 3}
{"code": "def working2analysis(self,r):\n        \"Transform working space inputs to the analysis color space.\"\n        a = self.colorspace.convert(self.working_space, self.analysis_space, r)\n        return self.swap_polar_HSVorder[self.analysis_space](a)", "label": 1}
{"code": "def uri(addr = nil, absolute = true, add_script_name = true)\n      return addr if addr =~ /\\A[A-z][A-z0-9\\+\\.\\-]*:/\n      uri = [host = \"\"]\n      if absolute\n        host << \"http#{'s' if request.secure?}://\"\n        if request.forwarded? or request.port != (request.secure? ? 443 : 80)\n          host << request.host_with_port\n        else\n          host << request.host\n        end\n      end\n      uri << request.script_name.to_s if add_script_name\n      uri << (addr ? addr : request.path_info).to_s\n      File.join uri\n    end", "label": 4}
{"code": "public static int cudnnActivationForward(\n        cudnnHandle handle, \n        cudnnActivationDescriptor activationDesc, \n        Pointer alpha, \n        cudnnTensorDescriptor xDesc, \n        Pointer x, \n        Pointer beta, \n        cudnnTensorDescriptor yDesc, \n        Pointer y)\n    {\n        return checkResult(cudnnActivationForwardNative(handle, activationDesc, alpha, xDesc, x, beta, yDesc, y));\n    }", "label": 0}
{"code": "function ChildProcess (command, args, env, code, maxBuffer) {\n        var self = this;\n\n        assert.string(command);\n        assert.optionalArrayOfNumber(code);\n\n        self.command = command;\n        self.file = self._parseCommandPath(self.command);\n        self.args = args;\n        self.environment = env || {};\n        self.exitCode = code || [0];\n        self.maxBuffer = maxBuffer || Constants.ChildProcess.MaxBuffer;\n\n        if (!self.file) {\n            throw new Error('Unable to locate command file (' + self.command +').');\n        }\n        if (!_.isEmpty(self.args)) {\n            try {\n                assert.arrayOfString(self.args, 'ChildProcess command arguments');\n            } catch (e) {\n                throw new Error('args must be an array of strings');\n            }\n        }\n\n        self.hasBeenKilled = false;\n        self.hasBeenCancelled = false;\n        self.spawnInstance = undefined;\n    }", "label": 3}
{"code": "private static ArrayList<NamedList<Object>> rewriteToArray(\n      NamedList<Object> nnl) {\n    ArrayList<NamedList<Object>> al = new ArrayList<>();\n    String key;\n    Iterator<Entry<String, Object>> it = nnl.iterator();\n    while (it.hasNext()) {\n      Entry<String, Object> entry = it.next();\n      NamedList<Object> item = (NamedList<Object>) entry.getValue();\n      key = entry.getKey();\n      if (key.startsWith(GroupHit.KEY_START)) {\n        StringBuilder newKey = new StringBuilder(\"\");\n        item.add(\"group\", GroupHit.keyToObject(key, newKey));\n        item.add(\"key\", newKey.toString().trim());\n      } else {\n        item.add(\"key\", key);\n      }\n      al.add(item);\n    }\n    return al;\n  }", "label": 0}
{"code": "public static function modelEvaluationName($project, $location, $model, $modelEvaluation)\n    {\n        return self::getModelEvaluationNameTemplate()->render([\n            'project' => $project,\n            'location' => $location,\n            'model' => $model,\n            'model_evaluation' => $modelEvaluation,\n        ]);\n    }", "label": 2}
{"code": "def validate_type(prop, value, expected):\n    \"\"\" Default validation for all types \"\"\"\n\n    # Validate on expected type(s), but ignore None: defaults handled elsewhere\n    if value is not None and not isinstance(value, expected):\n        _validation_error(prop, type(value).__name__, None, expected)", "label": 1}
{"code": "public boolean checkRead(TransactionImpl tx, Object obj)\r\n    {\r\n        if (hasReadLock(tx, obj))\r\n        {\r\n            return true;\r\n        }\r\n        LockEntry writer = getWriter(obj);\r\n        if (writer.isOwnedBy(tx))\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }", "label": 0}
{"code": "function chmod(file, permissions, options) {\n  if (!isPlatform('unix')) return;\n  if (!exists(file)) throw new Error(`Path '${file}' does not exists`);\n  const isDir = isDirectory(file);\n\n  options = _.sanitize(options, {recursive: false});\n  let filePermissions = null;\n  let dirPermissions = null;\n  if (_.isReallyObject(permissions)) {\n    filePermissions = permissions.file || null;\n    dirPermissions = permissions.directory || null;\n  } else {\n    filePermissions = permissions;\n    dirPermissions = permissions;\n  }\n\n  if (isDir && options.recursive) {\n    _.each(listDirContents(file, {compact: false, includeTopDir: true}), function(data) {\n      _chmod(data.file, data.type === 'directory' ? dirPermissions : filePermissions);\n    });\n  } else {\n    _chmod(file, isDir ? dirPermissions : filePermissions);\n  }\n}", "label": 3}
{"code": "private void buildJoinTree(Criteria crit)\r\n    {\r\n        Enumeration e = crit.getElements();\r\n\r\n        while (e.hasMoreElements())\r\n        {\r\n            Object o = e.nextElement();\r\n            if (o instanceof Criteria)\r\n            {\r\n                buildJoinTree((Criteria) o);\r\n            }\r\n            else\r\n            {\r\n                SelectionCriteria c = (SelectionCriteria) o;\r\n                \r\n                // BRJ skip SqlCriteria\r\n                if (c instanceof SqlCriteria)\r\n                {\r\n                    continue;\r\n                }\r\n                \r\n                // BRJ: Outer join for OR\r\n                boolean useOuterJoin = (crit.getType() == Criteria.OR);\r\n\r\n                // BRJ: do not build join tree for subQuery attribute                  \r\n                if (c.getAttribute() != null && c.getAttribute() instanceof String)\r\n                {\r\n\t\t\t\t\t//buildJoinTreeForColumn((String) c.getAttribute(), useOuterJoin, c.getAlias(), c.getPathClasses());\r\n\t\t\t\t\tbuildJoinTreeForColumn((String) c.getAttribute(), useOuterJoin, c.getUserAlias(), c.getPathClasses());\r\n                }\r\n                if (c instanceof FieldCriteria)\r\n                {\r\n                    FieldCriteria cc = (FieldCriteria) c;\r\n\t\t\t\t\tbuildJoinTreeForColumn((String) cc.getValue(), useOuterJoin, c.getUserAlias(), c.getPathClasses());\r\n                }\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "public static dnstxtrec get(nitro_service service, String domain) throws Exception{\n\t\tdnstxtrec obj = new dnstxtrec();\n\t\tobj.set_domain(domain);\n\t\tdnstxtrec response = (dnstxtrec) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (tl TypeLoader) Relkind(rt RelType) string {\n\tif tl.ProcessRelkind != nil {\n\t\treturn tl.ProcessRelkind(rt)\n\t}\n\n\treturn rt.String()\n}", "label": 5}
{"code": "function generateApplicationCode(swagger, codegenOptions) {\n  debug('Generating application code.');\n\n  // Build up the execution parameters for the templates.\n  const templateFunc = codegenOptions.templateSet;\n  const outputDirectory = codegenOptions.temporaryDirectory;\n  const codegenSettings = defaults(\n    templateFunc(codegenOptions.templateSettings),\n    {\n      output: (name, content) => {\n        const fullName = path.join(outputDirectory, name);\n        const parsed = path.parse(fullName);\n        mkdirp.sync(parsed.dir);\n        fs.writeFileSync(fullName, content);\n      },\n      swagger: JSON.parse(JSON.stringify(swagger)), // Clone to avoid issues\n    });\n\n  // Perform the actual code generation\n  codegen(codegenSettings);\n}", "label": 3}
{"code": "func CreateHTTPUpload(req HTTPTransferRequest) (Command, error) {\n\tif req.HTTPRequest == nil {\n\t\treturn nil, trace.BadParameter(\"missing parameter HTTPRequest\")\n\t}\n\n\tif req.FileName == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing file name\")\n\t}\n\n\tif req.RemoteLocation == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing remote location\")\n\t}\n\n\tcontentLength := req.HTTPRequest.Header.Get(\"Content-Length\")\n\tfileSize, err := strconv.ParseInt(contentLength, 10, 0)\n\tif err != nil {\n\t\treturn nil, trace.BadParameter(\"failed to parse Content-Length header: %q\", contentLength)\n\t}\n\n\tfs := &httpFileSystem{\n\t\treader:   req.HTTPRequest.Body,\n\t\tfileName: req.FileName,\n\t\tfileSize: fileSize,\n\t}\n\n\tflags := Flags{\n\t\t// scp treats it as a list of files to upload\n\t\tTarget: []string{req.FileName},\n\t}\n\n\tcfg := Config{\n\t\tFlags:          flags,\n\t\tFileSystem:     fs,\n\t\tUser:           req.User,\n\t\tProgressWriter: req.Progress,\n\t\tRemoteLocation: req.RemoteLocation,\n\t\tAuditLog:       req.AuditLog,\n\t}\n\n\tcmd, err := CreateUploadCommand(cfg)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn cmd, nil\n}", "label": 5}
{"code": "public Collection<HazeltaskTask<GROUP>> call() throws Exception {\n        try {\n            if(isShutdownNow)\n                return this.getDistributedExecutorService().shutdownNowWithHazeltask();\n            else\n                this.getDistributedExecutorService().shutdown();\n        } catch(IllegalStateException e) {}\n        \n        return Collections.emptyList();\n    }", "label": 0}
{"code": "def fix_bam_header(job, bamfile, sample_type, univ_options, samtools_options, retained_chroms=None):\n    \"\"\"\n    Fix the bam header to remove the command line call.  Failing to do this causes Picard to reject\n    the bam.\n\n    :param dict bamfile: The input bam file\n    :param str sample_type: Description of the sample to inject into the filename\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict samtools_options: Options specific to samtools\n    :param list retained_chroms: A list of chromosomes to retain\n    :return: fsID for the output bam\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    if retained_chroms is None:\n        retained_chroms = []\n\n    work_dir = os.getcwd()\n    input_files = {\n        sample_type + '.bam': bamfile}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=True)\n    parameters = ['view',\n                  '-H',\n                  input_files[sample_type + '.bam']]\n    with open('/'.join([work_dir, sample_type + '_input_bam.header']), 'w') as headerfile:\n        docker_call(tool='samtools', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'], outfile=headerfile,\n                    tool_version=samtools_options['version'])\n    with open(headerfile.name, 'r') as headerfile, \\\n            open('/'.join([work_dir, sample_type + '_output_bam.header']), 'w') as outheaderfile:\n        for line in headerfile:\n            if line.startswith('@PG'):\n                line = '\\t'.join([x for x in line.strip().split('\\t') if not x.startswith('CL')])\n            if retained_chroms and line.startswith('@SQ'):\n                if line.strip().split()[1].lstrip('SN:') not in retained_chroms:\n                    continue\n            print(line.strip(), file=outheaderfile)\n    parameters = ['reheader',\n                  docker_path(outheaderfile.name),\n                  input_files[sample_type + '.bam']]\n    with open('/'.join([work_dir, sample_type + '_fixPG.bam']), 'w') as fixpg_bamfile:\n        docker_call(tool='samtools', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'], outfile=fixpg_bamfile,\n                    tool_version=samtools_options['version'])\n    output_file = job.fileStore.writeGlobalFile(fixpg_bamfile.name)\n    # The old bam file is now useless.\n    job.fileStore.deleteGlobalFile(bamfile)\n    job.fileStore.logToMaster('Ran reheader on %s:%s successfully'\n                              % (univ_options['patient'], sample_type))\n    return output_file", "label": 1}
{"code": "public function translate($string, array $options = [])\n    {\n        $res = $this->translateBatch([$string], $options);\n        if (count($res) > 0) {\n            return $res[0];\n        }\n    }", "label": 2}
{"code": "def delete(self, changelist=0):\n        \"\"\"Marks the file for delete\n\n        :param changelist: Changelist to add the move to\n        :type changelist: :class:`.Changelist`\n        \"\"\"\n        cmd = ['delete']\n\n        if changelist:\n            cmd += ['-c', str(changelist)]\n\n        cmd.append(self.depotFile)\n        self._connection.run(cmd)\n\n        self.query()", "label": 1}
{"code": "def retryer(&blk)\n      loop do\n        @try_count += 1\n        y = blk.call(@try_count, @retry_exception)\n        @retry_exception = nil # no exception was raised in the block\n        return y if y\n        raise Bosh::Common::RetryCountExceeded if @try_count >= @retry_limit\n        wait\n      end\n    rescue Exception => exception\n      raise unless @matchers.any? { |m| m.matches?(exception) }\n      raise unless exception.message =~ @matching\n      raise if @try_count >= @retry_limit\n\n      @retry_exception = exception\n      wait\n      retry\n    ensure\n      @ensure_callback.call(@try_count)\n    end", "label": 4}
{"code": "public function setTimeRange($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\V2\\TimestampRange::class);\n        $this->time_range = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def start_session(options = {})\n      cluster.send(:get_session, self, options.merge(implicit: false)) ||\n        (raise Error::InvalidSession.new(Session::SESSIONS_NOT_SUPPORTED))\n    end", "label": 4}
{"code": "private function topicFactory($name, array $info = [])\n    {\n        return new Topic(\n            $this->connection,\n            $this->projectId,\n            $name,\n            $this->encode,\n            $info,\n            $this->clientConfig\n        );\n    }", "label": 2}
{"code": "def _encode_caveat_v2_v3(version, condition, root_key, third_party_pub_key,\n                         key, ns):\n    '''Create a version 2 or version 3 third-party caveat.\n\n    The format has the following packed binary fields (note\n    that all fields up to and including the nonce are the same\n    as the v2 format):\n\n        version 2 or 3 [1 byte]\n        first 4 bytes of third-party Curve25519 public key [4 bytes]\n        first-party Curve25519 public key [32 bytes]\n        nonce [24 bytes]\n        encrypted secret part [rest of message]\n\n    The encrypted part encrypts the following fields\n    with box.Seal:\n\n        version 2 or 3 [1 byte]\n        length of root key [n: uvarint]\n        root key [n bytes]\n        length of encoded namespace [n: uvarint] (Version 3 only)\n        encoded namespace [n bytes] (Version 3 only)\n        condition [rest of encrypted part]\n    '''\n    ns_data = bytearray()\n    if version >= VERSION_3:\n        ns_data = ns.serialize_text()\n    data = bytearray()\n    data.append(version)\n    data.extend(third_party_pub_key.serialize(raw=True)[:_PUBLIC_KEY_PREFIX_LEN])\n    data.extend(key.public_key.serialize(raw=True)[:])\n    secret = _encode_secret_part_v2_v3(version, condition, root_key, ns_data)\n    box = nacl.public.Box(key.key, third_party_pub_key.key)\n    encrypted = box.encrypt(secret)\n    nonce = encrypted[0:nacl.public.Box.NONCE_SIZE]\n    encrypted = encrypted[nacl.public.Box.NONCE_SIZE:]\n    data.extend(nonce[:])\n    data.extend(encrypted)\n    return bytes(data)", "label": 1}
{"code": "public static nslimitidentifier_stats[] get(nitro_service service) throws Exception{\n\t\tnslimitidentifier_stats obj = new nslimitidentifier_stats();\n\t\tnslimitidentifier_stats[] response = (nslimitidentifier_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function JobQueue(para) {\n\tthis.queue = [];\n\tthis.curr = 0;\n\tthis.all_passed = true;\n\tthis.timeout = ((typeof para === 'object' && typeof para.timeout === 'number') ? para.timeout : 0);\n}", "label": 3}
{"code": "func GetClaimNames(claims jose.Claims) []string {\n\tvar out []string\n\tfor claim := range claims {\n\t\tout = append(out, claim)\n\t}\n\treturn out\n}", "label": 5}
{"code": "func (fs *FSLocalKeyStore) GetKey(proxyHost string, username string) (*Key, error) {\n\tdirPath, err := fs.dirFor(proxyHost, false)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\t_, err = ioutil.ReadDir(dirPath)\n\tif err != nil {\n\t\treturn nil, trace.NotFound(\"no session keys for %v in %v\", username, proxyHost)\n\t}\n\n\tcertFile := filepath.Join(dirPath, username+fileExtCert)\n\tcert, err := ioutil.ReadFile(certFile)\n\tif err != nil {\n\t\tfs.log.Error(err)\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttlsCertFile := filepath.Join(dirPath, username+fileExtTLSCert)\n\ttlsCert, err := ioutil.ReadFile(tlsCertFile)\n\tif err != nil {\n\t\tfs.log.Error(err)\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tpub, err := ioutil.ReadFile(filepath.Join(dirPath, username+fileExtPub))\n\tif err != nil {\n\t\tfs.log.Error(err)\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tpriv, err := ioutil.ReadFile(filepath.Join(dirPath, username))\n\tif err != nil {\n\t\tfs.log.Error(err)\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tkey := &Key{Pub: pub, Priv: priv, Cert: cert, ProxyHost: proxyHost, TLSCert: tlsCert}\n\n\t// Validate the key loaded from disk.\n\terr = key.CheckCert()\n\tif err != nil {\n\t\t// KeyStore should return expired certificates as well\n\t\tif !utils.IsCertExpiredError(err) {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t}\n\tsshCertExpiration, err := key.CertValidBefore()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttlsCertExpiration, err := key.TLSCertValidBefore()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\t// Note, we may be returning expired certificates here, that is okay. If the\n\t// certificates is expired, it's the responsibility of the TeleportClient to\n\t// perform cleanup of the certificates and the profile.\n\tfs.log.Debugf(\"Returning SSH certificate %q valid until %q, TLS certificate %q valid until %q.\",\n\t\tcertFile, sshCertExpiration, tlsCertFile, tlsCertExpiration)\n\n\treturn key, nil\n}", "label": 5}
{"code": "func ProvisionTokensToV1(in []ProvisionToken) []ProvisionTokenV1 {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := make([]ProvisionTokenV1, len(in))\n\tfor i := range in {\n\t\tout[i] = *in[i].V1()\n\t}\n\treturn out\n}", "label": 5}
{"code": "function _buildCursor(db, EntityClass, query) {\n  // copy query to not mess with user's object\n  query = objects.copy(query);\n\n  // rename id field\n  if (query.hasOwnProperty('id')) {\n    query._id = query.id;\n    delete query.id;\n  }\n\n  // find collection name\n  var name = getEntityCollectionName(EntityClass);\n\n  // build cursor\n  return db.collection(name).find(query);\n}", "label": 3}
{"code": "public function getSignedCookie(array $options)\n    {\n        foreach (['key_pair_id', 'private_key'] as $required) {\n            if (!isset($options[$required])) {\n                throw new \\InvalidArgumentException(\"$required is required\");\n            }\n        }\n\n        $cookieSigner = new CookieSigner(\n            $options['key_pair_id'],\n            $options['private_key']\n        );\n\n        return $cookieSigner->getSignedCookie(\n            isset($options['url']) ? $options['url'] : null,\n            isset($options['expires']) ? $options['expires'] : null,\n            isset($options['policy']) ? $options['policy'] : null\n        );\n    }", "label": 2}
{"code": "public Boolean checkType(String type) {\n    if (mtasPositionType == null) {\n      return false;\n    } else {\n      return mtasPositionType.equals(type);\n    }\n  }", "label": 0}
{"code": "public static <E> Counter<E> divideInPlace(Counter<E> target, double divisor) {\r\n    for (Entry<E, Double> entry : target.entrySet()) {\r\n      target.setCount(entry.getKey(), entry.getValue() / divisor);\r\n    }\r\n    return target;\r\n  }", "label": 0}
{"code": "public SerialMessage getMultiInstanceGetMessage(CommandClass commandClass) {\r\n\t\tlogger.debug(\"Creating new message for application command MULTI_INSTANCE_GET for node {} and command class {}\", this.getNode().getNodeId(), commandClass.getLabel());\r\n\t\tSerialMessage result = new SerialMessage(this.getNode().getNodeId(), SerialMessageClass.SendData, SerialMessageType.Request, SerialMessageClass.ApplicationCommandHandler, SerialMessagePriority.Get);\r\n    \tbyte[] newPayload = { \t(byte) this.getNode().getNodeId(), \r\n    \t\t\t\t\t\t\t3, \r\n\t\t\t\t\t\t\t\t(byte) getCommandClass().getKey(), \r\n\t\t\t\t\t\t\t\t(byte) MULTI_INSTANCE_GET,\r\n\t\t\t\t\t\t\t\t(byte) commandClass.getKey()\r\n\t\t\t\t\t\t\t\t};\r\n    \tresult.setMessagePayload(newPayload);\r\n    \treturn result;\t\t\r\n\t}", "label": 0}
{"code": "public void setManyToOneAttribute(String name, AssociationValue value) {\n\t\tensureAttributes();\n\t\tAttribute attribute = new ManyToOneAttribute(value);\n\t\tattribute.setEditable(isEditable(name));\n\t\tgetAllAttributes().put(name, attribute);\n\n\t}", "label": 0}
{"code": "public static cacheobject[] get(nitro_service service) throws Exception{\n\t\tcacheobject obj = new cacheobject();\n\t\tcacheobject[] response = (cacheobject[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (t *Torrent) NewReader() Reader {\n\tr := reader{\n\t\tmu:        t.cl.locker(),\n\t\tt:         t,\n\t\treadahead: 5 * 1024 * 1024,\n\t\tlength:    *t.length,\n\t}\n\tt.addReader(&r)\n\treturn &r\n}", "label": 5}
{"code": "public function ordinal(string $key, string $period = null): string\n    {\n        $number = $this->$key;\n        $result = $this->translate('ordinal', [\n            ':number' => $number,\n            ':period' => $period,\n        ]);\n\n        return strval($result === 'ordinal' ? $number : $result);\n    }", "label": 2}
{"code": "def get_resource(remote):\n    \"\"\"Query CERN Resources to get user info and groups.\"\"\"\n    cached_resource = session.pop('cern_resource', None)\n    if cached_resource:\n        return cached_resource\n\n    response = remote.get(REMOTE_APP_RESOURCE_API_URL)\n    dict_response = get_dict_from_response(response)\n    session['cern_resource'] = dict_response\n    return dict_response", "label": 1}
{"code": "func PgForeignDataWrapperByOid(db XODB, oid pgtypes.Oid) (*PgForeignDataWrapper, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, fdwname, fdwowner, fdwhandler, fdwvalidator, fdwacl, fdwoptions ` +\n\t\t`FROM pg_catalog.pg_foreign_data_wrapper ` +\n\t\t`WHERE oid = $1`\n\n\t// run query\n\tXOLog(sqlstr, oid)\n\tpfdw := PgForeignDataWrapper{}\n\n\terr = db.QueryRow(sqlstr, oid).Scan(&pfdw.Tableoid, &pfdw.Cmax, &pfdw.Xmax, &pfdw.Cmin, &pfdw.Xmin, &pfdw.Oid, &pfdw.Ctid, &pfdw.Fdwname, &pfdw.Fdwowner, &pfdw.Fdwhandler, &pfdw.Fdwvalidator, &pfdw.Fdwacl, &pfdw.Fdwoptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pfdw, nil\n}", "label": 5}
{"code": "public function upsert(EntityInterface $entity, array $options = [])\n    {\n        $res = $this->upsertBatch([$entity], $options);\n        return $this->parseSingleMutationResult($res);\n    }", "label": 2}
{"code": "func (c *Client) UpsertSAMLConnector(connector services.SAMLConnector) error {\n\tdata, err := services.GetSAMLConnectorMarshaler().MarshalSAMLConnector(connector)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t_, err = c.PutJSON(c.Endpoint(\"saml\", \"connectors\"), &upsertSAMLConnectorRawReq{\n\t\tConnector: data,\n\t})\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "func (i *Handle) GetDestinations(s *Service) ([]*Destination, error) {\n\treturn i.doGetDestinationsCmd(s, nil)\n}", "label": 5}
{"code": "public void registerPrefixStatsSinglePositionValue(String field,\n      String prefix, IndexOutput outPrefix) throws IOException {\n    initPrefixStatsField(field);\n    registerPrefix(field, prefix, outPrefix);\n    if (!multiplePositionPrefix.get(field).contains(prefix)) {\n      singlePositionPrefix.get(field).add(prefix);\n    }\n  }", "label": 0}
{"code": "function deleteIfEmpty(file, options) {\n  options = _.opts(options, {deleteDirs: true});\n  return fileDelete(file, _.extend(_.opts(options), {onlyEmptyDirs: true}));\n}", "label": 3}
{"code": "public function setProperty($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Vision\\V1\\TextAnnotation_TextProperty::class);\n        $this->property = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function (methodName, params, execOptions) {\n                execOptions = execOptions || {};\n\n                var options = {\n                    enableBatching: execOptions.hasOwnProperty('enableBatching') ?\n                        execOptions.enableBatching :\n                        this._options.enableBatching,\n                    timeout: execOptions.timeout || this._options.timeout\n                };\n\n                return options.enableBatching ?\n                    this._execWithBatching(methodName, params, options) :\n                    this._execWithoutBatching(methodName, params, options);\n            }", "label": 3}
{"code": "def list(self, id, filter=None, type=None, sort=None, limit=None, page=None): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Get a list of a device's attachments.\n\n        :param id: Device ID as an int.\n        :param filter: (optional) Filters to apply as a string list.\n        :param type: (optional) `union` or `inter` as string.\n        :param sort: (optional) Sort fields to apply as string list.\n        :param limit: (optional) Limit returned list length.\n        :param page: (optional) Page to return.\n        :return: :class:`attachments.Page <attachments.Page>` object\n        \"\"\"\n        schema = AttachmentSchema(exclude=('path'))\n        resp = self.service.list(self._base(id), filter, type, sort, limit, page)\n        at, l = self.service.decode(schema, resp, many=True, links=True)\n        return Page(at, l)", "label": 1}
{"code": "def formatted_offset(colon = true, alternate_utc_string = nil)\n      utc? && alternate_utc_string || TimeZone.seconds_to_utc_offset(utc_offset, colon)\n    end", "label": 4}
{"code": "protected String sp_createSequenceQuery(String sequenceName, long maxKey)\r\n    {\r\n        return \"insert into \" + SEQ_TABLE_NAME + \" (\"\r\n                + SEQ_NAME_STRING + \",\" + SEQ_ID_STRING +\r\n                \") values ('\" + sequenceName + \"',\" + maxKey + \")\";\r\n    }", "label": 0}
{"code": "public function set($key, $value)\n    {\n        return $this->add('set', new Expr\\Comparison($key, Expr\\Comparison::EQ, $value), true);\n    }", "label": 2}
{"code": "func isURI(fl FieldLevel) bool {\n\n\tfield := fl.Field()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\n\t\ts := field.String()\n\n\t\t// checks needed as of Go 1.6 because of change https://github.com/golang/go/commit/617c93ce740c3c3cc28cdd1a0d712be183d0b328#diff-6c2d018290e298803c0c9419d8739885L195\n\t\t// emulate browser and strip the '#' suffix prior to validation. see issue-#237\n\t\tif i := strings.Index(s, \"#\"); i > -1 {\n\t\t\ts = s[:i]\n\t\t}\n\n\t\tif len(s) == 0 {\n\t\t\treturn false\n\t\t}\n\n\t\t_, err := url.ParseRequestURI(s)\n\n\t\treturn err == nil\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}", "label": 5}
{"code": "func (s SearchIndex) FindChild(ctx context.Context, entity Reference, name string) (Reference, error) {\n\treq := types.FindChild{\n\t\tThis:   s.Reference(),\n\t\tEntity: entity.Reference(),\n\t\tName:   name,\n\t}\n\n\tres, err := methods.FindChild(ctx, s.c, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.Returnval == nil {\n\t\treturn nil, nil\n\t}\n\treturn NewReference(s.c, *res.Returnval), nil\n}", "label": 5}
{"code": "def run_matrix_ordered(self, process_data):\n        \"\"\"\n        Running pipelines one after the other.\n\n        Returns\n            dict: with two fields: success True/False and captured output (list of str).\n        \"\"\"\n        output = []\n        for entry in self.matrix:\n            env = entry['env'].copy()\n            env.update({'PIPELINE_MATRIX': entry['name']})\n\n            if Matrix.can_process_matrix(entry, process_data.options.matrix_tags):\n                self.logger.info(\"Processing pipeline for matrix entry '%s'\", entry['name'])\n                pipeline = Pipeline(model=process_data.model, env=env,\n                                    options=process_data.options)\n                pipeline.hooks = process_data.hooks\n                result = pipeline.process(process_data.pipeline)\n                output += result['output']\n                if not result['success']:\n                    return {'success': False, 'output': output}\n        return {'success': True, 'output': output}", "label": 1}
{"code": "def process_source(data)\n      if data['source'] =~ %r[://]\n        source_uri = URI.parse(data['source'])\n      else\n        source_uri = URI.parse(\"http://#{data['source']}\")\n      end\n\n      if source_uri.host =~ /^(www\\.)?github\\.com$/\n        source_uri.scheme = 'https'\n        source_uri.path.sub!(/\\.git$/, '')\n        data['project_page'] ||= @data['project_page'] || source_uri.to_s\n        data['issues_url'] ||= @data['issues_url'] || source_uri.to_s.sub(/\\/*$/, '') + '/issues'\n      end\n\n    rescue URI::Error\n      return\n    end", "label": 4}
{"code": "private function adjust_offset_for_shrinking_result_set() {\n\t\tif ( empty( $this->count_query ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$row_count = $this->db->get_var( $this->count_query );\n\n\t\tif ( $row_count < $this->row_count ) {\n\t\t\t$this->offset -= $this->row_count - $row_count;\n\t\t}\n\n\t\t$this->row_count = $row_count;\n\t}", "label": 2}
{"code": "func (rd *Redirector) ClickableURL() string {\n\tif rd.server == nil {\n\t\treturn \"<undefined - server is not started>\"\n\t}\n\treturn utils.ClickableURL(rd.server.URL + rd.shortPath)\n}", "label": 5}
{"code": "function loadWithPromise (options) {\n  return new Promise((resolve, reject) => {\n    loadWithCallback(options, (error, config) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(config)\n      }\n    })\n  })\n}", "label": 3}
{"code": "def server_errors\n      [\n        OpenSSL::SSL::SSLError,\n        Errno::ETIMEDOUT,\n        Errno::EHOSTUNREACH,\n        Errno::ENETUNREACH,\n        Errno::ECONNRESET,\n        Net::OpenTimeout,\n        SocketError,\n        Net::HTTPServerError\n      ] + extra_server_errors\n    end", "label": 4}
{"code": "public function rename($title)\n    {\n        if ($this->title !== $title) {\n            $oldTitle = $this->title;\n            $this->title = $title;\n\n            $this->raise(new Renamed($this, $oldTitle));\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "public static nsrpcnode[] get(nitro_service service) throws Exception{\n\t\tnsrpcnode obj = new nsrpcnode();\n\t\tnsrpcnode[] response = (nsrpcnode[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func makeTeleportClientConfig(ctx *SessionContext) (*client.Config, error) {\n\tagent, cert, err := ctx.GetAgent()\n\tif err != nil {\n\t\treturn nil, trace.BadParameter(\"failed to get user credentials: %v\", err)\n\t}\n\n\tsigners, err := agent.Signers()\n\tif err != nil {\n\t\treturn nil, trace.BadParameter(\"failed to get user credentials: %v\", err)\n\t}\n\n\ttlsConfig, err := ctx.ClientTLSConfig()\n\tif err != nil {\n\t\treturn nil, trace.BadParameter(\"failed to get client TLS config: %v\", err)\n\t}\n\n\tconfig := &client.Config{\n\t\tUsername:         ctx.user,\n\t\tAgent:            agent,\n\t\tSkipLocalAuth:    true,\n\t\tTLS:              tlsConfig,\n\t\tAuthMethods:      []ssh.AuthMethod{ssh.PublicKeys(signers...)},\n\t\tDefaultPrincipal: cert.ValidPrincipals[0],\n\t\tHostKeyCallback:  func(string, net.Addr, ssh.PublicKey) error { return nil },\n\t}\n\n\treturn config, nil\n}", "label": 5}
{"code": "public function getDropSchemaSQL(array $classes)\n    {\n        $visitor = new DropSchemaSqlCollector($this->platform);\n        $schema  = $this->getSchemaFromMetadata($classes);\n\n        $sm         = $this->em->getConnection()->getSchemaManager();\n        $fullSchema = $sm->createSchema();\n\n        foreach ($fullSchema->getTables() as $table) {\n            if (! $schema->hasTable($table->getName())) {\n                foreach ($table->getForeignKeys() as $foreignKey) {\n                    /** @var $foreignKey \\Doctrine\\DBAL\\Schema\\ForeignKeyConstraint */\n                    if ($schema->hasTable($foreignKey->getForeignTableName())) {\n                        $visitor->acceptForeignKey($table, $foreignKey);\n                    }\n                }\n            } else {\n                $visitor->acceptTable($table);\n                foreach ($table->getForeignKeys() as $foreignKey) {\n                    $visitor->acceptForeignKey($table, $foreignKey);\n                }\n            }\n        }\n\n        if ($this->platform->supportsSequences()) {\n            foreach ($schema->getSequences() as $sequence) {\n                $visitor->acceptSequence($sequence);\n            }\n\n            foreach ($schema->getTables() as $table) {\n                /** @var $sequence Table */\n                if ($table->hasPrimaryKey()) {\n                    $columns = $table->getPrimaryKey()->getColumns();\n                    if (count($columns) === 1) {\n                        $checkSequence = $table->getName() . '_' . $columns[0] . '_seq';\n                        if ($fullSchema->hasSequence($checkSequence)) {\n                            $visitor->acceptSequence($fullSchema->getSequence($checkSequence));\n                        }\n                    }\n                }\n            }\n        }\n\n        return $visitor->getQueries();\n    }", "label": 2}
{"code": "function each_pair_in_object_expression(ast, func) {\n  if (! (ast && ast[\"type\"] == \"ObjectExpression\")) {\n    return;\n  }\n\n  return _.each(ast[\"properties\"], function(p) {\n    isFn(key_value(p[\"key\"]), p[\"value\"], p);\n  });\n}", "label": 3}
{"code": "def setAccessRules(self, pid, public=False):\n        \"\"\"\n        Set access rules for a resource.  Current only allows for setting the public or private setting.\n\n        :param pid: The HydroShare ID of the resource\n        :param public: True if the resource should be made public.\n        \"\"\"\n        url = \"{url_base}/resource/accessRules/{pid}/\".format(url_base=self.url_base,\n                                                              pid=pid)\n        params = {'public': public}\n\n        r = self._request('PUT', url, data=params)\n        if r.status_code != 200:\n            if r.status_code == 403:\n                raise HydroShareNotAuthorized(('PUT', url))\n            elif r.status_code == 404:\n                raise HydroShareNotFound((pid,))\n            else:\n                raise HydroShareHTTPException((url, 'PUT', r.status_code, params))\n\n        resource = r.json()\n        assert(resource['resource_id'] == pid)\n        return resource['resource_id']", "label": 1}
{"code": "def parse_single_country(e164, data)\n      valid_match = phone_match_data?(e164, data)\n      if valid_match\n        national_and_data(data, valid_match)\n      else\n        possible_match = phone_match_data?(e164, data, true)\n        possible_match && national_and_data(data, possible_match, true)\n      end\n    end", "label": 4}
{"code": "function translate(singular, plural) {\n    if (!locales[currentLocale]) {\n        read(currentLocale);\n    }\n\n    if (plural) {\n        if (!locales[currentLocale][singular]) {\n            locales[currentLocale][singular] = {\n                'one': singular,\n                'other': plural\n            };\n            write(currentLocale);\n        }\n    }\n\n    if (!locales[currentLocale][singular]) {\n        locales[currentLocale][singular] = singular;\n        write(currentLocale);\n    }\n    return locales[currentLocale][singular];\n}", "label": 3}
{"code": "function(numbers)\n  {\n    var resolver = createNumberResolver( numbers );\n    var result = 0;\n    var total = 0;\n\n    function process(x)\n    {\n      result += x;\n      total++;\n    }\n\n    function getResult()\n    {\n      return total === 0 ? 0 : result / total;\n    }\n\n    return this.aggregate( resolver, isNumber, process, getResult );\n  }", "label": 3}
{"code": "func NewSimulationScreen(charset string) SimulationScreen {\n\tif charset == \"\" {\n\t\tcharset = \"UTF-8\"\n\t}\n\ts := &simscreen{charset: charset}\n\treturn s\n}", "label": 5}
{"code": "private Criteria buildPrefetchCriteriaMultipleKeys(Collection ids, FieldDescriptor fields[])\r\n    {\r\n        Criteria crit = new Criteria();\r\n        Iterator iter = ids.iterator();\r\n        Object[] val;\r\n        Identity id;\r\n\r\n        while (iter.hasNext())\r\n        {\r\n            Criteria c = new Criteria();\r\n            id = (Identity) iter.next();\r\n            val = id.getPrimaryKeyValues();\r\n            for (int i = 0; i < val.length; i++)\r\n            {\r\n                if (val[i] == null)\r\n                {\r\n                    c.addIsNull(fields[i].getAttributeName());\r\n                }\r\n                else\r\n                {\r\n                    c.addEqualTo(fields[i].getAttributeName(), val[i]);\r\n                }\r\n            }\r\n            crit.addOrCriteria(c);\r\n        }\r\n\r\n        return crit;\r\n    }", "label": 0}
{"code": "def append_lane(lane)\n      lane.compact! # remove nil values\n\n      new_lines = \"\\n\\n\"\n      if self.is_swift_fastfile\n        new_lines = \"\" unless self.fastfile_content.include?(\"lane() {\") # the first lane we don't want new lines\n        self.fastfile_content.gsub!(\"[[LANES]]\", \"#{new_lines}\\t#{lane.join(\"\\n\\t\")}[[LANES]]\")\n      else\n        new_lines = \"\" unless self.fastfile_content.include?(\"lane :\") # the first lane we don't want new lines\n        self.fastfile_content.gsub!(\"[[LANES]]\", \"#{new_lines}  #{lane.join(\"\\n  \")}[[LANES]]\")\n      end\n    end", "label": 4}
{"code": "def get_offers(self, n_points=6):\n        \"\"\" Returns quantity and price offers created from the cost function.\n        \"\"\"\n        from pyreto.smart_market import Offer\n\n        qtyprc = self._get_qtyprc(n_points)\n        return [Offer(self, qty, prc) for qty, prc in qtyprc]", "label": 1}
{"code": "func (c *IpamConf) Validate() error {\n\tif c.Gateway != \"\" && nil == net.ParseIP(c.Gateway) {\n\t\treturn types.BadRequestErrorf(\"invalid gateway address %s in Ipam configuration\", c.Gateway)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function () {\n      var self = this;\n\n      this.trajectories.forEach(function(line, index) {\n        write('\\u001b[' + self.scoreboardWidth + 'C');\n        write(line.join(''));\n        write('\\n');\n      });\n\n      cursor.up(this.numberOfLines);\n    }", "label": 3}
{"code": "public function whereHas($relation, $closure)\n    {\n        $this->model = $this->model->whereHas($relation, $closure);\n\n        return $this;\n    }", "label": 2}
{"code": "def token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Used by flask-oauthlib to get the access token when making requests.\n\n    :param remote: The remote application.\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n        identify which token to retrieve. (Default: ``''``)\n    :returns: The token.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated:\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)", "label": 1}
{"code": "func (f *Fpdf) write(h float64, txtStr string, link int, linkStr string) {\n\t// dbg(\"Write\")\n\tcw := &f.currentFont.Cw\n\tw := f.w - f.rMargin - f.x\n\twmax := (w - 2*f.cMargin) * 1000 / f.fontSize\n\ts := strings.Replace(txtStr, \"\\r\", \"\", -1)\n\tnb := len(s)\n\tsep := -1\n\ti := 0\n\tj := 0\n\tl := 0.0\n\tnl := 1\n\tfor i < nb {\n\t\t// Get next character\n\t\tc := []byte(s)[i]\n\t\tif c == '\\n' {\n\t\t\t// Explicit line break\n\t\t\tf.CellFormat(w, h, s[j:i], \"\", 2, \"\", false, link, linkStr)\n\t\t\ti++\n\t\t\tsep = -1\n\t\t\tj = i\n\t\t\tl = 0.0\n\t\t\tif nl == 1 {\n\t\t\t\tf.x = f.lMargin\n\t\t\t\tw = f.w - f.rMargin - f.x\n\t\t\t\twmax = (w - 2*f.cMargin) * 1000 / f.fontSize\n\t\t\t}\n\t\t\tnl++\n\t\t\tcontinue\n\t\t}\n\t\tif c == ' ' {\n\t\t\tsep = i\n\t\t}\n\t\tl += float64(cw[c])\n\t\tif l > wmax {\n\t\t\t// Automatic line break\n\t\t\tif sep == -1 {\n\t\t\t\tif f.x > f.lMargin {\n\t\t\t\t\t// Move to next line\n\t\t\t\t\tf.x = f.lMargin\n\t\t\t\t\tf.y += h\n\t\t\t\t\tw = f.w - f.rMargin - f.x\n\t\t\t\t\twmax = (w - 2*f.cMargin) * 1000 / f.fontSize\n\t\t\t\t\ti++\n\t\t\t\t\tnl++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif i == j {\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tf.CellFormat(w, h, s[j:i], \"\", 2, \"\", false, link, linkStr)\n\t\t\t} else {\n\t\t\t\tf.CellFormat(w, h, s[j:sep], \"\", 2, \"\", false, link, linkStr)\n\t\t\t\ti = sep + 1\n\t\t\t}\n\t\t\tsep = -1\n\t\t\tj = i\n\t\t\tl = 0.0\n\t\t\tif nl == 1 {\n\t\t\t\tf.x = f.lMargin\n\t\t\t\tw = f.w - f.rMargin - f.x\n\t\t\t\twmax = (w - 2*f.cMargin) * 1000 / f.fontSize\n\t\t\t}\n\t\t\tnl++\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\t// Last chunk\n\tif i != j {\n\t\tf.CellFormat(l/1000*f.fontSize, h, s[j:], \"\", 0, \"\", false, link, linkStr)\n\t}\n}", "label": 5}
{"code": "public function setPartOfSpeech($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Language\\V1\\PartOfSpeech::class);\n        $this->part_of_speech = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_response disable(nitro_service client, nsacl6 resource) throws Exception {\n\t\tnsacl6 disableresource = new nsacl6();\n\t\tdisableresource.acl6name = resource.acl6name;\n\t\treturn disableresource.perform_operation(client,\"disable\");\n\t}", "label": 0}
{"code": "function (name, state) {\n        if (!module.exports.operations.validateState || module.exports.operations.validateState(state)) {\n            module.exports.config.states[name] = state;\n        } else {\n            log.error('Unable to update invalid state:', state, 'with name:', name);\n        }\n    }", "label": 3}
{"code": "function full(source) {\n        for (var i = 0, item; i < source.length; i++) {\n          item = source.splice(i, 1)[0];\n          seen.push(item);\n\n          if (source.length === 0) permutations.push(seen.slice());\n          full(source);\n\n          source.splice(i, 0, item);\n          seen.pop();\n        }\n\n        return permutations;\n      }", "label": 3}
{"code": "function(callback) {\n      var errName;\n      try {\n        if (self._covered) {\n          // If coverage is request, we want the testModule to reference the\n          // code instrumented by istanbul in lib-cov/ instead of any local code in lib/.\n          // This passage looks for variables assigned to by require('lib/*')\n          // and sets a value for the variable which is the equivalent module in lib-cov.\n\n          var fullModuleName = path.resolve(testModule);\n          if (!fullModuleName.match(/\\.js$/)) {\n            fullModuleName = fullModuleName + '.js';\n          }\n          var requirements = requiredAs(fullModuleName);\n\n          // for every requirement in lib/, rewrite to lib-cov/\n          var newRequirements = underscore.map(requirements, function(req) {\n            if (req.source.match(/node_modules/) || !req.source.match(/lib\\//)) {\n              return undefined;\n            }\n            req.source = path.resolve(path.dirname(fullModuleName), req.source);\n            req.source = req.source.replace(/lib\\//, 'lib-cov/');\n\n            return req;\n          });\n\n          exportedFunctions = rewire(fullModuleName);\n\n          underscore.each(newRequirements.filter(function(i) { return i; }), function(nr) {\n            exportedFunctions.__set__(nr.name, require(nr.source));\n          });\n        } else {\n          exportedFunctions = require(testModule);\n        }\n      }\n      catch (err) {\n        if (err.message.indexOf(testModule) !== -1 &&\n            err.message.match(/cannot find module/i)) {\n            errName = 'file_does_not_exist';\n          }\n          else {\n            errName = 'uncaught_exception';\n          }\n\n          test = new Test(errName, null);\n          test._markAsFailed(err);\n          self._reportTestResult(test.getResultObject());\n          callback(err);\n          return;\n      }\n\n      exportedFunctionsNames = Object.keys(exportedFunctions);\n      exportedFunctionsNames = exportedFunctionsNames.filter(isValidTestFunctionName);\n      testsLen = exportedFunctionsNames.length;\n      initializeFunc = exportedFunctions[constants.TEST_FILE_INITIALIZE_FUNCTION_NAME];\n      finalizeFunc = exportedFunctions[constants.TEST_FILE_FINALIZE_FUNCTION_NAME];\n      setUpFunc = exportedFunctions[constants.SETUP_FUNCTION_NAME];\n      tearDownFunc = exportedFunctions[constants.TEARDOWN_FUNCTION_NAME];\n\n      callback();\n    }", "label": 3}
{"code": "def select(table, cols=\"*\", where=(), group=\"\", order=(), limit=(), **kwargs):\r\n    \"\"\"Convenience wrapper for database SELECT.\"\"\"\r\n    where = dict(where, **kwargs).items()\r\n    sql, args = makeSQL(\"SELECT\", table, cols, where, group, order, limit)\r\n    return execute(sql, args)", "label": 1}
{"code": "public static vpnsessionaction get(nitro_service service, String name) throws Exception{\n\t\tvpnsessionaction obj = new vpnsessionaction();\n\t\tobj.set_name(name);\n\t\tvpnsessionaction response = (vpnsessionaction) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function getCompletionEntryDisplayName(name, target, performCharacterChecks) {\n            if (!name) {\n                return undefined;\n            }\n            name = ts.stripQuotes(name);\n            if (!name) {\n                return undefined;\n            }\n            // If the user entered name for the symbol was quoted, removing the quotes is not enough, as the name could be an\n            // invalid identifier name. We need to check if whatever was inside the quotes is actually a valid identifier name.\n            // e.g \"b a\" is valid quoted name but when we strip off the quotes, it is invalid.\n            // We, thus, need to check if whatever was inside the quotes is actually a valid identifier name.\n            if (performCharacterChecks) {\n                if (!ts.isIdentifier(name, target)) {\n                    return undefined;\n                }\n            }\n            return name;\n        }", "label": 3}
{"code": "public static ipseccounters_stats get(nitro_service service) throws Exception{\n\t\tipseccounters_stats obj = new ipseccounters_stats();\n\t\tipseccounters_stats[] response = (ipseccounters_stats[])obj.stat_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "public function newDefaultAnnotationDriver(array $paths = []) : AnnotationDriver\n    {\n        AnnotationRegistry::registerFile(__DIR__ . '/Annotation/DoctrineAnnotations.php');\n\n        $reader = new CachedReader(new AnnotationReader(), new ArrayCache());\n\n        return new AnnotationDriver($reader, $paths);\n    }", "label": 2}
{"code": "function getDataSourceIds(forms) {\n    var dataSources = _.map(forms, function(form) {\n      return _.map(form.dataSources.formDataSources, function(dataSourceMeta) {\n        return dataSourceMeta._id.toString();\n      });\n    });\n\n    dataSources = _.flatten(dataSources);\n\n    //Only want unique data source Ids as multiple forms may use the same data source.\n\n    return _.uniq(dataSources);\n  }", "label": 3}
{"code": "public static base_response restore(nitro_service client, systembackup resource) throws Exception {\n\t\tsystembackup restoreresource = new systembackup();\n\t\trestoreresource.filename = resource.filename;\n\t\treturn restoreresource.perform_operation(client,\"restore\");\n\t}", "label": 0}
{"code": "def relation_klass(relation, source: nil, was: false)\n      reflect = relation_reflect(relation)\n      if reflect.options.key?(:polymorphic)\n        raise \"Can't work out relation's class without being passed object (relation: #{relation}, reflect: #{reflect})\" if source.nil?\n        raise \"Can't work out polymorhpic relation's class with multiple relations yet\" unless (relation.is_a?(Symbol) || relation.length == 1)\n        # this is the column that stores the polymorphic type, aka the class name\n        type_column = reflect.foreign_type.to_sym\n        # so now turn that into the class that we're looking for here\n        if was\n          attribute_was(source, type_column).try(:constantize)\n        else\n          source.public_send(type_column).try(:constantize)\n        end\n      else\n        reflect.klass\n      end\n    end", "label": 4}
{"code": "public void addFile(InputStream inputStream) {\n        String name = \"file\";\n        fileStreams.put(normalizeDuplicateName(name), inputStream);\n    }", "label": 0}
{"code": "private function arrayParam($value, ArrayType $arrayType, $allowMixedArrayType = false)\n    {\n        if (!is_array($value) && $value !== null) {\n            throw new \\InvalidArgumentException('Array value must be an array or null.');\n        }\n\n        $inferredTypes = [];\n        $res = null;\n        if ($value !== null) {\n            $res = [];\n            foreach ($value as $element) {\n                $type = $this->paramType(\n                    $element,\n                    $arrayType->type() === Database::TYPE_STRUCT ? $arrayType->type() : null,\n                    $arrayType->structType()\n                );\n\n                $res[] = $type[0];\n                if (isset($type[1]['code'])) {\n                    $inferredTypes[] = $type[1]['code'];\n                }\n            }\n        }\n\n        if (!$allowMixedArrayType && count(array_unique($inferredTypes)) > 1) {\n            throw new \\InvalidArgumentException('Array values may not be of mixed type');\n        }\n\n        $nested = $arrayType->structType();\n        $arrayType = $arrayType->type();\n\n        if (!empty($value) && $arrayType && $arrayType !== $inferredTypes[0]) {\n            throw new \\InvalidArgumentException('Array data does not match given array parameter type.');\n        }\n\n        $typeCode = $arrayType === null && $inferredTypes\n            ? $inferredTypes[0]\n            : $arrayType;\n\n        if ($nested) {\n            $nestedDefType = $this->resolveTypeDefinition($nested);\n            $nestedDef = $this->paramType(null, $nestedDefType[0], $nestedDefType[1]);\n\n            $typeObject = $nestedDef[1];\n        } else {\n            $typeObject = $this->typeObject($typeCode);\n        }\n\n        $type = $this->typeObject(\n            self::TYPE_ARRAY,\n            $typeObject,\n            'arrayElementType'\n        );\n\n        return [$res, $type];\n    }", "label": 2}
{"code": "def scrobble_data_dir(dataDir, sampleMap, outF, qualF=None, idopt=None,\n                      utf16=False):\n    \"\"\"\n    Given a sample ID and a mapping, modify a Sanger FASTA file\n    to include the barcode and 'primer' in the sequence data\n    and change the description line as needed.\n    \"\"\"\n    seqcount = 0\n    outfiles = [osp.split(outF.name)[1]]\n    if qualF:\n        outfiles.append(osp.split(qualF.name)[1])\n\n    for item in os.listdir(dataDir):\n        if item in outfiles or not osp.isfile(os.path.join(dataDir, item)):\n            continue\n        # FASTA files\n        if osp.splitext(item)[1] in file_types['fasta']:\n            fh = open_enc(os.path.join(dataDir, item), utf16)\n            records = SeqIO.parse(fh, 'fasta')\n            for record in records:\n                if isinstance(idopt, tuple):\n                    sep, field = idopt\n                    sampleID = record.id.split(sep)[field - 1]\n                else:\n                    sampleID = osp.splitext(item)[0]\n                record.seq = (sampleMap[sampleID].barcode +\n                              sampleMap[sampleID].primer +\n                              record.seq)\n                SeqIO.write(record, outF, 'fasta')\n                seqcount += 1\n            fh.close()\n        # QUAL files\n        elif qualF and osp.splitext(item)[1] in file_types['qual']:\n            fh = open_enc(os.path.join(dataDir, item), utf16)\n            records = SeqIO.parse(fh, 'qual')\n            for record in records:\n                mi = sampleMap[sampleMap.keys()[0]]\n                quals = [40 for _ in range(len(mi.barcode) + len(mi.primer))]\n                record.letter_annotations['phred_quality'][0:0] = quals\n                SeqIO.write(record, qualF, 'qual')\n            fh.close()\n    return seqcount", "label": 1}
{"code": "def url(path, params = nil)\n      if path.respond_to? :query\n        if (query = path.query)\n          path = path.dup\n          path.query = nil\n        end\n      else\n        anchor_index = path.index('#')\n        path = path.slice(0, anchor_index) unless anchor_index.nil?\n        path, query = path.split('?', 2)\n      end\n      self.path = path\n      self.params.merge_query query, options.params_encoder\n      self.params.update(params) if params\n    end", "label": 4}
{"code": "def for(module_path, manifest)\n      Puppet::Node::Environment.create(:anonymous,\n                                       module_path.split(File::PATH_SEPARATOR),\n                                       manifest)\n    end", "label": 4}
{"code": "@PostConstruct\n\tprotected void postConstruct() {\n\t\tif (pixelPerUnitBased) {\n\t\t\t//\tCalculate numerator and denominator\n\t\t\tif (pixelPerUnit > PIXEL_PER_METER) {\n\t\t\t\tthis.numerator = pixelPerUnit / conversionFactor;\n\t\t\t\tthis.denominator = 1;\n\t\t\t} else {\n\t\t\t\tthis.numerator = 1;\n\t\t\t\tthis.denominator = PIXEL_PER_METER / pixelPerUnit;\n\t\t\t}\n\t\t\tsetPixelPerUnitBased(false);\n\t\t} else {\n\t\t\t// Calculate PPU\n\t\t\tthis.pixelPerUnit = numerator / denominator * conversionFactor;\n\t\t\tsetPixelPerUnitBased(true);\n\t\t}\n\t}", "label": 0}
{"code": "public function setHttpTarget($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Scheduler\\V1\\HttpTarget::class);\n        $this->writeOneof(6, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "function (name, value) {\n            var overriddenMember = this._extend.prototype[name];\n            if (undefined !== overriddenMember) {\n                this._checkOverridenMember(value, overriddenMember);\n            }\n        }", "label": 3}
{"code": "func (s *PresenceService) UpsertTunnelConnection(conn services.TunnelConnection) error {\n\tif err := conn.CheckAndSetDefaults(); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tvalue, err := services.MarshalTunnelConnection(conn)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t_, err = s.Put(context.TODO(), backend.Item{\n\t\tKey:     backend.Key(tunnelConnectionsPrefix, conn.GetClusterName(), conn.GetName()),\n\t\tValue:   value,\n\t\tExpires: conn.Expiry(),\n\t\tID:      conn.GetResourceID(),\n\t})\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "func (h *AuthHandlers) IsHostAuthority(cert ssh.PublicKey, address string) bool {\n\tif _, err := h.authorityForCert(services.HostCA, cert); err != nil {\n\t\th.Entry.Debugf(\"Unable to find SSH host CA: %v.\", err)\n\t\treturn false\n\t}\n\treturn true\n}", "label": 5}
{"code": "def updateNetwork(self,\n                      dhcp='dhcp',\n                      ipaddress=None,\n                      netmask=None,\n                      gateway=None,\n                      dns=None):\n        \"\"\"Change the current network settings.\"\"\"\n        return self.__post('/api/updateNetwork',\n                           data={\n                               'dhcp': dhcp,\n                               'ipaddress': ipaddress,\n                               'netmask': netmask,\n                               'gateway': gateway,\n                               'dns': json.dumps(dns)\n                           })", "label": 1}
{"code": "function(onLoad) {\n\n            // create the collection immediately so we only\n            // apply an update to an existing collection (Users)\n            // whenever messages changes\n            var users = app.models.Users();\n\n            // pluck participants from the messages & update users\n            caplet.watchProperty(this, \"messages\", function(messages) {\n                \n                var participants = [];\n                var used         = {};\n\n                messages.forEach(function(message) {\n                    if (used[message.userId]) return;\n                    used[message.userId] = 1;\n                    participants.push({ uid: message.userId });\n                });\n\n                users.set(\"data\", participants);\n                this.set(\"participants\", users);\n            }).trigger();\n        }", "label": 3}
{"code": "func CreateNativeZeroLengthFiles(info *metainfo.Info, dir string) (err error) {\n\tfor _, fi := range info.UpvertedFiles() {\n\t\tif fi.Length != 0 {\n\t\t\tcontinue\n\t\t}\n\t\tname := filepath.Join(append([]string{dir, info.Name}, fi.Path...)...)\n\t\tos.MkdirAll(filepath.Dir(name), 0777)\n\t\tvar f io.Closer\n\t\tf, err = os.Create(name)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tf.Close()\n\t}\n\treturn\n}", "label": 5}
{"code": "public static servicegroup_stats[] get(nitro_service service, options option) throws Exception{\n\t\tservicegroup_stats obj = new servicegroup_stats();\n\t\tservicegroup_stats[] response = (servicegroup_stats[])obj.stat_resources(service,option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static Result generate(@Nonnull final String code, @Nonnull final ImmutableSettings settings) {\n\t\tCheck.notNull(code, \"code\");\n\t\tfinal ImmutableSettings.Builder settingsBuilder = new ImmutableSettings.Builder(Check.notNull(settings, \"settings\"));\n\n\t\tfinal InterfaceAnalysis analysis = InterfaceAnalyzer.analyze(code);\n\t\tfinal Clazz clazz = scaffoldClazz(analysis, settings);\n\n\t\t// immutable settings\n\t\tsettingsBuilder.fields(clazz.getFields());\n\t\tsettingsBuilder.immutableName(clazz.getName());\n\t\tsettingsBuilder.imports(clazz.getImports());\n\t\tfinal Interface definition = new Interface(new Type(clazz.getPackage(), analysis.getInterfaceName(), GenericDeclaration.UNDEFINED));\n\t\tsettingsBuilder.mainInterface(definition);\n\t\tsettingsBuilder.interfaces(clazz.getInterfaces());\n\t\tsettingsBuilder.packageDeclaration(clazz.getPackage());\n\n\t\tfinal String implementationCode = SourceCodeFormatter.format(ImmutableObjectRenderer.toString(clazz, settingsBuilder.build()));\n\t\tfinal String testCode = SourceCodeFormatter.format(ImmutableObjectTestRenderer.toString(clazz, settingsBuilder.build()));\n\t\treturn new Result(implementationCode, testCode);\n\t}", "label": 0}
{"code": "public static function isSystemLittleEndian()\n    {\n        if (self::$isLittleEndian === null) {\n            self::$isLittleEndian = (pack(\"P\", 2) === pack(\"Q\", 2));\n        }\n        return self::$isLittleEndian;\n    }", "label": 2}
{"code": "func (d *Decoder) parseInt(v reflect.Value) {\n\tstart := d.Offset - 1\n\td.readUntil('e')\n\tif d.buf.Len() == 0 {\n\t\tpanic(&SyntaxError{\n\t\t\tOffset: start,\n\t\t\tWhat:   errors.New(\"empty integer value\"),\n\t\t})\n\t}\n\n\ts := bytesAsString(d.buf.Bytes())\n\n\tswitch v.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tn, err := strconv.ParseInt(s, 10, 64)\n\t\tcheckForIntParseError(err, start)\n\n\t\tif v.OverflowInt(n) {\n\t\t\tpanic(&UnmarshalTypeError{\n\t\t\t\tValue: \"integer \" + s,\n\t\t\t\tType:  v.Type(),\n\t\t\t})\n\t\t}\n\t\tv.SetInt(n)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tn, err := strconv.ParseUint(s, 10, 64)\n\t\tcheckForIntParseError(err, start)\n\n\t\tif v.OverflowUint(n) {\n\t\t\tpanic(&UnmarshalTypeError{\n\t\t\t\tValue: \"integer \" + s,\n\t\t\t\tType:  v.Type(),\n\t\t\t})\n\t\t}\n\t\tv.SetUint(n)\n\tcase reflect.Bool:\n\t\tv.SetBool(s != \"0\")\n\tdefault:\n\t\tpanic(&UnmarshalTypeError{\n\t\t\tValue: \"integer \" + s,\n\t\t\tType:  v.Type(),\n\t\t})\n\t}\n\td.buf.Reset()\n}", "label": 5}
{"code": "func GetKVMNetArgs(nds []NetDescriber) ([]string, error) {\n\n\tvar lkvmArgs []string\n\n\tfor _, nd := range nds {\n\t\tlkvmArgs = append(lkvmArgs, \"--network\")\n\t\tlkvmArg := fmt.Sprintf(\"mode=tap,tapif=%s,host_ip=%s,guest_ip=%s\", nd.IfName(), nd.Gateway(), nd.GuestIP())\n\t\tlkvmArgs = append(lkvmArgs, lkvmArg)\n\t}\n\n\treturn lkvmArgs, nil\n}", "label": 5}
{"code": "def invites\n      raise 'Tried to request invites from a non-server channel' unless server\n\n      invites = JSON.parse(API::Channel.invites(@bot.token, @id))\n      invites.map { |invite_data| Invite.new(invite_data, @bot) }\n    end", "label": 4}
{"code": "public static lbvserver_stats[] get(nitro_service service) throws Exception{\n\t\tlbvserver_stats obj = new lbvserver_stats();\n\t\tlbvserver_stats[] response = (lbvserver_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def get_element_class(element_name)\n      style_details = style_variables_for_theme[\"vic\"] || Pwb::PresetStyle.default_values\n      style_associations = style_details[\"associations\"] || []\n      style_associations[element_name] || \"\"\n    end", "label": 4}
{"code": "function find(array, predicate) {\n        for (var i = 0, len = array.length; i < len; i++) {\n            var value = array[i];\n            if (predicate(value, i)) {\n                return value;\n            }\n        }\n        return undefined;\n    }", "label": 3}
{"code": "public int[] sampleBatchWithReplacement() {\n        // Sample the indices with replacement.\n        int[] batch = new int[batchSize];\n        for (int i=0; i<batch.length; i++) {\n            batch[i] = Prng.nextInt(numExamples);\n        }\n        return batch;\n    }", "label": 0}
{"code": "protected static List<StackTraceElement> filterStackTrace(StackTraceElement[] stack) {\r\n    List<StackTraceElement> filteredStack = new ArrayList<StackTraceElement>();\r\n\r\n    int i = 2; // we can skip the first two (first is getStackTrace(), second is this method)\r\n    while (i < stack.length) {\r\n      boolean isLoggingClass = false;\r\n      for (String loggingClass : loggingClasses) {\r\n        String className = stack[i].getClassName();\r\n        if (className.startsWith(loggingClass)) {\r\n          isLoggingClass = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!isLoggingClass) {\r\n        filteredStack.add(stack[i]);\r\n      }\r\n\r\n      i += 1;\r\n    }\r\n\r\n    // if we didn't find anything, keep the full stack\r\n    if (filteredStack.size() == 0) {\r\n      return Arrays.asList(stack);\r\n    }\r\n    return filteredStack;\r\n  }", "label": 0}
{"code": "function generateTable() {\n   var data = []\n\n   for (var i=0; i<30; i++) {\n     var row = []\n     row.push(commands[Math.round(Math.random()*(commands.length-1))])\n     row.push(Math.round(Math.random()*5))\n     row.push(Math.round(Math.random()*100))\n     data.push(row)\n   }\n\n   return {headers: ['Process', 'Cpu (%)', 'Memory'], data: data};\n}", "label": 3}
{"code": "def is_prime(number):\n    \"\"\"\n    Testing given number to be a prime.\n\n    >>> [n for n in range(100+1) if is_prime(n)]\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    \"\"\"\n    if number < 2:\n        return False\n    if number % 2 == 0:\n        return number == 2\n\n    limit = int(math.sqrt(number))\n    for divisor in range(3, limit + 1, 2):\n        if number % divisor == 0:\n            return False\n\n    return True", "label": 1}
{"code": "function findArguments (node) {\n  if (!node) {\n    return []\n  }\n\n  return node.map(arg => {\n    const name = arg.name.value\n    const fieldType = findType(arg.type)\n    const isDeprecated = validateIfDeprecated(arg.directives)\n\n    return Object.assign({ name, isDeprecated }, fieldType)\n  })\n}", "label": 3}
{"code": "def render_charset(tags)\n      charset = meta_tags.extract(:charset)\n      tags << Tag.new(:meta, charset: charset) if charset.present?\n    end", "label": 4}
{"code": "public function sendGetBroadcastLists()\n    {\n        $msgId = $this->nodeId['get_lists'] = $this->createIqId();\n        $listsNode = new ProtocolNode('lists', null, null, null);\n        $node = new ProtocolNode('iq',\n            [\n                'id'    => $msgId,\n                'xmlns' => 'w:b',\n                'type'  => 'get',\n                'to'    => Constants::WHATSAPP_SERVER,\n            ], [$listsNode], null);\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "function (host, reInit) {\n        if (_.isEmpty(host.id) || !_.isString(host.id)) {\n            throw new Error(\"Host configuration is invalid. Host id is missing or not a string\");\n        }\n        if (_.isEmpty(host.host)) {\n            throw new Error(\"Host configuration is invalid. Host is missing\");\n        }\n\n        if (_.isString(host.host)) {\n            host.host = [host.host];\n        }\n\n        if (!_.isArray(host.host)) {\n            throw new Error(\"Host configuration is invalid. Host should be array or string\");\n        }\n\n        var router = new express.Router();\n\n        if (reInit === false) {\n            // Check if host is already defined. Use same router instance to merge routes\n            for (var index in _vhosts) {\n                for (var vh in _vhosts[index][\"host\"]) {\n                    if (_vhosts[index][\"host\"][vh] == host.host) {\n                        router = _vhosts[index][\"router\"];\n                    }\n                }\n            }\n        }\n\n        _vhosts[host.id] = {\n            host: host.host,\n            router: router,\n            http: !host.listener ? true : host.listener && host.listener.http || null,\n            https: !host.listener ? true : host.listener && host.listener.https || null\n        };\n\n        _applyRouterConfig(_vhosts[host.id][\"router\"]);\n        _customInitFuncton(_vhosts[host.id][\"router\"]);\n    }", "label": 3}
{"code": "public static dnsview get(nitro_service service, String viewname) throws Exception{\n\t\tdnsview obj = new dnsview();\n\t\tobj.set_viewname(viewname);\n\t\tdnsview response = (dnsview) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function install($name, $version = 'dev-master', $type = 'composer', $subtree = false)\n    {\n        $installer = new Installer($name, $version, $type, $subtree);\n\n        return $installer->run();\n    }", "label": 2}
{"code": "def remove_gaps(A, B):\n    \"\"\"\n    skip column if either is a gap\n    \"\"\"\n    a_seq, b_seq = [], []\n    for a, b in zip(list(A), list(B)):\n        if a == '-' or a == '.' or b == '-' or b == '.':\n            continue\n        a_seq.append(a)\n        b_seq.append(b)\n    return ''.join(a_seq), ''.join(b_seq)", "label": 1}
{"code": "public function add(string $place, ItemMenu $itemMenu)\n    {\n        $arg = get_object_vars($itemMenu);\n\n        if (array_key_exists('show', $arg) && ! $arg['show']) {\n            return $this;\n        }\n\n        $this->location = $place;\n        $this->arg = $arg;\n        $this->sort = $arg['sort'];\n\n        $this->item = [\n            'location' => $this->location,\n            'arg'      => $this->arg,\n            'sort'     => $this->sort,\n        ];\n\n        $this->container[$this->arg['slug']] = $this->item;\n\n        return $this;\n    }", "label": 2}
{"code": "function getOutputDir() {\n\tconst outputOptionIdx = process.argv.indexOf('-o') !== -1 ? process.argv.indexOf('-o') : process.argv.indexOf('--output-file'),\n\t\targsLength = process.argv.length,\n\t\toutputDirOption = '--outputDirectory=';\n\n\tif (process.argv[1].includes('grunt')) {\n\t\tfor (var i = 2; i < argsLength; i++) {\n\t\t\tif (process.argv[i].includes(outputDirOption)) {\n\t\t\t\treturn `/${process.argv[i].replace(outputDirOption, '')}`;\n\t\t\t}\n\t\t}\n\t\treturn '/reports/'; // defaults to a reports folder if nothing else is found\n\t} else if (outputOptionIdx !== -1) {\n\t\treturn `/${process.argv[outputOptionIdx + 1].split('/')[0]}/`;\n\t}\n\n\treturn '';\n}", "label": 3}
{"code": "function renderSass(options) {\n\treturn new Promise((resolve, reject) => {\n\t\ttry {\n\t\t\t// using synchronous rendering because it is faster\n\t\t\tlet result = sass.renderSync(options);\n\t\t\tresult.css = fixEOF(result.css);\n\t\t\tresolve(result);\n\t\t} catch(err) {\n\t\t\treject(err);\n\t\t}\n\t});\n}", "label": 3}
{"code": "public static function unloadDriver($driver)\n    {\n        foreach (array_keys(self::$drivers, $driver) as $key) {\n            unset(self::$drivers[$key]);\n        }\n    }", "label": 2}
{"code": "def translate_variant_reads(\n        variant,\n        variant_reads,\n        protein_sequence_length,\n        transcript_id_whitelist=None,\n        min_alt_rna_reads=MIN_ALT_RNA_READS,\n        min_variant_sequence_coverage=MIN_VARIANT_SEQUENCE_COVERAGE,\n        min_transcript_prefix_length=MIN_TRANSCRIPT_PREFIX_LENGTH,\n        max_transcript_mismatches=MAX_REFERENCE_TRANSCRIPT_MISMATCHES,\n        include_mismatches_after_variant=INCLUDE_MISMATCHES_AFTER_VARIANT,\n        variant_sequence_assembly=VARIANT_SEQUENCE_ASSEMBLY):\n    \"\"\"\n    Given a variant and its associated alt reads, construct variant sequences\n    and translate them into Translation objects.\n\n    Returns 0 or more Translation objects.\n\n    Parameters\n    ----------\n    variant : varcode.Variant\n\n    variant_reads : sequence or generator\n        AlleleRead objects supporting the variant\n\n    protein_sequence_length : int\n        Try to translate protein sequences of this length, though sometimes\n        we'll have to return something shorter (depending on the RNAseq data,\n        and presence of stop codons).\n\n    transcript_id_whitelist : set, optional\n        If given, expected to be a set of transcript IDs which we should use\n        for determining the reading frame around a variant. If omitted, then\n        try to use all overlapping reference transcripts.\n\n    min_alt_rna_reads : int\n        Drop variant sequences from loci with fewer than this number of\n        RNA reads supporting the alt allele.\n\n    min_variant_sequence_coverage : int\n        Trim variant sequences to nucleotides covered by at least this many\n        reads.\n\n    min_transcript_prefix_length : int\n        Minimum number of bases we need to try matching between the reference\n        context and variant sequence.\n\n    max_transcript_mismatches : int\n        Don't try to determine the reading frame for a transcript if more\n        than this number of bases differ.\n\n    include_mismatches_after_variant : bool\n        Include mismatches after the variant locus in the count compared\n        against max_transcript_mismatches.\n\n    variant_sequence_assembly : bool\n        Use overlap assembly to construct longer variant cDNA sequences.\n    \"\"\"\n    if len(variant_reads) == 0:\n        logger.info(\"No supporting reads for variant %s\", variant)\n        return []\n\n    # Adding an extra codon to the desired RNA sequence length in case we\n    # need to clip nucleotides at the start/end of the sequence\n    cdna_sequence_length = (protein_sequence_length + 1) * 3\n\n    variant_sequences = reads_to_variant_sequences(\n        variant=variant,\n        reads=variant_reads,\n        preferred_sequence_length=cdna_sequence_length,\n        min_alt_rna_reads=min_alt_rna_reads,\n        min_variant_sequence_coverage=min_variant_sequence_coverage,\n        variant_sequence_assembly=variant_sequence_assembly)\n\n    if not variant_sequences:\n        logger.info(\"No spanning cDNA sequences for variant %s\", variant)\n        return []\n\n    # try translating the variant sequences from the same set of\n    # ReferenceContext objects, which requires using the longest\n    # context_size to be compatible with all of the sequences. Some\n    # sequences maybe have fewer nucleotides than this before the variant\n    # and will thus have to be trimmed.\n    context_size = max(\n        len(variant_sequence.prefix)\n        for variant_sequence in variant_sequences)\n\n    reference_contexts = reference_contexts_for_variant(\n        variant,\n        context_size=context_size,\n        transcript_id_whitelist=transcript_id_whitelist)\n\n    return list(translation_generator(\n        variant_sequences=variant_sequences,\n        reference_contexts=reference_contexts,\n        min_transcript_prefix_length=min_transcript_prefix_length,\n        max_transcript_mismatches=max_transcript_mismatches,\n        include_mismatches_after_variant=include_mismatches_after_variant,\n        protein_sequence_length=protein_sequence_length))", "label": 1}
{"code": "public static double[] getTileLayerSize(TileCode code, Envelope maxExtent, double scale) {\n\t\tdouble div = Math.pow(2, code.getTileLevel());\n\t\tdouble tileWidth = Math.ceil((scale * maxExtent.getWidth()) / div) / scale;\n\t\tdouble tileHeight = Math.ceil((scale * maxExtent.getHeight()) / div) / scale;\n\t\treturn new double[] { tileWidth, tileHeight };\n\t}", "label": 0}
{"code": "def oauth_register(form):\n    \"\"\"Register user if possible.\n\n    :param form: A form instance.\n    :returns: A :class:`invenio_accounts.models.User` instance.\n    \"\"\"\n    if form.validate():\n        data = form.to_dict()\n        if not data.get('password'):\n            data['password'] = ''\n        user = register_user(**data)\n        if not data['password']:\n            user.password = None\n        _datastore.commit()\n        return user", "label": 1}
{"code": "function onComplete(commands) {\n        const content = commands.commands.map((command) => command.replyText)\n            .filter((text) => (text || '').trim())\n            .join('\\n\\n---\\n\\n');\n        if (!content) {\n            return Promise.resolve();\n        }\n        return commands._replyFn(content);\n    }", "label": 3}
{"code": "def add_readgroups(job, bamfile, sample_type, univ_options, picard_options):\n    \"\"\"\n    Add read groups to the bam.\n\n    :param dict bamfile: The input bam file\n    :param str sample_type: Description of the sample to inject into the filename\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict picard_options: Options specific to picard\n    :return: fsID for the output bam\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    work_dir = os.getcwd()\n    input_files = {\n        sample_type + '.bam': bamfile}\n    get_files_from_filestore(job, input_files, work_dir, docker=True)\n    parameters = ['AddOrReplaceReadGroups',\n                  'CREATE_INDEX=false',\n                  'I=/data/' + sample_type + '.bam',\n                  'O=/data/' + sample_type + '_reheader.bam',\n                  'SO=coordinate',\n                  'ID=1',\n                  ''.join(['LB=', univ_options['patient']]),\n                  'PL=ILLUMINA',\n                  'PU=12345',\n                  ''.join(['SM=', sample_type.rstrip('_dna')])]\n    docker_call(tool='picard', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], java_xmx=univ_options['java_Xmx'],\n                tool_version=picard_options['version'])\n    output_file = job.fileStore.writeGlobalFile(\n        '/'.join([work_dir, sample_type + '_reheader.bam']))\n    # Delete the old bam file\n    job.fileStore.deleteGlobalFile(bamfile)\n    job.fileStore.logToMaster('Ran add_read_groups on %s:%s successfully'\n                              % (univ_options['patient'], sample_type))\n    return output_file", "label": 1}
{"code": "def handle_specific_and_source(occurrence_identifier, source_data_criteria_extension, source_data_criteria_root,\n                                   specific_occurrence_const, specific_occurrence)\n      source_data_criteria = \"#{source_data_criteria_extension}_#{source_data_criteria_root}_source\"\n      if !occurrence_identifier.blank?\n        # if it doesn't exist, add extracted occurrence to the map\n        # puts \"\\tSetting #{@source_data_criteria}-#{@source_data_criteria_root} to #{occurrence_identifier}\"\n        @occurrences_map[strip_tokens(source_data_criteria)] ||= occurrence_identifier\n        specific_occurrence ||= occurrence_identifier\n        specific_occurrence_const = \"#{source_data_criteria}\".upcase\n      else\n        # create variable occurrences that do not already exist\n        if @is_variable\n          # puts \"\\tSetting #{@source_data_criteria}-#{@source_data_criteria_root} to #{occurrence_identifier}\"\n          @occurrences_map[strip_tokens(source_data_criteria)] ||= occurrence_identifier\n        end\n        occurrence = @occurrences_map.try(:[], strip_tokens(source_data_criteria))\n        unless occurrence\n          fail \"Could not find occurrence mapping for #{source_data_criteria}, #{source_data_criteria_root}\"\n        end\n        # puts \"\\tUsing #{occurrence} for #{@id}\"\n        specific_occurrence ||= occurrence\n      end\n\n      specific_occurrence = 'A' unless specific_occurrence\n      specific_occurrence_const = source_data_criteria.upcase unless specific_occurrence_const\n      [source_data_criteria, source_data_criteria_root, source_data_criteria_extension,\n       specific_occurrence, specific_occurrence_const]\n    end", "label": 4}
{"code": "public function prependFilter($callback, $name = null)\n    {\n        $tuple = $this->createFilterTuple(func_get_args());\n\n        array_unshift($this->filters, $tuple);\n\n        $this->handleChangedParameters();\n\n        return $this;\n    }", "label": 2}
{"code": "def content_length\n      # http://greenbytes.de/tech/webdav/rfc7230.html#rfc.section.3.3.3\n      # Clause 3: \"If a message is received with both a Transfer-Encoding\n      # and a Content-Length header field, the Transfer-Encoding overrides the Content-Length.\n      return nil if @headers.include?(Headers::TRANSFER_ENCODING)\n\n      value = @headers[Headers::CONTENT_LENGTH]\n      return nil unless value\n\n      begin\n        Integer(value)\n      rescue ArgumentError\n        nil\n      end\n    end", "label": 4}
{"code": "public void setRegistrationConfig(RegistrationConfig registrationConfig) {\n        this.registrationConfig = registrationConfig;\n\n        if (registrationConfig.getDefaultConfig()!=null) {\n            for (String key : registrationConfig.getDefaultConfig().keySet()) {\n                dynamicConfig.put(key, registrationConfig.getDefaultConfig().get(key));\n            }\n        }\n    }", "label": 0}
{"code": "def add_part(part)\n      if !body.multipart? && !Utilities.blank?(self.body.decoded)\n        @text_part = Mail::Part.new('Content-Type: text/plain;')\n        @text_part.body = body.decoded\n        self.body << @text_part\n        add_multipart_alternate_header\n      end\n      add_boundary\n      self.body << part\n    end", "label": 4}
{"code": "def reload\n      reloaded = _reload\n      if Mongoid.raise_not_found_error && reloaded.empty?\n        raise Errors::DocumentNotFound.new(self.class, _id, _id)\n      end\n      @attributes = reloaded\n      @attributes_before_type_cast = {}\n      changed_attributes.clear\n      reset_readonly\n      apply_defaults\n      reload_relations\n      run_callbacks(:find) unless _find_callbacks.empty?\n      run_callbacks(:initialize) unless _initialize_callbacks.empty?\n      self\n    end", "label": 4}
{"code": "function checkTimeCriteria() {\n    // don't bother if another box is currently open\n    if( isAnyBoxVisible() ) {\n        return;\n    }\n\n    boxes.forEach(function(box) {\n        if( ! box.mayAutoShow() ) {\n            return;\n        }\n\n        // check \"time on site\" trigger\n        if (box.config.trigger.method === 'time_on_site' && siteTimer.time >= box.config.trigger.value) {\n            box.trigger();\n        }\n\n        // check \"time on page\" trigger\n        if (box.config.trigger.method === 'time_on_page' && pageTimer.time >= box.config.trigger.value) {\n            box.trigger();\n        }\n    });\n}", "label": 3}
{"code": "func (a *HistoricalApi) podListMetrics(request *restful.Request, response *restful.Response) {\n\tstart, end, err := getStartEndTimeHistorical(request)\n\tif err != nil {\n\t\tresponse.WriteError(http.StatusBadRequest, err)\n\t\treturn\n\t}\n\n\tkeys := []core.HistoricalKey{}\n\tif request.PathParameter(\"pod-id-list\") != \"\" {\n\t\tfor _, podId := range strings.Split(request.PathParameter(\"pod-id-list\"), \",\") {\n\t\t\tkey := core.HistoricalKey{\n\t\t\t\tObjectType: core.MetricSetTypePod,\n\t\t\t\tPodId:      podId,\n\t\t\t}\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t} else {\n\t\tfor _, podName := range strings.Split(request.PathParameter(\"pod-list\"), \",\") {\n\t\t\tkey := core.HistoricalKey{\n\t\t\t\tObjectType:    core.MetricSetTypePod,\n\t\t\t\tNamespaceName: request.PathParameter(\"namespace-name\"),\n\t\t\t\tPodName:       podName,\n\t\t\t}\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\n\tlabels, err := getLabels(request)\n\tif err != nil {\n\t\tresponse.WriteError(http.StatusBadRequest, err)\n\t\treturn\n\t}\n\n\tmetricName := request.PathParameter(\"metric-name\")\n\tconvertedMetricName := convertMetricName(metricName)\n\n\tvar metrics map[core.HistoricalKey][]core.TimestampedMetricValue\n\tif labels != nil {\n\t\tmetrics, err = a.historicalSource.GetLabeledMetric(convertedMetricName, labels, keys, start, end)\n\t} else {\n\t\tmetrics, err = a.historicalSource.GetMetric(convertedMetricName, keys, start, end)\n\t}\n\n\tif err != nil {\n\t\tresponse.WriteError(http.StatusInternalServerError, err)\n\t\treturn\n\t}\n\n\tresult := types.MetricResultList{\n\t\tItems: make([]types.MetricResult, 0, len(keys)),\n\t}\n\tfor _, key := range keys {\n\t\tresult.Items = append(result.Items, exportTimestampedMetricValue(metrics[key]))\n\t}\n\tresponse.PrettyPrint(false)\n\tresponse.WriteEntity(result)\n}", "label": 5}
{"code": "public function setIndices($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::INT32);\n        $this->indices = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function maybe_name() {\n  skip_horiz_white();\n  if (look(ident_pattern_with_dot)) {\n    current_tag[\"name\"] = match(ident_pattern_with_dot);\n  }\n  else if (look(ident_pattern)) {\n    current_tag[\"name\"] = match(ident_pattern);\n  }\n}", "label": 3}
{"code": "public static systemglobal_authenticationldappolicy_binding[] get(nitro_service service) throws Exception{\n\t\tsystemglobal_authenticationldappolicy_binding obj = new systemglobal_authenticationldappolicy_binding();\n\t\tsystemglobal_authenticationldappolicy_binding response[] = (systemglobal_authenticationldappolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def element_focused(step, id):\n    \"\"\"\n    Check if the element is focused\n    \"\"\"\n\n    elem = world.browser.find_element_by_xpath(str('id(\"{id}\")'.format(id=id)))\n    focused = world.browser.switch_to_active_element()\n\n    assert_true(step, elem == focused)", "label": 1}
{"code": "func (s *AuthServer) CreateUserWithOTP(token string, password string, otpToken string) (services.WebSession, error) {\n\ttokenData, err := s.GetSignupToken(token)\n\tif err != nil {\n\t\tlog.Debugf(\"failed to get signup token: %v\", err)\n\t\treturn nil, trace.AccessDenied(\"expired or incorrect signup token\")\n\t}\n\n\terr = s.UpsertTOTP(tokenData.User.Name, tokenData.OTPKey)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\terr = s.CheckOTP(tokenData.User.Name, otpToken)\n\tif err != nil {\n\t\tlog.Debugf(\"failed to validate a token: %v\", err)\n\t\treturn nil, trace.AccessDenied(\"failed to validate a token\")\n\t}\n\n\terr = s.UpsertPassword(tokenData.User.Name, []byte(password))\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\t// create services.User and services.WebSession\n\twebSession, err := s.createUserAndSession(tokenData)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn webSession, nil\n}", "label": 5}
{"code": "private function isEof($seekable)\n    {\n        return $seekable\n            ? $this->source->tell() < $this->source->getSize()\n            : !$this->source->eof();\n    }", "label": 2}
{"code": "def iter_methods(self):\n        \"\"\"Iterate over stored coroutine functions\n\n        Yields:\n            Stored :term:`coroutine function` objects\n\n        .. seealso:: :meth:`pydispatch.utils.WeakMethodContainer.iter_instances`\n        \"\"\"\n        for wrkey, obj in self.iter_instances():\n            f, obj_id = wrkey\n            loop = self.event_loop_map[wrkey]\n            m = getattr(obj, f.__name__)\n            yield loop, m", "label": 1}
{"code": "def load_additional(from)\n      from = [ Ohai.config[:plugin_path], from].flatten\n      plugin_files_by_dir(from).collect do |plugin_file|\n        logger.trace \"Loading additional plugin: #{plugin_file}\"\n        plugin = load_plugin_class(plugin_file)\n        load_v7_plugin(plugin)\n      end\n    end", "label": 4}
{"code": "public function getCluster($projectId, $zone, $clusterId, array $optionalArgs = [])\n    {\n        $request = new GetClusterRequest();\n        $request->setProjectId($projectId);\n        $request->setZone($zone);\n        $request->setClusterId($clusterId);\n        if (isset($optionalArgs['name'])) {\n            $request->setName($optionalArgs['name']);\n        }\n\n        $requestParams = new RequestParamsHeaderDescriptor([\n          'name' => $request->getName(),\n        ]);\n        $optionalArgs['headers'] = isset($optionalArgs['headers'])\n            ? array_merge($requestParams->getHeader(), $optionalArgs['headers'])\n            : $requestParams->getHeader();\n\n        return $this->startCall(\n            'GetCluster',\n            Cluster::class,\n            $optionalArgs,\n            $request\n        )->wait();\n    }", "label": 2}
{"code": "def spanner scope: nil, timeout: nil, client_config: nil\n      Google::Cloud.spanner @project, @keyfile, scope: scope,\n                                                timeout: (timeout || @timeout),\n                                                client_config: client_config\n    end", "label": 4}
{"code": "String checkVersion(String pluginName, String dependency, String requestedVersion, String availableVersion) {\n\t\tif (null == availableVersion) {\n\t\t\treturn \"Dependency \" + dependency + \" not found for \" + pluginName + \", version \" + requestedVersion +\n\t\t\t\t\t\" or higher needed.\\n\";\n\t\t}\n\t\tif (requestedVersion.startsWith(EXPR_START) || availableVersion.startsWith(EXPR_START)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tVersion requested = new Version(requestedVersion);\n\t\tVersion available = new Version(availableVersion);\n\t\tif (requested.getMajor() != available.getMajor()) {\n\t\t\treturn \"Dependency \" + dependency + \" is provided in a incompatible API version for plug-in \" +\n\t\t\t\t\tpluginName + \", which requests version \" + requestedVersion +\n\t\t\t\t\t\", but version \" + availableVersion + \" supplied.\\n\";\n\t\t}\n\t\tif (requested.after(available)) {\n\t\t\treturn \"Dependency \" + dependency + \" too old for \" + pluginName + \", version \" + requestedVersion +\n\t\t\t\t\t\" or higher needed, but version \" + availableVersion + \" supplied.\\n\";\n\t\t}\n\t\treturn \"\";\n\t}", "label": 0}
{"code": "public function setFeatures($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::ENUM, \\Google\\Cloud\\VideoIntelligence\\V1\\Feature::class);\n        $this->features = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function setEntity($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\VideoIntelligence\\V1\\Entity::class);\n        $this->entity = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public void forAllMemberTagTokens(String template, Properties attributes) throws XDocletException\r\n    {\r\n        if (getCurrentField() != null) {\r\n            forAllMemberTagTokens(template, attributes, FOR_FIELD);\r\n        }\r\n        else if (getCurrentMethod() != null) {\r\n            forAllMemberTagTokens(template, attributes, FOR_METHOD);\r\n        }\r\n    }", "label": 0}
{"code": "function(next) {\n            if (options.noDb || core.noDb) return next();\n            db.initConfig(options, next);\n        }", "label": 3}
{"code": "func parsePackageSource(pkg string) (*types.Scope, *doc.Package, error) {\n\tpd, err := build.Import(pkg, \".\", 0)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tfset := token.NewFileSet()\n\tfiles := make(map[string]*ast.File)\n\tfileList := make([]*ast.File, len(pd.GoFiles))\n\tfor i, fname := range pd.GoFiles {\n\t\tsrc, err := ioutil.ReadFile(path.Join(pd.SrcRoot, pd.ImportPath, fname))\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tf, err := parser.ParseFile(fset, fname, src, parser.ParseComments|parser.AllErrors)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tfiles[fname] = f\n\t\tfileList[i] = f\n\t}\n\n\tcfg := types.Config{\n\t\tImporter: importer.Default(),\n\t}\n\tinfo := types.Info{\n\t\tDefs: make(map[*ast.Ident]types.Object),\n\t}\n\ttp, err := cfg.Check(pkg, fset, fileList, &info)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tscope := tp.Scope()\n\n\tap, _ := ast.NewPackage(fset, files, nil, nil)\n\tdocs := doc.New(ap, pkg, 0)\n\n\treturn scope, docs, nil\n}", "label": 5}
{"code": "func (a *AuthServer) GetCache() AuthCache {\n\ta.lock.RLock()\n\tdefer a.lock.RUnlock()\n\tif a.cache == nil {\n\t\treturn &a.AuthServices\n\t}\n\treturn a.cache\n}", "label": 5}
{"code": "public void processCollection(String template, Properties attributes) throws XDocletException\r\n    {\r\n        String                  name    = OjbMemberTagsHandler.getMemberName();\r\n        CollectionDescriptorDef collDef = _curClassDef.getCollection(name);\r\n        String                  attrName;\r\n\r\n        if (collDef == null)\r\n        {\r\n            collDef = new CollectionDescriptorDef(name);\r\n            _curClassDef.addCollection(collDef);\r\n        }\r\n        LogHelper.debug(false, OjbTagsHandler.class, \"processCollection\", \"  Processing collection \"+collDef.getName());\r\n\r\n        for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )\r\n        {\r\n            attrName = (String)attrNames.nextElement();\r\n            collDef.setProperty(attrName, attributes.getProperty(attrName));\r\n        }\r\n        if (OjbMemberTagsHandler.getMemberDimension() > 0)\r\n        {\r\n            // we store the array-element type for later use\r\n            collDef.setProperty(PropertyHelper.OJB_PROPERTY_ARRAY_ELEMENT_CLASS_REF,\r\n                                OjbMemberTagsHandler.getMemberType().getQualifiedName());\r\n        }\r\n        else\r\n        {    \r\n            collDef.setProperty(PropertyHelper.OJB_PROPERTY_VARIABLE_TYPE,\r\n                                OjbMemberTagsHandler.getMemberType().getQualifiedName());\r\n        }\r\n\r\n        _curCollectionDef = collDef;\r\n        generate(template);\r\n        _curCollectionDef = null;\r\n    }", "label": 0}
{"code": "private function getApiDocument(User $actor, array $params)\n    {\n        return json_decode($this->api->send(ListDiscussionsController::class, $actor, $params)->getBody());\n    }", "label": 2}
{"code": "protected static void appendHandler(Class<? extends LogRecordHandler> parent, LogRecordHandler child){\r\n    List<LogRecordHandler> toAdd = new LinkedList<LogRecordHandler>();\r\n    //--Find Parents\r\n    for(LogRecordHandler term : handlers){\r\n      if(parent.isAssignableFrom(term.getClass())){\r\n        toAdd.add(term);\r\n      }\r\n    }\r\n    //--Add Handler\r\n    for(LogRecordHandler p : toAdd){\r\n      appendHandler(p, child);\r\n    }\r\n  }", "label": 0}
{"code": "public function save(MetadataEnvelope $envelope, array $args)\n    {\n        $this->client->putObject([\n            'Bucket' => $args['Bucket'],\n            'Key' => $args['Key'] . $this->suffix,\n            'Body' => json_encode($envelope)\n        ]);\n\n        return $args;\n    }", "label": 2}
{"code": "protected static function registerMailableTagExtractor()\n    {\n        Mailable::buildViewDataUsing(function ($mailable) {\n            return [\n                '__telescope' => ExtractTags::from($mailable),\n                '__telescope_mailable' => get_class($mailable),\n                '__telescope_queued' => in_array(ShouldQueue::class, class_implements($mailable)),\n            ];\n        });\n    }", "label": 2}
{"code": "def cta_button\n      button_text = translated_attribute(current_organization.cta_button_text).presence || t(\"decidim.pages.home.hero.participate\")\n\n      link_to button_text, cta_button_path, class: \"hero-cta button expanded large button--sc\"\n    end", "label": 4}
{"code": "def filter_context(context)\n      case context\n      when Array\n        context.map { |arg| filter_context(arg) }\n      when Hash\n        Hash[context.map { |key, value| filter_context_hash(key, value) }]\n      else\n        format_globalid(context)\n      end\n    end", "label": 4}
{"code": "def _beta(catchment):\n        \"\"\"\n        Return beta, the GLO scale parameter divided by loc parameter estimated using simple regression model\n\n        Methodology source: Kjeldsen & Jones, 2009, table 2\n\n        :param catchment: Catchment to estimate beta for\n        :type catchment: :class:`Catchment`\n        :return: beta\n        :rtype: float\n        \"\"\"\n        lnbeta = -1.1221 \\\n                 - 0.0816 * log(catchment.descriptors.dtm_area) \\\n                 - 0.4580 * log(catchment.descriptors.saar / 1000) \\\n                 + 0.1065 * log(catchment.descriptors.bfihost)\n        return exp(lnbeta)", "label": 1}
{"code": "def as_json(_options = {})\n      {\n        resource_owner_id: resource_owner_id,\n        scope: scopes,\n        expires_in: expires_in_seconds,\n        application: { uid: application.try(:uid) },\n        created_at: created_at.to_i,\n      }\n    end", "label": 4}
{"code": "function _gpfStreamSecureInstallProgressFlag(constructor) {\n        constructor.prototype[_gpfStreamProgressRead] = false;\n        constructor.prototype[_gpfStreamProgressWrite] = false;\n    }", "label": 3}
{"code": "def service_check(name, status, opts=EMPTY_OPTIONS)\n      send_stat format_service_check(name, status, opts)\n    end", "label": 4}
{"code": "public function utf8ToUtf16BigEndian($str, $setbom = true) // UTF8ToUTF16BE\n\t{\n\t\tif ($this->mpdf->checkSIP && preg_match(\"/([\\x{20000}-\\x{2FFFF}])/u\", $str)) {\n\t\t\tif (!in_array($this->mpdf->currentfontfamily, ['gb', 'big5', 'sjis', 'uhc', 'gbB', 'big5B', 'sjisB', 'uhcB', 'gbI', 'big5I', 'sjisI', 'uhcI',\n\t\t\t\t'gbBI', 'big5BI', 'sjisBI', 'uhcBI'])) {\n\t\t\t\t$str = preg_replace(\"/[\\x{20000}-\\x{2FFFF}]/u\", chr(0), $str);\n\t\t\t}\n\t\t}\n\t\tif ($this->mpdf->checkSMP && preg_match(\"/([\\x{10000}-\\x{1FFFF}])/u\", $str)) {\n\t\t\t$str = preg_replace(\"/[\\x{10000}-\\x{1FFFF}]/u\", chr(0), $str);\n\t\t}\n\n\t\t$outstr = ''; // string to be returned\n\t\tif ($setbom) {\n\t\t\t$outstr .= \"\\xFE\\xFF\"; // Byte Order Mark (BOM)\n\t\t}\n\n\t\t$outstr .= mb_convert_encoding($str, 'UTF-16BE', 'UTF-8');\n\n\t\treturn $outstr;\n\t}", "label": 2}
{"code": "public static function parentName($project, $database, $collectionId)\n    {\n        return self::getParentNameTemplate()->render([\n            'project' => $project,\n            'database' => $database,\n            'collection_id' => $collectionId,\n        ]);\n    }", "label": 2}
{"code": "func (f *file) lintErrorStrings() {\n\tf.walk(func(node ast.Node) bool {\n\t\tce, ok := node.(*ast.CallExpr)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tif !isPkgDot(ce.Fun, \"errors\", \"New\") && !isPkgDot(ce.Fun, \"fmt\", \"Errorf\") {\n\t\t\treturn true\n\t\t}\n\t\tif len(ce.Args) < 1 {\n\t\t\treturn true\n\t\t}\n\t\tstr, ok := ce.Args[0].(*ast.BasicLit)\n\t\tif !ok || str.Kind != token.STRING {\n\t\t\treturn true\n\t\t}\n\t\ts, _ := strconv.Unquote(str.Value) // can assume well-formed Go\n\t\tif s == \"\" {\n\t\t\treturn true\n\t\t}\n\t\tclean, conf := lintErrorString(s)\n\t\tif clean {\n\t\t\treturn true\n\t\t}\n\n\t\tf.errorf(str, conf, link(styleGuideBase+\"#error-strings\"), category(\"errors\"),\n\t\t\t\"error strings should not be capitalized or end with punctuation or a newline\")\n\t\treturn true\n\t})\n}", "label": 5}
{"code": "public function annotate(Image $image, array $options = [])\n    {\n        $res = $this->annotateBatch([$image], $options);\n        return $res[0];\n    }", "label": 2}
{"code": "def replace_view(name, version: nil, revert_to_version: nil, materialized: false)\n      if version.blank?\n        raise ArgumentError, \"version is required\"\n      end\n\n      if materialized\n        raise ArgumentError, \"Cannot replace materialized views\"\n      end\n\n      sql_definition = definition(name, version)\n\n      Scenic.database.replace_view(name, sql_definition)\n    end", "label": 4}
{"code": "func Exists(table Table, chain string, rule ...string) bool {\n\treturn exists(false, table, chain, rule...)\n}", "label": 5}
{"code": "private function build_aliases( $aliases, $alias, $assoc_args, $is_grouping, $grouping = '', $is_update = false ) {\n\n\t\tif ( $is_grouping ) {\n\t\t\t$valid_assoc_args = array( 'config', 'grouping' );\n\t\t\t$invalid_args     = array_diff( array_keys( $assoc_args ), $valid_assoc_args );\n\n\t\t\t// Check for invalid args.\n\t\t\tif ( ! empty( $invalid_args ) ) {\n\t\t\t\t$args_info = implode( ',', $invalid_args );\n\t\t\t\tWP_CLI::error( \"--grouping argument works alone. Found invalid arg(s) '$args_info'.\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( $is_update ) {\n\t\t\t$this->validate_alias_type( $aliases, $alias, $assoc_args, $grouping );\n\t\t}\n\n\t\tif ( ! $is_grouping ) {\n\t\t\tforeach ( $assoc_args as $key => $value ) {\n\t\t\t\tif ( strpos( $key, 'set-' ) !== false ) {\n\t\t\t\t\t$alias_key_info = explode( '-', $key );\n\t\t\t\t\t$alias_key      = empty( $alias_key_info[1] ) ? '' : $alias_key_info[1];\n\t\t\t\t\tif ( ! empty( $alias_key ) && ! empty( $value ) ) {\n\t\t\t\t\t\t$aliases[ $alias ][ $alias_key ] = $value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tif ( ! empty( $grouping ) ) {\n\t\t\t\t$group_alias_list  = explode( ',', $grouping );\n\t\t\t\t$group_alias       = array_map(\n\t\t\t\t\tfunction ( $current_alias ) {\n\t\t\t\t\t\treturn '@' . ltrim( $current_alias, '@' );\n\t\t\t\t\t},\n\t\t\t\t\t$group_alias_list\n\t\t\t\t);\n\t\t\t\t$aliases[ $alias ] = $group_alias;\n\t\t\t}\n\t\t}\n\n\t\treturn $aliases;\n\t}", "label": 2}
{"code": "def ensembl_to_kegg(organism,kegg_db):\n    \"\"\"\n    Looks up KEGG mappings of KEGG ids to ensembl ids\n\n    :param organism: an organisms as listed in organismsKEGG()\n    :param kegg_db: a matching KEGG db as reported in databasesKEGG\n\n    :returns: a Pandas dataframe of with 'KEGGid' and 'ENSid'.\n\n    \"\"\"\n    print(\"KEGG API: http://rest.genome.jp/link/\"+kegg_db+\"/\"+organism)\n    sys.stdout.flush()\n    kegg_ens=urlopen(\"http://rest.genome.jp/link/\"+kegg_db+\"/\"+organism).read()\n    kegg_ens=kegg_ens.split(\"\\n\")\n    final=[]\n    for i in kegg_ens:\n        final.append(i.split(\"\\t\"))\n    df=pd.DataFrame(final[0:len(final)-1])[[0,1]]\n    ens_id=pd.DataFrame(df[1].str.split(\":\").tolist())[1]\n    df=pd.concat([df,ens_id],axis=1)\n    df.columns=['KEGGid','ensDB','ENSid']\n    df=df[['KEGGid','ENSid']]\n    return df", "label": 1}
{"code": "def bind_queue(queue, routing_keys)\n      unbind_redundant_bindings(queue, routing_keys)\n\n      # Ensure all the desired bindings are present\n      routing_keys.each do |routing_key|\n        logger.debug \"creating binding #{queue.name} <--> #{routing_key}\"\n        queue.bind(exchange, routing_key: routing_key)\n      end\n    end", "label": 4}
{"code": "def serialize_distribution(network_agents, known_modules=[]):\n    '''\n    When serializing an agent distribution, remove the thresholds, in order\n    to avoid cluttering the YAML definition file.\n    '''\n    d = deepcopy(list(network_agents))\n    for v in d:\n        if 'threshold' in v:\n            del v['threshold']\n        v['agent_type'] = serialize_type(v['agent_type'],\n                                         known_modules=known_modules)\n    return d", "label": 1}
{"code": "function(alias, model, copy) {\n      this.__currentObjectModels[alias] = model;\n      this.__updateCache(model);\n      this.resetUpdating();\n      if (copy) {\n        _.each(this.getMappings(), function(config, mappingAlias) {\n          var modelAliases;\n          if (alias === mappingAlias) {\n            this.__pull(mappingAlias);\n          }\n          if (config.computed) {\n            modelAliases = this.__getModelAliases(mappingAlias);\n            if (_.contains(modelAliases, alias)) {\n              this.__pull(mappingAlias);\n            }\n          }\n        }, this);\n      }\n    }", "label": 3}
{"code": "public static base_response update(nitro_service client, responderpolicy resource) throws Exception {\n\t\tresponderpolicy updateresource = new responderpolicy();\n\t\tupdateresource.name = resource.name;\n\t\tupdateresource.rule = resource.rule;\n\t\tupdateresource.action = resource.action;\n\t\tupdateresource.undefaction = resource.undefaction;\n\t\tupdateresource.comment = resource.comment;\n\t\tupdateresource.logaction = resource.logaction;\n\t\tupdateresource.appflowaction = resource.appflowaction;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def merge_phlat_calls(job, tumor_phlat, normal_phlat, rna_phlat):\n    \"\"\"\n    This module will merge the results form running PHLAT on the 3 input fastq\n    pairs.\n\n    ARGUMENTS\n    1. tumor_phlat: <JSid for tumor DNA called alleles>\n    2. normal_phlat: <JSid for normal DNA called alleles>\n    3. rna_phlat: <JSid for tumor RNA called alleles>\n\n    RETURN VALUES\n    1. output_files: Dict of JSids for consensus MHCI and MHCII alleles\n             output_files\n                    |- 'mhci_alleles.list': <JSid>\n                    +- 'mhcii_alleles.list': <JSid>\n\n    This module corresponds to node 14 on the tree\n    \"\"\"\n    job.fileStore.logToMaster('Merging Phlat calls')\n    work_dir = job.fileStore.getLocalTempDir()\n    input_files = {\n        'tumor_dna': tumor_phlat,\n        'normal_dna': normal_phlat,\n        'tumor_rna': rna_phlat}\n    input_files = get_files_from_filestore(job, input_files, work_dir)\n    with open(input_files['tumor_dna'], 'r') as td_file, \\\n            open(input_files['normal_dna'], 'r') as nd_file, \\\n            open(input_files['tumor_rna'], 'r') as tr_file:\n        # TODO: Could this be a defautdict?\n        mhc_alleles = {'HLA_A': [], 'HLA_B': [], 'HLA_C': [], 'HLA_DPA': [], 'HLA_DQA': [],\n                       'HLA_DPB': [], 'HLA_DQB': [], 'HLA_DRB': []}\n        for phlatfile in td_file, nd_file, tr_file:\n            mhc_alleles = parse_phlat_file(phlatfile, mhc_alleles)\n    # Get most probable alleles for each allele group and print to output\n    with open(os.path.join(work_dir, 'mhci_alleles.list'), 'w') as mhci_file, \\\n            open(os.path.join(work_dir, 'mhcii_alleles.list'), 'w') as mhcii_file:\n        for mhci_group in ['HLA_A', 'HLA_B', 'HLA_C']:\n            mpa = most_probable_alleles(mhc_alleles[mhci_group])\n            print('\\n'.join([''.join(['HLA-', x]) for x in mpa]), file=mhci_file)\n        drb_mpa = most_probable_alleles(mhc_alleles['HLA_DRB'])\n        print('\\n'.join([''.join(['HLA-', x]) for x in drb_mpa]), file=mhcii_file)\n        dqa_mpa = most_probable_alleles(mhc_alleles['HLA_DQA'])\n        dqb_mpa = most_probable_alleles(mhc_alleles['HLA_DQB'])\n        for dqa_allele in dqa_mpa:\n            for dqb_allele in dqb_mpa:\n                print(''.join(['HLA-', dqa_allele, '/', dqb_allele]), file=mhcii_file)\n    output_files = defaultdict()\n    for allele_file in ['mhci_alleles.list', 'mhcii_alleles.list']:\n        output_files[allele_file] = job.fileStore.writeGlobalFile(os.path.join(work_dir,\n                                                                               allele_file))\n    return output_files", "label": 1}
{"code": "func (s *MockStore) AtomicPut(key string, newValue []byte, previous *store.KVPair, options *store.WriteOptions) (bool, *store.KVPair, error) {\n\tmData := s.db[key]\n\n\tif previous == nil {\n\t\tif mData != nil {\n\t\t\treturn false, nil, types.BadRequestErrorf(\"atomic put failed because key exists\")\n\t\t} // Else OK.\n\t} else {\n\t\tif mData == nil {\n\t\t\treturn false, nil, types.BadRequestErrorf(\"atomic put failed because key exists\")\n\t\t}\n\t\tif mData != nil && mData.Index != previous.LastIndex {\n\t\t\treturn false, nil, types.BadRequestErrorf(\"atomic put failed due to mismatched Index\")\n\t\t} // Else OK.\n\t}\n\terr := s.Put(key, newValue, nil)\n\tif err != nil {\n\t\treturn false, nil, err\n\t}\n\treturn true, &store.KVPair{Key: key, Value: newValue, LastIndex: s.db[key].Index}, nil\n}", "label": 5}
{"code": "public function setPushConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\PubSub\\V1\\PushConfig::class);\n        $this->push_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def agent_color(self, val):\n        \"\"\"\n        gets a colour for agent 0 - 9\n        \"\"\"\n        if val == '0': \n            colour = 'blue'\n        elif val == '1':\n            colour = 'navy'\n        elif val == '2':\n            colour = 'firebrick'\n        elif val == '3':\n            colour = 'blue'\n        elif val == '4':\n            colour = 'blue2'\n        elif val == '5':\n            colour = 'blue4'\n        elif val == '6':\n            colour = 'gray22'\n        elif val == '7':\n            colour = 'gray57'\n        elif val == '8':\n            colour = 'red4'\n        elif val == '9':\n            colour = 'red3'\n\n    \n        \n        return colour", "label": 1}
{"code": "public static int findSpace(String haystack, int begin) {\r\n    int space = haystack.indexOf(' ', begin);\r\n    int nbsp = haystack.indexOf('\\u00A0', begin);\r\n    if (space == -1 && nbsp == -1) {\r\n      return -1;\r\n    } else if (space >= 0 && nbsp >= 0) {\r\n      return Math.min(space, nbsp);\r\n    } else {\r\n      // eg one is -1, and the other is >= 0\r\n      return Math.max(space, nbsp);\r\n    }\r\n  }", "label": 0}
{"code": "public function setConfusionMatrix($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\AutoMl\\V1beta1\\ClassificationEvaluationMetrics_ConfusionMatrix::class);\n        $this->confusion_matrix = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def get_merged_env(self, include_os=False):\n        \"\"\"\n        Copying and merging environment variables.\n\n        Args:\n            include_os (bool): when true then include the environment variables (default: False)\n\n        Returns:\n            dict: environment variables as defined in the pipeline\n                  (optional including system environment variables).\n        \"\"\"\n        env = {}\n        if include_os:\n            env.update(os.environ.copy())\n        for level in range(3):\n            env.update(self.pipeline.data.env_list[level].copy())\n        return env", "label": 1}
{"code": "def run_linter_on_file?(config, linter, file)\n      linter_config = config.for_linter(linter)\n\n      if linter_config['include'].any? &&\n         !HamlLint::Utils.any_glob_matches?(linter_config['include'], file)\n        return false\n      end\n\n      if HamlLint::Utils.any_glob_matches?(linter_config['exclude'], file)\n        return false\n      end\n\n      true\n    end", "label": 4}
{"code": "function(options) {\n            options = options || {};\n            options.idsToFetch = options.idsToFetch || this.trackedIds;\n            options.setOptions = options.setOptions || {remove: false};\n            return this.__loadWrapper(function() {\n              if (options.idsToFetch && options.idsToFetch.length) {\n                return parentInstance.fetchByIds(options);\n              } else {\n                return $.Deferred().resolve().promise();\n              }\n            });\n          }", "label": 3}
{"code": "function queryRxNormApproximate(medname, maxEntries, callback) {\n    // maxEntries is optional\n    if (!callback) {\n        callback = maxEntries;\n        maxEntries = 5;\n    }\n\n    query(\"http://rxnav.nlm.nih.gov/REST/approximateTerm.json\", {\n        term: medname,\n        maxEntries: maxEntries\n    }, callback);\n}", "label": 3}
{"code": "def read_string(buffer, offset)\n      # TODO: Length check\n      #   Exception when\n      #   - offset exceeds length of buffer\n      #   byteslice truncates when too long, but returns nil when start is beyond end of buffer\n      len     = buffer.byteslice(offset, 2).unpack('v').first\n      offset += 2\n      out     = buffer.byteslice(offset, len)\n      [out, offset + len]\n    end", "label": 4}
{"code": "public static sslcertkey_sslvserver_binding[] get(nitro_service service, String certkey) throws Exception{\n\t\tsslcertkey_sslvserver_binding obj = new sslcertkey_sslvserver_binding();\n\t\tobj.set_certkey(certkey);\n\t\tsslcertkey_sslvserver_binding response[] = (sslcertkey_sslvserver_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (aug *AuthUserGroup) Delete(db XODB) error {\n\tvar err error\n\n\t// if doesn't exist, bail\n\tif !aug._exists {\n\t\treturn nil\n\t}\n\n\t// if deleted, bail\n\tif aug._deleted {\n\t\treturn nil\n\t}\n\n\t// sql query\n\tconst sqlstr = `DELETE FROM django.auth_user_groups WHERE id = :1`\n\n\t// run query\n\tXOLog(sqlstr, aug.ID)\n\t_, err = db.Exec(sqlstr, aug.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set deleted\n\taug._deleted = true\n\n\treturn nil\n}", "label": 5}
{"code": "public static java.util.Date newDateTime() {\n        return new java.util.Date((System.currentTimeMillis() / SECOND_MILLIS) * SECOND_MILLIS);\n    }", "label": 0}
{"code": "public function setContentType($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Asset\\V1\\ContentType::class);\n        $this->content_type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public void setChildren(List<PrintComponent<?>> children) {\n\t\tthis.children = children;\n\t\t// needed for Json unmarshall !!!!\n\t\tfor (PrintComponent<?> child : children) {\n\t\t\tchild.setParent(this);\n\t\t}\n\t}", "label": 0}
{"code": "def run(self, tool, args, new_import_path=''):\n        \"\"\"\n        import the tool and call the function, passing the args.\n        \"\"\"\n        if new_import_path != '':\n            #print('APPENDING PATH = ', new_import_path)\n            sys.path.append(new_import_path)\n        \n        #if silent == 'N':\n        print('main called ' + tool['file'] + '->' + tool['function'] + ' with ', args, ' = ', tool['return'])\n        mod = __import__( os.path.basename(tool['file']).split('.')[0]) # for absolute folder names\n        # mod = __import__( tool['file'][:-2]) # for aikif folders (doesnt work)\n        func = getattr(mod, tool['function'])\n        tool['return'] = func(args)\n        return tool['return']", "label": 1}
{"code": "private synchronized Constructor getIndirectionHandlerConstructor()\r\n    {\r\n        if(_indirectionHandlerConstructor == null)\r\n        {\r\n            Class[] paramType = {PBKey.class, Identity.class};\r\n\r\n            try\r\n            {\r\n                _indirectionHandlerConstructor = getIndirectionHandlerClass().getConstructor(paramType);\r\n            }\r\n            catch(NoSuchMethodException ex)\r\n            {\r\n                throw new MetadataException(\"The class \"\r\n                        + _indirectionHandlerClass.getName()\r\n                        + \" specified for IndirectionHandlerClass\"\r\n                        + \" is required to have a public constructor with signature (\"\r\n                        + PBKey.class.getName()\r\n                        + \", \"\r\n                        + Identity.class.getName()\r\n                        + \").\");\r\n            }\r\n        }\r\n        return _indirectionHandlerConstructor;\r\n    }", "label": 0}
{"code": "func MustCreateProvisionToken(token string, roles teleport.Roles, expires time.Time) ProvisionToken {\n\tt, err := NewProvisionToken(token, roles, expires)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}", "label": 5}
{"code": "function resolveName(pkgpath) {\n  pkgpath = pkgpath.replace(RE_TRAILING, '');\n\n  const cwd = process.cwd();\n  const parts = pkgpath.split(path.sep);\n  const len = parts.length;\n\n  let idx = 1;\n\n  // Handle packages nested under root\n  if (!pkgpath.includes('node_modules') && cwd != pkgpath) {\n    // Increase by distance from root\n    idx += path.relative(cwd, pkgpath).split(path.sep).length;\n    // Handle scoped node_modules\n  } else if (parts[len - 2].charAt(0) == '@') {\n    idx = 2;\n  }\n\n  return parts.slice(len - idx).join(path.sep);\n}", "label": 3}
{"code": "public function setAuxiliaryTables($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\PrivacyMetric\\KMapEstimationConfig\\AuxiliaryTable::class);\n        $this->auxiliary_tables = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func GetBees() []*BeeInterface {\n\tr := []*BeeInterface{}\n\tfor _, bee := range bees {\n\t\tr = append(r, bee)\n\t}\n\n\treturn r\n}", "label": 5}
{"code": "public function exists(array $options = [])\n    {\n        try {\n            $this->connection->getSession($options + [\n                'name' => $this->name(),\n                'database' => $this->database\n            ]);\n\n            return true;\n        } catch (NotFoundException $e) {\n            return false;\n        }\n    }", "label": 2}
{"code": "def analyze(self, id): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Get a list of tests that will be skipped for a package.\n\n        :param id: Package ID as an int.\n        :return: :class:`packages.Analysis <packages.Analysis>` object\n        :rtype: packages.Analysis\n        \"\"\"\n        schema = AnalysisSchema()\n        resp = self.service.post(self.base+str(id)+'/', params={'process': 'analyze'})\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "private function checkBeforeExecution($callable)\n    {\n        if ($this->state->isExecuting()) {\n            throw new ClientException(\n                'Cannot invoke \"execute\" or \"exec\" inside an active transaction context.'\n            );\n        }\n\n        if ($callable) {\n            if (!is_callable($callable)) {\n                throw new \\InvalidArgumentException('The argument must be a callable object.');\n            }\n\n            if (!$this->commands->isEmpty()) {\n                $this->discard();\n\n                throw new ClientException(\n                    'Cannot execute a transaction block after using fluent interface.'\n                );\n            }\n        } elseif ($this->attempts) {\n            $this->discard();\n\n            throw new ClientException(\n                'Automatic retries are supported only when a callable block is provided.'\n            );\n        }\n    }", "label": 2}
{"code": "func (tc *TeleportClient) ListNodes(ctx context.Context) ([]services.Server, error) {\n\tvar err error\n\t// userhost is specified? that must be labels\n\tif tc.Host != \"\" {\n\t\ttc.Labels, err = ParseLabelSpec(tc.Host)\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t}\n\n\t// connect to the proxy and ask it to return a full list of servers\n\tproxyClient, err := tc.ConnectToProxy(ctx)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tdefer proxyClient.Close()\n\n\treturn proxyClient.FindServersByLabels(ctx, tc.Namespace, tc.Labels)\n}", "label": 5}
{"code": "public static base_response kill(nitro_service client, systemsession resource) throws Exception {\n\t\tsystemsession killresource = new systemsession();\n\t\tkillresource.sid = resource.sid;\n\t\tkillresource.all = resource.all;\n\t\treturn killresource.perform_operation(client,\"kill\");\n\t}", "label": 0}
{"code": "public function setResourceGroup($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Monitoring\\V3\\UptimeCheckConfig_ResourceGroup::class);\n        $this->writeOneof(4, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def usearchdb(fasta, alignment = 'local', usearch_loc = 'usearch'):\n    \"\"\"\n    make usearch db\n    \"\"\"\n    if '.udb' in fasta:\n        print('# ... database found: %s' % (fasta), file=sys.stderr)\n        return fasta\n    type = check_type(fasta)\n    db = '%s.%s.udb' % (fasta.rsplit('.', 1)[0], type)\n    if os.path.exists(db) is False:\n        print('# ... making usearch db for: %s' % (fasta), file=sys.stderr)\n        if alignment == 'local':\n            os.system('%s -makeudb_ublast %s -output %s >> log.txt' % (usearch_loc, fasta, db))\n        elif alignment == 'global':\n            os.system('%s -makeudb_usearch %s -output %s >> log.txt' % (usearch_loc, fasta, db))\n    else:\n        print('# ... database found for: %s' % (fasta), file=sys.stderr)\n    return db", "label": 1}
{"code": "def page_execute_url(params)\n      params = prepare_params(params)\n\n      uri = URI(@url)\n      uri.query = URI.encode_www_form(params)\n      uri.to_s\n    end", "label": 4}
{"code": "def coverage(self):\n        \"\"\"\n        Returns NumPy array indicating number of reads covering each\n        nucleotides of this sequence.\n        \"\"\"\n        variant_start_index, variant_end_index = self.variant_indices()\n        n_nucleotides = len(self)\n        coverage_array = np.zeros(n_nucleotides, dtype=\"int32\")\n        for read in self.reads:\n            coverage_array[\n                max(0, variant_start_index - len(read.prefix)):\n                min(n_nucleotides, variant_end_index + len(read.suffix))] += 1\n        return coverage_array", "label": 1}
{"code": "private function wait(\n        callable $isCompleteFn,\n        callable $reloadFn,\n        Job $job,\n        $maxRetries\n    ) {\n        if (!$isCompleteFn()) {\n            if ($maxRetries === null) {\n                $maxRetries = Job::MAX_RETRIES;\n            }\n\n            $retryFn = function () use ($isCompleteFn, $reloadFn, $job) {\n                $reloadFn();\n\n                if (!$isCompleteFn()) {\n                    throw new JobException('Job did not complete within the allowed number of retries.', $job);\n                }\n            };\n\n            (new ExponentialBackoff($maxRetries))\n                ->execute($retryFn);\n        }\n    }", "label": 2}
{"code": "public static int cudnnGetReductionWorkspaceSize(\n        cudnnHandle handle, \n        cudnnReduceTensorDescriptor reduceTensorDesc, \n        cudnnTensorDescriptor aDesc, \n        cudnnTensorDescriptor cDesc, \n        long[] sizeInBytes)\n    {\n        return checkResult(cudnnGetReductionWorkspaceSizeNative(handle, reduceTensorDesc, aDesc, cDesc, sizeInBytes));\n    }", "label": 0}
{"code": "private function createSnapshotWithData(\n        ValueMapper $valueMapper,\n        DocumentReference $reference,\n        array $document,\n        $exists = true\n    ) {\n        $fields = $exists\n            ? $valueMapper->decodeValues($this->pluck('fields', $document))\n            : [];\n\n        $document = $this->transformSnapshotTimestamps($document);\n\n        return new DocumentSnapshot($reference, $valueMapper, $document, $fields, $exists);\n    }", "label": 2}
{"code": "func (s *AuthServer) GenerateToken(req GenerateTokenRequest) (string, error) {\n\tif err := req.CheckAndSetDefaults(); err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\ttoken, err := services.NewProvisionToken(req.Token, req.Roles, s.clock.Now().UTC().Add(req.TTL))\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\tif err := s.Provisioner.UpsertToken(token); err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn req.Token, nil\n}", "label": 5}
{"code": "function sync (state, docsOrIds) {\n  var syncedObjects = []\n  var errors = state.db.constructor.Errors\n\n  return Promise.resolve(state.remote)\n\n  .then(function (remote) {\n    return new Promise(function (resolve, reject) {\n      if (Array.isArray(docsOrIds)) {\n        docsOrIds = docsOrIds.map(toId)\n      } else {\n        docsOrIds = docsOrIds && [toId(docsOrIds)]\n      }\n\n      if (docsOrIds && docsOrIds.filter(Boolean).length !== docsOrIds.length) {\n        return Promise.reject(errors.NOT_AN_OBJECT)\n      }\n\n      var replication = state.db.sync(remote, {\n        doc_ids: docsOrIds,\n        include_docs: true\n      })\n\n      /* istanbul ignore next */\n      replication.catch(function () {\n        // handled trough 'error' event\n      })\n\n      replication.on('complete', function () {\n        resolve(syncedObjects)\n      })\n      replication.on('error', reject)\n\n      replication.on('change', function (change) {\n        syncedObjects = syncedObjects.concat(change.change.docs)\n\n        for (var i = 0; i < change.change.docs.length; i++) {\n          state.emitter.emit(change.direction, change.change.docs[i])\n        }\n      })\n    })\n  })\n}", "label": 3}
{"code": "def delete_overwrite(target, reason = nil)\n      raise 'Tried deleting a overwrite for an invalid target' unless target.is_a?(Member) || target.is_a?(User) || target.is_a?(Role) || target.is_a?(Profile) || target.is_a?(Recipient) || target.respond_to?(:resolve_id)\n\n      API::Channel.delete_permission(@bot.token, @id, target.resolve_id, reason)\n    end", "label": 4}
{"code": "def write(self, file_or_filename):\n        \"\"\" Writes case data to file in Excel format.\n        \"\"\"\n        self.book = Workbook()\n        self._write_data(None)\n        self.book.save(file_or_filename)", "label": 1}
{"code": "def get_ids(a):\n    \"\"\"\n    make copy of sequences with short identifier\n    \"\"\"\n    a_id = '%s.id.fa' % (a.rsplit('.', 1)[0])\n    a_id_lookup = '%s.id.lookup' % (a.rsplit('.', 1)[0])\n    if check(a_id) is True:\n        return a_id, a_id_lookup\n    a_id_f = open(a_id, 'w')\n    a_id_lookup_f = open(a_id_lookup, 'w')\n    ids = []\n    for seq in parse_fasta(open(a)):\n        id = id_generator() \n        while id in ids:\n            id = id_generator() \n        ids.append(id)\n        header = seq[0].split('>')[1]\n        name = remove_bad(header)\n        seq[0] = '>%s %s' % (id, header)\n        print('\\n'.join(seq), file=a_id_f)\n        print('%s\\t%s\\t%s' % (id, name, header), file=a_id_lookup_f)\n    return a_id, a_id_lookup", "label": 1}
{"code": "public static sslcertkey_sslocspresponder_binding[] get(nitro_service service, String certkey) throws Exception{\n\t\tsslcertkey_sslocspresponder_binding obj = new sslcertkey_sslocspresponder_binding();\n\t\tobj.set_certkey(certkey);\n\t\tsslcertkey_sslocspresponder_binding response[] = (sslcertkey_sslocspresponder_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static function elementToBeClickable(WebDriverBy $by)\n    {\n        $visibility_of_element_located =\n            self::visibilityOfElementLocated($by);\n\n        return new static(\n            function (WebDriver $driver) use ($visibility_of_element_located) {\n                $element = call_user_func(\n                    $visibility_of_element_located->getApply(),\n                    $driver\n                );\n                try {\n                    if ($element !== null && $element->isEnabled()) {\n                        return $element;\n                    }\n\n                    return null;\n                } catch (StaleElementReferenceException $e) {\n                    return null;\n                }\n            }\n        );\n    }", "label": 2}
{"code": "public static <T> MetaTinyType<T> metaFor(Class<?> candidate) {\n        for (MetaTinyType meta : metas) {\n            if (meta.isMetaOf(candidate)) {\n                return meta;\n            }\n        }\n        throw new IllegalArgumentException(String.format(\"not a tinytype: %s\", candidate == null ? \"null\" : candidate.getCanonicalName()));\n    }", "label": 0}
{"code": "protected ValueContainer[] getNonKeyValues(PersistenceBroker broker, ClassDescriptor cld, Object obj) throws PersistenceBrokerException\r\n    {\r\n        return broker.serviceBrokerHelper().getNonKeyRwValues(cld, obj);\r\n    }", "label": 0}
{"code": "def set_callback\n      if request.streaming?\n        response = nil\n        easy.on_headers do |easy|\n          response = Response.new(Ethon::Easy::Mirror.from_easy(easy).options)\n          request.execute_headers_callbacks(response)\n        end\n        request.on_body.each do |callback|\n          easy.on_body do |chunk, easy|\n            callback.call(chunk, response)\n          end\n        end\n      else\n        easy.on_headers do |easy|\n          request.execute_headers_callbacks(Response.new(Ethon::Easy::Mirror.from_easy(easy).options))\n        end\n      end\n      request.on_progress.each do |callback|\n        easy.on_progress do |dltotal, dlnow, ultotal, ulnow, easy|\n          callback.call(dltotal, dlnow, ultotal, ulnow, response)\n        end\n      end\n      easy.on_complete do |easy|\n        request.finish(Response.new(easy.mirror.options))\n        Typhoeus::Pool.release(easy)\n        if hydra && !hydra.queued_requests.empty?\n          hydra.dequeue_many\n        end\n      end\n    end", "label": 4}
{"code": "def save(self, filename, format=None, **kwargs):\n        \"\"\" Save the object to file given by filename.\n        \"\"\"\n        if format is None:\n            # try to derive protocol from file extension\n            format = format_from_extension(filename)\n        with file(filename, 'wb') as fp:\n            self.save_to_file_object(fp, format, **kwargs)", "label": 1}
{"code": "def default_logger\n      logger = Logger.new($stdout)\n      logger.level = Mongoid::Config.log_level\n      logger\n    end", "label": 4}
{"code": "func (c *EventHistoryCollector) eventMatches(event types.BaseEvent) bool {\n\tspec := c.Filter.(types.EventFilterSpec)\n\n\tif !c.typeMatches(event, &spec) {\n\t\treturn false\n\t}\n\n\t// TODO: spec.Time, spec.UserName, etc\n\n\treturn c.entityMatches(event, &spec)\n}", "label": 5}
{"code": "func barcodeKey(bcode barcode.Barcode) string {\n\treturn bcode.Metadata().CodeKind + bcode.Content()\n}", "label": 5}
{"code": "private function normalizeDateValue($date)\n    {\n        if (is_string($date)) {\n            $date = strtotime($date);\n        } elseif ($date instanceof \\DateTime) {\n            $date = $date->format('U');\n        } elseif (!is_int($date)) {\n            throw new \\InvalidArgumentException('Date values must be a '\n                . 'string, an int, or a DateTime object.');\n        }\n\n        return $date;\n    }", "label": 2}
{"code": "public function first($columns = ['*'])\n    {\n        $this->applyCriteria();\n        $this->applyScope();\n\n        $results = $this->model->first($columns);\n\n        $this->resetModel();\n\n        return $this->parserResult($results);\n    }", "label": 2}
{"code": "public function getEnabledExtensions()\n    {\n        $enabled = [];\n        $extensions = $this->getExtensions();\n\n        foreach ($this->getEnabled() as $id) {\n            if (isset($extensions[$id])) {\n                $enabled[$id] = $extensions[$id];\n            }\n        }\n\n        return $enabled;\n    }", "label": 2}
{"code": "public function setNormalizedBoundingBoxes($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\VideoIntelligence\\V1\\NormalizedBoundingBox::class);\n        $this->normalized_bounding_boxes = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public void delete(Object obj, boolean ignoreReferences) throws PersistenceBrokerException\n    {\n        if(isTxCheck() && !isInTransaction())\n        {\n            if(logger.isEnabledFor(Logger.ERROR))\n            {\n                String msg = \"No running PB-tx found. Please, only delete objects in context of a PB-transaction\" +\n                    \" to avoid side-effects - e.g. when rollback of complex objects.\";\n                try\n                {\n                    throw new Exception(\"** Delete object without active PersistenceBroker transaction **\");\n                }\n                catch(Exception e)\n                {\n                    logger.error(msg, e);\n                }\n            }\n        }\n        try\n        {\n            doDelete(obj, ignoreReferences);\n        }\n        finally\n        {\n            markedForDelete.clear();\n        }\n    }", "label": 0}
{"code": "private function getCommitComponentModifiedList($url)\n    {\n        $commit = json_decode($this->http->get($url, [\n            'auth' => [null, $this->token]\n        ])->getBody(), true);\n\n        $changedComponents = [];\n        $fileDirectoryComponent = [];\n        foreach ($commit['files'] as $file) {\n            $filename = $file['filename'];\n            if (strpos($filename, '/') === false) {\n                continue;\n            }\n\n            $fileParts = explode('/', $filename);\n            $componentDirectory = $fileParts[0];\n\n            $composerPath = $this->rootPath .'/'. $componentDirectory .'/composer.json';\n            if (!array_key_exists($composerPath, $fileDirectoryComponent)) {\n                if (!file_exists($composerPath)) {\n                    continue;\n                }\n\n                $composer = json_decode(file_get_contents($composerPath), true)['extra']['component'];\n                $fileDirectoryComponent[$composerPath] = $composer;\n            } else {\n                $composer = $fileDirectoryComponent[$composerPath];\n            }\n\n            if (!isset($changedComponents[$composer['id']])) {\n                $changedComponents[$composer['id']] = [\n                    'files' => [],\n                    'level' => 'minor'\n                ];\n            }\n\n            $changedComponents[$composer['id']]['files'][] = $file['filename'];\n        }\n\n        return $changedComponents;\n    }", "label": 2}
{"code": "def include(self, path):\n        \"\"\"Returns `True` if the file is not ignored\"\"\"\n        for extension in IGNORE_EXTENSIONS:\n            if path.endswith(extension):\n                return False\n        parts = path.split(os.path.sep)\n        for part in parts:\n            if part in self.ignore_dirs:\n                return False\n        return True", "label": 1}
{"code": "public function subscriberByChannel(string $channel): ?Subscriber\n    {\n        $key = self::SUBSCRIBER_KEY.\".{$channel}\";\n\n        return $this->cache->get($key);\n    }", "label": 2}
{"code": "def message(self, data):\n        \"\"\"Sends a message to the framework scheduler.\n\n        These messages are best effort; do not expect a framework message to be\n        retransmitted in any reliable fashion.\n        \"\"\"\n        logging.info('Driver sends framework message {}'.format(data))\n        return self.driver.sendFrameworkMessage(data)", "label": 1}
{"code": "public function update()\n    {\n        // copy the code into memory\n        $backup = file($this->reflection->getFileName());\n\n        list($preamble, $class) = $this->splitClassFile($backup);\n        $preamble = $this->stripOutExistingDocBlock($preamble);\n        $preamble .= $this->buildUpdatedDocBlock();\n\n        if ($this->writeClassFile(implode(PHP_EOL, [$preamble, $class]))\n            && $this->commandLineLint($this->reflection->getFileName())\n        ) {\n            return true;\n        }\n\n        $this->writeClassFile(implode('', $backup));\n        return false;\n    }", "label": 2}
{"code": "public function recordProcessedJob(JobProcessed $event)\n    {\n        if (! Telescope::isRecording()) {\n            return;\n        }\n\n        $uuid = $event->job->payload()['telescope_uuid'] ?? null;\n\n        if (! $uuid) {\n            return;\n        }\n\n        Telescope::recordUpdate(EntryUpdate::make(\n            $uuid, EntryType::JOB, ['status' => 'processed']\n        ));\n    }", "label": 2}
{"code": "func pieceEndFileIndex(pieceEndOffset int64, files []*File) int {\n\tfor i, f := range files {\n\t\tif f.offset+f.length >= pieceEndOffset {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn 0\n}", "label": 5}
{"code": "protected function buildIdentity($identity_file = false)\n  {\n      if ($identity_file === false) {\n          $identity_file = sprintf('%s%s%sid.%s.dat', __DIR__, DIRECTORY_SEPARATOR, Constants::DATA_FOLDER.DIRECTORY_SEPARATOR, $this->phoneNumber);\n      }\n\n      // Check if the provided is not a file but a directory\n      if (is_dir($identity_file)) {\n          $identity_file = sprintf('%s/id.%s.dat',\n              rtrim($identity_file, \"/\"),\n              $this->phoneNumber\n          );\n      }\n\n      if (is_readable($identity_file)) {\n          $data = urldecode(file_get_contents($identity_file));\n          $length = strlen($data);\n\n          if ($length == 20 || $length == 16) {\n              return $data;\n          }\n      }\n\n      $bytes = strtolower(openssl_random_pseudo_bytes(20));\n\n      if (file_put_contents($identity_file, urlencode($bytes)) === false) {\n          throw new Exception('Unable to write identity file to '.$identity_file);\n      }\n\n      return $bytes;\n  }", "label": 2}
{"code": "func (s *Server) wrap() {\n\toldHook := s.Config.ConnState\n\ts.Config.ConnState = func(c net.Conn, cs http.ConnState) {\n\t\ts.mu.Lock()\n\t\tdefer s.mu.Unlock()\n\t\tswitch cs {\n\t\tcase http.StateNew:\n\t\t\ts.wg.Add(1)\n\t\t\tif _, exists := s.conns[c]; exists {\n\t\t\t\tpanic(\"invalid state transition\")\n\t\t\t}\n\t\t\tif s.conns == nil {\n\t\t\t\ts.conns = make(map[net.Conn]http.ConnState)\n\t\t\t}\n\t\t\ts.conns[c] = cs\n\t\t\tif s.closed {\n\t\t\t\t// Probably just a socket-late-binding dial from\n\t\t\t\t// the default transport that lost the race (and\n\t\t\t\t// thus this connection is now idle and will\n\t\t\t\t// never be used).\n\t\t\t\ts.closeConn(c)\n\t\t\t}\n\t\tcase http.StateActive:\n\t\t\tif oldState, ok := s.conns[c]; ok {\n\t\t\t\tif oldState != http.StateNew && oldState != http.StateIdle {\n\t\t\t\t\tpanic(\"invalid state transition\")\n\t\t\t\t}\n\t\t\t\ts.conns[c] = cs\n\t\t\t}\n\t\tcase http.StateIdle:\n\t\t\tif oldState, ok := s.conns[c]; ok {\n\t\t\t\tif oldState != http.StateActive {\n\t\t\t\t\tpanic(\"invalid state transition\")\n\t\t\t\t}\n\t\t\t\ts.conns[c] = cs\n\t\t\t}\n\t\t\tif s.closed {\n\t\t\t\ts.closeConn(c)\n\t\t\t}\n\t\tcase http.StateHijacked, http.StateClosed:\n\t\t\ts.forgetConn(c)\n\t\t}\n\t\tif oldHook != nil {\n\t\t\toldHook(c, cs)\n\t\t}\n\t}\n}", "label": 5}
{"code": "private static Iterator<String> splitIntoDocs(Reader r) {\r\n    if (TREAT_FILE_AS_ONE_DOCUMENT) {\r\n      return Collections.singleton(IOUtils.slurpReader(r)).iterator();\r\n    } else {\r\n      Collection<String> docs = new ArrayList<String>();\r\n      ObjectBank<String> ob = ObjectBank.getLineIterator(r);\r\n      StringBuilder current = new StringBuilder();\r\n      for (String line : ob) {\r\n        if (docPattern.matcher(line).lookingAt()) {\r\n          // Start new doc, store old one if non-empty\r\n          if (current.length() > 0) {\r\n            docs.add(current.toString());\r\n            current = new StringBuilder();\r\n          }\r\n        }\r\n        current.append(line);\r\n        current.append('\\n');\r\n      }\r\n      if (current.length() > 0) {\r\n        docs.add(current.toString());\r\n      }\r\n      return docs.iterator();\r\n    }\r\n  }", "label": 0}
{"code": "def genome_info(genome, info):\n    \"\"\"\n    return genome info for choosing representative\n\n    if ggKbase table provided - choose rep based on SCGs and genome length\n        - priority for most SCGs - extra SCGs, then largest genome\n\n    otherwise, based on largest genome\n    \"\"\"\n    try:\n        scg       = info['#SCGs']\n        dups      = info['#SCG duplicates']\n        length    = info['genome size (bp)']\n        return [scg - dups, length, genome]\n    except:\n        return [False, False, info['genome size (bp)'], genome]", "label": 1}
{"code": "public function removeRoleBySlug($slug): int\n    {\n        $role = $this->roles()->where('slug', $slug)->first();\n\n        return $this->roles()->detach($role);\n    }", "label": 2}
{"code": "protected function createPipeline(array $options = null, $callable = null)\n    {\n        if (isset($options['atomic']) && $options['atomic']) {\n            $class = 'Predis\\Pipeline\\Atomic';\n        } elseif (isset($options['fire-and-forget']) && $options['fire-and-forget']) {\n            $class = 'Predis\\Pipeline\\FireAndForget';\n        } else {\n            $class = 'Predis\\Pipeline\\Pipeline';\n        }\n\n        /*\n         * @var ClientContextInterface\n         */\n        $pipeline = new $class($this);\n\n        if (isset($callable)) {\n            return $pipeline->execute($callable);\n        }\n\n        return $pipeline;\n    }", "label": 2}
{"code": "function tryRequireEach(paths) {\n  let result;\n\n  while (!result && paths.length) {\n    result = tryRequire(paths.shift());\n  }\n\n  return result;\n}", "label": 3}
{"code": "func (auup *AuthUserUserPermission) Update(db XODB) error {\n\tvar err error\n\n\t// if doesn't exist, bail\n\tif !auup._exists {\n\t\treturn errors.New(\"update failed: does not exist\")\n\t}\n\n\t// if deleted, bail\n\tif auup._deleted {\n\t\treturn errors.New(\"update failed: marked for deletion\")\n\t}\n\n\t// sql query\n\tconst sqlstr = `UPDATE django.auth_user_user_permissions SET ` +\n\t\t`user_id = ?, permission_id = ?` +\n\t\t` WHERE id = ?`\n\n\t// run query\n\tXOLog(sqlstr, auup.UserID, auup.PermissionID, auup.ID)\n\t_, err = db.Exec(sqlstr, auup.UserID, auup.PermissionID, auup.ID)\n\treturn err\n}", "label": 5}
{"code": "function (template) {\n    var pattern = _.template(template)(fileReplace);\n    pattern = pattern.replace(/\\//g, '\\\\/');\n    pattern = pattern.replace(/\\s+/g, '\\\\s*');\n    pattern = '\\\\s*' + pattern + '\\\\s*';\n    return new RegExp(pattern);\n}", "label": 3}
{"code": "def execute_cleanup_tasks(ctx, cleanup_tasks, dry_run=False):\n    \"\"\"Execute several cleanup tasks as part of the cleanup.\n\n    REQUIRES: ``clean(ctx, dry_run=False)`` signature in cleanup tasks.\n\n    :param ctx:             Context object for the tasks.\n    :param cleanup_tasks:   Collection of cleanup tasks (as Collection).\n    :param dry_run:         Indicates dry-run mode (bool)\n    \"\"\"\n    # pylint: disable=redefined-outer-name\n    executor = Executor(cleanup_tasks, ctx.config)\n    for cleanup_task in cleanup_tasks.tasks:\n        print(\"CLEANUP TASK: %s\" % cleanup_task)\n        executor.execute((cleanup_task, dict(dry_run=dry_run)))", "label": 1}
{"code": "def write_type(field_info, value)\n      # if field_info is a Fixnum, assume it is a Thrift::Types constant\n      # convert it into a field_info Hash for backwards compatibility\n      if field_info.is_a? Fixnum\n        field_info = {:type => field_info}\n      end\n\n      case field_info[:type]\n      when Types::BOOL\n        write_bool(value)\n      when Types::BYTE\n        write_byte(value)\n      when Types::DOUBLE\n        write_double(value)\n      when Types::I16\n        write_i16(value)\n      when Types::I32\n        write_i32(value)\n      when Types::I64\n        write_i64(value)\n      when Types::STRING\n        if field_info[:binary]\n          write_binary(value)\n        else\n          write_string(value)\n        end\n      when Types::STRUCT\n        value.write(self)\n      else\n        raise NotImplementedError\n      end\n    end", "label": 4}
{"code": "def i(name, identifier={:index => 0}, &block)\n      standard_methods(name, identifier,'i_for', &block)\n      define_method(name) do\n        return platform.i_text_for identifier.clone unless block_given?\n        self.send(\"#{name}_element\").text\n      end\n    end", "label": 4}
{"code": "public function setIamPolicy($resource, $policy, array $optionalArgs = [])\n    {\n        $request = new SetIamPolicyRequest();\n        $request->setResource($resource);\n        $request->setPolicy($policy);\n\n        $requestParams = new RequestParamsHeaderDescriptor([\n          'resource' => $request->getResource(),\n        ]);\n        $optionalArgs['headers'] = isset($optionalArgs['headers'])\n            ? array_merge($requestParams->getHeader(), $optionalArgs['headers'])\n            : $requestParams->getHeader();\n\n        return $this->startCall(\n            'SetIamPolicy',\n            Policy::class,\n            $optionalArgs,\n            $request,\n            Call::UNARY_CALL,\n            'google.iam.v1.IAMPolicy'\n        )->wait();\n    }", "label": 2}
{"code": "public function setCurrentDocument($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\V1\\Precondition::class);\n        $this->current_document = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def save_excel(self, fd):\n        \"\"\" Saves the case as an Excel spreadsheet.\n        \"\"\"\n        from pylon.io.excel import ExcelWriter\n        ExcelWriter(self).write(fd)", "label": 1}
{"code": "def action_raw(name, callable, extra_env=nil)\n      # Run the action with the action runner on the environment\n      env = {\n        action_name: \"machine_action_#{name}\".to_sym,\n        machine: self,\n        machine_action: name,\n        ui: @ui,\n      }.merge(extra_env || {})\n      @env.action_runner.run(callable, env)\n    end", "label": 4}
{"code": "public void initialize() {\n\t\tthis.enqueue(new SerialMessage(SerialMessage.SerialMessageClass.GetVersion, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.GetVersion, SerialMessage.SerialMessagePriority.High));\n\t\tthis.enqueue(new SerialMessage(SerialMessage.SerialMessageClass.MemoryGetId, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.MemoryGetId, SerialMessage.SerialMessagePriority.High));\n\t\tthis.enqueue(new SerialMessage(SerialMessage.SerialMessageClass.SerialApiGetCapabilities, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.SerialApiGetCapabilities, SerialMessage.SerialMessagePriority.High));\n\t}", "label": 0}
{"code": "public function getJob($projectId, $region, $jobId, array $optionalArgs = [])\n    {\n        $request = new GetJobRequest();\n        $request->setProjectId($projectId);\n        $request->setRegion($region);\n        $request->setJobId($jobId);\n\n        return $this->startCall(\n            'GetJob',\n            Job::class,\n            $optionalArgs,\n            $request\n        )->wait();\n    }", "label": 2}
{"code": "def createbot(name, directory, verbosity):\n    \"\"\"\n    Creates a Bot's directory structure for the given bot NAME in\n    the current directory or optionally in the given DIRECTORY.\n    \"\"\"\n    handle_template('bot', name, target=directory, verbosity=verbosity)\n    click.echo(f\"Success: '{name}' bot was successfully created on '{directory}'\")", "label": 1}
{"code": "func New() *Validate {\n\n\ttc := new(tagCache)\n\ttc.m.Store(make(map[string]*cTag))\n\n\tsc := new(structCache)\n\tsc.m.Store(make(map[reflect.Type]*cStruct))\n\n\tv := &Validate{\n\t\ttagName:     defaultTagName,\n\t\taliases:     make(map[string]string, len(bakedInAliases)),\n\t\tvalidations: make(map[string]FuncCtx, len(bakedInValidators)),\n\t\ttagCache:    tc,\n\t\tstructCache: sc,\n\t}\n\n\t// must copy alias validators for separate validations to be used in each validator instance\n\tfor k, val := range bakedInAliases {\n\t\tv.RegisterAlias(k, val)\n\t}\n\n\t// must copy validators for separate validations to be used in each instance\n\tfor k, val := range bakedInValidators {\n\n\t\t// no need to error check here, baked in will always be valid\n\t\t_ = v.registerValidation(k, wrapFunc(val), true)\n\t}\n\n\tv.pool = &sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn &validate{\n\t\t\t\tv:        v,\n\t\t\t\tns:       make([]byte, 0, 64),\n\t\t\t\tactualNs: make([]byte, 0, 64),\n\t\t\t\tmisc:     make([]byte, 32),\n\t\t\t}\n\t\t},\n\t}\n\n\treturn v\n}", "label": 5}
{"code": "public void displayUseCases()\r\n    {\r\n        System.out.println();\r\n        for (int i = 0; i < useCases.size(); i++)\r\n        {\r\n            System.out.println(\"[\" + i + \"] \" + ((UseCase) useCases.get(i)).getDescription());\r\n        }\r\n    }", "label": 0}
{"code": "public function isLoggedIn()\n    {\n        //If you aren't connected you can't be logged in! ($this->isConnected())\n        //We are connected - but are we logged in? (the rest)\n        return $this->isConnected() && !empty($this->loginStatus) && $this->loginStatus === Constants::CONNECTED_STATUS;\n    }", "label": 2}
{"code": "func (m *Mock) AssertExpectations(t TestingT) bool {\n\tif h, ok := t.(tHelper); ok {\n\t\th.Helper()\n\t}\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\tvar somethingMissing bool\n\tvar failedExpectations int\n\n\t// iterate through each expectation\n\texpectedCalls := m.expectedCalls()\n\tfor _, expectedCall := range expectedCalls {\n\t\tif !expectedCall.optional && !m.methodWasCalled(expectedCall.Method, expectedCall.Arguments) && expectedCall.totalCalls == 0 {\n\t\t\tsomethingMissing = true\n\t\t\tfailedExpectations++\n\t\t\tt.Logf(\"FAIL:\\t%s(%s)\\n\\t\\tat: %s\", expectedCall.Method, expectedCall.Arguments.String(), expectedCall.callerInfo)\n\t\t} else {\n\t\t\tif expectedCall.Repeatability > 0 {\n\t\t\t\tsomethingMissing = true\n\t\t\t\tfailedExpectations++\n\t\t\t\tt.Logf(\"FAIL:\\t%s(%s)\\n\\t\\tat: %s\", expectedCall.Method, expectedCall.Arguments.String(), expectedCall.callerInfo)\n\t\t\t} else {\n\t\t\t\tt.Logf(\"PASS:\\t%s(%s)\", expectedCall.Method, expectedCall.Arguments.String())\n\t\t\t}\n\t\t}\n\t}\n\n\tif somethingMissing {\n\t\tt.Errorf(\"FAIL: %d out of %d expectation(s) were met.\\n\\tThe code you are testing needs to make %d more call(s).\\n\\tat: %s\", len(expectedCalls)-failedExpectations, len(expectedCalls), failedExpectations, assert.CallerInfo())\n\t}\n\n\treturn !somethingMissing\n}", "label": 5}
{"code": "public function clear()\n    {\n        $sessions = $this->config['lock']->synchronize(function () {\n            $item = $this->cacheItemPool->getItem($this->cacheKey);\n            $data = (array) $item->get() ?: $this->initialize();\n            $sessions = $data['queue'] + $data['inUse'];\n            $this->cacheItemPool->clear();\n\n            return $sessions;\n        });\n\n        $this->deleteSessions($sessions);\n    }", "label": 2}
{"code": "public static auditsyslogpolicy_systemglobal_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauditsyslogpolicy_systemglobal_binding obj = new auditsyslogpolicy_systemglobal_binding();\n\t\tobj.set_name(name);\n\t\tauditsyslogpolicy_systemglobal_binding response[] = (auditsyslogpolicy_systemglobal_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def px_to_window_rel(opts = {}, driver = $driver)\n      w = driver.window_size\n      x = opts.fetch :x, 0\n      y = opts.fetch :y, 0\n\n      OpenStruct.new(x: \"#{x.to_f} / #{w.width.to_f}\",\n                     y: \"#{y.to_f} / #{w.height.to_f}\")\n    end", "label": 4}
{"code": "def scene=(n)\n      if n.nil?\n        Kernel.raise IndexError, 'scene number out of bounds' unless @images.length.zero?\n        @scene = nil\n        return @scene\n      elsif @images.length.zero?\n        Kernel.raise IndexError, 'scene number out of bounds'\n      end\n\n      n = Integer(n)\n      Kernel.raise IndexError, 'scene number out of bounds' if n < 0 || n > length - 1\n      @scene = n\n      @scene\n    end", "label": 4}
{"code": "@Deprecated\n  public static TraceContextHolder wrap(TraceContext traceContext) {\n    return (traceContext != null) ? new TraceContextHolder(traceContext) : TraceContextHolder.EMPTY;\n  }", "label": 0}
{"code": "public int[] getPositions() {\n    int[] list;\n    if (assumeSinglePosition) {\n      list = new int[1];\n      list[0] = super.startPosition();\n      return list;\n    } else {\n      try {\n        processEncodedPayload();\n        list = mtasPosition.getPositions();\n        if (list != null) {\n          return mtasPosition.getPositions();\n        }\n      } catch (IOException e) {\n        log.debug(e);\n        // do nothing\n      }\n      int start = super.startPosition();\n      int end = super.endPosition();\n      list = new int[end - start];\n      for (int i = start; i < end; i++)\n        list[i - start] = i;\n      return list;\n    }\n  }", "label": 0}
{"code": "def format_datetime(value)\n      case value\n      when DateTime, Time\n        value.strftime('%FT%T.%9N%:z')\n      when String\n        value\n      else\n        raise ArgumentError, \"unsupported type '#{value.class}' of time value '#{value}'\"\n      end\n    end", "label": 4}
{"code": "def _enable_cleanup(func):\n    \"\"\"\n    Execute cleanup operation when the decorated function completed.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        self = args[0]\n        result = func(*args, **kwargs)\n        self.cleanup(self)\n        return result\n\n    return wrapper", "label": 1}
{"code": "func (tsdbSink *openTSDBSink) metricToPoint(name string, value core.MetricValue, timestamp time.Time, labels map[string]string) opentsdbclient.DataPoint {\n\tseriesName := strings.Replace(toValidOpenTsdbName(name), \"/\", \"_\", -1)\n\n\tif value.MetricType.String() != \"\" {\n\t\tseriesName = fmt.Sprintf(\"%s_%s\", seriesName, value.MetricType.String())\n\t}\n\n\tdatapoint := opentsdbclient.DataPoint{\n\t\tMetric:    seriesName,\n\t\tTags:      make(map[string]string, len(labels)),\n\t\tTimestamp: timestamp.Unix(),\n\t}\n\tif value.ValueType == core.ValueInt64 {\n\t\tdatapoint.Value = value.IntValue\n\t} else {\n\t\tdatapoint.Value = value.FloatValue\n\t}\n\n\tfor key, value := range labels {\n\t\tkey = toValidOpenTsdbName(key)\n\t\tvalue = toValidOpenTsdbName(value)\n\n\t\tif value != \"\" {\n\t\t\tdatapoint.Tags[key] = value\n\t\t}\n\t}\n\n\ttsdbSink.putDefaultTags(&datapoint)\n\treturn datapoint\n}", "label": 5}
{"code": "func (s SearchIndex) FindByInventoryPath(ctx context.Context, path string) (Reference, error) {\n\treq := types.FindByInventoryPath{\n\t\tThis:          s.Reference(),\n\t\tInventoryPath: path,\n\t}\n\n\tres, err := methods.FindByInventoryPath(ctx, s.c, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.Returnval == nil {\n\t\treturn nil, nil\n\t}\n\treturn NewReference(s.c, *res.Returnval), nil\n}", "label": 5}
{"code": "def get_fields(self):\n        \"\"\"Returns a fields dict for this serializer with a 'geometry' field\n        added.\n        \"\"\"\n        fields = super(GeoModelSerializer, self).get_fields()\n        # Set the geometry field name when it's undeclared.\n        if not self.Meta.geom_field:\n            for name, field in fields.items():\n                if isinstance(field, GeometryField):\n                    self.Meta.geom_field = name\n                    break\n        return fields", "label": 1}
{"code": "func (h *Handle) CopyTo(o datastore.KVObject) error {\n\th.Lock()\n\tdefer h.Unlock()\n\n\tdstH := o.(*Handle)\n\tif h == dstH {\n\t\treturn nil\n\t}\n\tdstH.Lock()\n\tdstH.bits = h.bits\n\tdstH.unselected = h.unselected\n\tdstH.head = h.head.getCopy()\n\tdstH.app = h.app\n\tdstH.id = h.id\n\tdstH.dbIndex = h.dbIndex\n\tdstH.dbExists = h.dbExists\n\tdstH.store = h.store\n\tdstH.curr = h.curr\n\tdstH.Unlock()\n\n\treturn nil\n}", "label": 5}
{"code": "def generate_diary(self):\n        \"\"\"\n        extracts event information from core tables into diary files\n        \"\"\"\n        print('Generate diary files from Event rows only')\n        for r in self.table:\n            print(str(type(r)) + ' = ', r)", "label": 1}
{"code": "public function setBreakpoint(array $args)\n    {\n        $breakpointArgs = $this->pluckArray([\n            'action',\n            'condition',\n            'expressions',\n            'logMessageFormat',\n            'logLevel',\n            'location'\n        ], $args);\n        return $this->send([$this->debuggerClient, 'setBreakpoint'], [\n            $this->pluck('debuggeeId', $args),\n            $this->serializer->decodeMessage(new Breakpoint(), $breakpointArgs),\n            DebuggerClient::getDefaultAgentVersion(),\n            $args\n        ]);\n    }", "label": 2}
{"code": "function topLevelItems(root) {\n            var topLevel = [];\n            function recur(item) {\n                if (isTopLevel(item)) {\n                    topLevel.push(item);\n                    if (item.children) {\n                        for (var _i = 0, _a = item.children; _i < _a.length; _i++) {\n                            var child = _a[_i];\n                            recur(child);\n                        }\n                    }\n                }\n            }\n            recur(root);\n            return topLevel;\n            function isTopLevel(item) {\n                switch (navigationBarNodeKind(item)) {\n                    case 221 /* ClassDeclaration */:\n                    case 192 /* ClassExpression */:\n                    case 224 /* EnumDeclaration */:\n                    case 222 /* InterfaceDeclaration */:\n                    case 225 /* ModuleDeclaration */:\n                    case 256 /* SourceFile */:\n                    case 223 /* TypeAliasDeclaration */:\n                    case 279 /* JSDocTypedefTag */:\n                        return true;\n                    case 148 /* Constructor */:\n                    case 147 /* MethodDeclaration */:\n                    case 149 /* GetAccessor */:\n                    case 150 /* SetAccessor */:\n                        return hasSomeImportantChild(item);\n                    case 180 /* ArrowFunction */:\n                    case 220 /* FunctionDeclaration */:\n                    case 179 /* FunctionExpression */:\n                        return isTopLevelFunctionDeclaration(item);\n                    default:\n                        return false;\n                }\n                function isTopLevelFunctionDeclaration(item) {\n                    if (!item.node.body) {\n                        return false;\n                    }\n                    switch (navigationBarNodeKind(item.parent)) {\n                        case 226 /* ModuleBlock */:\n                        case 256 /* SourceFile */:\n                        case 147 /* MethodDeclaration */:\n                        case 148 /* Constructor */:\n                            return true;\n                        default:\n                            return hasSomeImportantChild(item);\n                    }\n                }\n                function hasSomeImportantChild(item) {\n                    return ts.forEach(item.children, function (child) {\n                        var childKind = navigationBarNodeKind(child);\n                        return childKind !== 218 /* VariableDeclaration */ && childKind !== 169 /* BindingElement */;\n                    });\n                }\n            }\n        }", "label": 3}
{"code": "function parseList(kind, parseElement) {\n            var saveParsingContext = parsingContext;\n            parsingContext |= 1 << kind;\n            var result = [];\n            result.pos = getNodePos();\n            while (!isListTerminator(kind)) {\n                if (isListElement(kind, /*inErrorRecovery*/ false)) {\n                    var element = parseListElement(kind, parseElement);\n                    result.push(element);\n                    continue;\n                }\n                if (abortParsingListOrMoveToNextToken(kind)) {\n                    break;\n                }\n            }\n            result.end = getNodeEnd();\n            parsingContext = saveParsingContext;\n            return result;\n        }", "label": 3}
{"code": "void update(Object feature) throws LayerException {\n\t\tSimpleFeatureSource source = getFeatureSource();\n\t\tif (source instanceof SimpleFeatureStore) {\n\t\t\tSimpleFeatureStore store = (SimpleFeatureStore) source;\n\t\t\tString featureId = getFeatureModel().getId(feature);\n\t\t\tFilter filter = filterService.createFidFilter(new String[] { featureId });\n\t\t\ttransactionSynchronization.synchTransaction(store);\n\t\t\tList<Name> names = new ArrayList<Name>();\n\t\t\tMap<String, Attribute> attrMap = getFeatureModel().getAttributes(feature);\n\t\t\tList<Object> values = new ArrayList<Object>();\n\t\t\tfor (Map.Entry<String, Attribute> entry : attrMap.entrySet()) {\n\t\t\t\tString name = entry.getKey();\n\t\t\t\tnames.add(store.getSchema().getDescriptor(name).getName());\n\t\t\t\tvalues.add(entry.getValue().getValue());\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstore.modifyFeatures(names.toArray(new Name[names.size()]), values.toArray(), filter);\n\t\t\t\tstore.modifyFeatures(store.getSchema().getGeometryDescriptor().getName(), getFeatureModel()\n\t\t\t\t\t\t.getGeometry(feature), filter);\n\t\t\t\tlog.debug(\"Updated feature {} in {}\", featureId, getFeatureSourceName());\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tfeatureModelUsable = false;\n\t\t\t\tthrow new LayerException(ioe, ExceptionCode.LAYER_MODEL_IO_EXCEPTION);\n\t\t\t}\n\t\t} else {\n\t\t\tlog.error(\"Don't know how to create or update \" + getFeatureSourceName() + \", class \"\n\t\t\t\t\t+ source.getClass().getName() + \" does not implement SimpleFeatureStore\");\n\t\t\tthrow new LayerException(ExceptionCode.CREATE_OR_UPDATE_NOT_IMPLEMENTED, getFeatureSourceName(), source\n\t\t\t\t\t.getClass().getName());\n\t\t}\n\t}", "label": 0}
{"code": "public function loadRelationForPage(int $first, int $page, string $relationName, Closure $relationConstraints): self\n    {\n        // Load the count of relations of models, this will be the `total` argument of `Paginator`.\n        // Be aware that this will reload all the models entirely with the count of their relations,\n        // which will bring extra DB queries, always prefer querying without pagination if possible.\n        $this->reloadModelsWithRelationCount();\n\n        $relations = $this\n            ->buildRelationsFromModels($relationName, $relationConstraints)\n            ->map(\n                function (Relation $relation) use ($first, $page) {\n                    return $relation->forPage($page, $first);\n                }\n            );\n\n        /** @var \\Illuminate\\Database\\Eloquent\\Collection $relationModels */\n        $relationModels = $this\n            ->unionAllRelationQueries($relations)\n            ->get();\n\n        $this->hydratePivotRelation($relationName, $relationModels);\n\n        $this->loadDefaultWith($relationModels);\n\n        $this->associateRelationModels($relationName, $relationModels);\n\n        $this->convertRelationToPaginator($first, $page, $relationName);\n\n        return $this;\n    }", "label": 2}
{"code": "def remove_by_id(class_name, *ids)\n      ids.flatten!\n      @connection.delete_by_id(\n        ids.map { |id| Adapters::InstanceAdapter.index_id_for(class_name, id) }\n      )\n    end", "label": 4}
{"code": "public static appfwpolicylabel_stats get(nitro_service service, String labelname) throws Exception{\n\t\tappfwpolicylabel_stats obj = new appfwpolicylabel_stats();\n\t\tobj.set_labelname(labelname);\n\t\tappfwpolicylabel_stats response = (appfwpolicylabel_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (l VirtualDeviceList) FindSCSIController(name string) (*types.VirtualSCSIController, error) {\n\tif name != \"\" {\n\t\td := l.Find(name)\n\t\tif d == nil {\n\t\t\treturn nil, fmt.Errorf(\"device '%s' not found\", name)\n\t\t}\n\t\tif c, ok := d.(types.BaseVirtualSCSIController); ok {\n\t\t\treturn c.GetVirtualSCSIController(), nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"%s is not an SCSI controller\", name)\n\t}\n\n\tc := l.PickController((*types.VirtualSCSIController)(nil))\n\tif c == nil {\n\t\treturn nil, errors.New(\"no available SCSI controller\")\n\t}\n\n\treturn c.(types.BaseVirtualSCSIController).GetVirtualSCSIController(), nil\n}", "label": 5}
{"code": "public void addExtentClass(String newExtentClassName)\r\n    {\r\n        extentClassNames.add(newExtentClassName);\r\n        if(m_repository != null) m_repository.addExtent(newExtentClassName, this);\r\n    }", "label": 0}
{"code": "def _get_slack_array_construct(self):\n        \"\"\" Returns a construct for an array of slack bus data.\n        \"\"\"\n        bus_no = integer.setResultsName(\"bus_no\")\n        s_rating = real.setResultsName(\"s_rating\") # MVA\n        v_rating = real.setResultsName(\"v_rating\") # kV\n        v_magnitude = real.setResultsName(\"v_magnitude\") # p.u.\n        ref_angle = real.setResultsName(\"ref_angle\") # p.u.\n        q_max = Optional(real).setResultsName(\"q_max\") # p.u.\n        q_min = Optional(real).setResultsName(\"q_min\") # p.u.\n        v_max = Optional(real).setResultsName(\"v_max\") # p.u.\n        v_min = Optional(real).setResultsName(\"v_min\") # p.u.\n        p_guess = Optional(real).setResultsName(\"p_guess\") # p.u.\n        # Loss participation coefficient\n        lp_coeff = Optional(real).setResultsName(\"lp_coeff\")\n        ref_bus = Optional(boolean).setResultsName(\"ref_bus\")\n        status = Optional(boolean).setResultsName(\"status\")\n\n        slack_data = bus_no + s_rating + v_rating + v_magnitude + \\\n            ref_angle + q_max + q_min + v_max + v_min + p_guess + \\\n            lp_coeff + ref_bus + status + scolon\n\n        slack_data.setParseAction(self.push_slack)\n\n        slack_array = Literal(\"SW.con\") + \"=\" + \"[\" + \"...\" + \\\n            ZeroOrMore(slack_data + Optional(\"]\" + scolon))\n\n        return slack_array", "label": 1}
{"code": "func NewFileWithCustomPathMaker(baseDir string, pathMaker func(baseDir string, info *metainfo.Info, infoHash metainfo.Hash) string) ClientImpl {\n\treturn newFileWithCustomPathMakerAndCompletion(baseDir, pathMaker, pieceCompletionForDir(baseDir))\n}", "label": 5}
{"code": "def lookup_model_names #:nodoc:\n      @lookup_model_names ||= begin\n        child_index = options[:child_index]\n        names = object_name.to_s.scan(/(?!\\d)\\w+/).flatten\n        names.delete(child_index) if child_index\n        names.each { |name| name.gsub!('_attributes', '') }\n        names.freeze\n      end\n    end", "label": 4}
{"code": "def colophon(wobj)\n      s = @epub.colophon\n      if !s.nil? && !wobj.nil?\n        wobj.puts s\n      end\n    end", "label": 4}
{"code": "def remove_collection(self, first_arg, sec_arg, third_arg, fourth_arg=None, commit_msg=None):\n        \"\"\"Remove a collection\n        Given a collection_id, branch and optionally an\n        author, remove a collection on the given branch\n        and attribute the commit to author.\n        Returns the SHA of the commit on branch.\n        \"\"\"\n        if fourth_arg is None:\n            collection_id, branch_name, author = first_arg, sec_arg, third_arg\n            gh_user = branch_name.split('_collection_')[0]\n            parent_sha = self.get_master_sha()\n        else:\n            gh_user, collection_id, parent_sha, author = first_arg, sec_arg, third_arg, fourth_arg\n        if commit_msg is None:\n            commit_msg = \"Delete Collection '%s' via OpenTree API\" % collection_id\n        return self._remove_document(gh_user, collection_id, parent_sha, author, commit_msg)", "label": 1}
{"code": "@SuppressWarnings(\"rawtypes\")\n\tpublic void unsetReplicationClassLoader(Fqn regionFqn, ClassLoader classLoader) {\n\t\tif (!isLocalMode()) {\n\t\t\tfinal Region region = jBossCache.getRegion(regionFqn, true);\n\t\t\tif (region != null) {\n\t\t\t\tif (region.isActive()) {\n\t\t\t\t\tregion.deactivate();\n\t\t\t\t}\t\t\t\t\n\t\t\t\tregion.unregisterContextClassLoader();\n\t\t\t\tjBossCache.removeRegion(regionFqn);\n\t\t\t}\t\n\t\t}\n\t}", "label": 0}
{"code": "def _dictify(field, value):\n    \"\"\"Make `value` suitable for a dictionary.\n\n    * If `value` is an Entity, call to_dict() on it.\n    * If value is a timestamp, turn it into a string value.\n    * If none of the above are satisfied, return the input value\n    \"\"\"\n    if value is None:\n        return None\n    elif field.type_:\n        return value.to_dict()\n    return field.dict_value(value)", "label": 1}
{"code": "public function setValues($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->values = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "private static function calculateMessageAttributesMd5($message)\n    {\n        if (empty($message['MessageAttributes'])\n            || !is_array($message['MessageAttributes'])\n        ) {\n            return null;\n        }\n\n        ksort($message['MessageAttributes']);\n        $attributeValues = \"\";\n        foreach ($message['MessageAttributes'] as $name => $details) {\n            $attributeValues .= self::getEncodedStringPiece($name);\n            $attributeValues .= self::getEncodedStringPiece($details['DataType']);\n            if (substr($details['DataType'], 0, 6) === 'Binary') {\n                $attributeValues .= pack('c', 0x02);\n                $attributeValues .= self::getEncodedBinaryPiece(\n                    $details['BinaryValue']\n                );\n            } else {\n                $attributeValues .= pack('c', 0x01);\n                $attributeValues .= self::getEncodedStringPiece(\n                    $details['StringValue']\n                );\n            }\n        }\n\n        return md5($attributeValues);\n    }", "label": 2}
{"code": "def add_constraint(self, con):\n        \"\"\" Adds a constraint to the model.\n        \"\"\"\n        if isinstance(con, LinearConstraint):\n            N, M = con.A.shape\n            if con.name in [c.name for c in self.lin_constraints]:\n                logger.error(\"Constraint set named '%s' already exists.\"\n                             % con.name)\n                return False\n            else:\n                con.i1 = self.lin_N# + 1\n                con.iN = self.lin_N + N - 1\n\n                nv = 0\n                for vs in con.vs:\n                    nv = nv + self.get_var_N(vs)\n                if M != nv:\n                    logger.error(\"Number of columns of A does not match number\"\n                        \" of variables, A is %d x %d, nv = %d\", N, M, nv)\n                self.lin_constraints.append(con)\n        elif isinstance(con, NonLinearConstraint):\n            N = con.N\n            if con.name in [c.name for c in self.nln_constraints]:\n                logger.error(\"Constraint set named '%s' already exists.\"\n                             % con.name)\n                return False\n            else:\n                con.i1 = self.nln_N# + 1\n                con.iN = self.nln_N + N\n                self.nln_constraints.append(con)\n        else:\n            raise ValueError\n\n        return True", "label": 1}
{"code": "public function setVoice($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\VoiceSelectionParams::class);\n        $this->voice = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func (m *MockIndex) Chan(arg0 chan int, arg1 chan<- hash.Hash) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Chan\", arg0, arg1)\n}", "label": 5}
{"code": "def find_safe_starting_point(self):\n        \"\"\"\n        finds a place on the grid which is clear on all sides \n        to avoid starting in the middle of a blockage\n        \"\"\"\n        y = random.randint(2,self.grid_height-4)\n        x = random.randint(2,self.grid_width-4)\n        return y, x", "label": 1}
{"code": "func NewAssociation(ref mo.Reference) Association {\n\tobj := AssociatedObject(ref.Reference())\n\treturn Association{\n\t\tObjectID: &obj,\n\t}\n}", "label": 5}
{"code": "func (r *reader) readOnceAt(b []byte, pos int64, ctxErr *error) (n int, err error) {\n\tif pos >= r.length {\n\t\terr = io.EOF\n\t\treturn\n\t}\n\tfor {\n\t\tavail := r.waitAvailable(pos, int64(len(b)), ctxErr)\n\t\tif avail == 0 {\n\t\t\tif r.t.closed.IsSet() {\n\t\t\t\terr = errors.New(\"torrent closed\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif *ctxErr != nil {\n\t\t\t\terr = *ctxErr\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tpi := pieceIndex(r.torrentOffset(pos) / r.t.info.PieceLength)\n\t\tip := r.t.info.Piece(pi)\n\t\tpo := r.torrentOffset(pos) % r.t.info.PieceLength\n\t\tb1 := missinggo.LimitLen(b, ip.Length()-po, avail)\n\t\tn, err = r.t.readAt(b1, r.torrentOffset(pos))\n\t\tif n != 0 {\n\t\t\terr = nil\n\t\t\treturn\n\t\t}\n\t\tr.t.cl.lock()\n\t\t// TODO: Just reset pieces in the readahead window. This might help\n\t\t// prevent thrashing with small caches and file and piece priorities.\n\t\tlog.Printf(\"error reading torrent %s piece %d offset %d, %d bytes: %v\",\n\t\t\tr.t.infoHash.HexString(), pi, po, len(b1), err)\n\t\tif !r.t.updatePieceCompletion(pi) {\n\t\t\tlog.Printf(\"piece %d completion unchanged\", pi)\n\t\t}\n\t\tr.t.cl.unlock()\n\t}\n}", "label": 5}
{"code": "function isIso8601DateTimeString(value) {\n    var regex = /^(([+-]\\d{6}|\\d{4})(-(0[1-9]|1[0-2])(-(0[1-9]|[12]\\d|3[01]))?)?)(T((([01]\\d|2[0-3])(:[0-5]\\d)(:[0-5]\\d(\\.\\d{1,3})?)?)|(24:00(:00(\\.0{1,3})?)?))(Z|([+-])([01]\\d|2[0-3]):([0-5]\\d))?)?$/;\n\n    // Verify that it's in ISO 8601 format (via the regex) and that it represents a valid point in time (via Date.parse)\n    return regex.test(value) && !isNaN(Date.parse(value));\n  }", "label": 3}
{"code": "public function setSafeSearchAnnotation($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Vision\\V1\\SafeSearchAnnotation::class);\n        $this->safe_search_annotation = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function setUnaryFilter($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\V1\\StructuredQuery_UnaryFilter::class);\n        $this->writeOneof(3, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def options_match?(request)\n      (options ? options.all?{ |k,v| request.original_options[k] == v || request.options[k] == v } : true)\n    end", "label": 4}
{"code": "func (m *Martini) Use(handler Handler) {\n\tvalidateHandler(handler)\n\n\tm.handlers = append(m.handlers, handler)\n}", "label": 5}
{"code": "func (a *AuthWithRoles) filterNodes(nodes []services.Server) ([]services.Server, error) {\n\t// For certain built-in roles, continue to allow full access and return\n\t// the full set of nodes to not break existing clusters during migration.\n\t//\n\t// In addition, allow proxy (and remote proxy) to access all nodes for it's\n\t// smart resolution address resolution. Once the smart resolution logic is\n\t// moved to the auth server, this logic can be removed.\n\tif a.hasBuiltinRole(string(teleport.RoleAdmin)) ||\n\t\ta.hasBuiltinRole(string(teleport.RoleProxy)) ||\n\t\ta.hasRemoteBuiltinRole(string(teleport.RoleRemoteProxy)) {\n\t\treturn nodes, nil\n\t}\n\n\t// Fetch services.RoleSet for the identity of the logged in user.\n\troles, err := services.FetchRoles(a.user.GetRoles(), a.authServer, a.user.GetTraits())\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\t// Extract all unique allowed logins across all roles.\n\tallowedLogins := make(map[string]bool)\n\tfor _, role := range roles {\n\t\tfor _, login := range role.GetLogins(services.Allow) {\n\t\t\tallowedLogins[login] = true\n\t\t}\n\t}\n\n\t// Loop over all nodes and check if the caller has access.\n\tfilteredNodes := make([]services.Server, 0, len(nodes))\nNextNode:\n\tfor _, node := range nodes {\n\t\tfor login, _ := range allowedLogins {\n\t\t\terr := roles.CheckAccessToServer(login, node)\n\t\t\tif err == nil {\n\t\t\t\tfilteredNodes = append(filteredNodes, node)\n\t\t\t\tcontinue NextNode\n\t\t\t}\n\t\t}\n\t}\n\n\treturn filteredNodes, nil\n}", "label": 5}
{"code": "def looking_for_friends(self):\n        '''Look for friends to drink with'''\n        self.info('I am looking for friends')\n        available_friends = list(self.get_agents(drunk=False,\n                                                 pub=None,\n                                                 state_id=self.looking_for_friends.id))\n        if not available_friends:\n            self.info('Life sucks and I\\'m alone!')\n            return self.at_home\n        befriended = self.try_friends(available_friends)\n        if befriended:\n            return self.looking_for_pub", "label": 1}
{"code": "def make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.string_types):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner", "label": 1}
{"code": "private function emulatorGapicConfig($emulatorHost)\n    {\n        // Strip the URL scheme from the input, if it was provided.\n        if ($scheme = parse_url($emulatorHost, PHP_URL_SCHEME)) {\n            $search = $scheme . '://';\n            $emulatorHost = str_replace($search, '', $emulatorHost);\n        }\n\n        return [\n            'serviceAddress' => $emulatorHost,\n            'transportConfig' => [\n                'grpc' => [\n                    'stubOpts' => [\n                        'credentials' => \\Grpc\\ChannelCredentials::createInsecure()\n                    ]\n                ]\n            ]\n        ];\n    }", "label": 2}
{"code": "def is_gzipfile(filename):\n    \"\"\"\n    Attempt to ascertain the gzip status of a file based on the \"magic signatures\" of the file.\n\n    This was taken from the stack overflow post\n    http://stackoverflow.com/questions/13044562/python-mechanism-to-identify-compressed-file-type\\\n        -and-uncompress\n\n    :param str filename: A path to a file\n    :return: True if the file appears to be gzipped else false\n    :rtype: bool\n    \"\"\"\n    assert os.path.exists(filename), 'Input {} does not '.format(filename) + \\\n        'point to a file.'\n    with open(filename, 'rb') as in_f:\n        start_of_file = in_f.read(3)\n        if start_of_file == '\\x1f\\x8b\\x08':\n            return True\n        else:\n            return False", "label": 1}
{"code": "func MakeServers(clusterName string, servers []services.Server) []Server {\n\tuiServers := []Server{}\n\tfor _, server := range servers {\n\t\tuiLabels := []Label{}\n\t\tserverLabels := server.GetLabels()\n\t\tfor name, value := range serverLabels {\n\t\t\tuiLabels = append(uiLabels, Label{\n\t\t\t\tName:  name,\n\t\t\t\tValue: value,\n\t\t\t})\n\t\t}\n\n\t\tserverCmdLabels := server.GetCmdLabels()\n\t\tfor name, cmd := range serverCmdLabels {\n\t\t\tuiLabels = append(uiLabels, Label{\n\t\t\t\tName:  name,\n\t\t\t\tValue: cmd.GetResult(),\n\t\t\t})\n\t\t}\n\n\t\tsort.Sort(sortedLabels(uiLabels))\n\n\t\tuiServers = append(uiServers, Server{\n\t\t\tClusterName: clusterName,\n\t\t\tName:        server.GetName(),\n\t\t\tHostname:    server.GetHostname(),\n\t\t\tAddr:        server.GetAddr(),\n\t\t\tLabels:      uiLabels,\n\t\t})\n\t}\n\n\treturn uiServers\n}", "label": 5}
{"code": "def SAMflags(x):\n    \"\"\"\n    Explains a SAM flag.\n\n    :param x: flag\n\n    :returns: complete SAM flag explanaition\n    \"\"\"\n    flags=[]\n\n    if x & 1:\n        l=\"1: Read paired\"\n    else:\n        l=\"0: Read unpaired\"\n    flags.append(l)\n\n    if x & 2 :\n        l=\"1: Read mapped in proper pair\"\n    else:\n        l=\"0: Read not mapped in proper pair\"\n    flags.append(l)\n\n    if x & 4 :\n        l=\"1: Read unmapped\"\n    else:\n        l=\"0: Read mapped\"\n    flags.append(l)\n\n    if x & 8 :\n        l=\"1: Mate unmapped\"\n    else:\n        l=\"0: Mate mapped\"\n    flags.append(l)\n\n    if x & 16 :\n        l=\"1: Read reverse strand\"\n    else:\n        l=\"0: Read direct strand\"\n    flags.append(l)\n\n    if x & 32 :\n        l=\"1: Mate reverse strand\"\n    else:\n        l=\"0: Mate direct strand\"\n    flags.append(l)\n\n    if x & 64 :\n        l=\"1: First in pair\"\n    else:\n        l=\"0: Second in pair\"\n    flags.append(l)\n\n    if x & 128 :\n        l=\"1: Second in pair\"\n    else:\n        l=\"0: First in pair\"\n    flags.append(l)\n\n    if x & 256 :\n        l=\"1: Not primary alignment\"\n    else:\n        l=\"0: Primary alignment\"\n    flags.append(l)\n\n    if x & 512 :\n        l=\"1: Read fails platform/vendor quality checks\"\n    else:\n        l=\"0: Read passes platform/vendor quality checks\"\n    flags.append(l)\n\n    if x & 1024 :\n        l=\"1: Read is PCR or optical duplicate\"\n    else:\n        l=\"0: Read is not PCR or optical duplicate\"\n    flags.append(l)\n\n    if x & 2048 :\n        l=\"1: Supplementary alignment\"\n    else:\n        l=\"0: Not supplementary alignment\"\n    flags.append(l)\n\n    return flags", "label": 1}
{"code": "func unregisterPod(root string, uuid *types.UUID) error {\n\t_, err := os.Stat(filepath.Join(root, mdsRegisteredFile))\n\tswitch {\n\tcase err == nil:\n\t\tpth := path.Join(\"/pods\", uuid.String())\n\t\treturn httpRequest(\"DELETE\", pth, nil)\n\n\tcase os.IsNotExist(err):\n\t\treturn nil\n\n\tdefault:\n\t\treturn err\n\t}\n}", "label": 5}
{"code": "def split_phylogeny(p, level=\"s\"):\n    \"\"\"\n    Return either the full or truncated version of a QIIME-formatted taxonomy string.\n\n    :type p: str\n    :param p: A QIIME-formatted taxonomy string: k__Foo; p__Bar; ...\n\n    :type level: str\n    :param level: The different level of identification are kingdom (k), phylum (p),\n                  class (c),order (o), family (f), genus (g) and species (s). If level is\n                  not provided, the default level of identification is species.\n\n    :rtype: str\n    :return: A QIIME-formatted taxonomy string up to the classification given\n            by param level.\n    \"\"\"\n    level = level+\"__\"\n    result = p.split(level)\n    return result[0]+level+result[1].split(\";\")[0]", "label": 1}
{"code": "public function setMessageIds($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->message_ids = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function moveByOffset($x_offset, $y_offset)\n    {\n        $this->action->addAction(\n            new WebDriverMoveToOffsetAction($this->mouse, null, $x_offset, $y_offset)\n        );\n\n        return $this;\n    }", "label": 2}
{"code": "func DistFromImageString(is string) (dist.Distribution, error) {\n\tu, err := url.Parse(is)\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(fmt.Errorf(\"failed to parse image url %q\", is), err)\n\t}\n\n\t// Convert user friendly image string names to internal distribution URIs\n\t// file:///full/path/to/aci/file.aci -> archive:aci:file%3A%2F%2F%2Ffull%2Fpath%2Fto%2Faci%2Ffile.aci\n\tswitch u.Scheme {\n\tcase \"\":\n\t\t// no scheme given, hence it is an appc image name or path\n\t\tappImageType := guessAppcOrPath(is, []string{schema.ACIExtension})\n\n\t\tswitch appImageType {\n\t\tcase imageStringName:\n\t\t\tapp, err := discovery.NewAppFromString(is)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid appc image string %q: %v\", is, err)\n\t\t\t}\n\t\t\treturn dist.NewAppcFromApp(app), nil\n\t\tcase imageStringPath:\n\t\t\tabsPath, err := filepath.Abs(is)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errwrap.Wrap(fmt.Errorf(\"failed to get an absolute path for %q\", is), err)\n\t\t\t}\n\t\t\tis = \"file://\" + absPath\n\n\t\t\t// given a file:// image string, call this function again to return an ACI distribution\n\t\t\treturn DistFromImageString(is)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"invalid image string type %q\", appImageType)\n\t\t}\n\tcase \"file\", \"http\", \"https\":\n\t\t// An ACI archive with any transport type (file, http, s3 etc...) and final aci extension\n\t\tif filepath.Ext(u.Path) == schema.ACIExtension {\n\t\t\tdist, err := dist.NewACIArchiveFromTransportURL(u)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"archive distribution creation error: %v\", err)\n\t\t\t}\n\t\t\treturn dist, nil\n\t\t}\n\tcase \"docker\":\n\t\t// Accept both docker: and docker:// uri\n\t\tdockerStr := is\n\t\tif strings.HasPrefix(dockerStr, \"docker://\") {\n\t\t\tdockerStr = strings.TrimPrefix(dockerStr, \"docker://\")\n\t\t} else if strings.HasPrefix(dockerStr, \"docker:\") {\n\t\t\tdockerStr = strings.TrimPrefix(dockerStr, \"docker:\")\n\t\t}\n\n\t\tdist, err := dist.NewDockerFromString(dockerStr)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"docker distribution creation error: %v\", err)\n\t\t}\n\t\treturn dist, nil\n\tcase dist.Scheme: // cimd\n\t\treturn dist.Parse(is)\n\tdefault:\n\t\t// any other scheme is a an appc image name, i.e. \"my-app:v1.0\"\n\t\tapp, err := discovery.NewAppFromString(is)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid appc image string %q: %v\", is, err)\n\t\t}\n\n\t\treturn dist.NewAppcFromApp(app), nil\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid image string %q\", is)\n}", "label": 5}
{"code": "func OptionExposedPorts(exposedPorts []types.TransportPort) SandboxOption {\n\treturn func(sb *sandbox) {\n\t\tif sb.config.generic == nil {\n\t\t\tsb.config.generic = make(map[string]interface{})\n\t\t}\n\t\t// Defensive copy\n\t\teps := make([]types.TransportPort, len(exposedPorts))\n\t\tcopy(eps, exposedPorts)\n\t\t// Store endpoint label and in generic because driver needs it\n\t\tsb.config.exposedPorts = eps\n\t\tsb.config.generic[netlabel.ExposedPorts] = eps\n\t}\n}", "label": 5}
{"code": "public static cmppolicy_stats[] get(nitro_service service) throws Exception{\n\t\tcmppolicy_stats obj = new cmppolicy_stats();\n\t\tcmppolicy_stats[] response = (cmppolicy_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "protected function cleanParams(array $params)\n    {\n        $values = [];\n        foreach ($params as $name => $details) {\n            $this->cleanValueFrom($name, $details['value'], $values);\n        }\n\n        return $values;\n    }", "label": 2}
{"code": "@Api\n\tpublic static void configureNoCaching(HttpServletResponse response) {\n\t\t// HTTP 1.0 header:\n\t\tresponse.setHeader(HTTP_EXPIRES_HEADER, HTTP_EXPIRES_HEADER_NOCACHE_VALUE);\n\t\tresponse.setHeader(HTTP_CACHE_PRAGMA, HTTP_CACHE_PRAGMA_VALUE);\n\n\t\t// HTTP 1.1 header:\n\t\tresponse.setHeader(HTTP_CACHE_CONTROL_HEADER, HTTP_CACHE_CONTROL_HEADER_NOCACHE_VALUE);\n\t}", "label": 0}
{"code": "function isInList(value, listOfValues, msg) {\n    value = value.toLowerCase().trim();\n    if (listOfValues.indexOf(value) === -1) {\n        throw new Error(msg);\n    }\n}", "label": 3}
{"code": "func (d *driver) DeleteEndpoint(nid, eid string) error {\n\tdefer osl.InitOSContext()()\n\tif err := validateID(nid, eid); err != nil {\n\t\treturn err\n\t}\n\tn := d.network(nid)\n\tif n == nil {\n\t\treturn fmt.Errorf(\"network id %q not found\", nid)\n\t}\n\tep := n.endpoint(eid)\n\tif ep == nil {\n\t\treturn fmt.Errorf(\"endpoint id %q not found\", eid)\n\t}\n\tif link, err := ns.NlHandle().LinkByName(ep.srcName); err == nil {\n\t\tif err := ns.NlHandle().LinkDel(link); err != nil {\n\t\t\tlogrus.WithError(err).Warnf(\"Failed to delete interface (%s)'s link on endpoint (%s) delete\", ep.srcName, ep.id)\n\t\t}\n\t}\n\n\tif err := d.storeDelete(ep); err != nil {\n\t\tlogrus.Warnf(\"Failed to remove ipvlan endpoint %.7s from store: %v\", ep.id, err)\n\t}\n\tn.deleteEndpoint(ep.id)\n\treturn nil\n}", "label": 5}
{"code": "public static cachepolicylabel[] get(nitro_service service) throws Exception{\n\t\tcachepolicylabel obj = new cachepolicylabel();\n\t\tcachepolicylabel[] response = (cachepolicylabel[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function getStyle(element) {\n    const style = element.style;\n    const styles = {};\n    for (let i = 0; i < style.length; i++) {\n        const name = style.item(i);\n        const transformedName = transformName(name);\n        styles[transformedName] = style.getPropertyValue(name);\n    }\n    return styles;\n}", "label": 3}
{"code": "def find_nested_meta_first(d, prop_name, version):\n    \"\"\"Returns obj. for badgerfish and val for hbf. Appropriate for nested literals\"\"\"\n    if _is_badgerfish_version(version):\n        return find_nested_meta_first_bf(d, prop_name)\n    p = '^' + prop_name\n    return d.get(p)", "label": 1}
{"code": "public function subscriptions(array $options = [])\n    {\n        $resultLimit = $this->pluck('resultLimit', $options, false);\n\n        return new ItemIterator(\n            new PageIterator(\n                function ($subscription) {\n                    return $this->subscriptionFactory($subscription);\n                },\n                [$this->connection, 'listSubscriptionsByTopic'],\n                $options + ['topic' => $this->name],\n                [\n                    'itemsKey' => 'subscriptions',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "func (proxy *ProxyClient) currentCluster() (*services.Site, error) {\n\tsites, err := proxy.GetSites()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tif len(sites) == 0 {\n\t\treturn nil, trace.NotFound(\"no clusters registered\")\n\t}\n\tif proxy.siteName == \"\" {\n\t\treturn &sites[0], nil\n\t}\n\tfor _, site := range sites {\n\t\tif site.Name == proxy.siteName {\n\t\t\treturn &site, nil\n\t\t}\n\t}\n\treturn nil, trace.NotFound(\"cluster %v not found\", proxy.siteName)\n}", "label": 5}
{"code": "public static appflowcollector[] get(nitro_service service) throws Exception{\n\t\tappflowcollector obj = new appflowcollector();\n\t\tappflowcollector[] response = (appflowcollector[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def render_resource_last_editor(resource)\n      render partial: \"decidim/shared/version_author\",\n             locals: {\n               author: Decidim.traceability.last_editor(resource)\n             }\n    end", "label": 4}
{"code": "def extract_missing_special_type_names(schema, type_dict):\n        \"\"\"Extract the type names for fields with CardinalityField part.\n        Selects only the missing type names that are not in the type dictionary.\n\n        :param schema:     Parse schema to use (as string).\n        :param type_dict:  Type dictionary with type converters.\n        :return: Generator with missing type names (as string).\n        \"\"\"\n        for name in FieldParser.extract_types(schema):\n            if CardinalityField.matches_type(name) and (name not in type_dict):\n                    yield name", "label": 1}
{"code": "function(value, attr, maxLength, model) {\n        if (!_.isString(value) || value.length > maxLength) {\n          return this.format(getMessageKey(this.msgKey, defaultMessages.maxLength), this.formatLabel(attr, model), maxLength);\n        }\n      }", "label": 3}
{"code": "public function execute($callable = null)\n    {\n        if ($callable && !is_callable($callable)) {\n            throw new \\InvalidArgumentException('The argument must be a callable object.');\n        }\n\n        $exception = null;\n        $this->setRunning(true);\n\n        try {\n            if ($callable) {\n                call_user_func($callable, $this);\n            }\n\n            $this->flushPipeline();\n        } catch (\\Exception $exception) {\n            // NOOP\n        }\n\n        $this->setRunning(false);\n\n        if ($exception) {\n            throw $exception;\n        }\n\n        return $this->responses;\n    }", "label": 2}
{"code": "private function snapshotCursorValues(DocumentSnapshot $snapshot, array $orderBy)\n    {\n        $fieldValues = [];\n        foreach ($orderBy as $order) {\n            $path = $order['field']['fieldPath'];\n            if ($path === self::DOCUMENT_ID) {\n                continue;\n            }\n\n            $fieldValues[] = $snapshot->get($path);\n        }\n\n        $fieldValues[] = $snapshot->reference();\n        return $fieldValues;\n    }", "label": 2}
{"code": "def add_levels(elements, level=1)\n      elements.each do |e|\n        e.options[:element_level] = level\n        add_levels(e.children, level+1)\n      end\n    end", "label": 4}
{"code": "function popLoadingState(xhrEvent, stateName, modelOrCollection, context) {\n        var currentLoads = getState(stateName, context);\n        if (_.isArray(currentLoads)) {\n            var i = currentLoads.indexOf(xhrEvent);\n            while (i >= 0) {\n                currentLoads.splice(i, 1);\n                i = currentLoads.indexOf(xhrEvent);\n            }\n            if (!currentLoads.length) {\n                var toSet = {};\n                toSet[stateName] = undefined;\n                setState(toSet, context);\n            }\n        }\n    }", "label": 3}
{"code": "function mapSync(transformation) {\n    return through2.obj(function write(chunk, _, callback) {\n      let mappedData;\n      try {\n        mappedData = transformation(chunk);\n      } catch (error) {\n        callback(error);\n      }\n      if (mappedData !== undefined) {\n        this.push(mappedData);\n      }\n\n      callback();\n    });\n  }", "label": 3}
{"code": "func (p *defaultModules) TraitsFromLogins(logins []string, kubeGroups []string) map[string][]string {\n\treturn map[string][]string{\n\t\tteleport.TraitLogins:     logins,\n\t\tteleport.TraitKubeGroups: kubeGroups,\n\t}\n}", "label": 5}
{"code": "async def dump_variant(obj, elem, elem_type=None, params=None, field_archiver=None):\n    \"\"\"\n    Transform variant to the popo object representation.\n\n    :param obj:\n    :param elem:\n    :param elem_type:\n    :param params:\n    :param field_archiver:\n    :return:\n    \"\"\"\n    field_archiver = field_archiver if field_archiver else dump_field\n    if isinstance(elem, x.VariantType) or elem_type.WRAPS_VALUE:\n        return {\n            elem.variant_elem: await field_archiver(None, getattr(elem, elem.variant_elem), elem.variant_elem_type)\n        }\n\n    else:\n        fdef = elem_type.find_fdef(elem_type.f_specs(), elem)\n        return {\n            fdef[0]: await field_archiver(None, elem, fdef[1])\n        }", "label": 1}
{"code": "def all_stats(self):\n        \"\"\"Compute stats for all results.\n\n        :return: :class:`results.AllStats <results.AllStats>` object\n        :rtype: results.AllStats\n        \"\"\"\n        schema = AllStatsSchema()\n        resp = self.service.post(self.base, params={'stats': 'all'})\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "def tearpage(filename, bibtex=None, force=None):\n    \"\"\"\n    Tear some pages of the file if needed.\n\n    :params filename: Path to the file to handle.\n    :params bibtex: BibTeX dict associated to this file, as the one given by \\\n            ``bibtexparser``. (Mandatory if force is not specified)\n    :params force: If a list of integers, force the tearing of the \\\n            specified pages. (Optional)\n    :returns: A boolean indicating whether the file has been teared or not. \\\n            Side effect is tearing the necessary pages from the file.\n    \"\"\"\n    # Fetch pages to tear\n    pages_to_tear = []\n    if force is not None:\n        pages_to_tear = force\n    elif bibtex is not None:\n        pages_to_tear = tearpage_needed(bibtex)\n\n    if len(pages_to_tear) > 0:\n        # If tearing is needed, do it and return True\n        tearpage_backend(filename, teared_pages=pages_to_tear)\n        return True\n\n    # Else, simply return False\n    return False", "label": 1}
{"code": "public ConnectionRepository readConnectionRepository(String fileName)\r\n    {\r\n        try\r\n        {\r\n            RepositoryPersistor persistor = new RepositoryPersistor();\r\n            return persistor.readConnectionRepository(fileName);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new MetadataException(\"Can not read repository \" + fileName, e);\r\n        }\r\n    }", "label": 0}
{"code": "public function setResults($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\ProductSearchResults\\Result::class);\n        $this->results = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function unserialize($subscription): self\n    {\n        $data = json_decode($subscription, true);\n\n        $this->operationName = $data['operation_name'];\n        $this->channel = $data['channel'];\n        $this->args = $data['args'];\n        $this->context = $this->contextSerializer()->unserialize(\n            $data['context']\n        );\n        $this->query = AST::fromArray(\n            unserialize($data['query'])\n        );\n\n        return $this;\n    }", "label": 2}
{"code": "def from_entry_dict(cls, entry_dict):\n        \"\"\"\n        This is a \"constructor\" for the LogEntry class.\n\n        :param entry_dict: A dict we get from the REST API\n        :return: An instance of LogEntry.\n        \"\"\"\n        # Debug helper\n        # https://circleci.com/gh/andresriancho/w3af-api-docker/30\n        try:\n            _type = entry_dict['type']\n            _id = entry_dict['id']\n            _time = entry_dict['time']\n            message = entry_dict['message']\n            severity = entry_dict['severity']\n        except KeyError:\n            msg = ('Missing expected log entry attribute. Log entry'\n                   ' object is:\\n\\n%s')\n            raise APIException(msg % json.dumps(entry_dict, indent=4))\n\n        return cls(_type, message, _time, severity, _id)", "label": 1}
{"code": "function pruneDataSourceInfo(form) {\n        if (options.includeDataSources) {\n          return form;\n        }\n\n        delete form.dataSources;\n\n        form.pages = _.map(form.pages, function(page) {\n          page.fields = _.map(page.fields, function(field) {\n            delete field.dataSource;\n            delete field.dataSourceType;\n            return field;\n          });\n\n          return page;\n        });\n\n        return form;\n      }", "label": 3}
{"code": "def expand_paths(paths=None, predicate=None, filters=None, parent_uuid=None):\n    \"\"\"Return an unique list of resources or collections from a list of paths.\n    Supports fq_name and wilcards resolution.\n\n    >>> expand_paths(['virtual-network',\n                      'floating-ip/2a0a54b4-a420-485e-8372-42f70a627ec9'])\n    [Collection('virtual-network'),\n     Resource('floating-ip', uuid='2a0a54b4-a420-485e-8372-42f70a627ec9')]\n\n    :param paths: list of paths relative to the current path\n                  that may contain wildcards (*, ?) or fq_names\n    :type paths: [str]\n    :param predicate: function to filter found resources\n    :type predicate: f(resource) -> bool\n    :param filters: list of filters for Collections\n    :type filters: [(name, value), ...]\n    :rtype: [Resource or Collection]\n    :raises BadPath: path cannot be resolved\n    \"\"\"\n    if not paths:\n        paths = [Context().shell.current_path]\n    else:\n        paths = [Context().shell.current_path / res for res in paths]\n\n    # use a dict to have unique paths\n    # but keep them ordered\n    result = OrderedDict()\n    for res in parallel_map(_path_to_resources, paths,\n                            kwargs={'predicate': predicate,\n                                    'filters': filters,\n                                    'parent_uuid': parent_uuid},\n                            workers=50):\n        for r in res:\n            result[r.path] = r\n\n    resources = list(result.values())\n    if not resources:\n        raise NotFound()\n    return resources", "label": 1}
{"code": "private void checkProcedures(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r\n    {\r\n        if (CHECKLEVEL_NONE.equals(checkLevel))\r\n        {\r\n            return;\r\n        }\r\n\r\n        ProcedureDef procDef;\r\n        String       type;\r\n        String       name;\r\n        String       fieldName;\r\n        String       argName;\r\n        \r\n        for (Iterator it = classDef.getProcedures(); it.hasNext();)\r\n        {\r\n            procDef = (ProcedureDef)it.next();\r\n            type    = procDef.getName();\r\n            name    = procDef.getProperty(PropertyHelper.OJB_PROPERTY_NAME);\r\n            if ((name == null) || (name.length() == 0))\r\n            {\r\n                throw new ConstraintException(\"The \"+type+\"-procedure in class \"+classDef.getName()+\" doesn't have a name\");\r\n            }\r\n            fieldName = procDef.getProperty(PropertyHelper.OJB_PROPERTY_RETURN_FIELD_REF);\r\n            if ((fieldName != null) && (fieldName.length() > 0))\r\n            {\r\n                if (classDef.getField(fieldName) == null)\r\n                {\r\n                    throw new ConstraintException(\"The \"+type+\"-procedure \"+name+\" in class \"+classDef.getName()+\" references an unknown or non-persistent return field \"+fieldName);\r\n                }\r\n            }\r\n            for (CommaListIterator argIt = new CommaListIterator(procDef.getProperty(PropertyHelper.OJB_PROPERTY_ARGUMENTS)); argIt.hasNext();)\r\n            {\r\n                argName = argIt.getNext();\r\n                if (classDef.getProcedureArgument(argName) == null)\r\n                {\r\n                    throw new ConstraintException(\"The \"+type+\"-procedure \"+name+\" in class \"+classDef.getName()+\" references an unknown argument \"+argName);\r\n                }\r\n            }\r\n        }\r\n\r\n        ProcedureArgumentDef argDef;\r\n\r\n        for (Iterator it = classDef.getProcedureArguments(); it.hasNext();)\r\n        {\r\n            argDef = (ProcedureArgumentDef)it.next();\r\n            type   = argDef.getProperty(PropertyHelper.OJB_PROPERTY_TYPE);\r\n            if (\"runtime\".equals(type))\r\n            {\r\n                fieldName = argDef.getProperty(PropertyHelper.OJB_PROPERTY_FIELD_REF);\r\n                if ((fieldName != null) && (fieldName.length() > 0))\r\n                {\r\n                    if (classDef.getField(fieldName) == null)\r\n                    {\r\n                        throw new ConstraintException(\"The \"+type+\"-argument \"+argDef.getName()+\" in class \"+classDef.getName()+\" references an unknown or non-persistent return field \"+fieldName);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "private String[] getHeaders() {\n        final List<String> headers = new ArrayList<>();\n\n        if(decorator.getShowSources()){\n            headers.add(SOURCE_FIELD);\n        }\n\n        if(decorator.getShowSourcesVersion()){\n            headers.add(SOURCE_VERSION_FIELD);\n        }\n\n        if(decorator.getShowTargets()){\n            headers.add(TARGET_FIELD);\n        }\n\n        if(decorator.getShowTargetsDownloadUrl()){\n            headers.add(DOWNLOAD_URL_FIELD);\n        }\n\n        if(decorator.getShowTargetsSize()){\n            headers.add(SIZE_FIELD);\n        }\n\n        if(decorator.getShowScopes()){\n            headers.add(SCOPE_FIELD);\n        }\n\n        if(decorator.getShowLicenses()){\n            headers.add(LICENSE_FIELD);\n        }\n\n        if(decorator.getShowLicensesLongName()){\n            headers.add(LICENSE_LONG_NAME_FIELD);\n        }\n\n        if(decorator.getShowLicensesUrl()){\n            headers.add(LICENSE_URL_FIELD);\n        }\n\n        if(decorator.getShowLicensesComment()){\n            headers.add(LICENSE_COMMENT_FIELD);\n        }\n\n        return headers.toArray(new String[headers.size()]);\n    }", "label": 0}
{"code": "def fonts(limit_to_type0 = false)\n      fonts_array = []\n      pages.each do |pg|\n        if pg[:Resources][:Font]\n          pg[:Resources][:Font].values.each do |f|\n            f = f[:referenced_object] if f[:referenced_object]\n            if (limit_to_type0 || f[:Subtype] == :Type0) && f[:Type] == :Font && !fonts_array.include?(f)\n              fonts_array << f\n            end\n          end\n        end\n      end\n      fonts_array\n    end", "label": 4}
{"code": "public static void hideChannels(Object... channels){\r\n    // TODO this could share more code with the other show/hide(Only)Channels methods\r\n    for(LogRecordHandler handler : handlers){\r\n      if(handler instanceof VisibilityHandler){\r\n        VisibilityHandler visHandler = (VisibilityHandler) handler;\r\n        for (Object channel : channels) {\r\n          visHandler.alsoHide(channel);\r\n        }\r\n      }\r\n    }\r\n  }", "label": 0}
{"code": "public function setGatewayListOptions($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Iot\\V1\\GatewayListOptions::class);\n        $this->gateway_list_options = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static <E> List<Pair<E, Double>> toSortedListWithCounts(Counter<E> c) {\r\n    List<Pair<E, Double>> l = new ArrayList<Pair<E, Double>>(c.size());\r\n    for (E e : c.keySet()) {\r\n      l.add(new Pair<E, Double>(e, c.getCount(e)));\r\n    }\r\n    // descending order\r\n    Collections.sort(l, new Comparator<Pair<E, Double>>() {\r\n      public int compare(Pair<E, Double> a, Pair<E, Double> b) {\r\n        return Double.compare(b.second, a.second);\r\n      }\r\n    });\r\n    return l;\r\n  }", "label": 0}
{"code": "function (version) {\n    var splitDots = version.split(\".\");\n    var nbDots = splitDots.length - 1;\n    if (nbDots === 0) {\n        return version + \".0.0\";\n    } else if (nbDots === 1) {\n        return version + \".0\";\n    } else if (nbDots === 2) {\n        return version;\n    } else {\n        return splitDots.slice(0, 3).join(\".\") + \"-\" + splitDots.slice(3).join(\".\");\n    }\n}", "label": 3}
{"code": "def getlist(self, section, option, raw=False, vars=None, fallback=[], delimiters=','):\n        \"\"\"\n        A convenience method which coerces the option in the specified section to a list of strings.\n        \"\"\"\n        v = self.get(section, option, raw=raw, vars=vars, fallback=fallback)\n        return self._convert_to_list(v, delimiters=delimiters)", "label": 1}
{"code": "def devise_verification_code(mapping, controllers)\n      resource :paranoid_verification_code, only: [:show, :update], path: mapping.path_names[:verification_code], controller: controllers[:paranoid_verification_code]\n    end", "label": 4}
{"code": "public void add(int ds, Object value) throws SerializationException, InvalidDataSetException {\r\n\t\tif (value == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDataSetInfo dsi = dsiFactory.create(ds);\r\n\t\tbyte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\r\n\t\tDataSet dataSet = new DefaultDataSet(dsi, data);\r\n\t\tdataSets.add(dataSet);\r\n\t}", "label": 0}
{"code": "private CoreLabel makeCoreLabel(String line) {\r\n    CoreLabel wi = new CoreLabel();\r\n    // wi.line = line;\r\n    String[] bits = line.split(\"\\\\s+\");\r\n    switch (bits.length) {\r\n    case 0:\r\n    case 1:\r\n      wi.setWord(BOUNDARY);\r\n      wi.set(AnswerAnnotation.class, OTHER);\r\n      break;\r\n    case 2:\r\n      wi.setWord(bits[0]);\r\n      wi.set(AnswerAnnotation.class, bits[1]);\r\n      break;\r\n    case 3:\r\n      wi.setWord(bits[0]);\r\n      wi.setTag(bits[1]);\r\n      wi.set(AnswerAnnotation.class, bits[2]);\r\n      break;\r\n    case 4:\r\n      wi.setWord(bits[0]);\r\n      wi.setTag(bits[1]);\r\n      wi.set(ChunkAnnotation.class, bits[2]);\r\n      wi.set(AnswerAnnotation.class, bits[3]);\r\n      break;\r\n    case 5:\r\n      if (flags.useLemmaAsWord) {\r\n        wi.setWord(bits[1]);\r\n      } else {\r\n        wi.setWord(bits[0]);\r\n        }\r\n      wi.set(LemmaAnnotation.class, bits[1]);\r\n      wi.setTag(bits[2]);\r\n      wi.set(ChunkAnnotation.class, bits[3]);\r\n      wi.set(AnswerAnnotation.class, bits[4]);\r\n      break;\r\n    default:\r\n      throw new RuntimeIOException(\"Unexpected input (many fields): \" + line);\r\n    }\r\n    wi.set(OriginalAnswerAnnotation.class, wi.get(AnswerAnnotation.class));\r\n    return wi;\r\n  }", "label": 0}
{"code": "public void addGroupBy(String[] fieldNames)\r\n    {\r\n        for (int i = 0; i < fieldNames.length; i++)\r\n        {\r\n            addGroupBy(fieldNames[i]);\r\n        }\r\n    }", "label": 0}
{"code": "public static void endThreads(String check){\r\n    //(error check)\r\n    if(currentThread != -1L){\r\n      throw new IllegalStateException(\"endThreads() called, but thread \" + currentThread + \" has not finished (exception in thread?)\");\r\n    }\r\n    //(end threaded environment)\r\n    assert !control.isHeldByCurrentThread();\r\n    isThreaded = false;\r\n    //(write remaining threads)\r\n    boolean cleanPass = false;\r\n    while(!cleanPass){\r\n      cleanPass = true;\r\n      for(long thread : threadedLogQueue.keySet()){\r\n        assert currentThread < 0L;\r\n        if(threadedLogQueue.get(thread) != null && !threadedLogQueue.get(thread).isEmpty()){\r\n          //(mark queue as unclean)\r\n          cleanPass = false;\r\n          //(variables)\r\n          Queue<Runnable> backlog = threadedLogQueue.get(thread);\r\n          currentThread = thread;\r\n          //(clear buffer)\r\n          while(currentThread >= 0){\r\n            if(currentThread != thread){ throw new IllegalStateException(\"Redwood control shifted away from flushing thread\"); }\r\n            if(backlog.isEmpty()){ throw new IllegalStateException(\"Forgot to call finishThread() on thread \" + currentThread); }\r\n            assert !control.isHeldByCurrentThread();\r\n            backlog.poll().run();\r\n          }\r\n          //(unregister thread)\r\n          threadsWaiting.remove(thread);\r\n        }\r\n      }\r\n    }\r\n    while(threadsWaiting.size() > 0){\r\n      assert currentThread < 0L;\r\n      assert control.tryLock();\r\n      assert !threadsWaiting.isEmpty();\r\n      control.lock();\r\n      attemptThreadControlThreadsafe(-1);\r\n      control.unlock();\r\n    }\r\n    //(clean up)\r\n    for(long threadId : threadedLogQueue.keySet()){\r\n      assert threadedLogQueue.get(threadId).isEmpty();\r\n    }\r\n    assert threadsWaiting.isEmpty();\r\n    assert currentThread == -1L;\r\n    endTrack(\"Threads( \"+check+\" )\");\r\n  }", "label": 0}
{"code": "def fetch_or_cache_partial(cached_partials, template, order_by:)\n        order_by.each_with_object({}) do |cache_key, hash|\n            hash[cache_key] =\n              if content = cached_partials[cache_key]\n                build_rendered_template(content, template)\n              else\n                yield.tap do |rendered_partial|\n                  collection_cache.write(cache_key, rendered_partial.body)\n                end\n              end\n          end\n      end", "label": 4}
{"code": "public static void Shuffle(double[] array, long seed) {\n        Random random = new Random();\n        if (seed != 0) random.setSeed(seed);\n\n        for (int i = array.length - 1; i > 0; i--) {\n            int index = random.nextInt(i + 1);\n            double temp = array[index];\n            array[index] = array[i];\n            array[i] = temp;\n        }\n    }", "label": 0}
{"code": "def deliver_messages\n      # There's no need to do anything if the buffer is empty.\n      return if buffer_size == 0\n\n      @instrumenter.instrument(\"deliver_messages.producer\") do |notification|\n        message_count = buffer_size\n\n        notification[:message_count] = message_count\n        notification[:attempts] = 0\n\n        begin\n          deliver_messages_with_retries(notification)\n        ensure\n          notification[:delivered_message_count] = message_count - buffer_size\n        end\n      end\n    end", "label": 4}
{"code": "def P(Document, *fields, **kw):\n\t\"\"\"Generate a MongoDB projection dictionary using the Django ORM style.\"\"\"\n\t\n\t__always__ = kw.pop('__always__', set())\n\tprojected = set()\n\tomitted = set()\n\t\n\tfor field in fields:\n\t\tif field[0] in ('-', '!'):\n\t\t\tomitted.add(field[1:])\n\t\telif field[0] == '+':\n\t\t\tprojected.add(field[1:])\n\t\telse:\n\t\t\tprojected.add(field)\n\t\n\tif not projected:  # We only have exclusions from the default projection.\n\t\tnames = set(getattr(Document, '__projection__', Document.__fields__) or Document.__fields__)\n\t\tprojected = {name for name in (names - omitted)}\n\t\n\tprojected |= __always__\n\t\n\tif not projected:\n\t\tprojected = {'_id'}\n\t\n\treturn {unicode(traverse(Document, name, name)): True for name in projected}", "label": 1}
{"code": "public function createFromIlluminate(IlluminateRequest $old)\n    {\n        $new = new static(\n            $old->query->all(), $old->request->all(), $old->attributes->all(),\n            $old->cookies->all(), $old->files->all(), $old->server->all(), $old->content\n        );\n\n        if ($session = $old->getSession()) {\n            $new->setLaravelSession($old->getSession());\n        }\n\n        $new->setRouteResolver($old->getRouteResolver());\n        $new->setUserResolver($old->getUserResolver());\n\n        return $new;\n    }", "label": 2}
{"code": "protected static function processMastersOrSlaves(array $servers)\n    {\n        foreach ($servers as $idx => $node) {\n            $processed = array();\n            $count = count($node);\n\n            for ($i = 0; $i < $count; ++$i) {\n                $processed[$node[$i]] = $node[++$i];\n            }\n\n            $servers[$idx] = $processed;\n        }\n\n        return $servers;\n    }", "label": 2}
{"code": "public function setSpans($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Trace\\V2\\Span::class);\n        $this->spans = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function _gpfHttMockMatch (mockedRequests, request) {\n    var result;\n    mockedRequests.every(function (mockedRequest) {\n        result = _gpfHttMockMatchRequest(mockedRequest, request);\n        return result === undefined;\n    });\n    return result;\n}", "label": 3}
{"code": "private function formatPropertyMappings(iterable $propertyMappings)\n    {\n        $output = [];\n\n        foreach ($propertyMappings as $propertyName => $property) {\n            $output[] = $this->formatField(sprintf('  %s', $propertyName), '');\n\n            if ($property instanceof FieldMetadata) {\n                $output = array_merge($output, $this->formatColumn($property));\n            } elseif ($property instanceof AssociationMetadata) {\n                // @todo guilhermeblanco Fix me! We are trying to iterate through an AssociationMetadata instance\n                foreach ($property as $field => $value) {\n                    $output[] = $this->formatField(sprintf('    %s', $field), $this->formatValue($value));\n                }\n            }\n        }\n\n        return $output;\n    }", "label": 2}
{"code": "public static Map<String,String> unserializeBuildInfo(final String buildInfo) throws IOException {\n        final ObjectMapper mapper = new ObjectMapper();\n        mapper.disable(MapperFeature.USE_GETTERS_AS_SETTERS);\n        return mapper.readValue(buildInfo,   new TypeReference<Map<String, Object>>(){});\n    }", "label": 0}
{"code": "def update!(new_answers = {})\n      unless new_answers.is_a?(Hash)\n        raise PDK::CLI::FatalError, _('Answer file can be updated only with a Hash')\n      end\n\n      answers.merge!(new_answers)\n\n      save_to_disk\n    end", "label": 4}
{"code": "function(serverName, config, options) {\n    this.methods[serverName] = {};\n    this.config.servers[serverName] = config;\n    var self = this;\n    ['valid_grant', 'treat_access_token', 'transform_token_response'].forEach(function(fctName) {\n      self.methods[serverName][fctName] = options[fctName] || self[fctName].bind(self);\n    });\n  }", "label": 3}
{"code": "def _normalize_render(*args, &block) # :nodoc:\n      options = _normalize_args(*args, &block)\n      _process_variant(options)\n      _normalize_options(options)\n      options\n    end", "label": 4}
{"code": "def show\n      # collect metadata\n      groups = Guard.state.session.groups.all\n\n      objects = []\n\n      empty_plugin = OpenStruct.new\n      empty_plugin.options = [[\"\", nil]]\n\n      groups.each do |group|\n        plugins = Array(Guard.state.session.plugins.all(group: group.name))\n        plugins = [empty_plugin] if plugins.empty?\n        plugins.each do |plugin|\n          options = plugin.options\n          options = [[\"\", nil]] if options.empty?\n          options.each do |option, raw_value|\n            value = raw_value.nil? ? \"\" : raw_value.inspect\n            objects << [group.title, plugin.title, option.to_s, value]\n          end\n        end\n      end\n\n      # presentation\n      rows = []\n      prev_group = prev_plugin = prev_option = prev_value = nil\n      objects.each do |group, plugin, option, value|\n        group_changed = prev_group != group\n        plugin_changed = (prev_plugin != plugin || group_changed)\n\n        rows << :split if group_changed || plugin_changed\n\n        rows << {\n          Group: group_changed ? group : \"\",\n          Plugin: plugin_changed ? plugin : \"\",\n          Option: option,\n          Value: value\n        }\n\n        prev_group = group\n        prev_plugin = plugin\n        prev_option = option\n        prev_value = value\n      end\n\n      # render\n      Formatador.display_compact_table(\n        rows.drop(1),\n        [:Group, :Plugin, :Option, :Value]\n      )\n    end", "label": 4}
{"code": "function getServerAliases(flapjack, options) {\n    options = options || {};\n    var aliases = getAliases('server', flapjack);\n    var serverAliases = options && options.serverAliases;\n    return _.extend({}, aliases, serverAliases);\n}", "label": 3}
{"code": "public List<String> getCorporateGroupIds(final String organizationId) {\n        final DbOrganization dbOrganization = getOrganization(organizationId);\n        return dbOrganization.getCorporateGroupIdPrefixes();\n    }", "label": 0}
{"code": "func ConvertS3Error(err error, args ...interface{}) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif aerr, ok := err.(awserr.Error); ok {\n\t\tswitch aerr.Code() {\n\t\tcase s3.ErrCodeNoSuchKey, s3.ErrCodeNoSuchBucket, s3.ErrCodeNoSuchUpload, \"NotFound\":\n\t\t\treturn trace.NotFound(aerr.Error(), args...)\n\t\tcase s3.ErrCodeBucketAlreadyExists, s3.ErrCodeBucketAlreadyOwnedByYou:\n\t\t\treturn trace.AlreadyExists(aerr.Error(), args...)\n\t\tdefault:\n\t\t\treturn trace.BadParameter(aerr.Error(), args...)\n\t\t}\n\t}\n\treturn err\n}", "label": 5}
{"code": "function _loadEntity() {\n    if (_Entity && _Entity !== models.Entity) {\n      if (_nameValidation) {\n        _Entity.adapter.loadEntity(_Entity);\n\n        for (var attribute in _attributes) {\n          _loadEntityAttribute(_attributes[attribute]);\n        }\n      }\n\n      for (var method in _methods) {\n        _loadEntityMethod(_methods[method], method);\n      }\n    }\n  }", "label": 3}
{"code": "def fetch_image(client, name):\n    \"\"\"\n    Fetch an image if it isn't already present.\n\n    This works like ``docker pull`` and will pull the tag ``latest`` if no tag\n    is specified in the image name.\n    \"\"\"\n    try:\n        image = client.images.get(name)\n    except docker.errors.ImageNotFound:\n        name, tag = _parse_image_tag(name)\n        tag = 'latest' if tag is None else tag\n\n        log.info(\"Pulling tag '{}' for image '{}'...\".format(tag, name))\n        image = client.images.pull(name, tag=tag)\n\n    log.debug(\"Found image '{}' for tag '{}'\".format(image.id, name))\n    return image", "label": 1}
{"code": "function isStore(object) {\n    if (!object || typeof object !== 'object') {\n        return false;\n    }\n    else if ('isStore' in object) {\n        diag.debug.assert(function () { return object.isStore === Store.prototype.isPrototypeOf(object); });\n        return object.isStore;\n    }\n    else {\n        return Store.prototype.isPrototypeOf(object);\n    }\n}", "label": 3}
{"code": "def stream(key)\n        file = file_for(key, skip_lookup: false)\n\n        chunk_size = 5.megabytes\n        offset = 0\n\n        raise ActiveStorage::FileNotFoundError unless file.present?\n\n        while offset < file.size\n          yield file.download(range: offset..(offset + chunk_size - 1)).string\n          offset += chunk_size\n        end\n      end", "label": 4}
{"code": "public OJBLock atomicGetOrCreateLock(Object resourceId, Object isolationId)\r\n    {\r\n        synchronized(globalLocks)\r\n        {\r\n            MultiLevelLock lock = getLock(resourceId);\r\n            if(lock == null)\r\n            {\r\n                lock = createLock(resourceId, isolationId);\r\n            }\r\n            return (OJBLock) lock;\r\n        }\r\n    }", "label": 0}
{"code": "def parse_config_file(job, config_file, max_cores=None):\n    \"\"\"\n    Parse the config file and spawn a ProTECT job for every input sample.\n\n    :param str config_file: Path to the input config file\n    :param int max_cores: The maximum cores to use for any single high-compute job.\n    \"\"\"\n    sample_set, univ_options, processed_tool_inputs = _parse_config_file(job, config_file,\n                                                                         max_cores)\n    # Start a job for each sample in the sample set\n    for patient_id in sample_set.keys():\n        job.addFollowOnJobFn(launch_protect, sample_set[patient_id], univ_options,\n                             processed_tool_inputs)\n    return None", "label": 1}
{"code": "public static Object instantiate(Constructor constructor) throws InstantiationException\r\n    {\r\n        if(constructor == null)\r\n        {\r\n            throw new ClassNotPersistenceCapableException(\r\n                    \"A zero argument constructor was not provided!\");\r\n        }\r\n\r\n        Object result = null;\r\n        try\r\n        {\r\n            result = constructor.newInstance(NO_ARGS);\r\n        }\r\n        catch(InstantiationException e)\r\n        {\r\n            throw e;\r\n        }\r\n        catch(Exception e)\r\n        {\r\n            throw new ClassNotPersistenceCapableException(\"Can't instantiate class '\"\r\n                    + (constructor != null ? constructor.getDeclaringClass().getName() : \"null\")\r\n                    + \"' with given constructor: \" + e.getMessage(), e);\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "private boolean absoluteAdvanced(int row)\r\n    {\r\n        boolean retval = false;\r\n        \r\n        try\r\n        {\r\n            if (getRsAndStmt().m_rs != null)\r\n            {\r\n                if (row == 0)\r\n                {\r\n                    getRsAndStmt().m_rs.beforeFirst();\r\n                }\r\n                else\r\n                {\r\n                    retval = getRsAndStmt().m_rs.absolute(row);                        \r\n                }\r\n                m_current_row = row;\r\n                setHasCalledCheck(false);\r\n            }\r\n        }\r\n        catch (SQLException e)\r\n        {\r\n            advancedJDBCSupport = false;\r\n        }\r\n        return retval;\r\n    }", "label": 0}
{"code": "function (req, res, next) {\n        var hostId = req.miajs.route.hostId;\n        var url = req.miajs.route.url;\n        var prefix = req.miajs.route.prefix;\n        var method = req.miajs.route.method;\n        var group = req.miajs.route.group;\n        var version = req.miajs.route.version;\n        var registeredServices = Shared.registeredServices();\n        var errors = [];\n        var routeFound = false;\n        req.miajs = req.miajs || {};\n\n        //console.log('checkPreconditions: url: ' + url + ', method: ' + method + ', body: ' + JSON.stringify(req.body));\n\n        for (var index in registeredServices) {\n\n            if (registeredServices[index].group == group\n                && registeredServices[index].hostId == hostId\n                && registeredServices[index].version == version\n                && registeredServices[index].prefix == prefix\n                && registeredServices[index].method == method\n                && registeredServices[index].url == url\n            ) {\n                routeFound = true;\n                if (registeredServices[index].preconditions) {\n                    var service = registeredServices[index];\n                    var preconditionsList = service.preconditions;\n                    var qfunctions = [];\n\n                    for (var cIndex in preconditionsList) {\n                        qfunctions.push(_checkControllerConditions(req, preconditionsList[cIndex]));\n                    }\n\n                    Q.all(qfunctions).then(function (results) {\n\n                        req.miajs.commonValidatedParameters = [];\n\n                        results.forEach(function (result) {\n                            if (result) {\n                                if (result.validatedData) {\n                                    req.miajs.commonValidatedParameters.push(result.validatedData);\n                                }\n\n                                var controllerErrors = result.errors;\n                                controllerErrors.forEach(function (error) {\n\n                                    var inList = false;\n                                    // Check for error duplicates\n                                    for (var eIndex in errors) {\n                                        if (errors[eIndex].code == error.code && errors[eIndex].id == error.id && errors[eIndex].in == error.in) {\n                                            inList = true;\n                                        }\n                                    }\n\n                                    if (inList == false) {\n                                        errors.push(error);\n                                    }\n                                });\n                            }\n                        });\n\n                    }).then(function () {\n                        if (!_.isEmpty(errors)) {\n                            next({'status': 400, err: errors})\n                            return;\n                        }\n                        else {\n                            next();\n                            return;\n                        }\n                    }).catch(function (err) {\n                        next({'status': 400, err: err});\n                        return;\n                    });\n                }\n                else {\n                    next();\n                    return;\n                }\n            }\n        }\n\n        if (routeFound == false) {\n            Logger.error('Can not find controller file in preconditionsCheck to perform parameter validation. Request canceled due to security reasons');\n            next({status: 500});\n            return;\n        }\n    }", "label": 3}
{"code": "function log() {\n    var _console;\n\n    if (LatticeLogs.failFast(LatticeLogs.LOG)) return;\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    (_console = console).log.apply(_console, (0, _toConsumableArray2.default)(args.map(LatticeLogs.argMapper)));\n  }", "label": 3}
{"code": "function processCompressedData (o) {\n  // Save the packet counter\n  o.lastSampleNumber = parseInt(o.rawDataPacket[0]);\n\n  const samples = [];\n  // Decompress the buffer into array\n  if (o.lastSampleNumber <= k.OBCIGanglionByteId18Bit.max) {\n    decompressSamples(o, decompressDeltas18Bit(o.rawDataPacket.slice(k.OBCIGanglionPacket18Bit.dataStart, k.OBCIGanglionPacket18Bit.dataStop)));\n    samples.push(buildSample(o.lastSampleNumber * 2 - 1, o.decompressedSamples[1], o.sendCounts));\n    samples.push(buildSample(o.lastSampleNumber * 2, o.decompressedSamples[2], o.sendCounts));\n\n    switch (o.lastSampleNumber % 10) {\n      case k.OBCIGanglionAccelAxisX:\n        o.accelArray[0] = o.sendCounts ? o.rawDataPacket.readInt8(k.OBCIGanglionPacket18Bit.auxByte - 1) : o.rawDataPacket.readInt8(k.OBCIGanglionPacket18Bit.auxByte - 1) * k.OBCIGanglionAccelScaleFactor;\n        break;\n      case k.OBCIGanglionAccelAxisY:\n        o.accelArray[1] = o.sendCounts ? o.rawDataPacket.readInt8(k.OBCIGanglionPacket18Bit.auxByte - 1) : o.rawDataPacket.readInt8(k.OBCIGanglionPacket18Bit.auxByte - 1) * k.OBCIGanglionAccelScaleFactor;\n        break;\n      case k.OBCIGanglionAccelAxisZ:\n        o.accelArray[2] = o.sendCounts ? o.rawDataPacket.readInt8(k.OBCIGanglionPacket18Bit.auxByte - 1) : o.rawDataPacket.readInt8(k.OBCIGanglionPacket18Bit.auxByte - 1) * k.OBCIGanglionAccelScaleFactor;\n        if (o.sendCounts) {\n          samples[0].accelData = o.accelArray;\n        } else {\n          samples[0].accelDataCounts = o.accelArray;\n        }\n        break;\n      default:\n        break;\n    }\n  } else {\n    decompressSamples(o, decompressDeltas19Bit(o.rawDataPacket.slice(k.OBCIGanglionPacket19Bit.dataStart, k.OBCIGanglionPacket19Bit.dataStop)));\n\n    samples.push(buildSample((o.lastSampleNumber - 100) * 2 - 1, o.decompressedSamples[1], o.sendCounts));\n    samples.push(buildSample((o.lastSampleNumber - 100) * 2, o.decompressedSamples[2], o.sendCounts));\n  }\n\n  // Rotate the 0 position for next time\n  for (let i = 0; i < k.OBCINumberOfChannelsGanglion; i++) {\n    o.decompressedSamples[0][i] = o.decompressedSamples[2][i];\n  }\n\n  return samples;\n}", "label": 3}
{"code": "def pivot(self):\n        \"\"\"\n        transposes rows and columns\n        \"\"\"\n        self.op_data = [list(i) for i in zip(*self.ip_data)]", "label": 1}
{"code": "public static java.util.Date rollDateTime(java.util.Date startDate, int period, int amount) {\n        GregorianCalendar gc = new GregorianCalendar();\n        gc.setTime(startDate);\n        gc.add(period, amount);\n        return new java.util.Date(gc.getTime().getTime());\n    }", "label": 0}
{"code": "def remove(page_index)\n      catalog = rebuild_catalog\n      pages_array = catalog[:Pages][:referenced_object][:Kids]\n      removed_page = pages_array.delete_at page_index\n      catalog[:Pages][:referenced_object][:Count] = pages_array.length\n      removed_page\n    end", "label": 4}
{"code": "func ForNode(cfg Config) Config {\n\tcfg.Watches = []services.WatchKind{\n\t\t{Kind: services.KindCertAuthority, LoadSecrets: false},\n\t\t{Kind: services.KindClusterName},\n\t\t{Kind: services.KindClusterConfig},\n\t\t{Kind: services.KindUser},\n\t\t{Kind: services.KindRole},\n\t\t// Node only needs to \"know\" about default\n\t\t// namespace events to avoid matching too much\n\t\t// data about other namespaces or node events\n\t\t{Kind: services.KindNamespace, Name: defaults.Namespace},\n\t}\n\tcfg.QueueSize = defaults.NodeQueueSize\n\treturn cfg\n}", "label": 5}
{"code": "def gen_otu_dict(nex_obj, nexson_version=None):\n    \"\"\"Takes a NexSON object and returns a dict of\n    otu_id -> otu_obj\n    \"\"\"\n    if nexson_version is None:\n        nexson_version = detect_nexson_version(nex_obj)\n    if _is_by_id_hbf(nexson_version):\n        otus = nex_obj['nexml']['otusById']\n        if len(otus) > 1:\n            d = {}\n            for v in otus.values():\n                d.update(v['otuById'])\n            return d\n        else:\n            return otus.values()[0]['otuById']\n    o_dict = {}\n    for ob in nex_obj.get('otus', []):\n        for o in ob.get('otu', []):\n            oid = o['@id']\n            o_dict[oid] = o\n    return o_dict", "label": 1}
{"code": "func createAgent(me *user.User, privateKeyByte []byte, certificateBytes []byte) (*teleagent.AgentServer, string, string, error) {\n\t// create a path to the unix socket\n\tsockDir, err := ioutil.TempDir(\"\", \"int-test\")\n\tif err != nil {\n\t\treturn nil, \"\", \"\", trace.Wrap(err)\n\t}\n\tsockPath := filepath.Join(sockDir, \"agent.sock\")\n\n\tuid, err := strconv.Atoi(me.Uid)\n\tif err != nil {\n\t\treturn nil, \"\", \"\", trace.Wrap(err)\n\t}\n\tgid, err := strconv.Atoi(me.Gid)\n\tif err != nil {\n\t\treturn nil, \"\", \"\", trace.Wrap(err)\n\t}\n\n\t// transform the key and certificate bytes into something the agent can understand\n\tpublicKey, _, _, _, err := ssh.ParseAuthorizedKey(certificateBytes)\n\tif err != nil {\n\t\treturn nil, \"\", \"\", trace.Wrap(err)\n\t}\n\tprivateKey, err := ssh.ParseRawPrivateKey(privateKeyByte)\n\tif err != nil {\n\t\treturn nil, \"\", \"\", trace.Wrap(err)\n\t}\n\tagentKey := agent.AddedKey{\n\t\tPrivateKey:       privateKey,\n\t\tCertificate:      publicKey.(*ssh.Certificate),\n\t\tComment:          \"\",\n\t\tLifetimeSecs:     0,\n\t\tConfirmBeforeUse: false,\n\t}\n\n\t// create a (unstarted) agent and add the key to it\n\tteleAgent := teleagent.NewServer()\n\tteleAgent.Add(agentKey)\n\n\t// start the SSH agent\n\terr = teleAgent.ListenUnixSocket(sockPath, uid, gid, 0600)\n\tif err != nil {\n\t\treturn nil, \"\", \"\", trace.Wrap(err)\n\t}\n\tgo teleAgent.Serve()\n\n\treturn teleAgent, sockDir, sockPath, nil\n}", "label": 5}
{"code": "public function setTranslationModelMetadata($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\AutoMl\\V1beta1\\TranslationModelMetadata::class);\n        $this->writeOneof(15, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "func PgAmByAmname(db XODB, amname pgtypes.Name) (*PgAm, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, amname, amstrategies, amsupport, amcanorder, amcanorderbyop, amcanbackward, amcanunique, amcanmulticol, amoptionalkey, amsearcharray, amsearchnulls, amstorage, amclusterable, ampredlocks, amkeytype, aminsert, ambeginscan, amgettuple, amgetbitmap, amrescan, amendscan, ammarkpos, amrestrpos, ambuild, ambuildempty, ambulkdelete, amvacuumcleanup, amcanreturn, amcostestimate, amoptions ` +\n\t\t`FROM pg_catalog.pg_am ` +\n\t\t`WHERE amname = $1`\n\n\t// run query\n\tXOLog(sqlstr, amname)\n\tpa := PgAm{}\n\n\terr = db.QueryRow(sqlstr, amname).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Oid, &pa.Ctid, &pa.Amname, &pa.Amstrategies, &pa.Amsupport, &pa.Amcanorder, &pa.Amcanorderbyop, &pa.Amcanbackward, &pa.Amcanunique, &pa.Amcanmulticol, &pa.Amoptionalkey, &pa.Amsearcharray, &pa.Amsearchnulls, &pa.Amstorage, &pa.Amclusterable, &pa.Ampredlocks, &pa.Amkeytype, &pa.Aminsert, &pa.Ambeginscan, &pa.Amgettuple, &pa.Amgetbitmap, &pa.Amrescan, &pa.Amendscan, &pa.Ammarkpos, &pa.Amrestrpos, &pa.Ambuild, &pa.Ambuildempty, &pa.Ambulkdelete, &pa.Amvacuumcleanup, &pa.Amcanreturn, &pa.Amcostestimate, &pa.Amoptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pa, nil\n}", "label": 5}
{"code": "func lastToken(data []byte) int {\n\tfor i := len(data) - 1; i >= 0; i-- {\n\t\tswitch data[i] {\n\t\tcase ' ', '\\n', '\\r', '\\t':\n\t\t\tcontinue\n\t\tdefault:\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}", "label": 5}
{"code": "func Log(bee string, message string, messageType uint) {\n\tlogMutex.Lock()\n\tdefer logMutex.Unlock()\n\n\tlogs[bee] = append(logs[bee], NewLogMessage(bee, message, messageType))\n}", "label": 5}
{"code": "func (i *TeleInstance) Reset() (err error) {\n\ti.Process, err = service.NewTeleport(i.Config)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function validateCards(cards) {\n  if (!Array.isArray(cards)) {\n    throw new Error('`cards` must be passed as an array');\n  }\n  for (let i=0; i < cards.length; i++) {\n    let card = cards[i];\n    if (card.type !== RENDER_TYPE) {\n      throw new Error(`Card \"${card.name}\" must be type \"${RENDER_TYPE}\", was \"${card.type}\"`);\n    }\n    if (!card.render) {\n      throw new Error(`Card \"${card.name}\" must define \\`render\\``);\n    }\n  }\n}", "label": 3}
{"code": "public function addBuilderDirective(string $argumentName, ArgBuilderDirective $argBuilderDirective): self\n    {\n        $this->builderDirectives[$argumentName] = $argBuilderDirective;\n\n        return $this;\n    }", "label": 2}
{"code": "def extract_annotations_from(file, pattern)\n      lineno = 0\n      result = File.readlines(file, encoding: Encoding::BINARY).inject([]) do |list, line|\n        lineno += 1\n        next list unless line =~ pattern\n        list << Annotation.new(lineno, $1, $2)\n      end\n      result.empty? ? {} : { file => result }\n    end", "label": 4}
{"code": "def create_status(*args)\n      arguments(args, required: [:user, :repo, :id]) do\n        assert_required %w[ state ]\n        permit VALID_STATUS_OPTIONS\n      end\n      params = arguments.params\n      params['accept'] ||= PREVIEW_MEDIA\n\n      post_request(\"repos/#{arguments.user}/#{arguments.repo}/deployments/#{arguments.id}/statuses\", params)\n    end", "label": 4}
{"code": "func (h *hawkularSink) checkCache(key string, hash uint64) bool {\n\th.regLock.Lock()\n\tdefer h.regLock.Unlock()\n\t_, found := h.expReg[key]\n\tif !found || h.expReg[key].hash != hash {\n\t\treturn false\n\t}\n\t// Update the TTL\n\th.expReg[key].ttl = h.runId\n\treturn true\n}", "label": 5}
{"code": "public function recordLog(MessageLogged $event)\n    {\n        if (! Telescope::isRecording() || $this->shouldIgnore($event)) {\n            return;\n        }\n\n        Telescope::recordLog(\n            IncomingEntry::make([\n                'level' => $event->level,\n                'message' => $event->message,\n                'context' => Arr::except($event->context, ['telescope']),\n            ])->tags($this->tags($event))\n        );\n    }", "label": 2}
{"code": "public function listUptimeCheckIps(array $optionalArgs = [])\n    {\n        $request = new ListUptimeCheckIpsRequest();\n        if (isset($optionalArgs['pageSize'])) {\n            $request->setPageSize($optionalArgs['pageSize']);\n        }\n        if (isset($optionalArgs['pageToken'])) {\n            $request->setPageToken($optionalArgs['pageToken']);\n        }\n\n        return $this->getPagedListResponse(\n            'ListUptimeCheckIps',\n            $optionalArgs,\n            ListUptimeCheckIpsResponse::class,\n            $request\n        );\n    }", "label": 2}
{"code": "private TableAlias getTableAliasForPath(String aPath, List hintClasses)\r\n    {\r\n        return (TableAlias) m_pathToAlias.get(buildAliasKey(aPath, hintClasses));\r\n    }", "label": 0}
{"code": "def _gh(self, x):\n        \"\"\" Evaluates the constraint function values.\n        \"\"\"\n        Pgen = x[self._Pg.i1:self._Pg.iN + 1] # Active generation in p.u.\n        Qgen = x[self._Qg.i1:self._Qg.iN + 1] # Reactive generation in p.u.\n\n        for i, gen in enumerate(self._gn):\n            gen.p = Pgen[i] * self._base_mva # active generation in MW\n            gen.q = Qgen[i] * self._base_mva # reactive generation in MVAr\n\n        # Rebuild the net complex bus power injection vector in p.u.\n        Sbus = self.om.case.getSbus(self._bs)\n\n        Vang = x[self._Va.i1:self._Va.iN + 1]\n        Vmag = x[self._Vm.i1:self._Vm.iN + 1]\n        V = Vmag * exp(1j * Vang)\n\n        # Evaluate the power flow equations.\n        mis = V * conj(self._Ybus * V) - Sbus\n\n        # Equality constraints (power flow).\n        g = r_[mis.real,  # active power mismatch for all buses\n               mis.imag]  # reactive power mismatch for all buses\n\n        # Inequality constraints (branch flow limits).\n        # (line constraint is actually on square of limit)\n        flow_max = array([(l.rate_a / self._base_mva)**2 for l in self._ln])\n        # FIXME: There must be a more elegant method for this.\n        for i, v in enumerate(flow_max):\n            if v == 0.0:\n                flow_max[i] = Inf\n\n        if self.flow_lim == IFLOW:\n            If = self._Yf * V\n            It = self._Yt * V\n            # Branch current limits.\n            h = r_[(If * conj(If)) - flow_max,\n                   (It * conj(It)) - flow_max]\n        else:\n            i_fbus = [e.from_bus._i for e in self._ln]\n            i_tbus = [e.to_bus._i for e in self._ln]\n            # Complex power injected at \"from\" bus (p.u.).\n            Sf = V[i_fbus] * conj(self._Yf * V)\n            # Complex power injected at \"to\" bus (p.u.).\n            St = V[i_tbus] * conj(self._Yt * V)\n            if self.flow_lim == PFLOW: # active power limit, P (Pan Wei)\n                # Branch real power limits.\n                h = r_[Sf.real()**2 - flow_max,\n                       St.real()**2 - flow_max]\n            elif self.flow_lim == SFLOW: # apparent power limit, |S|\n                # Branch apparent power limits.\n                h = r_[(Sf * conj(Sf)) - flow_max,\n                       (St * conj(St)) - flow_max].real\n            else:\n                raise ValueError\n\n        return h, g", "label": 1}
{"code": "def iot_event(props={})\n      if props.is_a?(String) # SQL Statement\n        props = {sql: props}\n        topic_props = {topic_rule_payload: props}\n      elsif props.key?(:topic_rule_payload) # full properties structure\n        topic_props = props\n      else # just the topic_rule_payload\n        topic_props = {topic_rule_payload: props}\n      end\n\n      declare_iot_topic(topic_props)\n    end", "label": 4}
{"code": "def _udp_transact(self, payload, handler, *args,\n                      broadcast=False, timeout=TIMEOUT):\n        \"\"\" Complete a UDP transaction.\n\n        UDP is stateless and not guaranteed, so we have to\n        take some mitigation steps:\n        - Send payload multiple times.\n        - Wait for awhile to receive response.\n\n        :param payload: Payload to send.\n        :param handler: Response handler.\n        :param args: Arguments to pass to response handler.\n        :param broadcast: Send a broadcast instead.\n        :param timeout: Timeout in seconds.\n        \"\"\"\n        if self.host in _BUFFER:\n            del _BUFFER[self.host]\n        host = self.host\n        if broadcast:\n            host = '255.255.255.255'\n        retval = None\n        for _ in range(RETRIES):\n            _SOCKET.sendto(bytearray(payload), (host, PORT))\n            start = time.time()\n            while time.time() < start + timeout:\n                data = _BUFFER.get(self.host, None)\n                if data:\n                    retval = handler(data, *args)\n                # Return as soon as a response is received\n                if retval:\n                    return retval", "label": 1}
{"code": "public static int cudnnPoolingBackward(\n        cudnnHandle handle, \n        cudnnPoolingDescriptor poolingDesc, \n        Pointer alpha, \n        cudnnTensorDescriptor yDesc, \n        Pointer y, \n        cudnnTensorDescriptor dyDesc, \n        Pointer dy, \n        cudnnTensorDescriptor xDesc, \n        Pointer x, \n        Pointer beta, \n        cudnnTensorDescriptor dxDesc, \n        Pointer dx)\n    {\n        return checkResult(cudnnPoolingBackwardNative(handle, poolingDesc, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx));\n    }", "label": 0}
{"code": "func NewFromReader(f io.Reader) (ret *IPList, err error) {\n\tvar ranges []Range\n\t// There's a lot of similar descriptions, so we maintain a pool and reuse\n\t// them to reduce memory overhead.\n\tuniqStrs := make(map[string]string)\n\tscanner := bufio.NewScanner(f)\n\tlineNum := 1\n\tfor scanner.Scan() {\n\t\tr, ok, lineErr := ParseBlocklistP2PLine(scanner.Bytes())\n\t\tif lineErr != nil {\n\t\t\terr = fmt.Errorf(\"error parsing line %d: %s\", lineNum, lineErr)\n\t\t\treturn\n\t\t}\n\t\tlineNum++\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif s, ok := uniqStrs[r.Description]; ok {\n\t\t\tr.Description = s\n\t\t} else {\n\t\t\tuniqStrs[r.Description] = r.Description\n\t\t}\n\t\tranges = append(ranges, r)\n\t}\n\terr = scanner.Err()\n\tif err != nil {\n\t\treturn\n\t}\n\tret = New(ranges)\n\treturn\n}", "label": 5}
{"code": "func (c *AuthPreferenceV2) CheckAndSetDefaults() error {\n\t// if nothing is passed in, set defaults\n\tif c.Spec.Type == \"\" {\n\t\tc.Spec.Type = teleport.Local\n\t}\n\tif c.Spec.SecondFactor == \"\" {\n\t\tc.Spec.SecondFactor = teleport.OTP\n\t}\n\n\t// make sure type makes sense\n\tswitch c.Spec.Type {\n\tcase teleport.Local, teleport.OIDC, teleport.SAML, teleport.Github:\n\tdefault:\n\t\treturn trace.BadParameter(\"authentication type %q not supported\", c.Spec.Type)\n\t}\n\n\t// make sure second factor makes sense\n\tswitch c.Spec.SecondFactor {\n\tcase teleport.OFF, teleport.OTP, teleport.U2F:\n\tdefault:\n\t\treturn trace.BadParameter(\"second factor type %q not supported\", c.Spec.SecondFactor)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def _layout_for_option(name)\n      case name\n      when String     then _normalize_layout(name)\n      when Proc       then name\n      when true       then Proc.new { |lookup_context, formats| _default_layout(lookup_context, formats, true)  }\n      when :default   then Proc.new { |lookup_context, formats| _default_layout(lookup_context, formats, false) }\n      when false, nil then nil\n      else\n        raise ArgumentError,\n          \"String, Proc, :default, true, or false, expected for `layout'; you passed #{name.inspect}\"\n      end\n    end", "label": 4}
{"code": "func (ww *WidgetWatchers) Unwatch(handler tcell.EventHandler) {\n\tif ww.watchers != nil {\n\t\tdelete(ww.watchers, handler)\n\t}\n}", "label": 5}
{"code": "public function process($object = false)\n    {\n        $this->output = [];\n        $indexColumn  = config('datatables.index_column', 'DT_RowIndex');\n\n        foreach ($this->results as $row) {\n            $data  = Helper::convertToArray($row);\n            $value = $this->addColumns($data, $row);\n            $value = $this->editColumns($value, $row);\n            $value = $this->setupRowVariables($value, $row);\n            $value = $this->selectOnlyNeededColumns($value);\n            $value = $this->removeExcessColumns($value);\n\n            if ($this->includeIndex) {\n                $value[$indexColumn] = ++$this->start;\n            }\n\n            $this->output[] = $object ? $value : $this->flatten($value);\n        }\n\n        return $this->escapeColumns($this->output);\n    }", "label": 2}
{"code": "public function basic_cancel($consumer_tag, $nowait = false, $noreturn = false)\n    {\n        list($class_id, $method_id, $args) = $this->protocolWriter->basicCancel($consumer_tag, $nowait);\n        $this->send_method_frame(array($class_id, $method_id), $args);\n\n        if ($nowait || $noreturn) {\n            unset($this->callbacks[$consumer_tag]);\n            return $consumer_tag;\n        }\n\n        return $this->wait(array(\n            $this->waitHelper->get_wait('basic.cancel_ok')\n        ), false, $this->channel_rpc_timeout);\n    }", "label": 2}
{"code": "public function getReadIds(User $user)\n    {\n        return Discussion::leftJoin('discussion_user', 'discussion_user.discussion_id', '=', 'discussions.id')\n            ->where('discussion_user.user_id', $user->id)\n            ->whereColumn('last_read_post_number', '>=', 'last_post_number')\n            ->pluck('id')\n            ->all();\n    }", "label": 2}
{"code": "public function sample($probability)\n    {\n        if ($probability < 0) {\n            throw new \\InvalidArgumentException('Probability must be positive');\n        }\n        if ($probability >= 1.0) {\n            throw new \\InvalidArgumentException('Probability must be less than 1.0');\n        }\n\n        return new SimpleFilter(\n            (new RowFilter)->setRowSampleFilter($probability)\n        );\n    }", "label": 2}
{"code": "private function reset()\n    {\n        $this->prevRowKey = null;\n        $this->rowKey = null;\n        $this->state = self::$rowStateEnum['NEW_ROW'];\n        $this->row = [];\n    }", "label": 2}
{"code": "def __default(self, ast_token):\n        \"\"\"Handle tokens inside the list or outside the list.\"\"\"\n        if self.list_level == 1:\n            if self.list_entry is None:\n                self.list_entry = ast_token\n            elif not isinstance(ast_token, type(self.list_entry)):\n                self.final_ast_tokens.append(ast_token)\n        elif self.list_level == 0:\n            self.final_ast_tokens.append(ast_token)", "label": 1}
{"code": "func isEq(fl FieldLevel) bool {\n\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\t\treturn field.String() == param\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\tp := asInt(param)\n\n\t\treturn int64(field.Len()) == p\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tp := asInt(param)\n\n\t\treturn field.Int() == p\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tp := asUint(param)\n\n\t\treturn field.Uint() == p\n\n\tcase reflect.Float32, reflect.Float64:\n\t\tp := asFloat(param)\n\n\t\treturn field.Float() == p\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}", "label": 5}
{"code": "def to_h(obj = self)\n      case obj\n      when Struct\n        obj.members.each.with_object({}) do |member, hash|\n          value = obj[member]\n          hash[member] = to_hash(value) unless value.nil?\n        end\n      when Hash\n        obj.each.with_object({}) do |(key, value), hash|\n          hash[key] = to_hash(value)\n        end\n      when Array\n        obj.collect { |value| to_hash(value) }\n      else\n        obj\n      end\n    end", "label": 4}
{"code": "func StartCmd(wdPath, name, kernelPath string, nds []kvm.NetDescriber, cpu, mem int64, debug bool) []string {\n\tvar (\n\t\tdriverConfiguration = hypervisor.KvmHypervisor{\n\t\t\tBin: \"./qemu\",\n\t\t\tKernelParams: []string{\n\t\t\t\t\"root=/dev/root\",\n\t\t\t\t\"rootfstype=9p\",\n\t\t\t\t\"rootflags=trans=virtio,version=9p2000.L,cache=mmap\",\n\t\t\t\t\"rw\",\n\t\t\t\t\"systemd.default_standard_error=journal+console\",\n\t\t\t\t\"systemd.default_standard_output=journal+console\",\n\t\t\t},\n\t\t}\n\t)\n\n\tdriverConfiguration.InitKernelParams(debug)\n\n\tcmd := []string{\n\t\tfilepath.Join(wdPath, driverConfiguration.Bin),\n\t\t\"-L\", wdPath,\n\t\t\"-no-reboot\",\n\t\t\"-display\", \"none\",\n\t\t\"-enable-kvm\",\n\t\t\"-smp\", strconv.FormatInt(cpu, 10),\n\t\t\"-m\", strconv.FormatInt(mem, 10),\n\t\t\"-kernel\", kernelPath,\n\t\t\"-fsdev\", \"local,id=root,path=stage1/rootfs,security_model=none\",\n\t\t\"-device\", \"virtio-9p-pci,fsdev=root,mount_tag=/dev/root\",\n\t\t\"-append\", fmt.Sprintf(\"%s\", strings.Join(driverConfiguration.KernelParams, \" \")),\n\t\t\"-chardev\", \"stdio,id=virtiocon0,signal=off\",\n\t\t\"-device\", \"virtio-serial\",\n\t\t\"-device\", \"virtconsole,chardev=virtiocon0\",\n\t}\n\treturn append(cmd, kvmNetArgs(nds)...)\n}", "label": 5}
{"code": "func NewHMACAnonymizer(key string) (*hmacAnonymizer, error) {\n\tif strings.TrimSpace(key) == \"\" {\n\t\treturn nil, trace.BadParameter(\"HMAC key must not be empty\")\n\t}\n\treturn &hmacAnonymizer{\n\t\tkey: key,\n\t}, nil\n}", "label": 5}
{"code": "def encrypted(path, key_path: \"config/master.key\", env_key: \"RAILS_MASTER_KEY\")\n      ActiveSupport::EncryptedConfiguration.new(\n        config_path: Rails.root.join(path),\n        key_path: Rails.root.join(key_path),\n        env_key: env_key,\n        raise_if_missing_key: config.require_master_key\n      )\n    end", "label": 4}
{"code": "function isValidExtension(src){\n   var extension = src.split('.').pop();\n   var isValid = ENUM_INVALID_EXTENSIONS[extension] === false ? false : true;\n   return isValid;\n}", "label": 3}
{"code": "function deleteGroup(group) {\n  if (!runningAsRoot()) return;\n  if (!group) throw new Error('You must provide a group to delete');\n  if (!groupExists(group)) {\n    return;\n  }\n  const groupdelBin = _safeLocateBinary('groupdel');\n  const delgroupBin = _safeLocateBinary('delgroup');\n\n  if (isPlatform('linux')) {\n    if (groupdelBin !== null) { // most modern systems\n      runProgram(groupdelBin, [group]);\n    } else {\n      if (_isBusyboxBinary(delgroupBin)) { // busybox-based systems\n        runProgram(delgroupBin, [group]);\n      } else {\n        throw new Error(`Don't know how to delete group ${group} on this strange linux`);\n      }\n    }\n  } else if (isPlatform('osx')) {\n    runProgram('dscl', ['.', '-delete', `/Groups/${group}`]);\n  } else if (isPlatform('windows')) {\n    throw new Error(`Don't know how to delete group ${group} on Windows`);\n  } else {\n    throw new Error(`Don't know how to delete group ${group} on the current platformp`);\n  }\n}", "label": 3}
{"code": "function _gpfProcessDefineParams (rootNamespace, defaultSuper, params) {\n    _gpfProcessDefineParamNoSuperUsed(defaultSuper, params);\n    _gpfProcessDefineParamCheckIfRelativeName(rootNamespace, params);\n    _gpfProcessDefineParamDefaultSuper(defaultSuper, params);\n    _gpfProcessDefineParamDefaultDefinition(params);\n    _gpfProcessDefineParamResolveBase(params);\n    _gpfProcessDefineParamsCheck(params);\n}", "label": 3}
{"code": "protected function attachAppends(array $data)\n    {\n        $appends = [];\n        foreach ($this->appends as $key => $value) {\n            if (is_callable($value)) {\n                $appends[$key] = value($value($this->getFilteredQuery()));\n            } else {\n                $appends[$key] = $value;\n            }\n        }\n\n        return array_merge($data, $appends);\n    }", "label": 2}
{"code": "func (sink *influxdbSink) stringListQuery(q string, errStr string) ([]string, error) {\n\tsink.RLock()\n\tdefer sink.RUnlock()\n\n\tresp, err := sink.runQuery(q)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(errStr)\n\t}\n\n\tif len(resp[0].Series) < 1 {\n\t\treturn nil, fmt.Errorf(errStr)\n\t}\n\n\tres := make([]string, len(resp[0].Series[0].Values))\n\tfor i, rv := range resp[0].Series[0].Values {\n\t\tres[i] = rv[0].(string)\n\t}\n\treturn res, nil\n}", "label": 5}
{"code": "public function scopes($scopes)\n    {\n        $this->scopes = array_unique(array_merge($this->scopes, (array) $scopes));\n\n        return $this;\n    }", "label": 2}
{"code": "public function filterVisibleIds(array $ids, User $actor)\n    {\n        return $this->queryIds($ids, $actor)->pluck('posts.id')->all();\n    }", "label": 2}
{"code": "function destRoot(type, drizzle) {\n  const options = drizzle.options;\n\n  // TODO: this is unfortunate, and due to difficulty using defaults.keys\n  const keys = new Map([\n    ['page', 'pages'],\n    ['collection', 'collections'],\n    ['pattern', 'patterns']\n  ]);\n\n  return relativePath(options.dest.root, options.dest[keys.get(type)]);\n}", "label": 3}
{"code": "func GetMinimalIP(ip net.IP) net.IP {\n\tif ip != nil && ip.To4() != nil {\n\t\treturn ip.To4()\n\t}\n\treturn ip\n}", "label": 5}
{"code": "def select_team(team_id: nil, team_name: nil)\n      t_id = (team_id || ENV['FASTLANE_ITC_TEAM_ID'] || '').strip\n      t_name = (team_name || ENV['FASTLANE_ITC_TEAM_NAME'] || '').strip\n\n      if t_name.length > 0 && t_id.length.zero? # we prefer IDs over names, they are unique\n        puts(\"Looking for App Store Connect Team with name #{t_name}\") if Spaceship::Globals.verbose?\n\n        teams.each do |t|\n          t_id = t['contentProvider']['contentProviderId'].to_s if t['contentProvider']['name'].casecmp(t_name).zero?\n        end\n\n        puts(\"Could not find team with name '#{t_name}', trying to fallback to default team\") if t_id.length.zero?\n      end\n\n      t_id = teams.first['contentProvider']['contentProviderId'].to_s if teams.count == 1\n\n      if t_id.length > 0\n        puts(\"Looking for App Store Connect Team with ID #{t_id}\") if Spaceship::Globals.verbose?\n\n        # actually set the team id here\n        self.team_id = t_id\n        return self.team_id\n      end\n\n      # user didn't specify a team... #thisiswhywecanthavenicethings\n      loop do\n        puts(\"Multiple #{'App Store Connect teams'.yellow} found, please enter the number of the team you want to use: \")\n        if ENV[\"FASTLANE_HIDE_TEAM_INFORMATION\"].to_s.length == 0\n          puts(\"Note: to automatically choose the team, provide either the App Store Connect Team ID, or the Team Name in your fastlane/Appfile:\")\n          puts(\"Alternatively you can pass the team name or team ID using the `FASTLANE_ITC_TEAM_ID` or `FASTLANE_ITC_TEAM_NAME` environment variable\")\n          first_team = teams.first[\"contentProvider\"]\n          puts(\"\")\n          puts(\"  itc_team_id \\\"#{first_team['contentProviderId']}\\\"\")\n          puts(\"\")\n          puts(\"or\")\n          puts(\"\")\n          puts(\"  itc_team_name \\\"#{first_team['name']}\\\"\")\n          puts(\"\")\n        end\n\n        # We're not using highline here, as spaceship doesn't have a dependency to fastlane_core or highline\n        teams.each_with_index do |team, i|\n          puts(\"#{i + 1}) \\\"#{team['contentProvider']['name']}\\\" (#{team['contentProvider']['contentProviderId']})\")\n        end\n\n        unless Spaceship::Client::UserInterface.interactive?\n          puts(\"Multiple teams found on App Store Connect, Your Terminal is running in non-interactive mode! Cannot continue from here.\")\n          puts(\"Please check that you set FASTLANE_ITC_TEAM_ID or FASTLANE_ITC_TEAM_NAME to the right value.\")\n          raise \"Multiple App Store Connect Teams found; unable to choose, terminal not interactive!\"\n        end\n\n        selected = ($stdin.gets || '').strip.to_i - 1\n        team_to_use = teams[selected] if selected >= 0\n\n        if team_to_use\n          self.team_id = team_to_use['contentProvider']['contentProviderId'].to_s # actually set the team id here\n          return self.team_id\n        end\n      end\n    end", "label": 4}
{"code": "function ZTransform(options) {\n\tif(options) {\n\t\tif(options.objectMode) {\n\t\t\toptions.readableObjectMode = true;\n\t\t\toptions.writableObjectMode = true;\n\t\t}\n\t\tif(options.readableObjectMode && options.writableObjectMode) {\n\t\t\toptions.objectMode = true;\n\t\t}\n\t\tif(typeof options.transform === 'function') {\n\t\t\tthis._transform = options.transform;\n\t\t}\n\t\tif(typeof options.flush === 'function') {\n\t\t\tthis._flush = options.flush;\n\t\t}\n\t}\n\tTransform.call(this, options);\n\t// note: exclamation marks are used to convert to booleans\n\tif(options && !options.objectMode && (!options.readableObjectMode) !== (!options.writableObjectMode)) {\n\t\tthis._writableState.objectMode = !!options.writableObjectMode;\n\t\tthis._readableState.objectMode = !!options.readableObjectMode;\n\t}\n\tif(options && options.readableObjectMode) {\n\t\tthis._readableState.highWaterMark = 16;\n\t}\n\tif(options && options.writableObjectMode) {\n\t\tthis._writableState.highWaterMark = 16;\n\t}\n\tstreamMixins.call(this, Transform.prototype, options);\n\treadableMixins.call(this, options);\n\twritableMixins.call(this, options);\n}", "label": 3}
{"code": "def get(self, id, attid): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Get a device's attachment.\n\n        :param id: Device ID as an int.\n        :param attid: Attachment ID as an int.\n        :return: :class:`attachments.Attachment <attachments.Attachment>` object\n        :rtype: attachments.Attachment\n        \"\"\"\n        schema = AttachmentSchema()\n        resp = self.service.get_id(self._base(id), attid)\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "def find_cipher_key(*args)\n      fail ArgumentError, 'Unknown key derivation name ', args[1] unless args[1] == 'PBKDF2'\n\n      ::OpenSSL::PKCS5.pbkdf2_hmac_sha1(args[2], args[3], args[4], args[0].key_len)\n    end", "label": 4}
{"code": "function serviceCall(req, res, next) {\n        connector.runCall(req.params.connection, req.params.call, req.body).then(res.json.bind(res), next).done();\n    }", "label": 3}
{"code": "public DbProduct getProduct(final String name) {\n        final DbProduct dbProduct = repositoryHandler.getProduct(name);\n\n        if(dbProduct == null){\n            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)\n                    .entity(\"Product \" + name + \" does not exist.\").build());\n        }\n\n        return dbProduct;\n    }", "label": 0}
{"code": "protected boolean checkActionPackages(String classPackageName) {\n\t\tif (actionPackages != null) {\n\t\t\tfor (String packageName : actionPackages) {\n\t\t\t\tString strictPackageName = packageName + \".\";\n\t\t\t\tif (classPackageName.equals(packageName) || classPackageName.startsWith(strictPackageName))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "label": 0}
{"code": "public Object remove(Object key)\r\n    {\r\n        if (key == null) return null;\r\n        purge();\r\n        int hash = hashCode(key);\r\n        int index = indexFor(hash);\r\n        Entry previous = null;\r\n        Entry entry = table[index];\r\n        while (entry != null)\r\n        {\r\n            if ((hash == entry.hash) && equals(key, entry.getKey()))\r\n            {\r\n                if (previous == null)\r\n                    table[index] = entry.next;\r\n                else\r\n                    previous.next = entry.next;\r\n                this.size--;\r\n                modCount++;\r\n                return entry.getValue();\r\n            }\r\n            previous = entry;\r\n            entry = entry.next;\r\n        }\r\n        return null;\r\n    }", "label": 0}
{"code": "def postMetrics(self, name, suffix, description, default_value, **kwargs):\n        '''Create a new metric.\n\n        :param name: Name of metric\n        :param suffix: Measurments in\n        :param description: Description of what the metric is measuring\n        :param default_value: The default value to use when a point is added\n        :param display_chart: (optional) Whether to display the chart on the status page\n        :return: :class:`Response <Response>` object\n        :rtype: requests.Response\n        '''\n\n        kwargs['name'] = name\n        kwargs['suffix'] = suffix\n        kwargs['description'] = description\n        kwargs['default_value'] = default_value\n        return self.__postRequest('/metrics', kwargs)", "label": 1}
{"code": "public function setMutationRecord($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Monitoring\\V3\\MutationRecord::class);\n        $this->mutation_record = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function phpdocSummary()\n    {\n        $content = $this->phpdocContent();\n        if (!$content) {\n            return UNDEFINED;\n        }\n        $lines = preg_split('/(\\n|\\r\\n)/', $content);\n        $summary = '';\n        foreach ($lines as $line) {\n            $summary .= $line . \"\\n\";\n            if ($line === '' || substr($line, -1) === '.') {\n                return trim($summary);\n            }\n        }\n        $summary = trim($summary);\n        if ($summary === '') {\n            return UNDEFINED;\n        }\n\n        return $summary;\n    }", "label": 2}
{"code": "def power_on(self, id): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Power on a device using it's power on command.\n\n        :param id: Device ID as an int.\n        :return: :class:`devices.PowerCmd <devices.PowerCmd>` object\n        :rtype: devices.PowerCmd\n        \"\"\"\n        schema = PowerCmdSchema()\n        resp = self.service.post(self.base+str(id)+'/power/on/')\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "public function orderableColumns()\n    {\n        if (! $this->isOrderable()) {\n            return [];\n        }\n\n        $orderable = [];\n        for ($i = 0, $c = count($this->request->input('order')); $i < $c; $i++) {\n            $order_col = (int) $this->request->input(\"order.$i.column\");\n            $order_dir = strtolower($this->request->input(\"order.$i.dir\")) === 'asc' ? 'asc' : 'desc';\n            if ($this->isColumnOrderable($order_col)) {\n                $orderable[] = ['column' => $order_col, 'direction' => $order_dir];\n            }\n        }\n\n        return $orderable;\n    }", "label": 2}
{"code": "public static cachepolicylabel get(nitro_service service, String labelname) throws Exception{\n\t\tcachepolicylabel obj = new cachepolicylabel();\n\t\tobj.set_labelname(labelname);\n\t\tcachepolicylabel response = (cachepolicylabel) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (flag *ClientFlag) Environ(extra bool) []string {\n\tvar env []string\n\tadd := func(k, v string) {\n\t\tenv = append(env, fmt.Sprintf(\"%s=%s\", k, v))\n\t}\n\n\tu := *flag.url\n\tif u.User != nil {\n\t\tadd(envUsername, u.User.Username())\n\n\t\tif p, ok := u.User.Password(); ok {\n\t\t\tadd(envPassword, p)\n\t\t}\n\n\t\tu.User = nil\n\t}\n\n\tif u.Path == vim25.Path {\n\t\tu.Path = \"\"\n\t}\n\tu.Fragment = \"\"\n\tu.RawQuery = \"\"\n\n\tadd(envURL, strings.TrimPrefix(u.String(), \"https://\"))\n\n\tkeys := []string{\n\t\tenvCertificate,\n\t\tenvPrivateKey,\n\t\tenvInsecure,\n\t\tenvPersist,\n\t\tenvMinAPIVersion,\n\t\tenvVimNamespace,\n\t\tenvVimVersion,\n\t}\n\n\tfor _, k := range keys {\n\t\tif v := os.Getenv(k); v != \"\" {\n\t\t\tadd(k, v)\n\t\t}\n\t}\n\n\tif extra {\n\t\tadd(\"GOVC_URL_SCHEME\", flag.url.Scheme)\n\n\t\tv := strings.SplitN(u.Host, \":\", 2)\n\t\tadd(\"GOVC_URL_HOST\", v[0])\n\t\tif len(v) == 2 {\n\t\t\tadd(\"GOVC_URL_PORT\", v[1])\n\t\t}\n\n\t\tadd(\"GOVC_URL_PATH\", flag.url.Path)\n\n\t\tif f := flag.url.Fragment; f != \"\" {\n\t\t\tadd(\"GOVC_URL_FRAGMENT\", f)\n\t\t}\n\n\t\tif q := flag.url.RawQuery; q != \"\" {\n\t\t\tadd(\"GOVC_URL_QUERY\", q)\n\t\t}\n\t}\n\n\treturn env\n}", "label": 5}
{"code": "function (response_type, event) {\n\t\n\t\tLOG.sys('handling event response [' + response_type  + ']', l_name);\n\t\t\n\t\t// go over each registered callback function and see which one responds\n\t\tfor (var i=0; i < l_responders[response_type].length; i++) {\n\t\t\t// find the callback with matching client id\n\t\t\t// call callback and see whether it has been processed\n\t\t\tif (l_responders[response_type][i].cid === event.cid) {\n\t\t\t\t// log incoming message type & IP/port\n\t\t\t\tLOG.sys(SR.Tags.RCV + response_type + ' from ' + event.printSource() + SR.Tags.END, l_name);\n\n\t\t\t\t// make callback\n\t\t\t\tUTIL.safeCall(l_responders[response_type][i].onResponse, event);\n\n\t\t\t\t// then remove it\n\t\t\t\tl_responders[response_type].splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}", "label": 3}
{"code": "func GetContentLengthAndFingerprint(\n\tctx context.Context, uri string) (int64, string, error) {\n\tresp, err := http.Head(uri)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tif resp.TLS == nil || len(resp.TLS.PeerCertificates) == 0 {\n\t\treturn resp.ContentLength, \"\", nil\n\t}\n\tfingerprint := &bytes.Buffer{}\n\tsum := sha1.Sum(resp.TLS.PeerCertificates[0].Raw)\n\tfor i, b := range sum {\n\t\tfmt.Fprintf(fingerprint, \"%X\", b)\n\t\tif i < len(sum)-1 {\n\t\t\tfmt.Fprint(fingerprint, \":\")\n\t\t}\n\t}\n\treturn resp.ContentLength, fingerprint.String(), nil\n}", "label": 5}
{"code": "def build_access_token(response, access_token_opts, access_token_class)\n      access_token_class.from_hash(self, response.parsed.merge(access_token_opts)).tap do |access_token|\n        access_token.response = response if access_token.respond_to?(:response=)\n      end\n    end", "label": 4}
{"code": "func (ag *AuthGroup) Delete(db XODB) error {\n\tvar err error\n\n\t// if doesn't exist, bail\n\tif !ag._exists {\n\t\treturn nil\n\t}\n\n\t// if deleted, bail\n\tif ag._deleted {\n\t\treturn nil\n\t}\n\n\t// sql query\n\tconst sqlstr = `DELETE FROM django.auth_group WHERE id = :1`\n\n\t// run query\n\tXOLog(sqlstr, ag.ID)\n\t_, err = db.Exec(sqlstr, ag.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set deleted\n\tag._deleted = true\n\n\treturn nil\n}", "label": 5}
{"code": "def span(name, identifier={:index => 0}, &block)\n      standard_methods(name, identifier, 'span_for', &block)\n      define_method(name) do\n        return platform.span_text_for identifier.clone unless block_given?\n        self.send(\"#{name}_element\").text\n      end\n    end", "label": 4}
{"code": "func (l VirtualDeviceList) TypeName(device types.BaseVirtualDevice) string {\n\tdtype := reflect.TypeOf(device)\n\tif dtype == nil {\n\t\treturn \"\"\n\t}\n\treturn dtype.Elem().Name()\n}", "label": 5}
{"code": "func (f *Finder) Element(ctx context.Context, ref types.ManagedObjectReference) (*list.Element, error) {\n\trl := func(_ context.Context) (object.Reference, error) {\n\t\treturn ref, nil\n\t}\n\n\ts := &spec{\n\t\tRelative: rl,\n\t}\n\n\te, err := f.find(ctx, \"./\", s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(e) == 0 {\n\t\treturn nil, &NotFoundError{ref.Type, ref.Value}\n\t}\n\n\tif len(e) > 1 {\n\t\tpanic(\"ManagedObjectReference must be unique\")\n\t}\n\n\treturn &e[0], nil\n}", "label": 5}
{"code": "def launch_app(app_path, params=[], time_before_kill_app=15):\n    \"\"\"\n    start an app\n    \"\"\"\n    import subprocess\n    try:\n        res = subprocess.call([app_path, params], timeout=time_before_kill_app, shell=True)\n        print('res = ', res)\n        if res == 0:\n            return True\n        else:\n            return False\n    except Exception as ex:\n        print('error launching app  ' + str(app_path) + ' with params ' + str(params) + '\\n' + str(ex))\n        return False", "label": 1}
{"code": "def resource(*args, &block)\n      options = args.last.is_a?(Hash) ? args.pop : {}\n      options[:api_doc_dsl] = :resource\n      options[:resource_name] = args.first.to_s\n      options[:document] = :all unless options.key?(:document)\n      args.push(options)\n      describe(*args, &block)\n    end", "label": 4}
{"code": "def get_shift(id, opts = {})\n      data, _status_code, _headers = get_shift_with_http_info(id, opts)\n      return data\n    end", "label": 4}
{"code": "public static function createFromLocaleFormat($format, $locale, $time, $tz = null)\n    {\n        return static::rawCreateFromFormat($format, static::translateTimeString($time, $locale, 'en'), $tz);\n    }", "label": 2}
{"code": "public String pop() {\n        return doWithJedis(new JedisCallable<String>() {\n            @Override\n            public String call(Jedis jedis) {\n                return jedis.spop(getKey());\n            }\n        });\n    }", "label": 0}
{"code": "func CreateUploaderDir(dir string) error {\n\terr := os.MkdirAll(filepath.Join(dir, teleport.LogsDir, teleport.ComponentUpload,\n\t\tevents.SessionLogsDir, defaults.Namespace), teleport.SharedDirMode)\n\tif err != nil {\n\t\treturn trace.ConvertSystemError(err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public function setRawIndices($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\WebRisk\\V1beta1\\RawIndices::class);\n        $this->raw_indices = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function on($names, $callback)\n    {\n        if (! is_array($names)) {\n            $names = [$names];\n        }\n\n        $callable = $this->getCallable($callback);\n\n        foreach ($names as $name) {\n            $this->events[] = [\n                'name' => $name,\n                'callback' => $callable,\n            ];\n        }\n    }", "label": 2}
{"code": "func (m *Mock) AssertNotCalled(t TestingT, methodName string, arguments ...interface{}) bool {\n\tif h, ok := t.(tHelper); ok {\n\t\th.Helper()\n\t}\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\tif m.methodWasCalled(methodName, arguments) {\n\t\treturn assert.Fail(t, \"Should not have called with given arguments\",\n\t\t\tfmt.Sprintf(\"Expected %q to not have been called with:\\n%v\\nbut actually it was.\", methodName, arguments))\n\t}\n\treturn true\n}", "label": 5}
{"code": "def newResponseEvent(self):\n        \"\"\"creates a response event and adds it to a waiting list\n           When the reponse arrives it will be removed from the list. \n        \"\"\"\n        respEvt = ResponseEvent()\n        self.respLock.acquire()\n        eid = id(respEvt)\n        self.respEvents[eid] = respEvt\n        self.respLock.release()\n        return (respEvt,eid)", "label": 1}
{"code": "def process_def(exp, parent)\n      inside_new_context(current_context.method_context_class, exp, parent) do\n        increase_statement_count_by(exp.body)\n        process(exp)\n      end\n    end", "label": 4}
{"code": "func (m *DatastoreFileManager) Delete(ctx context.Context, name string) error {\n\tswitch path.Ext(name) {\n\tcase \".vmdk\":\n\t\treturn m.DeleteVirtualDisk(ctx, name)\n\tdefault:\n\t\treturn m.DeleteFile(ctx, name)\n\t}\n}", "label": 5}
{"code": "public function build($resource, $method, array $options = [])\n    {\n        $root = $this->resourceRoot;\n\n        array_push($root, 'resources');\n        $root = array_merge($root, explode('.', $resource));\n        array_push($root, 'methods', $method);\n\n        $action = $this->service;\n        foreach ($root as $rootItem) {\n            if (!isset($action[$rootItem])) {\n                throw new \\InvalidArgumentException('Provided path item ' . $rootItem . ' does not exist.');\n            }\n            $action = $action[$rootItem];\n        }\n\n        $path = [];\n        $query = [];\n        $body = [];\n\n        if (isset($action['parameters'])) {\n            foreach ($action['parameters'] as $parameter => $parameterOptions) {\n                if ($parameterOptions['location'] === 'path' && array_key_exists($parameter, $options)) {\n                    $path[$parameter] = $options[$parameter];\n                    unset($options[$parameter]);\n                }\n\n                if ($parameterOptions['location'] === 'query' && array_key_exists($parameter, $options)) {\n                    $query[$parameter] = $options[$parameter];\n                }\n            }\n        }\n\n        if (isset($this->service['parameters'])) {\n            foreach ($this->service['parameters'] as $parameter => $parameterOptions) {\n                if ($parameterOptions['location'] === 'query' && array_key_exists($parameter, $options)) {\n                    $query[$parameter] = $options[$parameter];\n                }\n            }\n        }\n\n        if (isset($action['request'])) {\n            $schema = $action['request']['$ref'];\n\n            foreach ($this->service['schemas'][$schema]['properties'] as $property => $propertyOptions) {\n                if (array_key_exists($property, $options)) {\n                    $body[$property] = $options[$property];\n                }\n            }\n        }\n\n        $uri = $this->buildUriWithQuery(\n            $this->expandUri($this->baseUri . $action['path'], $path),\n            $query\n        );\n\n        return new Request(\n            $action['httpMethod'],\n            $uri,\n            ['Content-Type' => 'application/json'],\n            $body ? $this->jsonEncode($body) : null\n        );\n    }", "label": 2}
{"code": "public function stream_seek($offset, $whence = SEEK_SET)\n    {\n        if ($this->stream->isSeekable()) {\n            $this->stream->seek($offset, $whence);\n            return true;\n        }\n        return false;\n    }", "label": 2}
{"code": "def extract_row(self,  row):\n        \"\"\"\n        get row number 'row'\n        \"\"\"\n        new_row = []\n        for col in range(self.get_grid_width()):\n            new_row.append(self.get_tile(row, col))    \n        return new_row", "label": 1}
{"code": "public void fillEllipse(Rectangle rect, Color color) {\n\t\ttemplate.saveState();\n\t\tsetFill(color);\n\t\ttemplate.ellipse(origX + rect.getLeft(), origY + rect.getBottom(), origX + rect.getRight(),\n\t\t\t\torigY + rect.getTop());\n\t\ttemplate.fill();\n\t\ttemplate.restoreState();\n\t}", "label": 0}
{"code": "def write(self, parallel=True):\n        \"\"\"\n        Writes the configuration to disk.\n        \"\"\"\n        # Write the Solution files\n        solutions = sorted(self._solutions, key=lambda x: x.Name)\n        with VSGWriteCommand('Writing VSG Solution', solutions, parallel) as command:\n            command.execute()\n\n        # Write the Projects files\n        projects = set(sorted((p for s in solutions for p in s.Projects), key=lambda x: x.Name))\n        with VSGWriteCommand('Writing VSG Projects', projects, parallel) as command:\n            command.execute()\n\n        # Register the registerables\n        registerables = set(sorted((p for s in solutions for p in s.Projects), key=lambda x: x.Name))\n        with VSGRegisterCommand('Registering Project Registerables', registerables) as command:\n            command.execute()", "label": 1}
{"code": "def indim(self):\n        \"\"\" The number of action values that the environment accepts.\n        \"\"\"\n        indim = self.numOffbids * len(self.generators)\n\n        if self.maxWithhold is not None:\n            return indim * 2\n        else:\n            return indim", "label": 1}
{"code": "func (l *LoadBalancer) Listen() error {\n\tvar err error\n\tl.listener, err = net.Listen(l.frontend.AddrNetwork, l.frontend.Addr)\n\tif err != nil {\n\t\treturn trace.ConvertSystemError(err)\n\t}\n\tl.Debugf(\"created listening socket\")\n\treturn nil\n}", "label": 5}
{"code": "func (c *controller) agentInitComplete() {\n\tc.Lock()\n\tif c.agentInitDone != nil {\n\t\tclose(c.agentInitDone)\n\t\tc.agentInitDone = nil\n\t}\n\tc.Unlock()\n}", "label": 5}
{"code": "func (r *Registry) Remove(item types.ManagedObjectReference) {\n\tr.applyHandlers(func(o RegisterObject) {\n\t\to.RemoveObject(item)\n\t})\n\n\tr.m.Lock()\n\tdelete(r.objects, item)\n\tdelete(r.handlers, item)\n\tdelete(r.locks, item)\n\tr.m.Unlock()\n}", "label": 5}
{"code": "public function setAddress($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\Address::class);\n        $this->address = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function createProgram(\n      gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n    var errFn = opt_errorCallback || error;\n    var program = gl.createProgram();\n    shaders.forEach(function(shader) {\n      gl.attachShader(program, shader);\n    });\n    if (opt_attribs) {\n      opt_attribs.forEach(function(attrib, ndx) {\n        gl.bindAttribLocation(\n            program,\n            opt_locations ? opt_locations[ndx] : ndx,\n            attrib);\n      });\n    }\n    gl.linkProgram(program);\n\n    // Check the link status\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n        // something went wrong with the link\n        var lastError = gl.getProgramInfoLog(program);\n        errFn(\"Error in program linking:\" + lastError);\n\n        gl.deleteProgram(program);\n        return null;\n    }\n    return program;\n  }", "label": 3}
{"code": "def dump_value(key, value, f, indent=0):\n    '''Save a value of any libconfig type\n\n    This function serializes takes ``key`` and ``value`` and serializes them\n    into ``f``. If ``key`` is ``None``, a list-style output is produced.\n    Otherwise, output has ``key = value`` format.\n    '''\n\n    spaces = ' ' * indent\n\n    if key is None:\n        key_prefix = ''\n        key_prefix_nl = ''\n    else:\n        key_prefix = key + ' = '\n        key_prefix_nl = key + ' =\\n' + spaces\n\n    dtype = get_dump_type(value)\n    if dtype == 'd':\n        f.write(u'{}{}{{\\n'.format(spaces, key_prefix_nl))\n        dump_dict(value, f, indent + 4)\n        f.write(u'{}}}'.format(spaces))\n    elif dtype == 'l':\n        f.write(u'{}{}(\\n'.format(spaces, key_prefix_nl))\n        dump_collection(value, f, indent + 4)\n        f.write(u'\\n{})'.format(spaces))\n    elif dtype == 'a':\n        f.write(u'{}{}[\\n'.format(spaces, key_prefix_nl))\n        value_dtype = get_array_value_dtype(value)\n\n        # If int array contains one or more Int64, promote all values to i64.\n        if value_dtype == 'i64':\n            value = [LibconfInt64(v) for v in value]\n        dump_collection(value, f, indent + 4)\n        f.write(u'\\n{}]'.format(spaces))\n    elif dtype == 's':\n        f.write(u'{}{}{}'.format(spaces, key_prefix, dump_string(value)))\n    elif dtype == 'i' or dtype == 'i64':\n        f.write(u'{}{}{}'.format(spaces, key_prefix, dump_int(value)))\n    elif dtype == 'f' or dtype == 'b':\n        f.write(u'{}{}{}'.format(spaces, key_prefix, value))\n    else:\n        raise ConfigSerializeError(\"Can not serialize object %r of type %s\" %\n                                   (value, type(value)))", "label": 1}
{"code": "public static base_responses change(nitro_service client, nsaptlicense resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tnsaptlicense updateresources[] = new nsaptlicense[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new nsaptlicense();\n\t\t\t\tupdateresources[i].id = resources[i].id;\n\t\t\t\tupdateresources[i].sessionid = resources[i].sessionid;\n\t\t\t\tupdateresources[i].bindtype = resources[i].bindtype;\n\t\t\t\tupdateresources[i].countavailable = resources[i].countavailable;\n\t\t\t\tupdateresources[i].licensedir = resources[i].licensedir;\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, updateresources,\"update\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "func (sb *sandbox) clearDefaultGW() error {\n\tvar ep *endpoint\n\n\tif ep = sb.getEndpointInGWNetwork(); ep == nil {\n\t\treturn nil\n\t}\n\tif err := ep.sbLeave(sb, false); err != nil {\n\t\treturn fmt.Errorf(\"container %s: endpoint leaving GW Network failed: %v\", sb.containerID, err)\n\t}\n\tif err := ep.Delete(false); err != nil {\n\t\treturn fmt.Errorf(\"container %s: deleting endpoint on GW Network failed: %v\", sb.containerID, err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def delete_reaction(user, reaction)\n      reaction = reaction.to_reaction if reaction.respond_to?(:to_reaction)\n      API::Channel.delete_user_reaction(@bot.token, @channel.id, @id, reaction, user.resolve_id)\n    end", "label": 4}
{"code": "def on_page(page_class, params={:using_params => {}}, visit=false, &block)\n      page_class = class_from_string(page_class) if page_class.is_a? String\n      return super(page_class, params, visit, &block) unless page_class.ancestors.include? PageObject\n      merged = page_class.params.merge(params[:using_params])\n      page_class.instance_variable_set(\"@merged_params\", merged) unless merged.empty?\n      @current_page = page_class.new(@browser, visit)\n      block.call @current_page if block\n      @current_page\n    end", "label": 4}
{"code": "func Handshake(sock io.ReadWriter, ih *metainfo.Hash, peerID [20]byte, extensions PeerExtensionBits) (res HandshakeResult, ok bool, err error) {\n\t// Bytes to be sent to the peer. Should never block the sender.\n\tpostCh := make(chan []byte, 4)\n\t// A single error value sent when the writer completes.\n\twriteDone := make(chan error, 1)\n\t// Performs writes to the socket and ensures posts don't block.\n\tgo handshakeWriter(sock, postCh, writeDone)\n\n\tdefer func() {\n\t\tclose(postCh) // Done writing.\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\t// Wait until writes complete before returning from handshake.\n\t\terr = <-writeDone\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"error writing: %s\", err)\n\t\t}\n\t}()\n\n\tpost := func(bb []byte) {\n\t\tselect {\n\t\tcase postCh <- bb:\n\t\tdefault:\n\t\t\tpanic(\"mustn't block while posting\")\n\t\t}\n\t}\n\n\tpost([]byte(Protocol))\n\tpost(extensions[:])\n\tif ih != nil { // We already know what we want.\n\t\tpost(ih[:])\n\t\tpost(peerID[:])\n\t}\n\tvar b [68]byte\n\t_, err = io.ReadFull(sock, b[:68])\n\tif err != nil {\n\t\terr = nil\n\t\treturn\n\t}\n\tif string(b[:20]) != Protocol {\n\t\treturn\n\t}\n\tmissinggo.CopyExact(&res.PeerExtensionBits, b[20:28])\n\tmissinggo.CopyExact(&res.Hash, b[28:48])\n\tmissinggo.CopyExact(&res.PeerID, b[48:68])\n\t// peerExtensions.Add(res.PeerExtensionBits.String(), 1)\n\n\t// TODO: Maybe we can just drop peers here if we're not interested. This\n\t// could prevent them trying to reconnect, falsely believing there was\n\t// just a problem.\n\tif ih == nil { // We were waiting for the peer to tell us what they wanted.\n\t\tpost(res.Hash[:])\n\t\tpost(peerID[:])\n\t}\n\n\tok = true\n\treturn\n}", "label": 5}
{"code": "public function setCommandHandler($commandID, $callback = null)\n    {\n        $commandID = strtoupper($commandID);\n\n        if (!isset($callback)) {\n            unset($this->commands[$commandID]);\n\n            return;\n        }\n\n        if (!is_callable($callback)) {\n            throw new \\InvalidArgumentException(\n                'The argument must be a callable object or NULL.'\n            );\n        }\n\n        $this->commands[$commandID] = $callback;\n    }", "label": 2}
{"code": "def axis_names_without(self, axis):\n        \"\"\"Return axis names without axis, or None if axis_names is None\"\"\"\n        if self.axis_names is None:\n            return None\n        return itemgetter(*self.other_axes(axis))(self.axis_names)", "label": 1}
{"code": "function resolveUrl(path, options) {\n    if (options === void 0) { options = {}; }\n    var serverUrl = resolveServer(path, options);\n    if (!serverUrl) {\n        return path;\n    }\n    if (path.charAt(0) !== '/') {\n        // construct full application url\n        var tenantOrga = options.tenantOrga;\n        if (!tenantOrga) {\n            // following extracts the tenantOrga set on the specific server\n            var serverObj = server.Server.getInstance(serverUrl);\n            tenantOrga = serverObj.applyOptions({\n                serverUrl: serverUrl\n            }).tenantOrga;\n            if (!tenantOrga) {\n                tenantOrga = init.initOptions.tenantOrga;\n                if (!tenantOrga) {\n                    var organization = serverObj.organization;\n                    if (organization) {\n                        tenantOrga = organization.uniqueName;\n                    }\n                }\n            }\n        }\n        var application = options.application || init.initOptions.application;\n        serverUrl = url.resolve(serverUrl, '/' + tenantOrga + '/' + application + '/');\n    }\n    return url.resolve(serverUrl, path);\n}", "label": 3}
{"code": "def cycle_lights(self, states,\n        defaults, direction='forward', selector='all'):\n        \"\"\"Cycle through list of effects.\n\n        Provide array states as a list of dictionaries with set_state arguments.\n        See http://api.developer.lifx.com/docs/cycle\n\n        selector: String\n            The selector to limit which lights will run the effect.\n            default: all\n\n        states: required List of Dicts\n            List of arguments, named as per set_state. Must have 2 to 5 entries.\n\n        defaults: Object\n            Default values to use when not specified in each states[] object.\n            Argument names as per set_state.\n\n        direction: String\n            Direction in which to cycle through the list. Can be forward or backward\n            default: forward\n        \"\"\"\n\n        argument_tuples = [\n            (\"states\", states),\n            (\"defaults\", defaults),\n            (\"direction\", direction)\n        ]\n\n        return self.client.perform_request(\n            method='post', endpoint='lights/{}/cycle', endpoint_args=[selector],\n            argument_tuples=argument_tuples, json_body=True)", "label": 1}
{"code": "func (t *Table) IsHeadless() bool {\n\ttotal := 0\n\tfor i := range t.columns {\n\t\ttotal += len(t.columns[i].title)\n\t}\n\treturn total == 0\n}", "label": 5}
{"code": "def sign_message(message, private_key, public_key=None):\n    \"\"\"\n    Signs a `message` using `private_key` and `public_key`\n\n    .. warning:: Not safe to use with secret keys or secret data. See module\n                 docstring.  This function should be used for testing only.\n\n    :param message: the message to sign\n    :type message: bytes\n\n    :param private_key: private key used to sign message\n    :type private_key: bytes\n\n    :param public_key: public key used to sign message\n    :type public_key: bytes\n\n    :return: the signature of the signed message\n    :rtype: bytes\n    \"\"\"\n\n    if public_key is None:\n        public_key = private_to_public_key(private_key)\n\n    return ed25519_blake2.signature_unsafe(message, private_key, public_key)", "label": 1}
{"code": "def have_enum_values(enum, values, headers = nil, &b)\n      values.each do |value|\n        have_enum_value(enum, value, headers, &b)\n      end\n    end", "label": 4}
{"code": "def bargraph(data, max_key_width=30):\n    \"\"\"Return a bar graph as a string, given a dictionary of data.\"\"\"\n    lines = []\n    max_length = min(max(len(key) for key in data.keys()), max_key_width)\n    max_val = max(data.values())\n    max_val_length = max(\n        len(_style_value(val))\n        for val in data.values())\n    term_width = get_terminal_size()[0]\n    max_bar_width = term_width - MARGIN - (max_length + 3 + max_val_length + 3)\n    template = u\"{key:{key_width}} [ {value:{val_width}} ] {bar}\"\n    for key, value in data.items():\n        try:\n            bar = int(math.ceil(max_bar_width * value / max_val)) * TICK\n        except ZeroDivisionError:\n            bar = ''\n        line = template.format(\n            key=key[:max_length],\n            value=_style_value(value),\n            bar=bar,\n            key_width=max_length,\n            val_width=max_val_length\n        )\n        lines.append(line)\n    return '\\n'.join(lines)", "label": 1}
{"code": "protected function hideParameters($data, $hidden)\n    {\n        foreach ($hidden as $parameter) {\n            if (Arr::get($data, $parameter)) {\n                Arr::set($data, $parameter, '********');\n            }\n        }\n\n        return $data;\n    }", "label": 2}
{"code": "func (c *Context) postEvent(events ...types.BaseEvent) {\n\tm := Map.EventManager()\n\tc.WithLock(m, func() {\n\t\tfor _, event := range events {\n\t\t\tm.PostEvent(c, &types.PostEvent{EventToPost: event})\n\t\t}\n\t})\n}", "label": 5}
{"code": "function(req, data, name, snippet, field, callback) {\n      var manager = self._pages.getManager(field.withType);\n      if (!manager) {\n        return callback(new Error('join with type ' + field.withType + ' unrecognized'));\n      }\n      var titlesOrIds = self._apos.sanitizeString(data[name]).split(/\\s*,\\s*/);\n      if ((!titlesOrIds) || (titlesOrIds[0] === undefined)) {\n        return setImmediate(callback);\n      }\n      var clauses = [];\n      _.each(titlesOrIds, function(titleOrId) {\n        clauses.push({ sortTitle: self._apos.sortify(titleOrId) });\n        clauses.push({ _id: titleOrId });\n      });\n      return manager.get(req, { $or: clauses }, { fields: { _id: 1 }, withJoins: false }, function(err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results = results.pages || results.snippets;\n        if (field.limit !== undefined) {\n          results = results.slice(0, field.limit);\n        }\n        snippet[field.idsField] = _.pluck(results, '_id');\n        return callback(null);\n      });\n    }", "label": 3}
{"code": "def call(env)\n      session = Clearance::Session.new(env)\n      env[:clearance] = session\n      response = @app.call(env)\n      session.add_cookie_to_headers response[1]\n      response\n    end", "label": 4}
{"code": "public function setEvent($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\EventInput::class);\n        $this->writeOneof(3, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def purchase_time(self):\n        \"\"\"Date and time of app purchase.\n\n        :rtype: datetime\n        \"\"\"\n        ts = self._iface.get_purchase_time(self.app_id)\n        return datetime.utcfromtimestamp(ts)", "label": 1}
{"code": "def iconify_auto_link(field, show_link = true)\n      if field.is_a? Hash\n        options = field[:config].separator_options || {}\n        text = field[:value].to_sentence(options)\n      else\n        text = field\n      end\n      # this block is only executed when a link is inserted;\n      # if we pass text containing no links, it just returns text.\n      auto_link(html_escape(text)) do |value|\n        \"<span class='glyphicon glyphicon-new-window'></span>#{('&nbsp;' + value) if show_link}\"\n      end\n    end", "label": 4}
{"code": "func (b *EtcdBackend) KeepAlive(ctx context.Context, lease backend.Lease, expires time.Time) error {\n\tif lease.ID == 0 {\n\t\treturn trace.BadParameter(\"lease is not specified\")\n\t}\n\tre, err := b.client.Get(ctx, prependPrefix(lease.Key), clientv3.WithSerializable(), clientv3.WithKeysOnly())\n\tif err != nil {\n\t\treturn convertErr(err)\n\t}\n\tif len(re.Kvs) == 0 {\n\t\treturn trace.NotFound(\"item %q is not found\", string(lease.Key))\n\t}\n\t// instead of keep-alive on the old lease, setup a new lease\n\t// because we would like the event to be generated\n\t// which does not happen in case of lease keep-alive\n\tvar opts []clientv3.OpOption\n\tvar newLease backend.Lease\n\tif err := b.setupLease(ctx, backend.Item{Expires: expires}, &newLease, &opts); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\topts = append(opts, clientv3.WithIgnoreValue())\n\tkv := re.Kvs[0]\n\t_, err = b.client.Put(ctx, string(kv.Key), \"\", opts...)\n\treturn convertErr(err)\n}", "label": 5}
{"code": "public static void add(double[] array1, double[] array2) {\n        assert (array1.length == array2.length);\n        for (int i=0; i<array1.length; i++) {\n            array1[i] += array2[i];\n        }\n    }", "label": 0}
{"code": "def clear_environment(mode = default_env)\n    case mode\n      when :posix\n        ENV.clear\n      when :windows\n        Puppet::Util::Windows::Process.get_environment_strings.each do |key, _|\n          Puppet::Util::Windows::Process.set_environment_variable(key, nil)\n        end\n      else\n        raise _(\"Unable to clear the environment for mode %{mode}\") % { mode: mode }\n    end\n  end", "label": 4}
{"code": "def define_and_assign_attr_accessors_for_each_filter(fp)\n      model_class.filterrific_available_filters.each do |filter_name|\n        self.class.send(:attr_accessor, filter_name)\n        v = fp[filter_name]\n        self.send(\"#{ filter_name }=\", v)  if v.present?\n      end\n    end", "label": 4}
{"code": "def ref=(cell_reference)\n      cell_reference = cell_reference.r if cell_reference.is_a?(Cell)\n      Axlsx::validate_string cell_reference\n      @ref = cell_reference\n    end", "label": 4}
{"code": "function submissions(req, res, next) {\n  var params = {\n    formId: req.params.id\n  };\n\n  logger.debug(\"Middleware: form submissions: \", {params: params});\n\n  forms.getSubmissions(req.connectionOptions, params, function(err, getSubmissionResponse) {\n    if (err) {\n      logger.error(\"Middleware: form submissions \", {error: err});\n    }\n    getSubmissionResponse = getSubmissionResponse || {};\n    req.appformsResultPayload = {\n      data: getSubmissionResponse.submissions,\n      type: constants.resultTypes.submissions\n    };\n\n    next(err);\n  });\n}", "label": 3}
{"code": "function (config, mockSrc) {\n    var mockManifestPath = path.join(process.cwd(), mockSrc,\n      mockManifestFilename),\n\n      // read manifest JSON by require'ing it\n      mockManifest = require(mockManifestPath),\n\n      // read files for default scenario first, so we can merge it into other\n      // scenarios later\n      defaultScenario = readScenario(config, mockSrc, [],\n        mockManifest._default, '_default');\n\n    // read files for each scenario\n    return _.mapValues(mockManifest, function (filenames, scenarioName) {\n      return readScenario(config, mockSrc, defaultScenario, filenames,\n        scenarioName);\n    });\n  }", "label": 3}
{"code": "def to_dict(self):\n        '''Return a dict representation of the macaroon data in JSON format.\n        @return a dict\n        '''\n        if self.version < VERSION_3:\n            if len(self._caveat_data) > 0:\n                raise ValueError('cannot serialize pre-version3 macaroon with '\n                                 'external caveat data')\n            return json.loads(self._macaroon.serialize(\n                json_serializer.JsonSerializer()))\n        serialized = {\n            'm': json.loads(self._macaroon.serialize(\n                json_serializer.JsonSerializer())),\n            'v': self._version,\n        }\n        if self._namespace is not None:\n            serialized['ns'] = self._namespace.serialize_text().decode('utf-8')\n        caveat_data = {}\n        for id in self._caveat_data:\n            key = base64.b64encode(id).decode('utf-8')\n            value = base64.b64encode(self._caveat_data[id]).decode('utf-8')\n            caveat_data[key] = value\n        if len(caveat_data) > 0:\n            serialized['cdata'] = caveat_data\n        return serialized", "label": 1}
{"code": "func (c *CertChecker) CheckCert(principal string, cert *ssh.Certificate) error {\n\terr := validate(cert)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn c.CertChecker.CheckCert(principal, cert)\n}", "label": 5}
{"code": "func (c *HoneycombClient) SendBatch(batch Batch) error {\n\tif len(batch) == 0 {\n\t\t// Nothing to send\n\t\treturn nil\n\t}\n\n\terrs := []string{}\n\tfor i := 0; i < len(batch); i += maxBatchSize {\n\t\toffset := i + maxBatchSize\n\t\tif offset > len(batch) {\n\t\t\toffset = len(batch)\n\t\t}\n\t\tif err := c.sendBatch(batch[i:offset]); err != nil {\n\t\t\terrs = append(errs, err.Error())\n\t\t}\n\t}\n\n\tif len(errs) > 0 {\n\t\treturn errors.New(strings.Join(errs, \"\\n\"))\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def calcMD5(path):\n    \"\"\"\n    calc MD5 based on path\n    \"\"\"\n    # check that file exists\n    if os.path.exists(path) is False:\n        yield False\n    else:\n        command = ['md5sum', path]\n        p = Popen(command, stdout = PIPE)\n        for line in p.communicate()[0].splitlines():\n            yield line.decode('ascii').strip().split()[0]\n        p.wait()\n        yield False", "label": 1}
{"code": "def create_modifier_option(location_id, modifier_list_id, body, opts = {})\n      data, _status_code, _headers = create_modifier_option_with_http_info(location_id, modifier_list_id, body, opts)\n      return data\n    end", "label": 4}
{"code": "function deleteRules(rulesToDelete, cb) {\n    var idsToRemove = _.pluck(rulesToDelete, \"_id\");\n\n    function deleteRule(fieldRuleId, cb1) {\n      rulesModel.findByIdAndRemove(fieldRuleId, cb1);\n    }\n    async.each(idsToRemove, deleteRule, cb);\n  }", "label": 3}
{"code": "def load_file(file_name)\n      File.open(file_name, \"r\") do |f|\n        f.each_line.collect do |line|\n          parse_json(line)\n        end\n      end\n    end", "label": 4}
{"code": "function ShaderAttribute(gl, program, location, dimension, name, constFunc, relink) {\n  this._gl = gl\n  this._program = program\n  this._location = location\n  this._dimension = dimension\n  this._name = name\n  this._constFunc = constFunc\n  this._relink = relink\n}", "label": 3}
{"code": "func (a *Allocator) checkConsistency(as string) {\n\tvar sKeyList []SubnetKey\n\n\t// Retrieve this address space's configuration and bitmasks from the datastore\n\ta.refresh(as)\n\ta.Lock()\n\taSpace, ok := a.addrSpaces[as]\n\ta.Unlock()\n\tif !ok {\n\t\treturn\n\t}\n\ta.updateBitMasks(aSpace)\n\n\taSpace.Lock()\n\tfor sk, pd := range aSpace.subnets {\n\t\tif pd.Range != nil {\n\t\t\tcontinue\n\t\t}\n\t\tsKeyList = append(sKeyList, sk)\n\t}\n\taSpace.Unlock()\n\n\tfor _, sk := range sKeyList {\n\t\ta.Lock()\n\t\tbm := a.addresses[sk]\n\t\ta.Unlock()\n\t\tif err := bm.CheckConsistency(); err != nil {\n\t\t\tlogrus.Warnf(\"Error while running consistency check for %s: %v\", sk, err)\n\t\t}\n\t}\n}", "label": 5}
{"code": "def plausible? rest, hints = {}\n      local, _, ndc, *rest = internal_split rest\n\n      # Element based checking.\n      #\n      # Note: ndc == false means the country has none.\n      #\n      return false if ndc.nil?\n      return false if ndc && ndc.empty?\n      return false if @invalid_ndcs && @invalid_ndcs === ndc\n\n      # # A valid range for the rest is 0 or 3+ total digits.\n      # #\n      # return false if (1..2) === rest_size\n\n      # National destination code plausible?\n      #\n      ndc_needed = hints[:ndc]\n      return false if ndc_needed && !(ndc_needed === ndc)\n      \n      # If there is no local part, we can assume it's not a plausible number.\n      # (Or, not defined correctly in Phony yet)\n      return false unless local\n\n      # Local code specific checks.\n      #\n      return local.plausible? rest, hints\n    end", "label": 4}
{"code": "public function setValue($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Debugger\\V2\\Breakpoint_Action::class);\n        $this->value = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def envelope(self, data, many):\n        \"\"\"Wrap result in envelope.\"\"\"\n        if not many:\n            return data\n\n        result = dict(\n            hits=dict(\n                hits=data,\n                total=self.context.get('total', len(data))\n            )\n        )\n\n        page = self.context.get('page')\n        if page:\n            links_pagination_factory = self.context.get(\n                'links_pagination_factory',\n                default_links_pagination_factory\n            )\n\n            urlkwargs = self.context.get('urlkwargs', {})\n\n            result['links'] = links_pagination_factory(page, urlkwargs)\n\n        return result", "label": 1}
{"code": "func delDummyLink(linkName string) error {\n\t// delete the vlan subinterface\n\tdummyLink, err := ns.NlHandle().LinkByName(linkName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to find link %s on the Docker host : %v\", linkName, err)\n\t}\n\t// verify a parent interface is being deleted\n\tif dummyLink.Attrs().ParentIndex != 0 {\n\t\treturn fmt.Errorf(\"link %s is not a parent dummy interface\", linkName)\n\t}\n\t// delete the ipvlan dummy device\n\tif err := ns.NlHandle().LinkDel(dummyLink); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete the dummy %s link: %v\", linkName, err)\n\t}\n\tlogrus.Debugf(\"Deleted a dummy parent link: %s\", linkName)\n\n\treturn nil\n}", "label": 5}
{"code": "public static void validate(final ArtifactQuery artifactQuery) {\n        final Pattern invalidChars = Pattern.compile(\"[^A-Fa-f0-9]\");\n        if(artifactQuery.getUser() == null ||\n        \t\tartifactQuery.getUser().isEmpty()){\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                    .entity(\"Mandatory field [user] missing\")\n                    .build());\n        }\n        if( artifactQuery.getStage() != 0 && artifactQuery.getStage() !=1 ){\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                    .entity(\"Invalid [stage] value (supported 0 | 1)\")\n                    .build());\n        }\n        if(artifactQuery.getName() == null ||\n        \t\tartifactQuery.getName().isEmpty()){\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                    .entity(\"Mandatory field [name] missing, it should be the file name\")\n                    .build());\n        }\n        if(artifactQuery.getSha256() == null ||\n                artifactQuery.getSha256().isEmpty()){\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                    .entity(\"Mandatory field [sha256] missing\")\n                    .build());\n        }\n        if(artifactQuery.getSha256().length() < 64 || invalidChars.matcher(artifactQuery.getSha256()).find()){\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                    .entity(\"Invalid file checksum value\")\n                    .build());\n        }\n        if(artifactQuery.getType() == null ||\n        \t\tartifactQuery.getType().isEmpty()){\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                    .entity(\"Mandatory field [type] missing\")\n                    .build());\n        }\n    }", "label": 0}
{"code": "def update_width(cell, fixed_width=nil, use_autowidth=true)\n      if fixed_width.is_a? Numeric\n       self.width = fixed_width\n      elsif use_autowidth\n       cell_width = cell.autowidth\n       self.width = cell_width unless (width || 0) > (cell_width || 0)\n      end \n    end", "label": 4}
{"code": "private function validateAuthorizationCode(\n        $authCodePayload,\n        ClientEntityInterface $client,\n        ServerRequestInterface $request\n    ) {\n        if (time() > $authCodePayload->expire_time) {\n            throw OAuthServerException::invalidRequest('code', 'Authorization code has expired');\n        }\n\n        if ($this->authCodeRepository->isAuthCodeRevoked($authCodePayload->auth_code_id) === true) {\n            throw OAuthServerException::invalidRequest('code', 'Authorization code has been revoked');\n        }\n\n        if ($authCodePayload->client_id !== $client->getIdentifier()) {\n            throw OAuthServerException::invalidRequest('code', 'Authorization code was not issued to this client');\n        }\n\n        // The redirect URI is required in this request\n        $redirectUri = $this->getRequestParameter('redirect_uri', $request, null);\n        if (empty($authCodePayload->redirect_uri) === false && $redirectUri === null) {\n            throw OAuthServerException::invalidRequest('redirect_uri');\n        }\n\n        if ($authCodePayload->redirect_uri !== $redirectUri) {\n            throw OAuthServerException::invalidRequest('redirect_uri', 'Invalid redirect URI');\n        }\n    }", "label": 2}
{"code": "func (r *BeeResource) Validate(context smolder.APIContext, data interface{}, request *restful.Request) error {\n\t//\tps := data.(*BeePostStruct)\n\t// FIXME\n\treturn nil\n}", "label": 5}
{"code": "public static spilloverpolicy_lbvserver_binding[] get(nitro_service service, String name) throws Exception{\n\t\tspilloverpolicy_lbvserver_binding obj = new spilloverpolicy_lbvserver_binding();\n\t\tobj.set_name(name);\n\t\tspilloverpolicy_lbvserver_binding response[] = (spilloverpolicy_lbvserver_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def set(self, name, value, overwrite=False):\n        \"\"\"\n        Sets a new value for a given configuration parameter.\n\n        If it already exists, an Exception is thrown.\n        To overwrite an existing value, set overwrite to True.\n\n        :param name: Unique name of the parameter\n        :param value: Value of the configuration parameter\n        :param overwrite: If true, an existing parameter of *name* gets overwritten without warning or exception.\n        :type overwrite: boolean\n        \"\"\"\n        if hasattr(self, name):\n            if overwrite:\n                setattr(self, name, value)\n            else:\n                self._log.warning(\"Configuration parameter %s exists and overwrite not allowed\" % name)\n                raise Exception(\"Configuration parameter %s exists and overwrite not allowed\" % name)\n        else:\n            setattr(self, name, value)\n        return getattr(self, name)", "label": 1}
{"code": "func (f *Fpdf) SetXY(x, y float64) {\n\tf.SetY(y)\n\tf.SetX(x)\n}", "label": 5}
{"code": "func Fault(msg string, fault types.BaseMethodFault) *soap.Fault {\n\tf := &soap.Fault{\n\t\tCode:   \"ServerFaultCode\",\n\t\tString: msg,\n\t}\n\n\tf.Detail.Fault = fault\n\n\treturn f\n}", "label": 5}
{"code": "def parse_request_headers(headers):\n    \"\"\"\n    convert headers in human readable format\n\n    :param headers:\n    :return:\n    \"\"\"\n    request_header_keys = set(headers.keys(lower=True))\n    request_meta_keys = set(XHEADERS_TO_ARGS_DICT.keys())\n    data_header_keys = request_header_keys.intersection(request_meta_keys)\n    return dict(([XHEADERS_TO_ARGS_DICT[key],\n                  headers.get(key, None)] for key in data_header_keys))", "label": 1}
{"code": "def set_updated_at\n      if Dynamoid::Config.timestamps && !updated_at_changed?\n        self.updated_at = DateTime.now.in_time_zone(Time.zone)\n      end\n    end", "label": 4}
{"code": "def kmeans_clustering(self, numc, X=None, npcs=15):\n        \"\"\"Performs k-means clustering.\n\n        Parameters\n        ----------\n        numc - int\n            Number of clusters\n\n        npcs - int, optional, default 15\n            Number of principal components to use as inpute for k-means\n            clustering.\n\n        \"\"\"\n\n        from sklearn.cluster import KMeans\n        if X is None:\n            D_sub = self.adata.uns['X_processed']\n            X = (\n                D_sub -\n                D_sub.mean(0)).dot(\n                self.adata.uns['pca_obj'].components_[\n                    :npcs,\n                    :].T)\n            save = True\n        else:\n            save = False\n\n        cl = KMeans(n_clusters=numc).fit_predict(Normalizer().fit_transform(X))\n\n        if save:\n            self.adata.obs['kmeans_clusters'] = pd.Categorical(cl)\n        else:\n            return cl", "label": 1}
{"code": "private function updateStatus()\n    {\n        if (isset($this->inputs['status']) && trim($this->inputs['status']) !== '') {\n            $this->connectToWhatsApp();\n            $this->wa->sendStatusUpdate($this->inputs['status']);\n            exit(json_encode([\n                'success'  => true,\n                'data'     => \"<br />Your status was updated to - <b>{$this->inputs['status']}</b>\",\n                'messages' => $this->messages,\n            ]));\n        } else {\n            exit(json_encode([\n                'success'  => false,\n                'errormsg' => 'There was no text in the submitted status box!',\n            ]));\n        }\n    }", "label": 2}
{"code": "public static policymap[] get(nitro_service service) throws Exception{\n\t\tpolicymap obj = new policymap();\n\t\tpolicymap[] response = (policymap[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def request(self, method, path=None, url_kwargs=None, **kwargs):\n        \"\"\"\n        Make a request against a container.\n\n        :param method:\n            The HTTP method to use.\n        :param list path:\n            The HTTP path (either absolute or relative).\n        :param dict url_kwargs:\n            Parameters to override in the generated URL. See `~hyperlink.URL`.\n        :param kwargs:\n            Any other parameters to pass to Requests.\n        \"\"\"\n        return self._session.request(\n            method, self._url(path, url_kwargs), **kwargs)", "label": 1}
{"code": "func (d Datastore) Open(ctx context.Context, name string) (*DatastoreFile, error) {\n\treturn &DatastoreFile{\n\t\td:      d,\n\t\tname:   name,\n\t\tlength: -1,\n\t\tctx:    ctx,\n\t}, nil\n}", "label": 5}
{"code": "private function waitUntilStopped(int $pid): void\n    {\n        $wait = 5000; // 5ms\n        $timeout = 1000000; // 1 sec\n        $elapsed = 0;\n        while (posix_getpgid($pid) !== false) {\n            usleep($wait);\n            $elapsed += $wait;\n            if ($elapsed > $timeout) {\n                throw new \\Exception('Timeout while waiting for PHP-FPM to stop');\n            }\n        }\n    }", "label": 2}
{"code": "def dihed_iter(self, g_nums, ats_1, ats_2, ats_3, ats_4, \\\n                                                    invalid_error=False):\n        \"\"\" Iterator over selected dihedral angles.\n\n        Angles are in degrees as with :meth:`dihed_single`.\n\n        See `above <toc-generators_>`_ for more information on\n        calling options.\n\n\n        Parameters\n        ----------\n        g_nums\n            |int| or iterable |int| or |None| --\n            Indices of the desired geometry\n\n        ats_1\n            |int| or iterable |int| or |None| --\n            Indices of the first atoms\n\n        ats_2\n            |int| or iterable |int| or |None| --\n            Indices of the second atoms\n\n        ats_3\n            |int| or iterable |int| or |None| --\n            Indices of the third atoms\n\n        ats_4\n            |int| or iterable |int| or |None| --\n            Indices of the fourth atoms\n\n        invalid_error\n            |bool|, optional --\n            If |False| (the default), |None| values are returned for\n            results corresponding to invalid indices. If |True|,\n            exceptions are raised per normal.\n\n        Yields\n        ------\n        dihed\n            |npfloat_| --\n            Out-of-plane/dihedral angles in degrees for the indicated\n            atom sets `ats_1`-`ats_2`-`ats_3`-`ats_4`, drawn from\n            the respective `g_nums`.\n\n        Raises\n        ------\n        ~exceptions.IndexError\n            If an invalid (out-of-range) `g_num` or `at_#` is provided.\n\n        ~exceptions.ValueError\n            If all iterable objects are not the same length.\n\n        ~exceptions.ValueError\n            If any corresponding `ats_#` indices are equal.\n\n        ~opan.error.XYZError\n            (typecode :data:`~opan.error.XYZError.DIHED`) If either\n            of the atom trios (1-2-3 or\n            2-3-4) is too close to linearity for any group of `ats_#`\n\n        \"\"\"\n        # Suitability of ats_n indices will be checked within the\n        #  self.dihed_single() calls and thus no check is needed here.\n\n        # Import the tuple-generating function\n        from .utils import pack_tups\n\n        # Print the function inputs if debug mode is on\n        if _DEBUG:   # pragma: no cover\n            print(\"g_nums = {0}\".format(g_nums))\n            print(\"ats_1 = {0}\".format(ats_1))\n            print(\"ats_2 = {0}\".format(ats_2))\n            print(\"ats_3 = {0}\".format(ats_3))\n            print(\"ats_4 = {0}\".format(ats_4))\n        ## end if\n\n        # Perform the None substitution\n        arglist = self._none_subst(g_nums, ats_1, ats_2, ats_3, ats_4)\n\n        # Expand/pack the tuples from the inputs\n        tups = pack_tups(*arglist)\n\n        # Dump the results if debug mode is on\n        if _DEBUG:   # pragma: no cover\n            print(tups)\n        ## end if\n\n        # Construct the generator using the packed tuples.\n        for tup in tups:\n            yield self._iter_return(tup, self.dihed_single, invalid_error)", "label": 1}
{"code": "func methodFilter(name string) (bool, error) {\n\tif ok, _ := regexp.MatchString(\"^Test\", name); !ok {\n\t\treturn false, nil\n\t}\n\treturn regexp.MatchString(*matchMethod, name)\n}", "label": 5}
{"code": "public void registerPrefixStatsRangePositionValue(String field, String prefix,\n      IndexOutput outPrefix) throws IOException {\n    initPrefixStatsField(field);\n    registerPrefix(field, prefix, outPrefix);\n    singlePositionPrefix.get(field).remove(prefix);\n    multiplePositionPrefix.get(field).add(prefix);\n  }", "label": 0}
{"code": "public function executeRequest($request)\n    {\n        $body = curl_exec($request);\n        $info = curl_getinfo($request);\n\n        curl_close($request);\n\n        $statusCode = $info['http_code'] === 0 ? 500 : $info['http_code'];\n\n        return new Response((string) $body, $statusCode, []);\n    }", "label": 2}
{"code": "protected boolean _load ()\r\n    {\r\n        java.sql.ResultSet rs = null;\r\n        try\r\n        {\r\n            // This synchronization is necessary for Oracle JDBC drivers 8.1.7, 9.0.1, 9.2.0.1\r\n            // The documentation says synchronization is done within the driver, but they\r\n            // must have overlooked something. Without the lock we'd get mysterious error\r\n            // messages.            \r\n            synchronized(getDbMeta())\r\n            {\r\n                getDbMetaTreeModel().setStatusBarMessage(\"Reading columns for table \" + getSchema().getCatalog().getCatalogName() + \".\" + getSchema().getSchemaName() + \".\" + getTableName());\r\n                rs = getDbMeta().getColumns(getSchema().getCatalog().getCatalogName(), \r\n                                                          getSchema().getSchemaName(),\r\n                                                          getTableName(), \"%\");\r\n                final java.util.ArrayList alNew = new java.util.ArrayList();\r\n                while (rs.next())\r\n                {\r\n                    alNew.add(new DBMetaColumnNode(getDbMeta(), getDbMetaTreeModel(), DBMetaTableNode.this, rs.getString(\"COLUMN_NAME\")));\r\n                }\r\n                alChildren = alNew;            \r\n                javax.swing.SwingUtilities.invokeLater(new Runnable()\r\n                {\r\n                    public void run()\r\n                    {\r\n                        getDbMetaTreeModel().nodeStructureChanged(DBMetaTableNode.this);\r\n                    }\r\n                });\r\n                rs.close();\r\n            }\r\n        }\r\n        catch (java.sql.SQLException sqlEx)\r\n        {\r\n            this.getDbMetaTreeModel().reportSqlError(\"Error retrieving columns\", sqlEx);\r\n            try\r\n            {\r\n                if (rs != null) rs.close ();\r\n            }\r\n            catch (java.sql.SQLException sqlEx2)\r\n            {\r\n                this.getDbMetaTreeModel().reportSqlError(\"Error retrieving columns\", sqlEx2);\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }", "label": 0}
{"code": "def adapter\n      unless @adapter_.value\n        adapter = self.class.adapter_plugin_class.new\n        adapter.connect! if adapter.respond_to?(:connect!)\n        @adapter_.compare_and_set(nil, adapter)\n        clear_cache!\n      end\n      @adapter_.value\n    end", "label": 4}
{"code": "public function setProcessingOptions($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\Job_ProcessingOptions::class);\n        $this->processing_options = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func (s *AuthServer) WithUserLock(username string, authenticateFn func() error) error {\n\tuser, err := s.Identity.GetUser(username)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tstatus := user.GetStatus()\n\tif status.IsLocked && status.LockExpires.After(s.clock.Now().UTC()) {\n\t\treturn trace.AccessDenied(\"%v exceeds %v failed login attempts, locked until %v\",\n\t\t\tuser.GetName(), defaults.MaxLoginAttempts, utils.HumanTimeFormat(status.LockExpires))\n\t}\n\tfnErr := authenticateFn()\n\tif fnErr == nil {\n\t\t// upon successful login, reset the failed attempt counter\n\t\terr = s.DeleteUserLoginAttempts(username)\n\t\tif !trace.IsNotFound(err) {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\n\t\treturn nil\n\t}\n\t// do not lock user in case if DB is flaky or down\n\tif trace.IsConnectionProblem(err) {\n\t\treturn trace.Wrap(fnErr)\n\t}\n\t// log failed attempt and possibly lock user\n\tattempt := services.LoginAttempt{Time: s.clock.Now().UTC(), Success: false}\n\terr = s.AddUserLoginAttempt(username, attempt, defaults.AttemptTTL)\n\tif err != nil {\n\t\tlog.Error(trace.DebugReport(err))\n\t\treturn trace.Wrap(fnErr)\n\t}\n\tloginAttempts, err := s.Identity.GetUserLoginAttempts(username)\n\tif err != nil {\n\t\tlog.Error(trace.DebugReport(err))\n\t\treturn trace.Wrap(fnErr)\n\t}\n\tif !services.LastFailed(defaults.MaxLoginAttempts, loginAttempts) {\n\t\tlog.Debugf(\"%v user has less than %v failed login attempts\", username, defaults.MaxLoginAttempts)\n\t\treturn trace.Wrap(fnErr)\n\t}\n\tlockUntil := s.clock.Now().UTC().Add(defaults.AccountLockInterval)\n\tmessage := fmt.Sprintf(\"%v exceeds %v failed login attempts, locked until %v\",\n\t\tusername, defaults.MaxLoginAttempts, utils.HumanTimeFormat(status.LockExpires))\n\tlog.Debug(message)\n\tuser.SetLocked(lockUntil, \"user has exceeded maximum failed login attempts\")\n\terr = s.Identity.UpsertUser(user)\n\tif err != nil {\n\t\tlog.Error(trace.DebugReport(err))\n\t\treturn trace.Wrap(fnErr)\n\t}\n\treturn trace.AccessDenied(message)\n}", "label": 5}
{"code": "def validate_pr!(cork, fail_if_no_pr)\n      unless EnvironmentManager.pr?(system_env)\n        ci_name = EnvironmentManager.local_ci_source(system_env).name.split(\"::\").last\n\n        msg = \"Not a #{ci_name} Pull Request - skipping `danger` run. \"\n        # circle won't run danger properly if the commit is pushed and build runs before the PR exists\n        # https://danger.systems/guides/troubleshooting.html#circle-ci-doesnt-run-my-build-consistently\n        # the best solution is to enable `fail_if_no_pr`, and then re-run the job once the PR is up\n        if ci_name == \"CircleCI\"\n          msg << \"If you only created the PR recently, try re-running your workflow.\"\n        end\n        cork.puts msg.strip.yellow\n\n        exit(fail_if_no_pr ? 1 : 0)\n      end\n    end", "label": 4}
{"code": "function(apiClient) {\n    this.apiClient = apiClient || ApiClient.instance;\n\n\n\n    /**\n     * Finds a phone service channel by id\n     * Finds a phone service channel by id\n     * @param {String} phoneServiceChannelId Phone service channel id\n     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PhoneServiceChannel}\n     */\n    this.findPhoneServiceChannel = function(phoneServiceChannelId) {\n      var postBody = null;\n\n      // verify the required parameter 'phoneServiceChannelId' is set\n      if (phoneServiceChannelId == undefined || phoneServiceChannelId == null) {\n        throw \"Missing the required parameter 'phoneServiceChannelId' when calling findPhoneServiceChannel\";\n      }\n\n\n      var pathParams = {\n        'phoneServiceChannelId': phoneServiceChannelId\n      };\n      var queryParams = {\n      };\n      var headerParams = {\n      };\n      var formParams = {\n      };\n\n      var authNames = ['basicAuth'];\n      var contentTypes = ['application/json;charset=utf-8'];\n      var accepts = ['application/json;charset=utf-8'];\n      var returnType = PhoneServiceChannel;\n\n      return this.apiClient.callApi(\n        '/phoneServiceChannels/{phoneServiceChannelId}', 'GET',\n        pathParams, queryParams, headerParams, formParams, postBody,\n        authNames, contentTypes, accepts, returnType\n      );\n    }\n\n\n    /**\n     * Lists phone service channels\n     * Lists phone service channels\n     * @param {Object} opts Optional parameters\n     * @param {String} opts.organizationId Organization id\n     * @param {String} opts.search Search channels by free-text query\n     * @param {String} opts.sortBy define order (NATURAL or SCORE). Default is NATURAL\n     * @param {String} opts.sortDir ASC or DESC. Default is ASC\n     * @param {Integer} opts.firstResult First result\n     * @param {Integer} opts.maxResults Max results\n     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/PhoneServiceChannel>}\n     */\n    this.listPhoneServiceChannels = function(opts) {\n      opts = opts || {};\n      var postBody = null;\n\n\n      var pathParams = {\n      };\n      var queryParams = {\n        'organizationId': opts['organizationId'],\n        'search': opts['search'],\n        'sortBy': opts['sortBy'],\n        'sortDir': opts['sortDir'],\n        'firstResult': opts['firstResult'],\n        'maxResults': opts['maxResults']\n      };\n      var headerParams = {\n      };\n      var formParams = {\n      };\n\n      var authNames = ['basicAuth'];\n      var contentTypes = ['application/json;charset=utf-8'];\n      var accepts = ['application/json;charset=utf-8'];\n      var returnType = [PhoneServiceChannel];\n\n      return this.apiClient.callApi(\n        '/phoneServiceChannels', 'GET',\n        pathParams, queryParams, headerParams, formParams, postBody,\n        authNames, contentTypes, accepts, returnType\n      );\n    }\n\n\n    /**\n     * Updates a channel\n     * Updates a service channel\n     * @param {String} phoneServiceChannelId phone channel id\n     * @param {module:model/PhoneServiceChannel} payload New phone service data\n     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PhoneServiceChannel}\n     */\n    this.updatePhoneServiceChannel = function(phoneServiceChannelId, payload) {\n      var postBody = payload;\n\n      // verify the required parameter 'phoneServiceChannelId' is set\n      if (phoneServiceChannelId == undefined || phoneServiceChannelId == null) {\n        throw \"Missing the required parameter 'phoneServiceChannelId' when calling updatePhoneServiceChannel\";\n      }\n\n      // verify the required parameter 'payload' is set\n      if (payload == undefined || payload == null) {\n        throw \"Missing the required parameter 'payload' when calling updatePhoneServiceChannel\";\n      }\n\n\n      var pathParams = {\n        'phoneServiceChannelId': phoneServiceChannelId\n      };\n      var queryParams = {\n      };\n      var headerParams = {\n      };\n      var formParams = {\n      };\n\n      var authNames = ['basicAuth'];\n      var contentTypes = ['application/json;charset=utf-8'];\n      var accepts = ['application/json;charset=utf-8'];\n      var returnType = PhoneServiceChannel;\n\n      return this.apiClient.callApi(\n        '/phoneServiceChannels/{phoneServiceChannelId}', 'PUT',\n        pathParams, queryParams, headerParams, formParams, postBody,\n        authNames, contentTypes, accepts, returnType\n      );\n    }\n  }", "label": 3}
{"code": "function DiscordJS(embed) {\n  if (embed.file) {\n    console.log('Files in embeds will not be sent.');\n    embed.file = undefined;\n  }\n  return {\n    'embeds': [\n      embed,\n    ],\n  };\n}", "label": 3}
{"code": "def subscribe_inbox\n      # double-check locking to reduce synchronization\n      if @subject_id.nil?\n        # nats lazy-load needs to be outside the synchronized block\n        client = nats\n        @lock.synchronize do\n          if @subject_id.nil?\n            @subject_id = client.subscribe(\"#{@inbox_name}.>\") do |message, _, subject|\n              @handled_response = true\n              handle_response(message, subject)\n            end\n          end\n        end\n      end\n    end", "label": 4}
{"code": "def TEST(fname):\n    \"\"\"\n    Test function to step through all functions in\n    order to try and identify all features on a map\n    This test function should be placed in a main \n    section later\n    \"\"\"\n    #fname = os.path.join(os.getcwd(), '..','..',  # os.path.join(os.path.getcwd(), '\n    m = MapObject(fname, os.path.join(os.getcwd(), 'img_prog_results'))\n    m.add_layer(ImagePathFollow('border'))\n    m.add_layer(ImagePathFollow('river'))\n    m.add_layer(ImagePathFollow('road'))\n    \n    m.add_layer(ImageArea('sea', col='Blue', density='light'))\n    m.add_layer(ImageArea('desert', col='Yellow', density='med'))\n    m.add_layer(ImageArea('forest', col='Drak Green', density='light'))\n    m.add_layer(ImageArea('fields', col='Green', density='light'))\n    \n    m.add_layer(ImageObject('mountains'))\n    m.add_layer(ImageObject('trees'))\n    m.add_layer(ImageObject('towns'))", "label": 1}
{"code": "def print_exception(current_location, exception, destination = nil)\n      if !exception.is_a?(SystemExit)\n        data = exception.backtrace_string(current_location)\n        if defined?(DebugLogging) && self.is_a?(DebugLogging)\n          error(data)\n        else\n          destination ||= STDERR\n          destination.puts(data)\n          destination.flush if destination.respond_to?(:flush)\n        end\n      end\n    end", "label": 4}
{"code": "public static String wordShape(String inStr, int wordShaper, Collection<String> knownLCWords) {\r\n    // this first bit is for backwards compatibility with how things were first\r\n    // implemented, where the word shaper name encodes whether to useLC.\r\n    // If the shaper is in the old compatibility list, then a specified\r\n    // list of knownLCwords is ignored\r\n    if (knownLCWords != null && dontUseLC(wordShaper)) {\r\n      knownLCWords = null;\r\n    }\r\n    switch (wordShaper) {\r\n      case NOWORDSHAPE:\r\n        return inStr;\r\n      case WORDSHAPEDAN1:\r\n        return wordShapeDan1(inStr);\r\n      case WORDSHAPECHRIS1:\r\n        return wordShapeChris1(inStr);\r\n      case WORDSHAPEDAN2:\r\n        return wordShapeDan2(inStr, knownLCWords);\r\n      case WORDSHAPEDAN2USELC:\r\n        return wordShapeDan2(inStr, knownLCWords);\r\n      case WORDSHAPEDAN2BIO:\r\n        return wordShapeDan2Bio(inStr, knownLCWords);\r\n      case WORDSHAPEDAN2BIOUSELC:\r\n        return wordShapeDan2Bio(inStr, knownLCWords);\r\n      case WORDSHAPEJENNY1:\r\n        return wordShapeJenny1(inStr, knownLCWords);\r\n      case WORDSHAPEJENNY1USELC:\r\n        return wordShapeJenny1(inStr, knownLCWords);\r\n      case WORDSHAPECHRIS2:\r\n        return wordShapeChris2(inStr, false, knownLCWords);\r\n      case WORDSHAPECHRIS2USELC:\r\n        return wordShapeChris2(inStr, false, knownLCWords);\r\n      case WORDSHAPECHRIS3:\r\n        return wordShapeChris2(inStr, true, knownLCWords);\r\n      case WORDSHAPECHRIS3USELC:\r\n        return wordShapeChris2(inStr, true, knownLCWords);\r\n      case WORDSHAPECHRIS4:\r\n        return wordShapeChris4(inStr, false, knownLCWords);\r\n      case WORDSHAPEDIGITS:\r\n        return wordShapeDigits(inStr);\r\n      default:\r\n        throw new IllegalStateException(\"Bad WordShapeClassifier\");\r\n    }\r\n  }", "label": 0}
{"code": "def __get_float(section, name):\n    \"\"\"Get the forecasted float from json section.\"\"\"\n    try:\n        return float(section[name])\n    except (ValueError, TypeError, KeyError):\n        return float(0)", "label": 1}
{"code": "public static <E> IntCounter<E> toRankCounter(Counter<E> c) {\r\n    IntCounter<E> rankCounter = new IntCounter<E>();\r\n    List<E> sortedList = toSortedList(c);\r\n    for (int i = 0; i < sortedList.size(); i++) {\r\n      rankCounter.setCount(sortedList.get(i), i);\r\n    }\r\n    return rankCounter;\r\n  }", "label": 0}
{"code": "public String format(final LoggingEvent event) {\n\t\tfinal StringBuffer buf = new StringBuffer();\n\t\tfor (PatternConverter c = head; c != null; c = c.next) {\n\t\t\tc.format(buf, event);\n\t\t}\n\t\treturn buf.toString();\n\t}", "label": 0}
{"code": "function(theDialog) {\n            var body = $('body');\n            var blockout = $('<div class=\"modalBlockout\"></div>')\n                .css({ 'z-index': dialog.getNextZIndex(), 'opacity': this.blockoutOpacity })\n                .appendTo(body);\n\n            var host = $('<div class=\"modalHost\"></div>')\n                .css({ 'z-index': dialog.getNextZIndex() })\n                .appendTo(body);\n\n            theDialog.host = host.get(0);\n            theDialog.blockout = blockout.get(0);\n\n            if (!dialog.isOpen()) {\n                theDialog.oldBodyMarginRight = body.css(\"margin-right\");\n                theDialog.oldInlineMarginRight = body.get(0).style.marginRight;\n\n                var html = $(\"html\");\n                var oldBodyOuterWidth = body.outerWidth(true);\n                var oldScrollTop = html.scrollTop();\n                $(\"html\").css(\"overflow-y\", \"hidden\");\n                var newBodyOuterWidth = $(\"body\").outerWidth(true);\n                body.css(\"margin-right\", (newBodyOuterWidth - oldBodyOuterWidth + parseInt(theDialog.oldBodyMarginRight, 10)) + \"px\");\n                html.scrollTop(oldScrollTop); // necessary for Firefox\n            }\n        }", "label": 3}
{"code": "public static int Minimum(ImageSource fastBitmap, int startX, int startY, int width, int height) {\r\n        int min = 255;\r\n        if (fastBitmap.isGrayscale()) {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getRGB(j, i);\r\n                    if (gray < min) {\r\n                        min = gray;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = startX; i < height; i++) {\r\n                for (int j = startY; j < width; j++) {\r\n                    int gray = fastBitmap.getG(j, i);\r\n                    if (gray < min) {\r\n                        min = gray;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }", "label": 0}
{"code": "func NewStaticTokens(spec StaticTokensSpecV2) (StaticTokens, error) {\n\tst := StaticTokensV2{\n\t\tKind:    KindStaticTokens,\n\t\tVersion: V2,\n\t\tMetadata: Metadata{\n\t\t\tName:      MetaNameStaticTokens,\n\t\t\tNamespace: defaults.Namespace,\n\t\t},\n\t\tSpec: spec,\n\t}\n\tif err := st.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn &st, nil\n}", "label": 5}
{"code": "function generateFieldHeader(field, headerName, fieldRepeatIndex) {\n  var csv = '';\n  //If the field is repeating, the structure of the header is different\n  if (_.isNumber(fieldRepeatIndex)) {\n    //If it is a file type field, need to add two fields for the file name and url\n    if (fieldTypeUtils.isFileType(field.type)) {\n      csv += csvStr(headerName + '-' + (fieldRepeatIndex + 1) + \"-name\") + \",\";\n      csv += csvStr(headerName + '-' + (fieldRepeatIndex + 1) + \"-url\");\n    } else if (fieldTypeUtils.isBarcodeType(field.type)) {\n      //If it is a barcode type field, need to add two fields for the format name and text\n      csv += csvStr(headerName + '-' + (fieldRepeatIndex + 1) + \"-format\") +\n        \",\";\n      csv += csvStr(headerName + '-' + (fieldRepeatIndex + 1) + \"-text\");\n    } else {\n      //Otherwise, just append the index.\n      csv += csvStr(headerName + '-' + (fieldRepeatIndex + 1));\n    }\n  } else {\n    //If it is a file type field, need to add two fields for the file name and url\n    if (fieldTypeUtils.isFileType(field.type)) {\n      csv += csvStr(headerName + \"-name\") + \",\";\n      csv += csvStr(headerName + \"-url\");\n    } else if (fieldTypeUtils.isBarcodeType(field.type)) {\n      //If it is a barcode type field, need to add two fields for the format name and text\n      csv += csvStr(headerName + \"-format\") + \",\";\n      csv += csvStr(headerName + \"-text\");\n    } else {\n      csv += csvStr(headerName);\n    }\n  }\n\n  return csv;\n}", "label": 3}
{"code": "public function createDerivedFiles(Media $media, array $only = [], $onlyIfMissing = false)\n    {\n        $profileCollection = ConversionCollection::createForMedia($media);\n\n        if (! empty($only)) {\n            $profileCollection = $profileCollection->filter(function ($collection) use ($only) {\n                return in_array($collection->getName(), $only);\n            });\n        }\n\n        $this->performConversions(\n            $profileCollection->getNonQueuedConversions($media->collection_name),\n            $media,\n            $onlyIfMissing\n        );\n\n        $queuedConversions = $profileCollection->getQueuedConversions($media->collection_name);\n\n        if ($queuedConversions->isNotEmpty()) {\n            $this->dispatchQueuedConversions($media, $queuedConversions);\n        }\n    }", "label": 2}
{"code": "func valueRange(a, b, base int) []int {\n\tvalue := make([]int, absoluteOverBreakpoint(a, b, base)+1)\n\ti := 0\n\tfor ; a != b; a++ {\n\t\tif a == base {\n\t\t\ta = 0\n\t\t}\n\t\tvalue[i] = a\n\t\ti++\n\t}\n\tvalue[i] = a\n\treturn value\n}", "label": 5}
{"code": "func (i *Handle) DelDestination(s *Service, d *Destination) error {\n\treturn i.doCmd(s, d, ipvsCmdDelDest)\n}", "label": 5}
{"code": "def loads(string, filename=None, includedir=''):\n    '''Load the contents of ``string`` to a Python object\n\n    The returned object is a subclass of ``dict`` that exposes string keys as\n    attributes as well.\n\n    Example:\n\n        >>> config = libconf.loads('window: { title: \"libconfig example\"; };')\n        >>> config['window']['title']\n        'libconfig example'\n        >>> config.window.title\n        'libconfig example'\n    '''\n\n    try:\n        f = io.StringIO(string)\n    except TypeError:\n        raise TypeError(\"libconf.loads() input string must by unicode\")\n\n    return load(f, filename=filename, includedir=includedir)", "label": 1}
{"code": "def extract_group_data_criteria_tree(conjunction, preconditions, type, parent_id)\n      \n      children = []\n      preconditions.each do |precondition|\n        if (precondition.comparison?) \n          if (precondition.reference.id == HQMF::Document::MEASURE_PERIOD_ID)\n            children << measure_period_criteria\n          else\n            children << v2_data_criteria_by_id[precondition.reference.id]\n          end\n        else\n          converted_conjunction = convert_grouping_conjunction(precondition.conjunction_code) \n          children << extract_group_data_criteria_tree(converted_conjunction, precondition.preconditions, type, parent_id)\n        end\n      end\n      \n      # if we have just one child element, just return it.  An AND or OR of a single item is not useful.\n      if (children.size > 1)\n        build_group_data_criteria(children, type, parent_id, conjunction)\n      else\n        children.first\n      end\n      \n    end", "label": 4}
{"code": "public static function createSerializer(Service $api, $endpoint)\n    {\n        static $mapping = [\n            'json'      => 'Aws\\Api\\Serializer\\JsonRpcSerializer',\n            'query'     => 'Aws\\Api\\Serializer\\QuerySerializer',\n            'rest-json' => 'Aws\\Api\\Serializer\\RestJsonSerializer',\n            'rest-xml'  => 'Aws\\Api\\Serializer\\RestXmlSerializer'\n        ];\n\n        $proto = $api->getProtocol();\n\n        if (isset($mapping[$proto])) {\n            return new $mapping[$proto]($api, $endpoint);\n        }\n\n        if ($proto == 'ec2') {\n            return new QuerySerializer($api, $endpoint, new Ec2ParamBuilder());\n        }\n\n        throw new \\UnexpectedValueException(\n            'Unknown protocol: ' . $api->getProtocol()\n        );\n    }", "label": 2}
{"code": "public List<CRFCliqueTree> getCliqueTrees(String filename, DocumentReaderAndWriter<IN> readerAndWriter) {\r\n    // only for the OCR data does this matter\r\n    flags.ocrTrain = false;\r\n\r\n    List<CRFCliqueTree> cts = new ArrayList<CRFCliqueTree>();\r\n    ObjectBank<List<IN>> docs = makeObjectBankFromFile(filename, readerAndWriter);\r\n    for (List<IN> doc : docs) {\r\n      cts.add(getCliqueTree(doc));\r\n    }\r\n\r\n    return cts;\r\n  }", "label": 0}
{"code": "func (p *TerminalParams) Winsize() *term.Winsize {\n\treturn &term.Winsize{\n\t\tWidth:  uint16(p.W),\n\t\tHeight: uint16(p.H),\n\t}\n}", "label": 5}
{"code": "def keys(pattern = SCAN_PATTERN, count = DEFAULT_COUNT)\n      return redis(&:keys) if pattern.nil?\n\n      redis { |conn| conn.scan_each(match: prefix(pattern), count: count).to_a }\n    end", "label": 4}
{"code": "func (m *DatastoreFileManager) Path(name string) *DatastorePath {\n\tvar p DatastorePath\n\n\tif !p.FromString(name) {\n\t\tp.Path = name\n\t\tp.Datastore = m.Datastore.Name()\n\t}\n\n\treturn &p\n}", "label": 5}
{"code": "private boolean contains(ArrayList defs, DefBase obj)\r\n    {\r\n        for (Iterator it = defs.iterator(); it.hasNext();)\r\n        {\r\n            if (obj.getName().equals(((DefBase)it.next()).getName()))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }", "label": 0}
{"code": "def upgrade_config(self, contents):\n        \"\"\"Process config contents with cdrouter-cli -upgrade-config.\n\n        :param contents: Config contents as string.\n        :return: :class:`configs.UpgradeConfig <configs.UpgradeConfig>` object\n        :rtype: configs.UpgradeConfig\n        \"\"\"\n        schema = UpgradeConfigSchema()\n        resp = self.service.post(self.base,\n                                 params={'process': 'upgrade'}, json={'contents': contents})\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "func (m *Model) Remove() {\n\tfor _, dir := range m.dirs {\n\t\t_ = os.RemoveAll(dir)\n\t}\n}", "label": 5}
{"code": "function convertObjectCell (cell) {\n  return _.chain(cell.rows)\n  .map(rowsToCells)\n  .assign(_.pick(cell, CARRY_OVER_PROPERTIES))\n  .value()\n}", "label": 3}
{"code": "def render_liquid(content, payload, info, path)\n      _renderer.render_liquid(content, payload, info, path)\n    end", "label": 4}
{"code": "def define_touchable!(association)\n      name = association.name\n      method_name = define_relation_touch_method(name, association)\n      association.inverse_class.tap do |klass|\n        klass.after_save method_name\n        klass.after_destroy method_name\n        klass.after_touch method_name\n      end\n    end", "label": 4}
{"code": "function Message (data, headers, deliveryInfo) {\n        assert.object(data);\n        assert.object(headers);\n        assert.object(deliveryInfo);\n\n        this.data = Message.factory(data, deliveryInfo.type);\n        this.headers = headers;\n        this.deliveryInfo = deliveryInfo;\n    }", "label": 3}
{"code": "def basic_auth(opts)\n      user = opts.fetch :user\n      pass = opts.fetch :pass\n\n      auth(\"Basic \" + Base64.strict_encode64(\"#{user}:#{pass}\"))\n    end", "label": 4}
{"code": "async def dump_message(obj, msg, field_archiver=None):\n    \"\"\"\n    Dumps message to the object.\n    Returns message popo representation.\n\n    :param obj:\n    :param msg:\n    :param field_archiver:\n    :return:\n    \"\"\"\n    mtype = msg.__class__\n    fields = mtype.f_specs()\n\n    obj = collections.OrderedDict() if obj is None else get_elem(obj)\n    for field in fields:\n        await dump_message_field(obj, msg=msg, field=field, field_archiver=field_archiver)\n    return obj", "label": 1}
{"code": "def _read_tags(self):\n        \"\"\"\n        Fill in the _tags dict from the tags file.\n\n        Args:\n            None\n\n        Returns:\n            True\n\n        Todo:\n            Figure what could go wrong and at least acknowledge the\n            the fact that Murphy was an optimist.\n        \"\"\"\n        tags = self._config.get('tags', {})\n        logging.info('Tags:')\n        for tag_name in tags.keys():\n            tag = {}\n            tag['Key'] = tag_name\n            tag['Value'] = tags[tag_name]\n            self._tags.append(tag)\n            logging.info('{} = {}'.format(tag_name, tags[tag_name]))\n\n        logging.debug(json.dumps(\n            self._tags,\n            indent=2,\n            sort_keys=True\n        ))\n        return True", "label": 1}
{"code": "def clone_submodule(repo, fetch_options)\n      # the remote was just added by setup_add, no need to check presence\n      repo.remotes['origin'].fetch(fetch_options)\n\n      repo.branches.create('master','origin/master')\n      repo.branches['master'].upstream = repo.branches['origin/master']\n\n      repo.checkout_head(strategy: :force)\n    end", "label": 4}
{"code": "def script(inbox, cfg):\n    \"\"\"\n    Execute arbitrary scripts. \n\n    Arguments:\n    \n      - cfg(``dict``) script configuartion dictionary\n\n    \"\"\"\n    script_name = cfg[\"id\"]\n    script_id = str(abs(hash((cfg[\"id\"],) + tuple(inbox[0].values()))))[0:8]\n    # LOG.log(mp.DEFAULT, \"@papy;script %s:%s started\" % (script_name, script_id))\n    # LOG.log(mp.SUBDEFAULT, \"@papy;%s:%s received: %s\" % (script_name, script_id, inbox))\n    args = {}\n    args[\"params\"] = dict(cfg[\"params\"])\n    args[\"in\"] = {}\n    for in_port in cfg[\"in\"]:\n        for inin_ports in inbox:\n            in_path = inin_ports.get(in_port, None)\n            if (in_path is not None):\n                # first matching input-output (including type) port is linked remaining ignored\n                args[\"in\"][in_port] = in_path\n                break\n    # check that all input ports are connected\n    if len(args[\"in\"]) < len(cfg[\"in\"]):\n        raise Exception(\"not all in_ports connected, got: %s\" % (args[\"in\"],))\n    # create output file for out_ports\n    args[\"out\"] = {}\n    out = {}\n    for i, (out_port, out_ext) in enumerate(cfg[\"out\"]):\n        if cfg[\"in\"] == tuple(out_port_ for out_port_, _ in cfg[\"out\"]):\n            pfx = args[\"in\"][cfg[\"in\"][i]].split(\"/\")[-1].split(\".\")[0] + \"_\"\n            base = cfg[\"id\"]\n        else:\n            pfx = args[\"in\"][cfg[\"in\"][0]].split(\"/\")[-1].split(\".\")[0] + \"_\"\n            base = cfg[\"id\"] + \"-\" + out_port \n        if out_ext:\n            out_path = cfg[\"dir\"] + \"/\" + pfx + base + \".\" + out_ext\n        else:\n            out_path = cfg[\"dir\"] + \"/\" + pfx + base\n        args[\"out\"][out_port] = out_path\n        out[out_port] = out_path\n    # evaluate and check for errors\n    ret = _eval_script(cfg[\"evaluator\"], cfg[\"preamble\"], cfg[\"dir\"], cfg[\"executable\"], cfg[\"script\"], args)\n    if ret[0] != 0:\n        # LOG.error(\"@papy;%s:%s %s:%s:%s\" % (script_name, script_id, ret[0], \n        #                                                              ret[1].replace(\"\\n\", \"<br>\"), \n        #                                                              ret[2].replace(\"\\n\", \"<br>\")))\n        raise Exception(ret[0], cfg[\"script\"], ret[1], ret[2])\n    #LOG.log(mp.SUBDEFAULT, \"@papy;%s:%s produced:%s\" % (script_name, script_id, out))\n    #LOG.log(mp.DEFAULT, \"@papy;script %s:%s finished\" % (script_name, script_id))\n    return out", "label": 1}
{"code": "func (r RoleMap) Equals(o RoleMap) bool {\n\tif len(r) != len(o) {\n\t\treturn false\n\t}\n\tfor i := range r {\n\t\tif !r[i].Equals(o[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "label": 5}
{"code": "public function contains($element)\n    {\n        if ($this->isInitialized()) {\n            return $this->collection->contains($element);\n        }\n\n        return $this->entityPersister->exists($element, $this->criteria);\n    }", "label": 2}
{"code": "func (c *Client) RegisterUsingToken(req RegisterUsingTokenRequest) (*PackedKeys, error) {\n\tif err := req.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tout, err := c.PostJSON(c.Endpoint(\"tokens\", \"register\"), req)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvar keys PackedKeys\n\tif err := json.Unmarshal(out.Bytes(), &keys); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn &keys, nil\n}", "label": 5}
{"code": "def users\n      if text?\n        @server.online_members(include_idle: true).select { |u| u.can_read_messages? self }\n      elsif voice?\n        @server.voice_states.map { |id, voice_state| @server.member(id) if !voice_state.voice_channel.nil? && voice_state.voice_channel.id == @id }.compact\n      end\n    end", "label": 4}
{"code": "def basic_status_and_output(messages)\n      status =\n        if messages.any? { |message| message.type == :error }\n          :fail\n        elsif messages.any? { |message| message.type == :warning }\n          :warn\n        else\n          :pass\n        end\n\n      output = ''\n      if messages.any?\n        output += messages.join(\"\\n\") + \"\\n\"\n      end\n\n      [status, output]\n    end", "label": 4}
{"code": "function render(lexed) {\n    // Options to parser\n    var options = Object.create(kramed.defaults);\n    options.renderer = renderer();\n\n    if(!lexed.links) {\n        lexed.links = {};\n    }\n\n    return kramed.parser(lexed, options);\n}", "label": 3}
{"code": "func (f *DatastoreFile) TailFunc(lines int, include func(line int, message string) bool) error {\n\t// Read the file in reverse using bsize chunks\n\tconst bsize = int64(1024 * 16)\n\n\tfsize, err := f.Seek(0, io.SeekEnd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif lines == 0 {\n\t\treturn nil\n\t}\n\n\tchunk := int64(-1)\n\n\tbuf := bytes.NewBuffer(make([]byte, 0, bsize))\n\tline := 0\n\n\tfor {\n\t\tvar eof bool\n\t\tvar pos int64\n\n\t\tnread := bsize\n\n\t\toffset := chunk * bsize\n\t\tremain := fsize + offset\n\n\t\tif remain < 0 {\n\t\t\tif pos, err = f.Seek(0, io.SeekStart); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tnread = bsize + remain\n\t\t\teof = true\n\t\t} else if pos, err = f.Seek(offset, io.SeekEnd); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err = io.CopyN(buf, f, nread); err != nil {\n\t\t\tif err != io.EOF {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tb := buf.Bytes()\n\t\tidx, done := lastIndexLines(b, &line, include)\n\n\t\tif done {\n\t\t\tif chunk == -1 {\n\t\t\t\t// We found all N lines in the last chunk of the file.\n\t\t\t\t// The seek offset is also now at the current end of file.\n\t\t\t\t// Save this buffer to avoid another GET request when Read() is called.\n\t\t\t\tbuf.Next(int(idx + 1))\n\t\t\t\tf.buf = buf\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif _, err = f.Seek(pos+idx+1, io.SeekStart); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tif eof {\n\t\t\tif remain < 0 {\n\t\t\t\t// We found < N lines in the entire file, so seek to the start.\n\t\t\t\t_, _ = f.Seek(0, io.SeekStart)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tchunk--\n\t\tbuf.Reset()\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def i3():\n    '''Install and customize the tiling window manager i3.'''\n    install_package('i3')\n    install_file_legacy(path='~/.i3/config', username=env.user, repos_dir='repos')\n\n    # setup: hide the mouse if not in use\n    # in ~/.i3/config: 'exec /home/<USERNAME>/repos/hhpc/hhpc -i 10 &'\n    install_packages(['make', 'pkg-config', 'gcc', 'libc6-dev', 'libx11-dev'])\n    checkup_git_repo_legacy(url='https://github.com/aktau/hhpc.git')\n    run('cd ~/repos/hhpc  &&  make')", "label": 1}
{"code": "func (this *sinkManager) ExportData(data *core.DataBatch) {\n\tvar wg sync.WaitGroup\n\tfor _, sh := range this.sinkHolders {\n\t\twg.Add(1)\n\t\tgo func(sh sinkHolder, wg *sync.WaitGroup) {\n\t\t\tdefer wg.Done()\n\t\t\tglog.V(2).Infof(\"Pushing data to: %s\", sh.sink.Name())\n\t\t\tselect {\n\t\t\tcase sh.dataBatchChannel <- data:\n\t\t\t\tglog.V(2).Infof(\"Data push completed: %s\", sh.sink.Name())\n\t\t\t\t// everything ok\n\t\t\tcase <-time.After(this.exportDataTimeout):\n\t\t\t\tglog.Warningf(\"Failed to push data to sink: %s\", sh.sink.Name())\n\t\t\t}\n\t\t}(sh, &wg)\n\t}\n\t// Wait for all pushes to complete or timeout.\n\twg.Wait()\n}", "label": 5}
{"code": "private function buildHeaders($key, $keySHA256, $useCopySourceHeaders)\n    {\n        if ($key) {\n            $headerNames = $useCopySourceHeaders\n                ? $this->copySourceEncryptionHeaderNames\n                : $this->encryptionHeaderNames;\n\n            if (!$keySHA256) {\n                $decodedKey = base64_decode($key);\n                $keySHA256 = base64_encode(hash('SHA256', $decodedKey, true));\n            }\n\n            return [\n                $headerNames['algorithm'] => 'AES256',\n                $headerNames['key'] => $key,\n                $headerNames['keySHA256'] => $keySHA256\n            ];\n        }\n\n        return [];\n    }", "label": 2}
{"code": "private Class[] getInterfaces(Class clazz) {\r\n        Class superClazz = clazz;\r\n        Class[] interfaces = clazz.getInterfaces();\r\n\r\n        // clazz can be an interface itself and when getInterfaces()\r\n        // is called on an interface it returns only the extending\r\n        // interfaces, not the interface itself.\r\n        if (clazz.isInterface()) {\r\n            Class[] tempInterfaces = new Class[interfaces.length + 1];\r\n            tempInterfaces[0] = clazz;\r\n\r\n            System.arraycopy(interfaces, 0, tempInterfaces, 1, interfaces.length);\r\n            interfaces = tempInterfaces;\r\n        }\r\n\r\n        // add all interfaces implemented by superclasses to the interfaces array\r\n        while ((superClazz = superClazz.getSuperclass()) != null) {\r\n            Class[] superInterfaces = superClazz.getInterfaces();\r\n            Class[] combInterfaces = new Class[interfaces.length + superInterfaces.length];\r\n            System.arraycopy(interfaces, 0, combInterfaces, 0, interfaces.length);\r\n            System.arraycopy(superInterfaces, 0, combInterfaces, interfaces.length, superInterfaces.length);\r\n            interfaces = combInterfaces;\r\n        }\r\n\r\n        /**\r\n         * Must remove duplicate interfaces before calling Proxy.getProxyClass().\r\n         * Duplicates can occur if a subclass re-declares that it implements\r\n         * the same interface as one of its ancestor classes.\r\n         **/\r\n        HashMap unique = new HashMap();\r\n        for (int i = 0; i < interfaces.length; i++) {\r\n            unique.put(interfaces[i].getName(), interfaces[i]);\r\n        }\r\n        /* Add the OJBProxy interface as well */\r\n        unique.put(OJBProxy.class.getName(), OJBProxy.class);\r\n\r\n        interfaces = (Class[])unique.values().toArray(new Class[unique.size()]);\r\n\r\n        return interfaces;\r\n    }", "label": 0}
{"code": "def get(self, signal=None, plugin=None):\n        \"\"\"\n        Get one or more signals.\n\n        :param signal: Name of the signal\n        :type signal: str\n        :param plugin: Plugin object, under which the signals where registered\n        :type plugin: GwBasePattern\n        \"\"\"\n        if plugin is not None:\n            if signal is None:\n                signals_list = {}\n                for key in self.signals.keys():\n                    if self.signals[key].plugin == plugin:\n                        signals_list[key] = self.signals[key]\n                return signals_list\n            else:\n                if signal in self.signals.keys():\n                    if self.signals[signal].plugin == plugin:\n                        return self.signals[signal]\n                    else:\n                        return None\n                else:\n                    return None\n        else:\n            if signal is None:\n                return self.signals\n            else:\n                if signal in self.signals.keys():\n                    return self.signals[signal]\n                else:\n                    return None", "label": 1}
{"code": "def append_label(solr_doc, solr_field_key, field_info, val)\n        ActiveFedora::Indexing::Inserter.create_and_insert_terms(solr_field_key,\n                                                                 val,\n                                                                 field_info.behaviors, solr_doc)\n        ActiveFedora::Indexing::Inserter.create_and_insert_terms(\"#{solr_field_key}_label\",\n                                                                 val,\n                                                                 field_info.behaviors, solr_doc)\n      end", "label": 4}
{"code": "function parseData(options) {\n  return readFileTree(options.src.data, options.keys.data, options);\n}", "label": 3}
{"code": "def clear_query_caches_for_current_thread\n      ActiveRecord::Base.connection_handlers.each_value do |handler|\n        handler.connection_pool_list.each do |pool|\n          pool.connection.clear_query_cache if pool.active_connection?\n        end\n      end\n    end", "label": 4}
{"code": "function (char) {\n                var\n                    parsedItem = this._lastItem();\n                if (\"*\" === char) {\n                    parsedItem._min = 0;\n                    parsedItem._max = 0;\n                } else if (\"+\" === char) {\n                    parsedItem._max = 0;\n                } else if (\"?\" === char) {\n                    parsedItem._min = 0;\n                }\n                return PatternItem.PARSE_PROCESSED;\n            }", "label": 3}
{"code": "public function setRecordingDeviceType($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Speech\\V1p1beta1\\RecognitionMetadata_RecordingDeviceType::class);\n        $this->recording_device_type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def _transform(self, value):\n        \"\"\" Applies any defined transformation to the given value\n        \"\"\"\n        if self.transform:\n            try:\n                value = self.transform(value)\n            except:\n                import sys\n                exc_type, exc_obj, exc_tb = sys.exc_info()\n                raise AssertionError('Error applying transformation <{0}>: {2}: {3}'.format(\n                    self.transform.__name__, value, exc_type.__name__, exc_obj))\n\n        return value", "label": 1}
{"code": "func (s *AccessService) CreateRole(role services.Role) error {\n\tvalue, err := services.GetRoleMarshaler().MarshalRole(role)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\titem := backend.Item{\n\t\tKey:     backend.Key(rolesPrefix, role.GetName(), paramsPrefix),\n\t\tValue:   value,\n\t\tExpires: role.Expiry(),\n\t}\n\n\t_, err = s.Create(context.TODO(), item)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "func (c *CertAuthID) Check() error {\n\tif err := c.Type.Check(); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tif strings.TrimSpace(c.DomainName) == \"\" {\n\t\treturn trace.BadParameter(\"identity validation error: empty domain name\")\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def show(title, lst, full=-1):\n    \"\"\"\n    for testing, simply shows a list details\n    \"\"\"\n    txt = title + ' (' + str(len(lst)) + ') items :\\n '\n    num = 0\n    for i in lst:\n        if full == -1 or num < full:\n            if type(i) is str:\n                txt = txt + i + ',\\n '\n            else:\n                txt = txt + i + ', ['\n                for j in i:\n                    txt = txt + j + ', '\n                txt = txt + ']\\n'\n        num = num + 1\n    try:\n        print(txt)\n    except Exception as ex:\n        print('index.show() - cant print line, error ' + str(ex))", "label": 1}
{"code": "func PIt(text string, _ ...interface{}) bool {\n\tglobalSuite.PushItNode(text, func() {}, types.FlagTypePending, codelocation.New(1), 0)\n\treturn true\n}", "label": 5}
{"code": "def phone_match_data?(phone, data, possible = false)\n      country_code = \"#{data[Core::COUNTRY_CODE]}\"\n      inter_prefix = \"(#{data[Core::INTERNATIONAL_PREFIX]})?\"\n      return unless phone.match cr(\"^0{2}?#{inter_prefix}#{country_code}\")\n\n      type = possible ? Core::POSSIBLE_PATTERN : Core::VALID_PATTERN\n      phone.match full_regex_for_data(data, type, false)\n    end", "label": 4}
{"code": "public function hasOne($model, $serializer, $relation = null)\n    {\n        return $this->buildRelationship($model, $serializer, $relation);\n    }", "label": 2}
{"code": "def run_plugins(safe = false, attribute_filter = nil)\n      begin\n        @provides_map.all_plugins(attribute_filter).each do |plugin|\n          @runner.run_plugin(plugin)\n        end\n      rescue Ohai::Exceptions::AttributeNotFound, Ohai::Exceptions::DependencyCycle => e\n        logger.error(\"Encountered error while running plugins: #{e.inspect}\")\n        raise\n      end\n      critical_failed = Ohai::Config.ohai[:critical_plugins] & @runner.failed_plugins\n      unless critical_failed.empty?\n        msg = \"The following Ohai plugins marked as critical failed: #{critical_failed}\"\n        if @cli\n          logger.error(msg)\n          exit(true)\n        else\n          raise Ohai::Exceptions::CriticalPluginFailure, \"#{msg}. Failing Chef run.\"\n        end\n      end\n\n      # Freeze all strings.\n      freeze_strings!\n    end", "label": 4}
{"code": "def serializable_hash(options = nil)\n      options ||= {}\n\n      attribute_names = attributes.keys\n      if only = options[:only]\n        attribute_names &= Array(only).map(&:to_s)\n      elsif except = options[:except]\n        attribute_names -= Array(except).map(&:to_s)\n      end\n\n      hash = {}\n      attribute_names.each { |n| hash[n] = read_attribute_for_serialization(n) }\n\n      Array(options[:methods]).each { |m| hash[m.to_s] = send(m) }\n\n      serializable_add_includes(options) do |association, records, opts|\n        hash[association.to_s] = if records.respond_to?(:to_ary)\n          records.to_ary.map { |a| a.serializable_hash(opts) }\n        else\n          records.serializable_hash(opts)\n        end\n      end\n\n      hash\n    end", "label": 4}
{"code": "func (h *hawkularSink) pushToCache(key string, hash uint64) {\n\th.regLock.Lock()\n\th.expReg[key] = &expiringItem{\n\t\thash: hash,\n\t\tttl:  h.runId,\n\t}\n\th.regLock.Unlock()\n}", "label": 5}
{"code": "func (c *Client) CreateSAMLAuthRequest(req services.SAMLAuthRequest) (*services.SAMLAuthRequest, error) {\n\tout, err := c.PostJSON(c.Endpoint(\"saml\", \"requests\", \"create\"), createSAMLAuthRequestReq{\n\t\tReq: req,\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvar response *services.SAMLAuthRequest\n\tif err := json.Unmarshal(out.Bytes(), &response); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn response, nil\n}", "label": 5}
{"code": "def update_oauth_application(name, redirect_uris, description = '', icon = nil)\n      API.update_oauth_application(@token, name, redirect_uris, description, icon)\n    end", "label": 4}
{"code": "private ClassDescriptor getRealClassDescriptor(ClassDescriptor aCld, Object anObj)\r\n    {\r\n        ClassDescriptor result;\r\n\r\n        if(aCld.getClassOfObject() == ProxyHelper.getRealClass(anObj))\r\n        {\r\n            result = aCld;\r\n        }\r\n        else\r\n        {\r\n            result = aCld.getRepository().getDescriptorFor(anObj.getClass());\r\n        }\r\n\r\n        return result;\r\n    }", "label": 0}
{"code": "def run(self):\n        \"\"\" Computes cleared offers and bids.\n        \"\"\"\n        # Start the clock.\n        t0 = time.time()\n\n        # Manage reactive power offers/bids.\n        haveQ = self._isReactiveMarket()\n\n        # Withhold offers/bids outwith optional price limits.\n        self._withholdOffbids()\n\n        # Convert offers/bids to pwl functions and update limits.\n        self._offbidToCase()\n\n        # Compute dispatch points and LMPs using OPF.\n        success = self._runOPF()\n\n        if success:\n            # Get nodal marginal prices from OPF.\n            gteeOfferPrice, gteeBidPrice = self._nodalPrices(haveQ)\n            # Determine quantity and price for each offer/bid.\n            self._runAuction(gteeOfferPrice, gteeBidPrice, haveQ)\n\n            logger.info(\"SmartMarket cleared in %.3fs\" % (time.time() - t0))\n        else:\n            for offbid in self.offers + self.bids:\n                offbid.clearedQuantity = 0.0\n                offbid.clearedPrice = 0.0\n                offbid.accepted = False\n\n                offbid.generator.p = 0.0\n\n            logger.error(\"Non-convergent market OPF. Blackout!\")\n\n        return self.offers, self.bids", "label": 1}
{"code": "private void checkObjectCache(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r\n    {\r\n        if (!CHECKLEVEL_STRICT.equals(checkLevel))\r\n        {\r\n            return;\r\n        }\r\n        \r\n        ObjectCacheDef objCacheDef = classDef.getObjectCache();\r\n\r\n        if (objCacheDef == null)\r\n        {\r\n            return;\r\n        }\r\n\r\n        String objectCacheName = objCacheDef.getName();\r\n\r\n        if ((objectCacheName == null) || (objectCacheName.length() == 0))\r\n        {\r\n            throw new ConstraintException(\"No class specified for the object-cache of class \"+classDef.getName());\r\n        }\r\n\r\n        try\r\n        {\r\n            InheritanceHelper helper = new InheritanceHelper();\r\n\r\n            if (!helper.isSameOrSubTypeOf(objectCacheName, OBJECT_CACHE_INTERFACE))\r\n            {\r\n                throw new ConstraintException(\"The class \"+objectCacheName+\" specified as object-cache of class \"+classDef.getName()+\" does not implement the interface \"+OBJECT_CACHE_INTERFACE);\r\n            }\r\n        }\r\n        catch (ClassNotFoundException ex)\r\n        {\r\n            throw new ConstraintException(\"Could not find the class \"+ex.getMessage()+\" on the classpath while checking the object-cache class \"+objectCacheName+\" of class \"+classDef.getName());\r\n        }\r\n    }", "label": 0}
{"code": "function (soajs, combo, cb) {\n        soajs.mongoDb.insert(combo.collection, combo.record, cb);\n    }", "label": 3}
{"code": "public function publishBatch(array $messages, array $options = [])\n    {\n        foreach ($messages as &$message) {\n            $message = $this->formatMessage($message);\n        }\n\n        return $this->connection->publishMessage($options + [\n            'topic' => $this->name,\n            'messages' => $messages\n        ]);\n    }", "label": 2}
{"code": "public function setState($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Spanner\\Admin\\Database\\V1\\Database_State::class);\n        $this->state = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def serialize(v, known_modules=[]):\n    '''Get a text representation of an object.'''\n    tname = name(v, known_modules=known_modules)\n    func = serializer(tname)\n    return func(v), tname", "label": 1}
{"code": "def get_dispatcher_event(self, name):\n        \"\"\"Retrieves an Event object by name\n\n        Args:\n            name (str): The name of the :class:`Event` or\n                :class:`~pydispatch.properties.Property` object to retrieve\n\n        Returns:\n            The :class:`Event` instance for the event or property definition\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        e = self.__property_events.get(name)\n        if e is None:\n            e = self.__events[name]\n        return e", "label": 1}
{"code": "function fallBack () {\n      var programFilesVar = \"ProgramFiles\";\n      if (arch === \"(64)\") {\n        console.warn(\"You are using 32-bit version of Firefox on 64-bit versions of the Windows.\\nSome features may not work correctly in this version. You should upgrade Firefox to the latest 64-bit version now!\")\n        programFilesVar = \"ProgramFiles(x86)\";\n      }\n      resolve(path.join(process.env[programFilesVar], appName, \"firefox.exe\"));\n    }", "label": 3}
{"code": "public static base_response update(nitro_service client, nsappflowparam resource) throws Exception {\n\t\tnsappflowparam updateresource = new nsappflowparam();\n\t\tupdateresource.templaterefresh = resource.templaterefresh;\n\t\tupdateresource.udppmtu = resource.udppmtu;\n\t\tupdateresource.httpurl = resource.httpurl;\n\t\tupdateresource.httpcookie = resource.httpcookie;\n\t\tupdateresource.httpreferer = resource.httpreferer;\n\t\tupdateresource.httpmethod = resource.httpmethod;\n\t\tupdateresource.httphost = resource.httphost;\n\t\tupdateresource.httpuseragent = resource.httpuseragent;\n\t\tupdateresource.clienttrafficonly = resource.clienttrafficonly;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def linear(self, limits=None, k=5):\n        \"\"\"Returns an ndarray of linear breaks.\"\"\"\n        start, stop = limits or (self.minval, self.maxval)\n        return np.linspace(start, stop, k)", "label": 1}
{"code": "public CollectionDescriptor getCollectionDescriptorByName(String name)\r\n    {\r\n        if (name == null)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        CollectionDescriptor cod  = (CollectionDescriptor) getCollectionDescriptorNameMap().get(name);\r\n\r\n        //\r\n        // BRJ: if the CollectionDescriptor is not found\r\n        // look in the ClassDescriptor referenced by 'super' for it\r\n        //\r\n        if (cod == null)\r\n        {\r\n            ClassDescriptor superCld = getSuperClassDescriptor();\r\n            if (superCld != null)\r\n            {\r\n                cod = superCld.getCollectionDescriptorByName(name);\r\n            }\r\n        }\r\n\r\n        return cod;\r\n    }", "label": 0}
{"code": "def valid_token(token):\n    \"\"\"Asserts a provided string is a valid duration token representation\n\n    :param  token: duration representation token\n    :type   token: string\n    \"\"\"\n    is_scale = False\n\n    # Check if the token represents a scale\n    # If it doesn't set a flag accordingly\n    try:\n        Scale(token)\n        is_scale = True\n    except ScaleFormatError:\n        pass\n\n    # If token either represents a numerical value, a\n    # separator token, or a scale, it is considered valid\n    if any([token.isdigit(), token in SEPARATOR_TOKENS, is_scale]):\n        return True\n\n    return False", "label": 1}
{"code": "func (s *Reporter) trackRequest(opType OpType, key []byte, endKey []byte) {\n\tif !s.TrackTopRequests {\n\t\treturn\n\t}\n\tif len(key) == 0 {\n\t\treturn\n\t}\n\t// take just the first two parts, otherwise too many distinct requests\n\t// can end up in the map\n\tparts := bytes.Split(key, []byte{Separator})\n\tif len(parts) > 3 {\n\t\tparts = parts[:3]\n\t}\n\trangeSuffix := teleport.TagFalse\n\tif len(endKey) != 0 {\n\t\t// Range denotes range queries in stat entry\n\t\trangeSuffix = teleport.TagTrue\n\t}\n\tcounter, err := requests.GetMetricWithLabelValues(s.Component, string(bytes.Join(parts, []byte{Separator})), rangeSuffix)\n\tif err != nil {\n\t\tlog.Warningf(\"Failed to get counter: %v\", err)\n\t\treturn\n\t}\n\tcounter.Inc()\n}", "label": 5}
{"code": "function(delaySort)\n  {\n    var removed = AP.pop.apply( this );\n    var i = this.length;\n\n    this.trigger( Collection.Events.Remove, [this, removed, i] );\n\n    if ( !delaySort )\n    {\n      this.sort( undefined, undefined, true );\n    }\n\n    return removed;\n  }", "label": 3}
{"code": "func (h *handshake) postY(x *big.Int) error {\n\tvar y big.Int\n\ty.Exp(&g, x, &p)\n\treturn h.postWrite(paddedLeft(y.Bytes(), 96))\n}", "label": 5}
{"code": "public static Optimizer<DifferentiableFunction> getRegularizedOptimizer(final Optimizer<DifferentiableFunction> opt,\n            final double l1Lambda, final double l2Lambda) {\n        if (l1Lambda == 0 && l2Lambda == 0) {\n            return opt;\n        }\n        return new Optimizer<DifferentiableFunction>() {\n            \n            @Override\n            public boolean minimize(DifferentiableFunction objective, IntDoubleVector point) {\n                DifferentiableFunction fn = getRegularizedFn(objective, false, l1Lambda, l2Lambda);\n                return opt.minimize(fn, point);\n            }\n            \n        };\n    }", "label": 0}
{"code": "function SumFunction(win) {\n  var self = this, s;\n  self.name = \"sum\";\n  self.type = \"simple\";\n  self.init = function() { s = 0; };\n  self.accumulate = function(v) { s += v; };\n  self.compensate = function(v) { s -= v; };\n  self.emit = function()  { return s; };\n  self.make = function(win) { return new SumFunction(win); };\n}", "label": 3}
{"code": "public static function getTypeFromValue($value)\n    {\n        switch (gettype($value)) {\n            case 'boolean':\n                if ($value) {\n                    return Type::getTrue();\n                }\n\n                return Type::getFalse();\n\n            case 'integer':\n                return Type::getInt(false, $value);\n\n            case 'double':\n                return Type::getFloat($value);\n\n            case 'string':\n                return Type::getString($value);\n\n            case 'array':\n                return Type::getArray();\n\n            case 'NULL':\n                return Type::getNull();\n\n            default:\n                return Type::getMixed();\n        }\n    }", "label": 2}
{"code": "func (c *controller) getPrimaryKeyTag(subsys string) ([]byte, uint64, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tsort.Sort(ByTime(c.keys))\n\tkeys := []*types.EncryptionKey{}\n\tfor _, key := range c.keys {\n\t\tif key.Subsystem == subsys {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\treturn keys[1].Key, keys[1].LamportTime, nil\n}", "label": 5}
{"code": "def condition_from_code(condcode):\n    \"\"\"Get the condition name from the condition code.\"\"\"\n    if condcode in __BRCONDITIONS:\n        cond_data = __BRCONDITIONS[condcode]\n\n        return {CONDCODE: condcode,\n                CONDITION: cond_data[0],\n                DETAILED: cond_data[1],\n                EXACT: cond_data[2],\n                EXACTNL: cond_data[3],\n                }\n    return None", "label": 1}
{"code": "private void updateSortedServices() {\n    List<T> copiedList = new ArrayList<T>(serviceMap.values());\n    sortedServices = Collections.unmodifiableList(copiedList);\n    if (changeListener != null) {\n      changeListener.changed();\n    }\n  }", "label": 0}
{"code": "def aab_version_codes\n      ensure_active_edit!\n\n      result = call_google_api { client.list_edit_bundles(current_package_name, current_edit.id) }\n\n      return Array(result.bundles).map(&:version_code)\n    end", "label": 4}
{"code": "public function fullByteSize()\n    {\n        $size = $this->byteSize();\n        foreach ($this->members as $variable) {\n            $size += $variable->fullByteSize();\n        }\n        return $size;\n    }", "label": 2}
{"code": "public static netbridge get(nitro_service service, String name) throws Exception{\n\t\tnetbridge obj = new netbridge();\n\t\tobj.set_name(name);\n\t\tnetbridge response = (netbridge) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static base_response save(nitro_service client, cacheobject resource) throws Exception {\n\t\tcacheobject saveresource = new cacheobject();\n\t\tsaveresource.locator = resource.locator;\n\t\treturn saveresource.perform_operation(client,\"save\");\n\t}", "label": 0}
{"code": "def initialize_constants!\n      @initialize_constants ||= begin\n        class_const = options[:class] || @name.to_s.camelize\n        class_const = class_const.constantize if class_const.is_a?(String)\n        options[:class] = class_const\n\n        if options[:builder]\n          options[:builder] = options[:builder].constantize if options[:builder].is_a?(String)\n        end\n\n        true\n      end\n      \n      unless Mutations.cache_constants?\n        options[:class] = options[:class].to_s.constantize if options[:class]\n        options[:builder] = options[:builder].to_s.constantize if options[:builder]\n      end\n    end", "label": 4}
{"code": "func (s *APIServer) createRemoteCluster(auth ClientI, w http.ResponseWriter, r *http.Request, p httprouter.Params, version string) (interface{}, error) {\n\tvar req createRemoteClusterRawReq\n\tif err := httplib.ReadJSON(r, &req); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tconn, err := services.UnmarshalRemoteCluster(req.RemoteCluster)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tif err := auth.CreateRemoteCluster(conn); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn message(\"ok\"), nil\n}", "label": 5}
{"code": "public static base_response update(nitro_service client, nsip6 resource) throws Exception {\n\t\tnsip6 updateresource = new nsip6();\n\t\tupdateresource.ipv6address = resource.ipv6address;\n\t\tupdateresource.td = resource.td;\n\t\tupdateresource.nd = resource.nd;\n\t\tupdateresource.icmp = resource.icmp;\n\t\tupdateresource.vserver = resource.vserver;\n\t\tupdateresource.telnet = resource.telnet;\n\t\tupdateresource.ftp = resource.ftp;\n\t\tupdateresource.gui = resource.gui;\n\t\tupdateresource.ssh = resource.ssh;\n\t\tupdateresource.snmp = resource.snmp;\n\t\tupdateresource.mgmtaccess = resource.mgmtaccess;\n\t\tupdateresource.restrictaccess = resource.restrictaccess;\n\t\tupdateresource.state = resource.state;\n\t\tupdateresource.map = resource.map;\n\t\tupdateresource.dynamicrouting = resource.dynamicrouting;\n\t\tupdateresource.hostroute = resource.hostroute;\n\t\tupdateresource.ip6hostrtgw = resource.ip6hostrtgw;\n\t\tupdateresource.metric = resource.metric;\n\t\tupdateresource.vserverrhilevel = resource.vserverrhilevel;\n\t\tupdateresource.ospf6lsatype = resource.ospf6lsatype;\n\t\tupdateresource.ospfarea = resource.ospfarea;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def iter_methods(self):\n        \"\"\"Iterate over stored functions and instance methods\n\n        Yields:\n            Instance methods or function objects\n        \"\"\"\n        for wrkey, obj in self.iter_instances():\n            f, obj_id = wrkey\n            if f == 'function':\n                yield self[wrkey]\n            else:\n                yield getattr(obj, f.__name__)", "label": 1}
{"code": "public function diffInMilliseconds($date = null, $absolute = true)\n    {\n        return (int) ($this->diffInMicroseconds($date, $absolute) / static::MICROSECONDS_PER_MILLISECOND);\n    }", "label": 2}
{"code": "public function repeat($question = '')\n    {\n        $conversation = $this->bot->getStoredConversation();\n\n        if (! $question instanceof Question && ! $question) {\n            $question = unserialize($conversation['question']);\n        }\n\n        $next = $conversation['next'];\n        $additionalParameters = unserialize($conversation['additionalParameters']);\n\n        if (is_string($next)) {\n            $next = unserialize($next)->getClosure();\n        } elseif (is_array($next)) {\n            $next = Collection::make($next)->map(function ($callback) {\n                if ($this->bot->getDriver()->serializesCallbacks() && ! $this->bot->runsOnSocket()) {\n                    $callback['callback'] = unserialize($callback['callback'])->getClosure();\n                }\n\n                return $callback;\n            })->toArray();\n        }\n        $this->ask($question, $next, $additionalParameters);\n    }", "label": 2}
{"code": "private void validate(Object object) {\n\t\tSet<ConstraintViolation<Object>> viols = validator.validate(object);\n\t\tfor (ConstraintViolation<Object> constraintViolation : viols) {\n\t\t\tif (Null.class.isAssignableFrom(constraintViolation.getConstraintDescriptor().getAnnotation().getClass())) {\n\t\t\t\tObject o = constraintViolation.getLeafBean();\n\t\t\t\tIterator<Node> iterator = constraintViolation.getPropertyPath().iterator();\n\t\t\t\tString propertyName = null;\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tpropertyName = iterator.next().getName();\n\t\t\t\t}\n\t\t\t\tif (propertyName != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(o.getClass(), propertyName);\n\t\t\t\t\t\tdescriptor.getWriteMethod().invoke(o, new Object[] { null });\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "label": 0}
{"code": "public function modifyAckDeadlineBatch(array $messages, $seconds, array $options = [])\n    {\n        $this->validateBatch($messages, Message::class);\n\n        $this->connection->modifyAckDeadline($options + [\n            'subscription' => $this->name,\n            'ackIds' => $this->getMessageAckIds($messages),\n            'ackDeadlineSeconds' => $seconds\n        ]);\n    }", "label": 2}
{"code": "def _retrieve_download_url():\n    \"\"\"\n    Retrieves download location for FEH data zip file from hosted json configuration file.\n\n    :return: URL for FEH data file\n    :rtype: str\n    \"\"\"\n    try:\n        # Try to obtain the url from the Open Hydrology json config file.\n        with urlopen(config['nrfa']['oh_json_url'], timeout=10) as f:\n            remote_config = json.loads(f.read().decode('utf-8'))\n        # This is just for testing, assuming a relative local file path starting with ./\n        if remote_config['nrfa_url'].startswith('.'):\n            remote_config['nrfa_url'] = 'file:' + pathname2url(os.path.abspath(remote_config['nrfa_url']))\n\n        # Save retrieved config data\n        _update_nrfa_metadata(remote_config)\n\n        return remote_config['nrfa_url']\n    except URLError:\n        # If that fails (for whatever reason) use the fallback constant.\n        return config['nrfa']['url']", "label": 1}
{"code": "function enhanceErrorMessages (method, log) {\n  program.Command.prototype[method] = function (argument) {\n    if (method === 'unknownOption' && this._allowUnknownOption) {\n      return\n    }\n\n    this.outputHelp()\n    console.log(chalk`\\n{red ${log(argument)}}`)\n    process.exit(1)\n  }\n}", "label": 3}
{"code": "private void logState(final FileRollEvent fileRollEvent) {\n\n//\t\tif (ApplicationState.isApplicationStateEnabled()) {\n\t\t\t\n\t\t\tsynchronized (this) {\n\t\t\t\t\n\t\t\t\tfinal Collection<ApplicationState.ApplicationStateMessage> entries = ApplicationState.getAppStateEntries();\n\t\t\t\tfor (ApplicationState.ApplicationStateMessage entry : entries) {\n                    Level level = ApplicationState.getLog4jLevel(entry.getLevel());\n\t\t\t\t    if(level.isGreaterOrEqual(ApplicationState.LOGGER.getEffectiveLevel())) {\n\t\t\t\t\t\tfinal org.apache.log4j.spi.LoggingEvent loggingEvent = new org.apache.log4j.spi.LoggingEvent(ApplicationState.FQCN, ApplicationState.LOGGER, level, entry.getMessage(), null);\n\n\t\t\t\t\t\t//Save the current layout before changing it to the original (relevant for marker cases when the layout was changed)\n\t\t\t\t\t\tLayout current=fileRollEvent.getSource().getLayout();\n\t\t\t\t\t\t//fileRollEvent.getSource().activeOriginalLayout();\n\t\t\t\t\t\tString flowContext = (String) MDC.get(\"flowCtxt\");\n\t\t\t\t\t\tMDC.remove(\"flowCtxt\");\n\t\t\t\t\t\t//Write applicationState:\n\t\t\t\t\t\tif(fileRollEvent.getSource().isAddApplicationState() && fileRollEvent.getSource().getFile().endsWith(\"log\")){\n\t\t\t\t\t\t\tfileRollEvent.dispatchToAppender(loggingEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Set current again.\n\t\t\t\t\t\tfileRollEvent.getSource().setLayout(current);\n\t\t\t\t\t\tif (flowContext != null) {\n\t\t\t\t\t\t\tMDC.put(\"flowCtxt\", flowContext);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n//\t\t}\n\t}", "label": 0}
{"code": "public SqlStatement getPreparedDeleteStatement(ClassDescriptor cld)\r\n    {\r\n        SqlForClass sfc = getSqlForClass(cld);\r\n        SqlStatement sql = sfc.getDeleteSql();\r\n        if(sql == null)\r\n        {\r\n            ProcedureDescriptor pd = cld.getDeleteProcedure();\r\n\r\n            if(pd == null)\r\n            {\r\n                sql = new SqlDeleteByPkStatement(cld, logger);\r\n            }\r\n            else\r\n            {\r\n                sql = new SqlProcedureStatement(pd, logger);\r\n            }\r\n            // set the sql string\r\n            sfc.setDeleteSql(sql);\r\n\r\n            if(logger.isDebugEnabled())\r\n            {\r\n                logger.debug(\"SQL:\" + sql.getStatement());\r\n            }\r\n        }\r\n        return sql;\r\n    }", "label": 0}
{"code": "def bulk_copy(self, ids):\n        \"\"\"Bulk copy a set of devices.\n\n        :param ids: Int list of device IDs.\n        :return: :class:`devices.Device <devices.Device>` list\n        \"\"\"\n        schema = DeviceSchema()\n        return self.service.bulk_copy(self.base, self.RESOURCE, ids, schema)", "label": 1}
{"code": "public static void main(String[] args) {\r\n    try {\r\n      TreeFactory tf = new LabeledScoredTreeFactory();\r\n      Reader r = new BufferedReader(new InputStreamReader(new FileInputStream(args[0]), \"UTF-8\"));\r\n      TreeReader tr = new PennTreeReader(r, tf);\r\n      Tree t = tr.readTree();\r\n      while (t != null) {\r\n        System.out.println(t);\r\n        System.out.println();\r\n        t = tr.readTree();\r\n      }\r\n      r.close();\r\n    } catch (IOException ioe) {\r\n      ioe.printStackTrace();\r\n    }\r\n  }", "label": 0}
{"code": "function getCursorPosition(event) {\n  let cursorX;\n  let cursorY;\n  let rect = htmlElement.getBoundingClientRect();\n  if (event.touches !== undefined) {\n    cursorX = event.touches[0].clientX;\n    cursorY = event.touches[0].clientY;\n  } else {\n    cursorX = event.clientX;\n    cursorY = event.clientY;\n  }\n  return {\n    x: cursorX - rect.left,\n    y: cursorY - rect.top,\n  };\n}", "label": 3}
{"code": "public Object getAttributeValue(String attributeName) {\n\t\tAttribute attribute = getAllAttributes().get(attributeName);\n\t\tif (attribute != null) {\n\t\t\treturn attribute.getValue();\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "public function kind($kinds)\n    {\n        if (!is_array($kinds)) {\n            $kinds = [$kinds];\n        }\n\n        foreach ($kinds as $kind) {\n            $this->query['kind'][] = $this->propertyName($kind);\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "func (r *reader) Done(err error) {\n\tq := readerReport{\n\t\tt:    time.Now(),\n\t\tpos:  r.pos,\n\t\tsize: r.size,\n\t\tbps:  &r.bps,\n\t\terr:  err,\n\t}\n\n\tselect {\n\tcase r.ch <- q:\n\t\tclose(r.ch)\n\tcase <-r.ctx.Done():\n\t}\n}", "label": 5}
{"code": "public static function normalizeVariadic(array $arguments)\n    {\n        if (count($arguments) === 2 && is_array($arguments[1])) {\n            return array_merge(array($arguments[0]), $arguments[1]);\n        }\n\n        return $arguments;\n    }", "label": 2}
{"code": "def add_stylesheets(self, *css_files):\n        \"\"\"add stylesheet files in HTML head\"\"\"\n        for css_file in css_files:\n            self.main_soup.style.append(self._text_file(css_file))", "label": 1}
{"code": "def commit(self, id, impreq): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Commit a staged import.\n\n        :param id: Staged import ID as an int.\n        :param impreq: :class:`imports.Request <imports.Request>` object\n        :return: :class:`imports.Request <imports.Request>` object\n        :rtype: imports.Request\n        \"\"\"\n        schema = RequestSchema()\n        json = self.service.encode(schema, impreq)\n\n        schema = RequestSchema()\n        resp = self.service.post(self.base+str(id)+'/', json=json)\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "def setup(self, config_file=None, aws_config=None, gpg_config=None,\n              decrypt_gpg=True, decrypt_kms=True):\n        \"\"\"Make setup easier by providing a constructor method.\n\n        Move to config_file\n        File can be located with a filename only, relative path, or absolute path.\n        If only name or relative path is provided, look in this order:\n\n        1. current directory\n        2. `~/.config/<file_name>`\n        3. `/etc/<file_name>`\n\n        It is a good idea to include you __package__ in the file name.\n        For example, `cfg = Config(os.path.join(__package__, 'config.yaml'))`.\n        This way it will look for your_package/config.yaml,\n        ~/.config/your_package/config.yaml, and /etc/your_package/config.yaml.\n        \"\"\"\n        if aws_config is not None:\n            self.aws_config = aws_config\n        if gpg_config is not None:\n            self.gpg_config = gpg_config\n        if decrypt_kms is not None:\n            self.decrypt_kms = decrypt_kms\n        if decrypt_gpg is not None:\n            self.decrypt_gpg = decrypt_gpg\n        # Again, load the file last so that it can rely on other properties.\n        if config_file is not None:\n            self.config_file = config_file\n        return self", "label": 1}
{"code": "def init_queue():\n    \"\"\"Initialize indexing queue.\"\"\"\n    def action(queue):\n        queue.declare()\n        click.secho('Indexing queue has been initialized.', fg='green')\n        return queue\n    return action", "label": 1}
{"code": "function failFast(logLevel, lessThan) {\n    var ll = LatticeLogs;\n\n    if (logLevel) {\n      var compareTo = lessThan || process.env.LATTICE_LOGLEVEL || ll.ERROR;\n      if (!ll.equalOrBelow(logLevel, compareTo)) return true;\n    }\n\n    return /\\b(NONE|OFF|NO|0)\\b/i.test(process.env.LATTICE_ERRORS || '');\n  }", "label": 3}
{"code": "function start(id) {\n  if (!timers[id]) {\n    timers[id] = {\n      start: 0,\n      elapsed: 0\n    };\n  }\n  timers[id].start = process.hrtime();\n}", "label": 3}
{"code": "function assetFingerprint(label, fingerprint, cacheInfo) {\n\t\tif(arguments.length > 1)\n\t\t{\n\t\t\t//Add a label\n\t\t\tvar labelInfo = labels[label] = {\"fingerprint\": fingerprint};\n\t\t\tif(cacheInfo)\n\t\t\t\tfor(var i in cacheInfo)\n\t\t\t\t\tlabelInfo[i] = cacheInfo[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Try to get a fingerprint from a registered label\n\t\t\tvar info = labels[label];\n\t\t\tif(info)\n\t\t\t{\n\t\t\t\tfingerprints[info.fingerprint] = info;\n\t\t\t\treturn info.fingerprint;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinfo = {};\n\t\t\t\t//Try to get a fingerprint using the specified cache strategy\n\t\t\t\tvar fullPath = path.resolve(rootPath + \"/\" + (label || this.url) );\n\t\t\t\t//Use the \"cache strategy\" to get a fingerprint\n\t\t\t\t//Prefer the use of etag over lastModified when generating fingerprints\n\t\t\t\tif(!fs.existsSync(fullPath) )\n\t\t\t\t\treturn label;\n\t\t\t\tif(strategy.lastModified)\n\t\t\t\t{\n\t\t\t\t\tvar mdate = info.lastModified = strategy.lastModified(fullPath);\n\t\t\t\t\tmdate.setMilliseconds(0);\n\t\t\t\t}\n\t\t\t\tif(strategy.etag)\n\t\t\t\t\tinfo.etag = strategy.etag(fullPath);\n\t\t\t\tif(strategy.expires)\n\t\t\t\t\tinfo.expires = strategy.expires(fullPath);\n\t\t\t\tif(strategy.fileFingerprint)\n\t\t\t\t{\n\t\t\t\t\tvar fingerprint = strategy.fileFingerprint(label, fullPath);\n\t\t\t\t\tfingerprints[fingerprint] = info;\n\t\t\t\t\treturn fingerprint;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn label; //Do not generate a fingerprint\n\t\t\t}\n\t\t}\n\t}", "label": 3}
{"code": "def stop(self, timeout=None):\n        \"\"\"\n        Send the GET request required to stop the scan\n\n        If timeout is not specified we just send the request and return. When\n        it is the method will wait for (at most) :timeout: seconds until the\n        scan changes it's status/stops. If the timeout is reached then an\n        exception is raised.\n\n        :param timeout: The timeout in seconds\n        :return: None, an exception is raised if the timeout is exceeded\n        \"\"\"\n        assert self.scan_id is not None, 'No scan_id has been set'\n\n        #\n        #   Simple stop\n        #\n        if timeout is None:\n            url = '/scans/%s/stop' % self.scan_id\n            self.conn.send_request(url, method='GET')\n            return\n\n        #\n        #   Stop with timeout\n        #\n        self.stop()\n\n        for _ in xrange(timeout):\n            time.sleep(1)\n\n            is_running = self.get_status()['is_running']\n            if not is_running:\n                return\n\n        msg = 'Failed to stop the scan in %s seconds'\n        raise ScanStopTimeoutException(msg % timeout)", "label": 1}
{"code": "def cluster_options\n      # We share clusters when a new client with different CRUD_OPTIONS\n      # is requested; therefore, cluster should not be getting any of these\n      # options upon instantiation\n      options.reject do |key, value|\n        CRUD_OPTIONS.include?(key.to_sym)\n      end.merge(\n        server_selection_semaphore: @server_selection_semaphore,\n        # but need to put the database back in for auth...\n        database: options[:database],\n\n        # Put these options in for legacy compatibility, but note that\n        # their values on the client and the cluster do not have to match -\n        # applications should read these values from client, not from cluster\n        max_read_retries: options[:max_read_retries],\n        read_retry_interval: options[:read_retry_interval],\n      )\n    end", "label": 4}
{"code": "Boolean prevalidateObject(MtasParserObject object,\n      Map<String, List<MtasParserObject>> currentList) {\n    MtasParserType objectType = object.getType();\n    List<MtasParserMapping<?>> mappings = objectType.getItems();\n    if (mappings.isEmpty()) {\n      return true;\n    }\n    for (MtasParserMapping<?> mapping : mappings) {\n      try {\n        precheckMappingConditions(object, mapping.getConditions(), currentList);\n        return true;\n      } catch (MtasParserException e) {\n        log.debug(e);\n      }\n    }\n    return false;\n  }", "label": 0}
{"code": "def unseal(shard)\n      json = client.put(\"/v1/sys/unseal\", JSON.fast_generate(\n        key: shard,\n      ))\n      return SealStatus.decode(json)\n    end", "label": 4}
{"code": "def find_config(file)\n      path = Pathname(file).expand_path\n\n      while path.parent != path\n        config1 = path.join(\"browserslist\")\n        return config1.read if config1.exist? && !config1.directory?\n\n        config2 = path.join(\".browserslistrc\")\n        return config2.read if config2.exist? && !config1.directory?\n\n        path = path.parent\n      end\n\n      nil\n    end", "label": 4}
{"code": "function createComparator(comparator, nullsFirst)\n{\n  if ( isFunction( comparator ) )\n  {\n    return comparator;\n  }\n  else if ( isString( comparator ) )\n  {\n    if ( comparator in Comparators )\n    {\n      return Comparators[ comparator ];\n    }\n\n    if ( comparator.charAt(0) === '-' )\n    {\n      var parsed = createComparator( comparator.substring( 1 ), !nullsFirst );\n\n      return function compareObjectsReversed(a, b)\n      {\n        return -parsed( a, b );\n      };\n    }\n    else if ( isFormatInput( comparator ) )\n    {\n      var formatter = createFormatter( comparator );\n\n      return function compareFormatted(a, b)\n      {\n        var af = formatter( a );\n        var bf = formatter( b );\n\n        return af.localeCompare( bf );\n      };\n    }\n    else if ( isParseInput( comparator ) )\n    {\n      var parser = createParser( comparator );\n\n      return function compareExpression(a, b)\n      {\n        var ap = parser( a );\n        var bp = parser( b );\n\n        return compare( ap, bp, nullsFirst );\n      };\n    }\n    else\n    {\n      return function compareObjects(a, b)\n      {\n        var av = isValue( a ) ? a[ comparator ] : a;\n        var bv = isValue( b ) ? b[ comparator ] : b;\n\n        return compare( av, bv, nullsFirst );\n      };\n    }\n  }\n  else if ( isArray( comparator ) )\n  {\n    var parsedChain = [];\n\n    for (var i = 0; i < comparator.length; i++)\n    {\n      parsedChain[ i ] = createComparator( comparator[ i ], nullsFirst );\n    }\n\n    return function compareObjectsCascade(a, b)\n    {\n      var d = 0;\n\n      for (var i = 0; i < parsedChain.length && d === 0; i++)\n      {\n        d = parsedChain[ i ]( a, b );\n      }\n\n      return d;\n    };\n  }\n\n  return null;\n}", "label": 3}
{"code": "protected function defaultJobData($connection, $queue, array $payload, array $data)\n    {\n        return [\n            'connection' => $connection,\n            'queue' => $queue,\n            'name' => $payload['displayName'],\n            'tries' => $payload['maxTries'],\n            'timeout' => $payload['timeout'],\n            'data' => $data,\n        ];\n    }", "label": 2}
{"code": "public static <E> Counter<E> intersection(Counter<E> c1, Counter<E> c2) {\r\n    Counter<E> result = c1.getFactory().create();\r\n    for (E key : Sets.union(c1.keySet(), c2.keySet())) {\r\n      double count1 = c1.getCount(key);\r\n      double count2 = c2.getCount(key);\r\n      double minCount = (count1 < count2 ? count1 : count2);\r\n      if (minCount > 0) {\r\n        result.setCount(key, minCount);\r\n      }\r\n    }\r\n    return result;\r\n  }", "label": 0}
{"code": "function(args) {\n      args = args || {};\n\n      /* Listen to model validation callbacks */\n      var FormModelClass = args.FormModelClass || this.FormModelClass || FormModel;\n      this.model = args.model || this.model || (new FormModelClass());\n\n      /* Override template */\n      this.template = args.template || this.template;\n\n      /* Merge events, fields, bindings, and computeds */\n      this.events = _.extend({}, this.events || {}, args.events || {});\n      this.fields = _.extend({}, this.fields || {}, args.fields || {});\n      this._errors = [];\n      this._success = false;\n      // this._bindings is a snapshot of the original bindings\n      this._bindings = _.extend({}, this.bindings || {}, args.bindings || {});\n\n      View.apply(this, arguments);\n\n      this.resetModelListeners(this.model);\n    }", "label": 3}
{"code": "public static int cudnnLRNCrossChannelBackward(\n        cudnnHandle handle, \n        cudnnLRNDescriptor normDesc, \n        int lrnMode, \n        Pointer alpha, \n        cudnnTensorDescriptor yDesc, \n        Pointer y, \n        cudnnTensorDescriptor dyDesc, \n        Pointer dy, \n        cudnnTensorDescriptor xDesc, \n        Pointer x, \n        Pointer beta, \n        cudnnTensorDescriptor dxDesc, \n        Pointer dx)\n    {\n        return checkResult(cudnnLRNCrossChannelBackwardNative(handle, normDesc, lrnMode, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx));\n    }", "label": 0}
{"code": "private void modifyBeliefCount(int count){\n        introspector.setBeliefValue(getLocalName(), Definitions.RECEIVED_MESSAGE_COUNT, getBeliefCount()+count, null);\n    }", "label": 0}
{"code": "def is_iterable(etype) -> bool:\n    \"\"\" Determine whether etype is a List or other iterable \"\"\"\n    return type(etype) is GenericMeta and issubclass(etype.__extra__, Iterable)", "label": 1}
{"code": "public static void closeMASCaseManager(File caseManager) {\n\n        FileWriter caseManagerWriter;\n        try {\n            caseManagerWriter = new FileWriter(caseManager, true);\n            caseManagerWriter.write(\"}\\n\");\n            caseManagerWriter.flush();\n            caseManagerWriter.close();\n        } catch (IOException e) {\n            Logger logger = Logger\n                    .getLogger(\"CreateMASCaseManager.closeMASCaseManager\");\n            logger.info(\"ERROR: There is a mistake closing caseManager file.\\n\");\n        }\n\n    }", "label": 0}
{"code": "public static base_response add(nitro_service client, route resource) throws Exception {\n\t\troute addresource = new route();\n\t\taddresource.network = resource.network;\n\t\taddresource.netmask = resource.netmask;\n\t\taddresource.gateway = resource.gateway;\n\t\taddresource.cost = resource.cost;\n\t\taddresource.td = resource.td;\n\t\taddresource.distance = resource.distance;\n\t\taddresource.cost1 = resource.cost1;\n\t\taddresource.weight = resource.weight;\n\t\taddresource.advertise = resource.advertise;\n\t\taddresource.protocol = resource.protocol;\n\t\taddresource.msr = resource.msr;\n\t\taddresource.monitor = resource.monitor;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def vim_janus(uninstall=None):\n    '''Install or update Janus, a distribution of addons and mappings for vim.\n\n    More info:\n      https://github.com/carlhuda/janus\n      Customization: https://github.com/carlhuda/janus/wiki/Customization\n\n    Args:\n        uninstall: If not None, Uninstall janus and restore old vim config\n    '''\n    if uninstall is not None:\n        uninstall_janus()\n    else:\n        if not exists('~/.vim/janus'):\n            print_msg('not installed => install')\n            install_janus()\n        else:\n            print_msg('already installed => update')\n            update_janus()\n        customize_janus()\n        show_files_used_by_vim_and_janus()", "label": 1}
{"code": "def move_to_list_on_any_board(list_id)\n      list = List.find(list_id)\n      if board.id == list.board_id\n        move_to_list(list_id)\n      else\n        move_to_board(Board.find(list.board_id), list)\n      end\n    end", "label": 4}
{"code": "func downloadKey(u *url.URL, skipTLSCheck bool) (*os.File, error) {\n\ttf, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"error creating tempfile\"), err)\n\t}\n\tos.Remove(tf.Name()) // no need to keep the tempfile around\n\n\tdefer func() {\n\t\tif tf != nil {\n\t\t\ttf.Close()\n\t\t}\n\t}()\n\n\t// TODO(krnowak): we should probably apply credential headers\n\t// from config here\n\tvar client *http.Client\n\tif skipTLSCheck {\n\t\tclient = insecureClient\n\t} else {\n\t\tclient = secureClient\n\t}\n\n\tres, err := client.Get(u.String())\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"error getting key\"), err)\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"bad HTTP status code: %d\", res.StatusCode)\n\t}\n\n\tif _, err := io.Copy(tf, res.Body); err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"error copying key\"), err)\n\t}\n\n\tif _, err = tf.Seek(0, os.SEEK_SET); err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"error seeking\"), err)\n\t}\n\n\tretTf := tf\n\ttf = nil\n\treturn retTf, nil\n}", "label": 5}
{"code": "def agent\n      @agent ||= Sawyer::Agent.new(endpoint, sawyer_options) do |http|\n        http.headers[:accept] = default_media_type\n        http.headers[:content_type] = \"application/json\"\n        http.headers[:user_agent] = user_agent\n        if basic_authenticated?\n          http.basic_auth(@login, @password)\n        elsif token_authenticated?\n          http.authorization 'token', @access_token\n        elsif bearer_authenticated?\n          http.authorization 'Bearer', @bearer_token\n        elsif application_authenticated?\n          http.params = http.params.merge application_authentication\n        end\n      end\n    end", "label": 4}
{"code": "protected Class<?> getPropertyClass(ClassMetadata meta, String propertyName) throws HibernateLayerException {\n\t\t// try to assure the correct separator is used\n\t\tpropertyName = propertyName.replace(XPATH_SEPARATOR, SEPARATOR);\n\n\t\tif (propertyName.contains(SEPARATOR)) {\n\t\t\tString directProperty = propertyName.substring(0, propertyName.indexOf(SEPARATOR));\n\t\t\ttry {\n\t\t\t\tType prop = meta.getPropertyType(directProperty);\n\t\t\t\tif (prop.isCollectionType()) {\n\t\t\t\t\tCollectionType coll = (CollectionType) prop;\n\t\t\t\t\tprop = coll.getElementType((SessionFactoryImplementor) sessionFactory);\n\t\t\t\t}\n\t\t\t\tClassMetadata propMeta = sessionFactory.getClassMetadata(prop.getReturnedClass());\n\t\t\t\treturn getPropertyClass(propMeta, propertyName.substring(propertyName.indexOf(SEPARATOR) + 1));\n\t\t\t} catch (HibernateException e) {\n\t\t\t\tthrow new HibernateLayerException(e, ExceptionCode.HIBERNATE_COULD_NOT_RESOLVE, propertyName,\n\t\t\t\t\t\tmeta.getEntityName());\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\treturn meta.getPropertyType(propertyName).getReturnedClass();\n\t\t\t} catch (HibernateException e) {\n\t\t\t\tthrow new HibernateLayerException(e, ExceptionCode.HIBERNATE_COULD_NOT_RESOLVE, propertyName,\n\t\t\t\t\t\tmeta.getEntityName());\n\t\t\t}\n\t\t}\n\t}", "label": 0}
{"code": "def run_indel_caller(job, tumor_bam, normal_bam, univ_options, indel_options):\n    \"\"\"\n    This module will run an indel caller on the DNA bams.  This module will be\n    implemented in the future.\n\n    This module corresponds to node 13 on the tree\n    \"\"\"\n    job.fileStore.logToMaster('Running INDEL on %s' % univ_options['patient'])\n    indel_file = job.fileStore.getLocalTempFile()\n    output_file = job.fileStore.writeGlobalFile(indel_file)\n    return output_file", "label": 1}
{"code": "public function requestVersion(): array\n    {\n        try {\n            $versions = json_decode(file_get_contents($this->apiURL), true)['packages']['orchid/platform'];\n\n            return array_reverse($versions);\n        } catch (\\Exception $exception) {\n            Log::alert($exception->getMessage());\n\n            return [['version' => '0.0.0']];\n        }\n    }", "label": 2}
{"code": "public static nsaptlicense[] get(nitro_service service, nsaptlicense_args args) throws Exception{\n\t\tnsaptlicense obj = new nsaptlicense();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tnsaptlicense[] response = (nsaptlicense[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static responderpolicy_stats get(nitro_service service, String name) throws Exception{\n\t\tresponderpolicy_stats obj = new responderpolicy_stats();\n\t\tobj.set_name(name);\n\t\tresponderpolicy_stats response = (responderpolicy_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def option(opts, *args)\n      long_opt_symbol = long_opt_symbol(args)\n      args += Array(OptionsHelp::TEXT[long_opt_symbol])\n      opts.on(*args) do |arg|\n        @options[long_opt_symbol] = arg\n        yield arg if block_given?\n      end\n    end", "label": 4}
{"code": "def available_options(self):\n        \"\"\"Return options that can be used given\n        the current cmd line\n\n        rtype: command.Option generator\n        \"\"\"\n        for option in list(self.cmd.options.values()):\n            if (option.is_multiple or\n                    option not in list(self.used_options)):\n                yield option", "label": 1}
{"code": "def content_options(host, selected_id, object_type, options = {})\n      include_blank = options.fetch(:include_blank, nil)\n      include_blank = '<option></option>' if include_blank == true #check for true specifically\n      orgs = relevant_organizations(host)\n      all_options = []\n      orgs.each do |org|\n        content_object_options = \"\"\n        accessible_content_objects = if object_type == :lifecycle_environment\n                                       accessible_lifecycle_environments(org, host)\n                                     elsif object_type == :content_source\n                                       accessible_content_proxies(host)\n                                     end\n        accessible_content_objects.each do |content_object|\n          selected = selected_id == content_object.id ? 'selected' : ''\n          content_object_options << %(<option value=\"#{content_object.id}\" class=\"kt-env\" #{selected}>#{h(content_object.name)}</option>)\n        end\n\n        if orgs.count > 1\n          all_options << %(<optgroup label=\"#{org.name}\">#{content_object_options}</optgroup>)\n        else\n          all_options << content_object_options\n        end\n      end\n\n      all_options = all_options.join\n      all_options.insert(0, include_blank) if include_blank\n      all_options.html_safe\n    end", "label": 4}
{"code": "function FakeEvent(type, bubbles, cancelable, target) {\r\n\t\t\t\tthis.initEvent(type, bubbles, cancelable, target);\r\n\t\t\t}", "label": 3}
{"code": "public static double KumarJohnsonDivergence(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                r += Math.pow(p[i] * p[i] - q[i] * q[i], 2) / 2 * Math.pow(p[i] * q[i], 1.5);\n            }\n        }\n        return r;\n    }", "label": 0}
{"code": "function clearOfflineLogin(credentials, serverOptions) {\n    // simultaneous logins using different credentials is not realized so far,\n    // so that the credentials parameter is irrelevant, but provided for the\n    // sake of completeness...\n    try {\n        localStorage().removeItem(computeLocalStorageKey(serverOptions));\n        return Q.resolve(undefined);\n    }\n    catch (error) {\n        return Q.reject(error);\n    }\n}", "label": 3}
{"code": "def call(self, tag_name: str, *args, **kwargs):\n        \"\"\"Convenience method for calling methods with walker.\"\"\"\n        if hasattr(self, tag_name):\n            getattr(self, tag_name)(*args, **kwargs)", "label": 1}
{"code": "def bin_centers(self, axis=None):\n        \"\"\"Return bin centers along an axis, or if axis=None, list of bin_centers along each axis\"\"\"\n        if axis is None:\n            return np.array([self.bin_centers(axis=i) for i in range(self.dimensions)])\n        axis = self.get_axis_number(axis)\n        return 0.5 * (self.bin_edges[axis][1:] + self.bin_edges[axis][:-1])", "label": 1}
{"code": "func (r *Role) Set(v string) error {\n\tval := Role(strings.Title(v))\n\tif err := val.Check(); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t*r = val\n\treturn nil\n}", "label": 5}
{"code": "func prepareStage1Image(cfg PrepareConfig, cdir string) error {\n\ts1 := common.Stage1ImagePath(cdir)\n\tif err := os.MkdirAll(s1, common.DefaultRegularDirPerm); err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error creating stage1 directory\"), err)\n\t}\n\n\ttreeStoreID, _, err := cfg.TreeStore.Render(cfg.Stage1Image.String(), false)\n\tif err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error rendering tree image\"), err)\n\t}\n\n\tif err := writeManifest(*cfg.CommonConfig, cfg.Stage1Image, s1); err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error writing manifest\"), err)\n\t}\n\n\tif !cfg.UseOverlay {\n\t\tdestRootfs := filepath.Join(s1, \"rootfs\")\n\t\tcachedTreePath := cfg.TreeStore.GetRootFS(treeStoreID)\n\t\tif err := fileutil.CopyTree(cachedTreePath, destRootfs, cfg.PrivateUsers); err != nil {\n\t\t\treturn errwrap.Wrap(errors.New(\"error rendering ACI\"), err)\n\t\t}\n\t}\n\n\tfn := path.Join(cdir, common.Stage1TreeStoreIDFilename)\n\tif err := ioutil.WriteFile(fn, []byte(treeStoreID), common.DefaultRegularFilePerm); err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error writing stage1 treeStoreID\"), err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def has_next(self):\n        \"\"\"\n        Checks for one more item than last on this page.\n        \"\"\"\n        try:\n            next_item = self.paginator.object_list[self.paginator.per_page]\n        except IndexError:\n            return False\n        return True", "label": 1}
{"code": "public boolean matches(String resourcePath) {\n    if (!valid) {\n      return false;\n    }\n    if (resourcePath == null) {\n      return acceptsContextPathEmpty;\n    }\n    if (contextPathRegex != null && !contextPathRegex.matcher(resourcePath).matches()) {\n      return false;\n    }\n    if (contextPathBlacklistRegex != null && contextPathBlacklistRegex.matcher(resourcePath).matches()) {\n      return false;\n    }\n    return true;\n  }", "label": 0}
{"code": "def update_empty_fields(self, **kwargs):\n        \"\"\"Updates the field of info about an OTU that might not be filled in by a match_names or taxon call.\"\"\"\n        if self._is_deprecated is None:\n            self._is_deprecated = kwargs.get('is_deprecated')\n        if self._is_dubious is None:\n            self._is_dubious = kwargs.get('is_dubious')\n        if self._is_synonym is None:\n            self._is_synonym = kwargs.get('is_synonym')\n        if self._synonyms is _EMPTY_TUPLE:\n            self._synonyms = kwargs.get('synonyms')\n            if self._synonyms is None:\n                self._synonyms = _EMPTY_TUPLE\n        if self.rank is None:\n            self._rank = kwargs.get('rank')\n        if self._nomenclature_code:\n            self._nomenclature_code = kwargs.get('nomenclature_code')\n        if not self._unique_name:\n            self._unique_name = kwargs.get('unique_name')\n        if self._taxonomic_lineage is None:\n            self._taxonomic_lineage = kwargs.get('taxonomic_lineage')\n        if self._parent is None:\n            self._parent = kwargs.get('parent')\n            if self._parent is None and self._taxomachine_wrapper is not None and self._taxonomic_lineage:\n                self._fill_parent_attr()", "label": 1}
{"code": "def __merge_schema_locations(self, ni, incoming_schemaloc):\n        \"\"\"Merge incoming_schemaloc into the given `_NamespaceInfo`, ni.  If we\n        don't have one yet and the incoming value is non-None, update ours\n        with theirs.  This modifies ni.\n        \"\"\"\n        if ni.schema_location == incoming_schemaloc:  # TODO (bworrell): empty strings?\n            return\n        elif not ni.schema_location:\n            ni.schema_location = incoming_schemaloc or None\n        elif not incoming_schemaloc:\n            return\n        else:\n            raise ConflictingSchemaLocationError(ni.uri, ni.schema_location, incoming_schemaloc)", "label": 1}
{"code": "private function connectToWhatsApp()\n    {\n        if (isset($this->wa)) {\n            $this->wa->connect();\n            $this->wa->loginWithPassword($this->password);\n\n            return true;\n        }\n\n        return false;\n    }", "label": 2}
{"code": "public void adjustGlassSize() {\n        if (isGlassEnabled()) {\n            ResizeHandler handler = getGlassResizer();\n            if (handler != null) handler.onResize(null);\n        }\n    }", "label": 0}
{"code": "public function getKey(): string\n    {\n        $argKeys = $this->argKeys();\n\n        return $this->implode([\n            $this->privateCache\n                ? 'auth'\n                : null,\n            $this->privateCache\n                ? app('auth')->user()->getKey()\n                : null,\n            strtolower($this->resolveInfo->parentType->name),\n            $this->fieldKey,\n            strtolower($this->resolveInfo->fieldName),\n            $argKeys->isNotEmpty()\n                ? $argKeys->implode(':')\n                : null,\n        ]);\n    }", "label": 2}
{"code": "public static base_responses add(nitro_service client, filteraction resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tfilteraction addresources[] = new filteraction[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new filteraction();\n\t\t\t\taddresources[i].name = resources[i].name;\n\t\t\t\taddresources[i].qual = resources[i].qual;\n\t\t\t\taddresources[i].servicename = resources[i].servicename;\n\t\t\t\taddresources[i].value = resources[i].value;\n\t\t\t\taddresources[i].respcode = resources[i].respcode;\n\t\t\t\taddresources[i].page = resources[i].page;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "func (l *httpFileSystem) CreateFile(filePath string, length uint64) (io.WriteCloser, error) {\n\t_, filename := filepath.Split(filePath)\n\tcontentLength := strconv.FormatUint(length, 10)\n\theader := l.writer.Header()\n\n\thttplib.SetNoCacheHeaders(header)\n\thttplib.SetNoSniff(header)\n\theader.Set(\"Content-Length\", contentLength)\n\theader.Set(\"Content-Type\", \"application/octet-stream\")\n\tfilename = url.QueryEscape(filename)\n\theader.Set(\"Content-Disposition\", fmt.Sprintf(`attachment;filename=\"%v\"`, filename))\n\n\treturn &nopWriteCloser{Writer: l.writer}, nil\n}", "label": 5}
{"code": "def to_native(self, value):\n        \"\"\"Load a value as a list, converting items if necessary\"\"\"\n        if isinstance(value, six.string_types):\n            value_list = value.split(self.string_delim)\n        else:\n            value_list = value\n\n        to_native = self.member_type.to_native if self.member_type is not None else lambda x: x\n        return [to_native(item) for item in value_list]", "label": 1}
{"code": "func (d *driver) getNetworks() []*network {\n\td.Lock()\n\tdefer d.Unlock()\n\n\tls := make([]*network, 0, len(d.networks))\n\tfor _, nw := range d.networks {\n\t\tls = append(ls, nw)\n\t}\n\n\treturn ls\n}", "label": 5}
{"code": "function customRenderFn(renderFn) {\n  // The loader context.\n  var _this = this\n\n  return function (engine, template, locals, options) {\n    return renderFn.call(_this, template, locals, options)\n  }\n}", "label": 3}
{"code": "func UnmarshalWithSchema(schemaDefinition string, object interface{}, data []byte) error {\n\tschema, err := jsonschema.New([]byte(schemaDefinition))\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tjsonData, err := ToJSON(data)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\traw := map[string]interface{}{}\n\tif err := json.Unmarshal(jsonData, &raw); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t// schema will check format and set defaults\n\tprocessed, err := schema.ProcessObject(raw)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t// since ProcessObject works with unstructured data, the\n\t// data needs to be re-interpreted in structured form\n\tbytes, err := json.Marshal(processed)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tif err := json.Unmarshal(bytes, object); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def auto_message(self, args):\n        \"\"\"Try guess the message by the args passed\n\n        args: a set of args passed on the wrapper __call__ in\n              the definition above.\n\n        if the object already have some message (defined in __init__),\n        we don't change that. If the first arg is a function, so is decorated\n        without argument, use the func name as the message.\n\n        If not self.message anyway, use the default_message global,\n        another else  use the default self.message already\n\n        \"\"\"\n        if any(args) and callable(args[0]) and not self.message:\n            return args[0].__name__\n        elif not self.message:\n            return self.default_message\n        else:\n            return self.message", "label": 1}
{"code": "def twoSurfplots(self):\n    \"\"\"\n    Plot multiple subplot figure for 2D array\n    \"\"\"\n    # Could more elegantly just call surfplot twice\n    # And also could include xyzinterp as an option inside surfplot.\n    # Noted here in case anyone wants to take that on in the future...\n\n    plt.subplot(211)\n    plt.title('Load thickness, mantle equivalent [m]',fontsize=16)\n    if self.latlon:\n      plt.imshow(self.qs/(self.rho_m*self.g), extent=(0, self.dx*self.qs.shape[0], self.dy*self.qs.shape[1], 0))\n      plt.xlabel('longitude [deg E]', fontsize=12, fontweight='bold')\n      plt.ylabel('latitude [deg N]', fontsize=12, fontweight='bold')\n    else:\n      plt.imshow(self.qs/(self.rho_m*self.g), extent=(0, self.dx/1000.*self.qs.shape[0], self.dy/1000.*self.qs.shape[1], 0))\n      plt.xlabel('x [km]', fontsize=12, fontweight='bold')\n      plt.ylabel('y [km]', fontsize=12, fontweight='bold')\n    plt.colorbar()\n\n    plt.subplot(212)\n    plt.title('Deflection [m]')\n    if self.latlon:\n      plt.imshow(self.w, extent=(0, self.dx*self.w.shape[0], self.dy*self.w.shape[1], 0))\n      plt.xlabel('longitude [deg E]', fontsize=12, fontweight='bold')\n      plt.ylabel('latitude [deg N]', fontsize=12, fontweight='bold')\n    else:\n      plt.imshow(self.w, extent=(0, self.dx/1000.*self.w.shape[0], self.dy/1000.*self.w.shape[1], 0))\n      plt.xlabel('x [km]', fontsize=12, fontweight='bold')\n      plt.ylabel('y [km]', fontsize=12, fontweight='bold')\n    plt.colorbar()", "label": 1}
{"code": "public function retryAll()\n    {\n        foreach ($this->getFailedFiles() as $file) {\n            // Rename the file first\n            $tmpFile = dirname($file) . '/retrying-' . basename($file);\n            rename($file, $tmpFile);\n\n            $fp = @fopen($tmpFile, 'r');\n            if ($fp === false) {\n                fwrite(\n                    STDERR,\n                    sprintf('Could not open the file: %s' . PHP_EOL, $tmpFile)\n                );\n                continue;\n            }\n            while ($line = fgets($fp)) {\n                $a = unserialize($line);\n                $idNum = key($a);\n                $job = $this->runner->getJobFromIdNum($idNum);\n                if (! $job->callFunc($a[$idNum])) {\n                    $this->handleFailure($idNum, $a[$idNum]);\n                }\n            }\n            @fclose($fp);\n            @unlink($tmpFile);\n        }\n    }", "label": 2}
{"code": "public int max() {\r\n    int max = Integer.MIN_VALUE;\r\n    for (E key : map.keySet()) {\r\n      max = Math.max(max, getIntCount(key));\r\n    }\r\n    return max;\r\n  }", "label": 0}
{"code": "def remove_esc_chars(text_string):\n    '''\n    Removes any escape character within text_string and returns the new string as type str.\n\n    Keyword argument:\n\n    - text_string: string instance\n\n    Exceptions raised:\n\n    - InputError: occurs should a non-string argument be passed\n    '''\n    if text_string is None or text_string == \"\":\n        return \"\"\n    elif isinstance(text_string, str):\n        return \" \".join(re.sub(r'\\\\\\w', \"\", text_string).split())\n    else:\n        raise InputError(\"string not passed as argument\")", "label": 1}
{"code": "def smash(self):\n        \"\"\"\n        Smash the given stack\n\n        Args:\n            None\n\n        Returns:\n            True if True\n\n        Todo:\n            Figure out what could go wrong and take steps\n            to hanlde problems.\n        \"\"\"\n        self._initialize_smash()\n        try:\n            stack_name = self._config.get('environment', {}).get('stack_name', None)\n            response = self._cloudFormation.describe_stacks(StackName=stack_name)\n            logging.debug('smash pre-flight returned: {}'.format(\n                json.dumps(response,\n                           indent=4,\n                           default=json_util.default\n                           )))\n        except ClientError as wtf:\n            logging.warning('your stack is in another castle [0].')\n            return False\n        except Exception as wtf:\n            logging.error('failed to find intial status of smash candidate: {}'.format(wtf))\n            return False\n\n        response = self._cloudFormation.delete_stack(StackName=stack_name)\n        logging.info('delete started for stack: {}'.format(stack_name))\n        logging.debug('delete_stack returned: {}'.format(json.dumps(response, indent=4)))\n        return self.poll_stack()", "label": 1}
{"code": "function undeploy(req, res, next) {\n  var removeParams = {\n    _id: req.params.id\n  };\n\n  logger.debug(\"Middleware: undeploy form: \", {params: removeParams});\n\n  forms.deleteForm(_.extend(req.connectionOptions, removeParams), formsResultHandlers(constants.resultTypes.forms, req, next));\n}", "label": 3}
{"code": "function(section, pageFields, submittedFields) {\n  var thisSection = section;\n  var fieldsInSection = sectionUtils.getFieldsInSection(section._id, pageFields);\n\n  var renderData = [];\n  var addedSectionBreaks = false;\n  var idsOfFieldsInTheSection = [];\n\n  _.each(fieldsInSection, function(field) {\n    idsOfFieldsInTheSection.push(field._id);\n\n    var thisFieldInSection = _.filter(submittedFields, function(subField) {\n      return subField.fieldId._id === field._id;\n    });\n\n    if (!addedSectionBreaks) {\n      _.each(thisFieldInSection, function(field, index) {\n        var sectionForIndex = _.clone(thisSection);\n        sectionForIndex.idx = index + 1;\n        field.sectionIndex = field.sectionIndex || 0;\n        renderData[field.sectionIndex] = [sectionForIndex];\n      });\n      addedSectionBreaks = true;\n    }\n\n    _.each(thisFieldInSection, function(field) {\n      field.sectionIndex = field.sectionIndex || 0;\n      renderData[field.sectionIndex].push(convertFieldToFormFormat(field));\n    });\n  });\n  renderData = _.flatten(renderData);\n\n  return {renderData: renderData, fieldsInSection: idsOfFieldsInTheSection};\n}", "label": 3}
{"code": "def __to_float(val, digits):\n    \"\"\"Convert val into float with digits decimal.\"\"\"\n    try:\n        return round(float(val), digits)\n    except (ValueError, TypeError):\n        return float(0)", "label": 1}
{"code": "def glob_directory(path)\n      results = ::Dir[path]\n\n      return results unless RUBY_PLATFORM =~ /darwin/\n\n      results.map { |r| r.encode('UTF-8', 'UTF-8-MAC') }\n    end", "label": 4}
{"code": "func (m *MockIndex) Templates(arg0 template.CSS, arg1 template0.FuncMap) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Templates\", arg0, arg1)\n}", "label": 5}
{"code": "function(tox, opts) {\n  // If one argument and not tox, assume opts\n  if(arguments.length === 1 && !(tox instanceof Tox)) {\n    opts = tox;\n    tox = undefined;\n  }\n\n  if(!(tox instanceof Tox)) {\n    tox = undefined;\n    //var err = new Error('Tox instance required for ToxEncryptSave');\n    //throw err;\n  }\n\n  if(!opts) {\n    opts = {};\n  }\n\n  this._tox = tox;\n  this._libpath = opts['path'];\n\n  if(opts['sync'] === undefined || opts['sync'] === null) {\n    this._sync = true;\n  } else {\n    this._sync = !!opts['sync'];\n  }\n\n  this._toxencryptsave = this.createLibrary(this._libpath);\n}", "label": 3}
{"code": "def startproject(name, directory, verbosity):\n    \"\"\"\n    Creates a Trading-Bots project directory structure for the given project\n    NAME in the current directory or optionally in the given DIRECTORY.\n    \"\"\"\n    handle_template('project', name, target=directory, verbosity=verbosity)\n    click.echo(f\"Success: '{name}' project was successfully created on '{directory}'\")", "label": 1}
{"code": "public static base_response Shutdown(nitro_service client, shutdown resource) throws Exception {\n\t\tshutdown Shutdownresource = new shutdown();\n\t\treturn Shutdownresource.perform_operation(client);\n\t}", "label": 0}
{"code": "function readYaml(filePath) {\n    return new Promise((resolve, reject) => {\n        if (!filePath || typeof filePath !== 'string') {\n            throw new Error('Path must be a string');\n        }\n        fs.readFile(filePath, (err, data) => {\n            if (err) {\n                return reject(err);\n            }\n            // Remove UTF-8 BOM if present\n            if (data.length >= 3 && data[0] === 0xef &&\n                data[1] === 0xbb && data[2] === 0xbf) {\n                data = data.slice(3);\n            }\n            try {\n                return resolve(yaml.safeLoad(data));\n            } catch (yamlerr) {\n                return reject(yamlerr);\n            }\n        });\n    });\n}", "label": 3}
{"code": "public function setByteRange($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\Range::class);\n        $this->byte_range = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func RetryWithRelogin(ctx context.Context, tc *TeleportClient, fn func() error) error {\n\terr := fn()\n\tif err == nil {\n\t\treturn nil\n\t}\n\t// Assume that failed handshake is a result of expired credentials,\n\t// retry the login procedure\n\tif !utils.IsHandshakeFailedError(err) && !utils.IsCertExpiredError(err) && !trace.IsBadParameter(err) && trace.IsTrustError(err) {\n\t\treturn err\n\t}\n\tkey, err := tc.Login(ctx, true)\n\tif err != nil {\n\t\tif trace.IsTrustError(err) {\n\t\t\treturn trace.Wrap(err, \"refusing to connect to untrusted proxy %v without --insecure flag\\n\", tc.Config.SSHProxyAddr)\n\t\t}\n\t\treturn trace.Wrap(err)\n\t}\n\t// Save profile to record proxy credentials\n\tif err := tc.SaveProfile(key.ProxyHost, \"\", ProfileCreateNew|ProfileMakeCurrent); err != nil {\n\t\tlog.Warningf(\"Failed to save profile: %v\", err)\n\t\treturn trace.Wrap(err)\n\t}\n\t// Override client's auth methods, current cluster and user name\n\tauthMethod, err := key.AsAuthMethod()\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t// After successful login we have local agent updated with latest\n\t// and greatest auth information, setup client to try only this new\n\t// method fetched from key, to isolate the retry\n\ttc.Config.AuthMethods = []ssh.AuthMethod{authMethod}\n\treturn fn()\n}", "label": 5}
{"code": "def gen_class_index\n      gen_an_index(@classes, 'All Classes', RDoc::Page::CLASS_INDEX, \"fr_class_index.html\")\n      @allfiles.each do |file|\n        unless file['file'].context.file_relative_name =~ /\\.rb$/\n\n          gen_composite_index(\n            file,\n              RDoc::Page::COMBO_INDEX,\n\n              \"#{MODULE_DIR}/fr_#{file[\"file\"].context.module_name}.html\")\n        end\n      end\n    end", "label": 4}
{"code": "function exists(modulePath, options) {\n\n        if (this.aliases[modulePath]) {\n            modulePath = this.aliases[modulePath];\n        }\n\n        var len = this.factories.length - 1; // -1 because we don't want the default factory\n        for (var i = 0; this.factories && i < len; i++) {\n            if (this.factories[i].isCandidate(modulePath, options)) {\n                return true;\n            }\n        }\n\n        return false;\n    }", "label": 3}
{"code": "def angle_single(self, g_num, at_1, at_2, at_3):\n        \"\"\" Spanning angle among three atoms.\n\n        The indices `at_1` and `at_3` can be the same (yielding a\n        trivial zero angle), but `at_2` must be different from\n        both `at_1` and `at_3`.\n\n        Parameters\n        ----------\n        g_num\n            |int| --\n            Index of the desired geometry\n\n        at_1\n            |int| --\n            Index of the first atom\n\n        at_2\n            |int| --\n            Index of the second atom\n\n        at_3\n            |int| --\n            Index of the third atom\n\n        Returns\n        -------\n        angle\n            |npfloat_| --\n            Spanning angle in degrees between `at_1`-`at_2`-`at_3`, from\n            geometry `g_num`\n\n        Raises\n        ------\n        ~exceptions.IndexError\n            If an invalid (out-of-range) `g_num` or `at_#` is provided\n\n        ~exceptions.ValueError\n            If `at_2` is equal to either `at_1` or `at_3`\n\n        \"\"\"\n\n        # Imports\n        import numpy as np\n        from .utils import safe_cast as scast\n        from .utils.vector import vec_angle\n\n        # The below errors are explicitly thrown since they are multiplied by\n        #  three when they are used as an index and thus give non-intuitive\n        #  errors in later code.\n        # Complain if at_1 is invalid\n        if not(-self.num_atoms <= at_1 < self.num_atoms):\n            raise IndexError(\"Invalid index for 'at_1' ({0})\".format(at_1))\n\n        # Complain if at_2 is invalid\n        if not(-self.num_atoms <= at_2 < self.num_atoms):\n            raise IndexError(\"Invalid index for 'at_2' ({0})\".format(at_2))\n\n        # Complain if at_3 is invalid\n        if not(-self.num_atoms <= at_3 < self.num_atoms):\n            raise IndexError(\"Invalid index for 'at_3' ({0})\".format(at_3))\n\n        # Should never be necessary (save for badly erroneous calling code),\n        #  but coerce the at_x to their floor() values.  This is again\n        #  needed since they are multiplied by three in the index expresssions\n        #  below, and can cause funny behavior when truncated by the indexing\n        at_1 = scast(np.floor(at_1), np.int_)\n        at_2 = scast(np.floor(at_2), np.int_)\n        at_3 = scast(np.floor(at_3), np.int_)\n\n        # Complain if at_2 is equal to either at_1 or at_3.  Must factor in\n        #  the possibility of negative indexing via modulo arithmetic.\n        if (at_2 % self.num_atoms) == (at_1 % self.num_atoms):\n            raise ValueError(\"'at_1' and 'at_2' must be different\")\n        if (at_2 % self.num_atoms) == (at_3 % self.num_atoms):\n            raise ValueError(\"'at_2' and 'at_3' must be different\")\n\n        # Trivial return if at_1 and at_3 are the same\n        if (at_1 % self.num_atoms) == (at_3 % self.num_atoms):\n            # Angle is identically zero in this case\n            return 0.0\n        ## end if\n\n        # Store the displacement vectors from at_2 to at_1 and to at_3\n        # The np.float64 type should be retained through the displ_single call.\n        vec_2_1 = self.displ_single(g_num, at_2, at_1)\n        vec_2_3 = self.displ_single(g_num, at_2, at_3)\n\n        # Compute and return the calculated angle, in degrees\n        # v1 {dot} v2 == |v1||v2| * cos(theta)\n        angle = vec_angle(vec_2_1, vec_2_3)\n        return angle", "label": 1}
{"code": "def create filename, text\n      result = false\n      mutex.synchronize do\n        next unless contain?(filename) || open?(filename) || workspace.would_merge?(filename)\n        @synchronized = false\n        source = Solargraph::Source.load_string(text, filename)\n        workspace.merge(source)\n        result = true\n      end\n      result\n    end", "label": 4}
{"code": "public static servicegroupbindings get(nitro_service service, String servicegroupname) throws Exception{\n\t\tservicegroupbindings obj = new servicegroupbindings();\n\t\tobj.set_servicegroupname(servicegroupname);\n\t\tservicegroupbindings response = (servicegroupbindings) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static appqoepolicy_stats get(nitro_service service, String name) throws Exception{\n\t\tappqoepolicy_stats obj = new appqoepolicy_stats();\n\t\tobj.set_name(name);\n\t\tappqoepolicy_stats response = (appqoepolicy_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def _pot_month_counts(self, pot_dataset):\n        \"\"\"\n        Return a list of 12 sets. Each sets contains the years included in the POT record period.\n\n        :param pot_dataset: POT dataset (records and meta data)\n        :type pot_dataset: :class:`floodestimation.entities.PotDataset`\n        \"\"\"\n        periods = pot_dataset.continuous_periods()\n        result = [set() for x in range(12)]\n        for period in periods:\n            year = period.start_date.year\n            month = period.start_date.month\n            while True:\n                # Month by month, add the year\n                result[month - 1].add(year)\n                # If at end of period, break loop\n                if year == period.end_date.year and month == period.end_date.month:\n                    break\n                # Next month (and year if needed)\n                month += 1\n                if month == 13:\n                    month = 1\n                    year += 1\n        return result", "label": 1}
{"code": "def active_machines\n      # We have no active machines if we have no data path\n      return [] if !@local_data_path\n\n      machine_folder = @local_data_path.join(\"machines\")\n\n      # If the machine folder is not a directory then we just return\n      # an empty array since no active machines exist.\n      return [] if !machine_folder.directory?\n\n      # Traverse the machines folder accumulate a result\n      result = []\n\n      machine_folder.children(true).each do |name_folder|\n        # If this isn't a directory then it isn't a machine\n        next if !name_folder.directory?\n\n        name = name_folder.basename.to_s.to_sym\n        name_folder.children(true).each do |provider_folder|\n          # If this isn't a directory then it isn't a provider\n          next if !provider_folder.directory?\n\n          # If this machine doesn't have an ID, then ignore\n          next if !provider_folder.join(\"id\").file?\n\n          provider = provider_folder.basename.to_s.to_sym\n          result << [name, provider]\n        end\n      end\n\n      # Return the results\n      result\n    end", "label": 4}
{"code": "def update_gol(self):\n        \"\"\"\n        Function that performs one step of the Game of Life\n        \"\"\"\n        \n        updated_grid = [[self.update_cell(row, col) \\\n                            for col in range(self.get_grid_width())] \\\n                            for row in range(self.get_grid_height())]\n        \n        self.replace_grid(updated_grid)", "label": 1}
{"code": "def setup_router(self, args, kwargs, **fkwargs):\n        \"\"\"\n        Call method to perform any setup\n        \"\"\"\n        self._ready = self._setup_router(args=args, kwargs=kwargs, **fkwargs)\n\n        return self._ready", "label": 1}
{"code": "func (proxy *ProxyClient) ClusterAccessPoint(ctx context.Context, clusterName string, quiet bool) (auth.AccessPoint, error) {\n\tif clusterName == \"\" {\n\t\treturn nil, trace.BadParameter(\"parameter clusterName is missing\")\n\t}\n\tclt, err := proxy.ConnectToCluster(ctx, clusterName, quiet)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn proxy.teleportClient.accessPoint(clt, proxy.proxyAddress, clusterName)\n}", "label": 5}
{"code": "function() {\n      // Need to check if each view is attached because there is no guarentee that if parent is attached, child is attached.\n      if (!this.__attachedCallbackInvoked) {\n        this.trigger('before-attached-callback');\n        this._attached();\n        this.__attachedCallbackInvoked = true;\n        _.each(this.getTrackedViews(), function(view) {\n          if (view.isAttachedToParent()) {\n            view.__invokeAttached();\n          }\n        });\n      }\n    }", "label": 3}
{"code": "def create(self, **kwargs):\n        \"\"\"\n        Create an instance of this resource definition.\n\n        Only one instance may exist at any given time.\n        \"\"\"\n        if self.created:\n            raise RuntimeError(\n                '{} already created.'.format(self.__model_type__.__name__))\n\n        kwargs = self.merge_kwargs(self._create_kwargs, kwargs)\n\n        self._inner = self.helper.create(\n            self.name, *self._create_args, **kwargs)", "label": 1}
{"code": "def to_ode(self) -> HybridOde:\n        \"\"\"Convert to a HybridOde\"\"\"\n        res_split = split_dae_alg(self.f_x, self.dx)\n        alg = res_split['alg']\n        dae = res_split['dae']\n\n        x_rhs = tangent_approx(dae, self.dx, assert_linear=True)\n        y_rhs = tangent_approx(alg, self.y, assert_linear=True)\n\n        return HybridOde(\n            c=self.c,\n            dx=self.dx,\n            f_c=self.f_c,\n            f_i=self.f_i,\n            f_m=self.f_m,\n            f_x_rhs=x_rhs,\n            y_rhs=y_rhs,\n            m=self.m,\n            ng=self.ng,\n            nu=self.nu,\n            p=self.p,\n            pre_m=self.pre_m,\n            pre_c=self.pre_c,\n            prop=self.prop,\n            sym=self.sym,\n            t=self.t,\n            x=self.x,\n            y=self.y,\n        )", "label": 1}
{"code": "def is_valid(doi):\n    \"\"\"\n    Check that a given DOI is a valid canonical DOI.\n\n    :param doi: The DOI to be checked.\n    :returns: Boolean indicating whether the DOI is valid or not.\n\n    >>> is_valid('10.1209/0295-5075/111/40005')\n    True\n\n    >>> is_valid('10.1016.12.31/nature.S0735-1097(98)2000/12/31/34:7-7')\n    True\n\n    >>> is_valid('10.1002/(SICI)1522-2594(199911)42:5<952::AID-MRM16>3.0.CO;2-S')\n    True\n\n    >>> is_valid('10.1007/978-3-642-28108-2_19')\n    True\n\n    >>> is_valid('10.1007.10/978-3-642-28108-2_19')\n    True\n\n    >>> is_valid('10.1016/S0735-1097(98)00347-7')\n    True\n\n    >>> is_valid('10.1579/0044-7447(2006)35\\[89:RDUICP\\]2.0.CO;2')\n    True\n\n    >>> is_valid('<geo coords=\"10.4515260,51.1656910\"></geo>')\n    False\n    \"\"\"\n    match = REGEX.match(doi)\n    return (match is not None) and (match.group(0) == doi)", "label": 1}
{"code": "func GetFirewallInfo(s *object.HostSystem) (*FirewallInfo, error) {\n\tx, err := NewExecutor(s.Client(), s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres, err := x.Run([]string{\"network\", \"firewall\", \"get\"})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo := &FirewallInfo{\n\t\tLoaded:        res.Values[0][\"Loaded\"][0] == \"true\",\n\t\tEnabled:       res.Values[0][\"Enabled\"][0] == \"true\",\n\t\tDefaultAction: res.Values[0][\"DefaultAction\"][0],\n\t}\n\n\treturn info, nil\n}", "label": 5}
{"code": "def seed_fragment_photo(block_label, photo_file)\n      # content_key = self.slug + \"_\" + page_part_key\n      # get in content model associated with page and fragment\n      # join_model = page_contents.find_or_create_by(page_part_key: page_part_key)\n      # page_fragment_content = join_model.create_content(page_part_key: page_part_key)\n      # join_model.save!\n      # page_fragment_content = contents.find_or_create_by(page_part_key: page_part_key)\n\n      page_fragment_content = find_or_create_content\n\n      photo = page_fragment_content.content_photos.find_by_block_key(block_label)\n\n      if photo.present?\n        return photo\n      else\n        photo = page_fragment_content.content_photos.create(block_key: block_label)\n      end\n\n      if ENV[\"RAILS_ENV\"] == \"test\"\n        # don't create photos for tests\n        return nil\n      end\n      begin\n        # if photo_file.is_a?(String)\n        # photo.image = photo_file\n        photo.image = Pwb::Engine.root.join(photo_file).open\n        photo.save!\n        print \"#{slug}--#{page_part_key} image created: #{photo.optimized_image_url}\\n\"\n        # reload the record to ensure that url is available\n        photo.reload\n        print \"#{slug}--#{page_part_key} image created: #{photo.optimized_image_url}(after reload..)\"\n      rescue Exception => e\n        # log exception to console\n        print e\n      end\n      photo\n    end", "label": 4}
{"code": "function MinFunction(win) { \n  var self = this, r;\n  self.win = win;\n  self.name = \"min\";\n  self.type = \"ordered_reverse\";\n  self.init = function() { r = null; };\n  self.accumulate = function(v) { if (v == null) { return; } if (r == null) { r = v; return; } r = (v < r) ? v : r; };\n  self.compensate = function(v) { r = self.win.min(); };\n  self.emit = function()  { return r; };\n  self.make = function(win) { return new MinFunction(win); };\n}", "label": 3}
{"code": "public static int cudnnGetRNNWorkspaceSize(\n        cudnnHandle handle, \n        cudnnRNNDescriptor rnnDesc, \n        int seqLength, \n        cudnnTensorDescriptor[] xDesc, \n        long[] sizeInBytes)\n    {\n        return checkResult(cudnnGetRNNWorkspaceSizeNative(handle, rnnDesc, seqLength, xDesc, sizeInBytes));\n    }", "label": 0}
{"code": "def update_signature!\n      result = Overcommit::Utils.execute(\n        %w[git config --local] + [signature_config_key, signature]\n      )\n\n      unless result.success?\n        raise Overcommit::Exceptions::GitConfigError,\n              \"Unable to write to local repo git config: #{result.stderr}\"\n      end\n    end", "label": 4}
{"code": "def bulk_delete(self, ids=None, filter=None, type=None, all=False): # pylint: disable=redefined-builtin\n        \"\"\"Bulk delete a set of configs.\n\n        :param ids: (optional) Int list of config IDs.\n        :param filter: (optional) String list of filters.\n        :param type: (optional) `union` or `inter` as string.\n        :param all: (optional) Apply to all if bool `True`.\n        \"\"\"\n        return self.service.bulk_delete(self.base, self.RESOURCE,\n                                        ids=ids, filter=filter, type=type, all=all)", "label": 1}
{"code": "def add_ref(self, ref, attr=None):\n        \"\"\"Add reference to resource\n\n        :param ref: reference to add\n        :type ref: Resource\n\n        :rtype: Resource\n        \"\"\"\n        self.session.add_ref(self, ref, attr)\n        return self.fetch()", "label": 1}
{"code": "function createExport(options) {\n  options = Object.assign({}, options, { prepare: false })\n\n  /** we need no styleguide preparation, like asset copying etc. */\n  return resolveStyleguide(options)\n  .then(function (styleguide) {\n    return styleguide.exportStyleguide()\n  })\n  .catch(function (e) {\n    error('Cli.createExport', 'failed to build Styleguide', e)\n    throw (e)\n  })\n    /** create static styleguide structure */\n}", "label": 3}
{"code": "public function isReadOperation(CommandInterface $command)\n    {\n        if (isset($this->disallowed[$id = $command->getId()])) {\n            throw new NotSupportedException(\n                \"The command '$id' is not allowed in replication mode.\"\n            );\n        }\n\n        if (isset($this->readonly[$id])) {\n            if (true === $readonly = $this->readonly[$id]) {\n                return true;\n            }\n\n            return call_user_func($readonly, $command);\n        }\n\n        if (($eval = $id === 'EVAL') || $id === 'EVALSHA') {\n            $sha1 = $eval ? sha1($command->getArgument(0)) : $command->getArgument(0);\n\n            if (isset($this->readonlySHA1[$sha1])) {\n                if (true === $readonly = $this->readonlySHA1[$sha1]) {\n                    return true;\n                }\n\n                return call_user_func($readonly, $command);\n            }\n        }\n\n        return false;\n    }", "label": 2}
{"code": "public static vpnclientlessaccesspolicy[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{\n\t\tvpnclientlessaccesspolicy obj = new vpnclientlessaccesspolicy();\n\t\toptions option = new options();\n\t\toption.set_filter(filter);\n\t\tvpnclientlessaccesspolicy[] response = (vpnclientlessaccesspolicy[]) obj.getfiltered(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def to_api(include_content: false)\n      output = hash_for_api\n      output = output.merge(url_fields)\n\n      # Include content, if requested, otherwise remove it\n      if include_content\n        output = output.merge(content_fields)\n      else\n        CONTENT_FIELDS.each { |field| output.delete(field) }\n      end\n\n      # Documents have duplicate output and content fields, Pages do not\n      # Since it's an API, use `content` in both for consistency\n      output.delete(\"output\")\n\n      # By default, calling to_liquid on a collection will return a docs\n      # array with each rendered document, which we don't want.\n      if is_a?(Jekyll::Collection)\n        output.delete(\"docs\")\n        output[\"entries_url\"] = entries_url\n      end\n\n      if is_a?(Jekyll::Document)\n        output[\"relative_path\"] = relative_path.sub(\"_drafts/\", \"\") if draft?\n        output[\"name\"] = basename\n      end\n\n      if is_a?(Jekyll::StaticFile)\n        output[\"from_theme\"] = from_theme_gem?\n      end\n\n      output\n    end", "label": 4}
{"code": "def when_present(timeout = nil)\n      msg = '#when_present'\n      repl_msg = '#wait_until_present if a wait is still needed'\n      Watir.logger.deprecate msg, repl_msg, ids: [:when_present]\n\n      timeout ||= Watir.default_timeout\n      message = \"waiting for #{selector_string} to become present\"\n\n      if block_given?\n        Wait.until(timeout, message) { present? }\n        yield self\n      else\n        WhenPresentDecorator.new(self, timeout, message)\n      end\n    end", "label": 4}
{"code": "def add_entry(name, cache_entry)\n      Puppet.debug {\"Caching environment '#{name}' #{cache_entry.label}\"}\n      @cache[name] = cache_entry\n      expires = cache_entry.expires\n      @expirations.add(expires)\n      if @next_expiration > expires\n        @next_expiration = expires\n      end\n    end", "label": 4}
{"code": "def environment_keys?(hash)\n      hash.is_a?(Hash) && hash.any? { |k, _| environments.include?(k.to_s) }\n    end", "label": 4}
{"code": "function() {\n\t\tvar top;\n\n\t\tthis.getScope(function(scope) {\n\t\t\tif (scope._meta.viewModel) {\n\t\t\t\ttop = scope;\n\t\t\t}\n\n\t\t\t// walk entire scope tree\n\t\t\treturn false;\n\t\t});\n\n\t\treturn top && top._context;\n\t}", "label": 3}
{"code": "def build(klass, attributes = nil)\n      attributes ||= {}\n      type = attributes[TYPE] || attributes[TYPE.to_sym]\n      if type && klass._types.include?(type)\n        type.constantize.new(attributes)\n      else\n        klass.new(attributes)\n      end\n    end", "label": 4}
{"code": "protected function addControllerIfNotExists(Collection $controllers, $controller)\n    {\n        $class = get_class($controller);\n\n        if ($controllers->has($class)) {\n            return;\n        }\n\n        $reflection = new ReflectionClass($controller);\n\n        $interface = Arr::first($reflection->getInterfaces(), function ($key, $value) {\n            return ends_with($key, 'Docs');\n        });\n\n        if ($interface) {\n            $controller = $interface;\n        }\n\n        $controllers->put($class, $controller);\n    }", "label": 2}
{"code": "func (p *TerminalParams) String() string {\n\treturn fmt.Sprintf(\"TerminalParams(w=%v, h=%v)\", p.W, p.H)\n}", "label": 5}
{"code": "def zlib_compression_level(value)\n      if /\\A-?\\d+\\z/ =~ value\n        i = value.to_i\n\n        if i >= -1 && i <= 9\n          return i\n        end\n      end\n\n      log_warn(\"#{value} is not a valid zlibCompressionLevel\")\n      nil\n    end", "label": 4}
{"code": "public function getProperty($property)\n    {\n        return isset($this->entity[$property])\n            ? $this->entity[$property]\n            : null;\n    }", "label": 2}
{"code": "private void ensurePKsFromHierarchy(ClassDescriptorDef classDef) throws ConstraintException\r\n    {\r\n        SequencedHashMap pks = new SequencedHashMap();\r\n\r\n        for (Iterator it = classDef.getAllExtentClasses(); it.hasNext();)\r\n        {\r\n            ClassDescriptorDef subTypeDef = (ClassDescriptorDef)it.next();\r\n\r\n            ArrayList subPKs = subTypeDef.getPrimaryKeys();\r\n\r\n            // check against already present PKs\r\n            for (Iterator pkIt = subPKs.iterator(); pkIt.hasNext();)\r\n            {\r\n                FieldDescriptorDef fieldDef   = (FieldDescriptorDef)pkIt.next();\r\n                FieldDescriptorDef foundPKDef = (FieldDescriptorDef)pks.get(fieldDef.getName());\r\n\r\n                if (foundPKDef != null)\r\n                {\r\n                    if (!isEqual(fieldDef, foundPKDef))\r\n                    {\r\n                        throw new ConstraintException(\"Cannot pull up the declaration of the required primary key \"+fieldDef.getName()+\r\n                                                      \" because its definitions in \"+fieldDef.getOwner().getName()+\" and \"+\r\n                                                      foundPKDef.getOwner().getName()+\" differ\");\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    pks.put(fieldDef.getName(), fieldDef);\r\n                }\r\n            }\r\n        }\r\n\r\n        ensureFields(classDef, pks.values());\r\n    }", "label": 0}
{"code": "func PgRelkind(relType internal.RelType) string {\n\tvar s string\n\tswitch relType {\n\tcase internal.Table:\n\t\ts = \"r\"\n\tcase internal.View:\n\t\ts = \"v\"\n\tdefault:\n\t\tpanic(\"unsupported RelType\")\n\t}\n\treturn s\n}", "label": 5}
{"code": "func (sink *influxdbSink) GetPodsFromNamespace(namespace string) ([]string, error) {\n\tif !nameAllowedChars.MatchString(namespace) {\n\t\treturn nil, fmt.Errorf(\"Invalid namespace name %q\", namespace)\n\t}\n\t// This is a bit difficult for the influx query language, so we cheat a bit here --\n\t// we just get all series for the uptime measurement for pods which match our namespace\n\t// (any measurement should work here, though)\n\tq := fmt.Sprintf(\"SHOW SERIES FROM %q WHERE %s = '%s' AND type = '%s'\", core.MetricUptime.MetricDescriptor.Name, core.LabelNamespaceName.Key, namespace, core.MetricSetTypePod)\n\treturn sink.stringListQueryCol(q, core.LabelPodName.Key, fmt.Sprintf(\"Unable to list pods in namespace %q\", namespace))\n}", "label": 5}
{"code": "def to_pdf(options = {})\n      # reset version if not specified\n      @version = 1.5 if @version.to_f == 0.0\n      # set info for merged file\n      @info[:ModDate] = @info[:CreationDate] = Time.now.strftime \"D:%Y%m%d%H%M%S%:::z'00\"\n      @info[:Subject] = options[:subject] if options[:subject]\n      @info[:Producer] = options[:producer] if options[:producer]\n      # rebuild_catalog\n      catalog = rebuild_catalog_and_objects\n      # add ID and generation numbers to objects\n      renumber_object_ids\n\n      out = []\n      xref = []\n      indirect_object_count = 1 # the first object is the null object\n      # write head (version and binanry-code)\n      out << \"%PDF-#{@version}\\n%\\xFF\\xFF\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x00\".force_encoding(Encoding::ASCII_8BIT)\n\n      # collect objects and set xref table locations\n      loc = 0\n      out.each { |line| loc += line.bytesize + 1 }\n      @objects.each do |o|\n        indirect_object_count += 1\n        xref << loc\n        out << object_to_pdf(o)\n        loc += out.last.bytesize + 1\n      end\n      xref_location = loc\n      # xref_location = 0\n      # out.each { |line| xref_location += line.bytesize + 1}\n      out << \"xref\\n0 #{indirect_object_count}\\n0000000000 65535 f \\n\"\n      xref.each { |offset| out << (out.pop + (\"%010d 00000 n \\n\" % offset)) }\n      out << out.pop + 'trailer'\n      out << \"<<\\n/Root #{false || \"#{catalog[:indirect_reference_id]} #{catalog[:indirect_generation_number]} R\"}\"\n      out << \"/Size #{indirect_object_count}\"\n      out << \"/Info #{@info[:indirect_reference_id]} #{@info[:indirect_generation_number]} R\"\n      out << \">>\\nstartxref\\n#{xref_location}\\n%%EOF\"\n      # when finished, remove the numbering system and keep only pointers\n      remove_old_ids\n      # output the pdf stream\n      out.join(\"\\n\".force_encoding(Encoding::ASCII_8BIT)).force_encoding(Encoding::ASCII_8BIT)\n    end", "label": 4}
{"code": "public static authenticationcertpolicy_systemglobal_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauthenticationcertpolicy_systemglobal_binding obj = new authenticationcertpolicy_systemglobal_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationcertpolicy_systemglobal_binding response[] = (authenticationcertpolicy_systemglobal_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def post(self, *args, **kwargs):\n        \"\"\"\n        This method handles POST requests.\n\n        The wizard will render either the current step (if form validation\n        wasn't successful), the next step (if the current step was stored\n        successful) or the done view (if no more steps are available)\n        \"\"\"\n        # Look for a wizard_prev_step element in the posted data which\n        # contains a valid step name. If one was found, render the requested\n        # form. (This makes stepping back a lot easier).\n        wizard_prev_step = self.request.POST.get('wizard_prev_step', None)\n        if wizard_prev_step and wizard_prev_step in self.get_form_list():\n            self.storage.current_step = wizard_prev_step\n            form = self.get_form(\n                data=self.storage.get_step_data(self.steps.current),\n                files=self.storage.get_step_files(self.steps.current))\n            return self.render(form)\n\n        # Check if form was refreshed\n        management_form = ManagementForm(self.request.POST, prefix=self.prefix)\n        if not management_form.is_valid():\n            raise ValidationError(\n                'ManagementForm data is missing or has been tampered.')\n\n        form_current_step = management_form.cleaned_data['current_step']\n        if (form_current_step != self.steps.current and\n                self.storage.current_step is not None):\n            # form refreshed, change current step\n            self.storage.current_step = form_current_step\n\n        # get the form for the current step\n        form = self.get_form(data=self.request.POST, files=self.request.FILES)\n\n        # and try to validate\n        if form.is_valid():\n            # if the form is valid, store the cleaned data and files.\n            self.storage.set_step_data(self.steps.current, self.process_step(form))\n            self.storage.set_step_files(self.steps.current, self.process_step_files(form))\n\n            # check if the current step is the last step\n            if self.steps.current == self.steps.last:\n                # no more steps, render done view\n                return self.render_done(form, **kwargs)\n            else:\n                # proceed to the next step\n                return self.render_next_step(form)\n        return self.render(form)", "label": 1}
{"code": "def remember_transaction_record_state\n        @_start_transaction_state ||= {\n          id: id,\n          new_record: @new_record,\n          destroyed: @destroyed,\n          attributes: @attributes,\n          frozen?: frozen?,\n          level: 0\n        }\n        @_start_transaction_state[:level] += 1\n        remember_new_record_before_last_commit\n      end", "label": 4}
{"code": "func (sink *influxdbSink) parseRawQueryRow(rawRow influx_models.Row) ([]core.TimestampedMetricValue, error) {\n\tvals := make([]core.TimestampedMetricValue, len(rawRow.Values))\n\twasInt := make(map[string]bool, 1)\n\tfor i, rawVal := range rawRow.Values {\n\t\tval := core.TimestampedMetricValue{}\n\n\t\tif ts, err := time.Parse(time.RFC3339, rawVal[0].(string)); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Unable to parse timestamp %q in series %q\", rawVal[0].(string), rawRow.Name)\n\t\t} else {\n\t\t\tval.Timestamp = ts\n\t\t}\n\n\t\tif err := tryParseMetricValue(\"value\", rawVal, &val.MetricValue, 1, wasInt); err != nil {\n\t\t\tglog.Errorf(\"Unable to parse field \\\"value\\\" in series %q: %v\", rawRow.Name, err)\n\t\t\treturn nil, fmt.Errorf(\"Unable to parse values in series %q\", rawRow.Name)\n\t\t}\n\n\t\tvals[i] = val\n\t}\n\n\tif wasInt[\"value\"] {\n\t\tfor i := range vals {\n\t\t\tvals[i].MetricValue.ValueType = core.ValueInt64\n\t\t}\n\t} else {\n\t\tfor i := range vals {\n\t\t\tvals[i].MetricValue.ValueType = core.ValueFloat\n\t\t}\n\t}\n\n\treturn vals, nil\n}", "label": 5}
{"code": "function narrowType(type, expr, assumeTrue) {\n                switch (expr.kind) {\n                    case 69 /* Identifier */:\n                    case 97 /* ThisKeyword */:\n                    case 172 /* PropertyAccessExpression */:\n                        return narrowTypeByTruthiness(type, expr, assumeTrue);\n                    case 174 /* CallExpression */:\n                        return narrowTypeByTypePredicate(type, expr, assumeTrue);\n                    case 178 /* ParenthesizedExpression */:\n                        return narrowType(type, expr.expression, assumeTrue);\n                    case 187 /* BinaryExpression */:\n                        return narrowTypeByBinaryExpression(type, expr, assumeTrue);\n                    case 185 /* PrefixUnaryExpression */:\n                        if (expr.operator === 49 /* ExclamationToken */) {\n                            return narrowType(type, expr.operand, !assumeTrue);\n                        }\n                        break;\n                }\n                return type;\n            }", "label": 3}
{"code": "def copy(\n            self,\n            name,\n            start_codons=None,\n            stop_codons=None,\n            codon_table=None,\n            codon_table_changes=None):\n        \"\"\"\n        Make copy of this GeneticCode object with optional replacement\n        values for all fields.\n        \"\"\"\n        new_start_codons = (\n            self.start_codons.copy()\n            if start_codons is None\n            else start_codons)\n\n        new_stop_codons = (\n            self.stop_codons.copy()\n            if stop_codons is None\n            else stop_codons)\n\n        new_codon_table = (\n            self.codon_table.copy()\n            if codon_table is None\n            else codon_table)\n\n        if codon_table_changes is not None:\n            new_codon_table.update(codon_table_changes)\n\n        return GeneticCode(\n            name=name,\n            start_codons=new_start_codons,\n            stop_codons=new_stop_codons,\n            codon_table=new_codon_table)", "label": 1}
{"code": "func getIoProgressReader(label string, res *http.Response) io.Reader {\n\tprefix := \"Downloading \" + label\n\tfmtBytesSize := 18\n\tbarSize := int64(80 - len(prefix) - fmtBytesSize)\n\tbar := ioprogress.DrawTextFormatBarForW(barSize, os.Stderr)\n\tfmtfunc := func(progress, total int64) string {\n\t\t// Content-Length is set to -1 when unknown.\n\t\tif total == -1 {\n\t\t\treturn fmt.Sprintf(\n\t\t\t\t\"%s: %v of an unknown total size\",\n\t\t\t\tprefix,\n\t\t\t\tioprogress.ByteUnitStr(progress),\n\t\t\t)\n\t\t}\n\t\treturn fmt.Sprintf(\n\t\t\t\"%s: %s %s\",\n\t\t\tprefix,\n\t\t\tbar(progress, total),\n\t\t\tioprogress.DrawTextFormatBytes(progress, total),\n\t\t)\n\t}\n\treturn &ioprogress.Reader{\n\t\tReader:       res.Body,\n\t\tSize:         res.ContentLength,\n\t\tDrawFunc:     ioprogress.DrawTerminalf(os.Stderr, fmtfunc),\n\t\tDrawInterval: time.Second,\n\t}\n}", "label": 5}
{"code": "func JoinSubcgroup(controller string, subcgroup string) error {\n\tsubcgroupPath := filepath.Join(\"/sys/fs/cgroup\", controller, subcgroup)\n\tif err := os.MkdirAll(subcgroupPath, 0600); err != nil {\n\t\treturn errwrap.Wrap(fmt.Errorf(\"error creating %q subcgroup\", subcgroup), err)\n\t}\n\tpidBytes := []byte(strconv.Itoa(os.Getpid()))\n\tif err := ioutil.WriteFile(filepath.Join(subcgroupPath, \"cgroup.procs\"), pidBytes, 0600); err != nil {\n\t\treturn errwrap.Wrap(fmt.Errorf(\"error adding ourselves to the %q subcgroup\", subcgroup), err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public function get_aliases() {\n\t\t$runtime_alias = getenv( 'WP_CLI_RUNTIME_ALIAS' );\n\t\tif ( false !== $runtime_alias ) {\n\t\t\t$returned_aliases = array();\n\t\t\tforeach ( json_decode( $runtime_alias, true ) as $key => $value ) {\n\t\t\t\tif ( preg_match( '#' . self::ALIAS_REGEX . '#', $key ) ) {\n\t\t\t\t\t$returned_aliases[ $key ] = array();\n\t\t\t\t\tforeach ( self::$alias_spec as $i ) {\n\t\t\t\t\t\tif ( isset( $value[ $i ] ) ) {\n\t\t\t\t\t\t\t$returned_aliases[ $key ][ $i ] = $value[ $i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $returned_aliases;\n\t\t}\n\n\t\treturn $this->aliases;\n\t}", "label": 2}
{"code": "def search_orcid(orcid):\n    \"\"\"\n    Search the ORCID public API\n\n    Specfically, return a dictionary with the personal details\n    (name, etc.) of the person associated with the given ORCID\n\n    Args:\n        orcid (`str`): The ORCID to be searched\n\n    Returns:\n        `dict`: Dictionary with the JSON response from the API\n\n    Raises:\n        `~requests.HTTPError`: If the given ORCID cannot be found, an `~requests.HTTPError`\n            is raised with status code 404\n    \"\"\"\n    url = 'https://pub.orcid.org/v2.1/{orcid}/person'.format(orcid=orcid)\n    r = requests.get(url, headers=headers)\n    if r.status_code != 200:\n        r.raise_for_status()\n    return r.json()", "label": 1}
{"code": "def update_fields(fields)\n      attributes[:yellow]  = fields['yellow'] || attributes[:yellow]\n      attributes[:red] = fields['red'] || attributes[:red]\n      attributes[:orange] = fields['orange'] || attributes[:orange]\n      attributes[:green] = fields['green'] || attributes[:green]\n      attributes[:purple] = fields['purple'] || attributes[:purple]\n      attributes[:blue] = fields['blue'] || attributes[:blue]\n      attributes[:sky] = fields['sky'] || attributes[:sky]\n      attributes[:pink] = fields['pink'] || attributes[:pink]\n      attributes[:lime] = fields['lime'] || attributes[:lime]\n      attributes[:black] = fields['black'] || attributes[:black]\n\n      self\n    end", "label": 4}
{"code": "func (a *allocator) ReleaseAddress(poolID string, address net.IP) error {\n\tvar relAddress string\n\tif address != nil {\n\t\trelAddress = address.String()\n\t}\n\treq := &api.ReleaseAddressRequest{PoolID: poolID, Address: relAddress}\n\tres := &api.ReleaseAddressResponse{}\n\treturn a.call(\"ReleaseAddress\", req, res)\n}", "label": 5}
{"code": "def plot_all(*args, **kwargs):\n    '''\n    Read all the trial data and plot the result of applying a function on them.\n    '''\n    dfs = do_all(*args, **kwargs)\n    ps = []\n    for line in dfs:\n        f, df, config = line\n        df.plot(title=config['name'])\n        ps.append(df)\n    return ps", "label": 1}
{"code": "public static function contentType(array $operations)\n    {\n        return function (callable $handler) use ($operations) {\n            return function (\n                CommandInterface $command,\n                RequestInterface $request = null\n            ) use ($handler, $operations) {\n                if (!$request->hasHeader('Content-Type')\n                    && in_array($command->getName(), $operations, true)\n                    && ($uri = $request->getBody()->getMetadata('uri'))\n                ) {\n                    $request = $request->withHeader(\n                        'Content-Type',\n                        Psr7\\mimetype_from_filename($uri) ?: 'application/octet-stream'\n                    );\n                }\n\n                return $handler($command, $request);\n            };\n        };\n    }", "label": 2}
{"code": "public void addBatch(PreparedStatement stmt) throws PlatformException\r\n    {\r\n        // Check for Oracle batching support\r\n        final boolean statementBatchingSupported = m_batchStatementsInProgress.containsKey(stmt);\r\n        if (statementBatchingSupported)\r\n        {\r\n            try\r\n            {\r\n                stmt.executeUpdate();\r\n            }\r\n            catch (SQLException e)\r\n            {\r\n                throw new PlatformException(e.getLocalizedMessage(), e);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            super.addBatch(stmt);\r\n        }\r\n    }", "label": 0}
{"code": "public static ComplexNumber Subtract(ComplexNumber z1, ComplexNumber z2) {\r\n        return new ComplexNumber(z1.real - z2.real, z1.imaginary - z2.imaginary);\r\n    }", "label": 0}
{"code": "func (nDB *NetworkDB) SetKey(key []byte) {\n\tlogrus.Debugf(\"Adding key %.5s\", hex.EncodeToString(key))\n\tnDB.Lock()\n\tdefer nDB.Unlock()\n\tfor _, dbKey := range nDB.config.Keys {\n\t\tif bytes.Equal(key, dbKey) {\n\t\t\treturn\n\t\t}\n\t}\n\tnDB.config.Keys = append(nDB.config.Keys, key)\n\tif nDB.keyring != nil {\n\t\tnDB.keyring.AddKey(key)\n\t}\n}", "label": 5}
{"code": "def create_missing_type_variants(cls, type_names, type_dict):\n        \"\"\"\n        Create missing type variants for types with a cardinality field.\n\n        :param type_names: List of type names with cardinality field suffix.\n        :param type_dict:  Type dictionary with named type converters.\n        :return: Type dictionary with missing type converter variants.\n        \"\"\"\n        missing_type_names = [ name for name in type_names\n                               if name not in type_dict ]\n        return cls.create_type_variants(missing_type_names, type_dict)", "label": 1}
{"code": "def upload(app_id, dir)\n      actual_dir = File.join(dir, \"#{app_id}.itmsp\")\n\n      UI.message(\"Going to upload updated app to App Store Connect\")\n      UI.success(\"This might take a few minutes. Please don't interrupt the script.\")\n\n      command = @transporter_executor.build_upload_command(@user, @password, actual_dir, @provider_short_name)\n      UI.verbose(@transporter_executor.build_upload_command(@user, 'YourPassword', actual_dir, @provider_short_name))\n\n      begin\n        result = @transporter_executor.execute(command, ItunesTransporter.hide_transporter_output?)\n      rescue TransporterRequiresApplicationSpecificPasswordError => ex\n        handle_two_step_failure(ex)\n        return upload(app_id, dir)\n      end\n\n      if result\n        UI.header(\"Successfully uploaded package to App Store Connect. It might take a few minutes until it's visible online.\")\n\n        FileUtils.rm_rf(actual_dir) unless Helper.test? # we don't need the package any more, since the upload was successful\n      else\n        handle_error(@password)\n      end\n\n      result\n    end", "label": 4}
{"code": "public static policystringmap[] get(nitro_service service) throws Exception{\n\t\tpolicystringmap obj = new policystringmap();\n\t\tpolicystringmap[] response = (policystringmap[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (l *localFileInfo) GetModePerm() os.FileMode {\n\treturn l.fileInfo.Mode() & os.ModePerm\n}", "label": 5}
{"code": "def read_from_disk\n      return {} if !File.file?(answer_file_path) || File.zero?(answer_file_path)\n\n      unless File.readable?(answer_file_path)\n        raise PDK::CLI::FatalError, _(\"Unable to open '%{file}' for reading\") % {\n          file: answer_file_path,\n        }\n      end\n\n      answers = JSON.parse(File.read(answer_file_path))\n      if answers.is_a?(Hash)\n        answers\n      else\n        PDK.logger.warn _(\"Answer file '%{path}' did not contain a valid set of answers, recreating it\") % {\n          path: answer_file_path,\n        }\n        {}\n      end\n    rescue JSON::JSONError\n      PDK.logger.warn _(\"Answer file '%{path}' did not contain valid JSON, recreating it\") % {\n        path: answer_file_path,\n      }\n      {}\n    end", "label": 4}
{"code": "func NewNetworkCli(out, err io.Writer, call CallFunc) *NetworkCli {\n\treturn &NetworkCli{\n\t\tout:  out,\n\t\terr:  err,\n\t\tcall: call,\n\t}\n}", "label": 5}
{"code": "function (value, length, pad) {\n        return _gpfToBaseANY(_gpfB64, value, {\n            length: length,\n            pad: pad\n        });\n    }", "label": 3}
{"code": "func (c *networkConfiguration) Validate() error {\n\tif c.Mtu < 0 {\n\t\treturn ErrInvalidMtu(c.Mtu)\n\t}\n\n\t// If bridge v4 subnet is specified\n\tif c.AddressIPv4 != nil {\n\t\t// If default gw is specified, it must be part of bridge subnet\n\t\tif c.DefaultGatewayIPv4 != nil {\n\t\t\tif !c.AddressIPv4.Contains(c.DefaultGatewayIPv4) {\n\t\t\t\treturn &ErrInvalidGateway{}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If default v6 gw is specified, AddressIPv6 must be specified and gw must belong to AddressIPv6 subnet\n\tif c.EnableIPv6 && c.DefaultGatewayIPv6 != nil {\n\t\tif c.AddressIPv6 == nil || !c.AddressIPv6.Contains(c.DefaultGatewayIPv6) {\n\t\t\treturn &ErrInvalidGateway{}\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "func (s *Server) EnableDiagnostic(ip string, port int) {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\ts.port = port\n\n\tif s.enable == 1 {\n\t\tlogrus.Info(\"The server is already up and running\")\n\t\treturn\n\t}\n\n\tlogrus.Infof(\"Starting the diagnostic server listening on %d for commands\", port)\n\tsrv := &http.Server{Addr: fmt.Sprintf(\"%s:%d\", ip, port), Handler: s}\n\ts.srv = srv\n\ts.enable = 1\n\tgo func(n *Server) {\n\t\t// Ignore ErrServerClosed that is returned on the Shutdown call\n\t\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tlogrus.Errorf(\"ListenAndServe error: %s\", err)\n\t\t\tatomic.SwapInt32(&n.enable, 0)\n\t\t}\n\t}(s)\n}", "label": 5}
{"code": "protected function getEmailAddress($token)\n    {\n        $url = 'https://api.linkedin.com/v2/emailAddress?q=members&projection=(elements*(handle~))';\n\n        $response = $this->getHttpClient()->get($url, [\n            'headers' => [\n                'Authorization' => 'Bearer '.$token,\n                'X-RestLi-Protocol-Version' => '2.0.0',\n            ],\n        ]);\n\n        return (array) Arr::get((array) json_decode($response->getBody(), true), 'elements.0.handle~');\n    }", "label": 2}
{"code": "public function serialize(): string\n    {\n        return serialize([\n            $this->password,\n            $this->salt,\n            $this->usernameCanonical,\n            $this->username,\n            $this->locked,\n            $this->enabled,\n            $this->id,\n            $this->encoderName,\n        ]);\n    }", "label": 2}
{"code": "private function getDatabaseAdminClient()\n    {\n        //@codeCoverageIgnoreStart\n        if ($this->databaseAdminClient) {\n            return $this->databaseAdminClient;\n        }\n        //@codeCoverageIgnoreEnd\n\n        $this->databaseAdminClient = new DatabaseAdminClient($this->grpcConfig);\n\n        return $this->databaseAdminClient;\n    }", "label": 2}
{"code": "def arg_tup_to_dict(argument_tuples):\n    \"\"\"Given a set of argument tuples, set their value in a data dictionary if not blank\"\"\"\n    data = dict()\n    for arg_name, arg_val in argument_tuples:\n        if arg_val is not None:\n            if arg_val is True:\n                arg_val = 'true'\n            elif arg_val is False:\n                arg_val = 'false'\n            data[arg_name] = arg_val\n\n    return data", "label": 1}
{"code": "public static cmppolicylabel_stats get(nitro_service service, String labelname) throws Exception{\n\t\tcmppolicylabel_stats obj = new cmppolicylabel_stats();\n\t\tobj.set_labelname(labelname);\n\t\tcmppolicylabel_stats response = (cmppolicylabel_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function transform(str, from, to) {\n  let out = '';\n  const escaped = '\\\\' + to;\n\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === to) {\n      out += escaped;\n    } else if (str[i] === from) {\n      out += to;\n    } else if (str[i] === '\\\\' && i + 1 < str.length && str[i + 1] === from) {\n      out += from;\n      i++;\n    } else {\n      out += str[i];\n    }\n  }\n  return out;\n}", "label": 3}
{"code": "def template_path(key, partial_root)\n      path = key.split(\".\")\n      path.delete_at(0) if path[0] == \"activity\"\n      path.unshift partial_root\n      path.join(\"/\")\n    end", "label": 4}
{"code": "public static bridgegroup_vlan_binding[] get(nitro_service service, Long id) throws Exception{\n\t\tbridgegroup_vlan_binding obj = new bridgegroup_vlan_binding();\n\t\tobj.set_id(id);\n\t\tbridgegroup_vlan_binding response[] = (bridgegroup_vlan_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def close(close_child_stream = true)\n      return if closed?\n\n      if size.positive?\n        final = @stream_cipher.final\n        @ios.write(final) unless final.empty?\n      end\n      @ios.close if close_child_stream\n      @closed = true\n    end", "label": 4}
{"code": "func (s *Server) Certificate() *x509.Certificate {\n\t// By default httptest.StartTLS uses http/internal.LocalhostCert, which we can access here:\n\tcert, _ := x509.ParseCertificate(s.TLS.Certificates[0].Certificate[0])\n\treturn cert\n}", "label": 5}
{"code": "def use(middleware, *args, &block)\n      return if faraday.builder.locked?\n      faraday.builder.insert_before(Middleware::ParseJson, middleware, *args, &block)\n    end", "label": 4}
{"code": "public function getAbbreviatedName($dst = false)\n    {\n        $name = $this->getName();\n\n        foreach ($this->listAbbreviations() as $abbreviation => $zones) {\n            foreach ($zones as $zone) {\n                if ($zone['timezone_id'] === $name && $zone['dst'] == $dst) {\n                    return $abbreviation;\n                }\n            }\n        }\n\n        return 'unknown';\n    }", "label": 2}
{"code": "public static base_response delete(nitro_service client, sslcertkey resource) throws Exception {\n\t\tsslcertkey deleteresource = new sslcertkey();\n\t\tdeleteresource.certkey = resource.certkey;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "function resolveInjects(obj, override){\n    var injects = obj.$inject || override;\n\n    if (exists(injects)) {\n      if (!Array.isArray(injects)) {\n        injects = [injects];\n      }\n      injects.forEach(function addInjects(element) {\n        addInject(obj, element);\n      });\n    }\n  }", "label": 3}
{"code": "func (cfg *UploaderConfig) CheckAndSetDefaults() error {\n\tif cfg.ServerID == \"\" {\n\t\treturn trace.BadParameter(\"missing parameter ServerID\")\n\t}\n\tif cfg.AuditLog == nil {\n\t\treturn trace.BadParameter(\"missing parameter AuditLog\")\n\t}\n\tif cfg.DataDir == \"\" {\n\t\treturn trace.BadParameter(\"missing parameter DataDir\")\n\t}\n\tif cfg.Namespace == \"\" {\n\t\treturn trace.BadParameter(\"missing parameter Namespace\")\n\t}\n\tif cfg.ConcurrentUploads <= 0 {\n\t\tcfg.ConcurrentUploads = defaults.UploaderConcurrentUploads\n\t}\n\tif cfg.ScanPeriod <= 0 {\n\t\tcfg.ScanPeriod = defaults.UploaderScanPeriod\n\t}\n\tif cfg.Context == nil {\n\t\tcfg.Context = context.TODO()\n\t}\n\tif cfg.Clock == nil {\n\t\tcfg.Clock = clockwork.NewRealClock()\n\t}\n\treturn nil\n}", "label": 5}
{"code": "private function getContext()\n    {\n        if (!$this->context) {\n            $key = isset($this->options['key']) ? $this->options['key'] : null;\n            $this->context = hash_init(\n                $this->algo,\n                $key ? HASH_HMAC : 0,\n                $key\n            );\n        }\n\n        return $this->context;\n    }", "label": 2}
{"code": "public void createLinks(ServiceReference<D> declarationSRef) {\n        D declaration = getDeclaration(declarationSRef);\n        for (ServiceReference<S> serviceReference : linkerManagement.getMatchedBinderServiceRef()) {\n            if (linkerManagement.canBeLinked(declaration, serviceReference)) {\n                linkerManagement.link(declaration, serviceReference);\n            }\n        }\n    }", "label": 0}
{"code": "public PropertiesEnvelope createUserProperties(String userId, AppProperties properties, String aid) throws ApiException {\n        ApiResponse<PropertiesEnvelope> resp = createUserPropertiesWithHttpInfo(userId, properties, aid);\n        return resp.getData();\n    }", "label": 0}
{"code": "def available_locales_set #:nodoc:\n      @@available_locales_set ||= available_locales.inject(Set.new) do |set, locale|\n        set << locale.to_s << locale.to_sym\n      end\n    end", "label": 4}
{"code": "def fq2fa(fq):\n    \"\"\"\n    convert fq to fa\n    \"\"\"\n    c = cycle([1, 2, 3, 4])\n    for line in fq:\n        n = next(c)\n        if n == 1:\n            seq = ['>%s' % (line.strip().split('@', 1)[1])]\n        if n == 2:\n            seq.append(line.strip())\n            yield seq", "label": 1}
{"code": "def to_db(catchment, session, method='create', autocommit=False):\n    \"\"\"\n    Load catchment object into the database.\n\n    A catchment/station number (:attr:`catchment.id`) must be provided. If :attr:`method` is set to `update`, any\n    existing catchment in the database with the same catchment number will be updated.\n\n    :param catchment: New catchment object to replace any existing catchment in the database\n    :type catchment: :class:`.entities.Catchment`\n    :param session: Database session to use, typically `floodestimation.db.Session()`\n    :type session: :class:`sqlalchemy.orm.session.Session`\n    :param method: - ``create``: only new catchments will be loaded, it must not already exist in the database.\n                   - ``update``: any existing catchment in the database will be updated. Otherwise it will be created.\n    :type method: str\n    :param autocommit: Whether to commit the database session immediately. Default: ``False``.\n    :type autocommit: bool\n    \"\"\"\n\n    if not catchment.id:\n        raise ValueError(\"Catchment/station number (`catchment.id`) must be set.\")\n    if method == 'create':\n        session.add(catchment)\n    elif method == 'update':\n        session.merge(catchment)\n    else:\n        raise ValueError(\"Method `{}` invalid. Use either `create` or `update`.\")\n    if autocommit:\n        session.commit()", "label": 1}
{"code": "def current(class_):\n\t\t\"Windows Platform SDK GetTimeZoneInformation\"\n\t\ttzi = class_()\n\t\tkernel32 = ctypes.windll.kernel32\n\t\tgetter = kernel32.GetTimeZoneInformation\n\t\tgetter = getattr(kernel32, 'GetDynamicTimeZoneInformation', getter)\n\t\tcode = getter(ctypes.byref(tzi))\n\t\treturn code, tzi", "label": 1}
{"code": "function tryClassifyNode(node) {\n                if (ts.isJSDocTag(node)) {\n                    return true;\n                }\n                if (ts.nodeIsMissing(node)) {\n                    return true;\n                }\n                var classifiedElementName = tryClassifyJsxElementName(node);\n                if (!ts.isToken(node) && node.kind !== 244 /* JsxText */ && classifiedElementName === undefined) {\n                    return false;\n                }\n                var tokenStart = node.kind === 244 /* JsxText */ ? node.pos : classifyLeadingTriviaAndGetTokenStart(node);\n                var tokenWidth = node.end - tokenStart;\n                ts.Debug.assert(tokenWidth >= 0);\n                if (tokenWidth > 0) {\n                    var type = classifiedElementName || classifyTokenType(node.kind, node);\n                    if (type) {\n                        pushClassification(tokenStart, tokenWidth, type);\n                    }\n                }\n                return true;\n            }", "label": 3}
{"code": "func DjangoAdminLogsByContentTypeID(db XODB, contentTypeID sql.NullInt64) ([]*DjangoAdminLog, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`id, action_time, object_id, object_repr, action_flag, change_message, content_type_id, user_id ` +\n\t\t`FROM public.django_admin_log ` +\n\t\t`WHERE content_type_id = $1`\n\n\t// run query\n\tXOLog(sqlstr, contentTypeID)\n\tq, err := db.Query(sqlstr, contentTypeID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer q.Close()\n\n\t// load results\n\tres := []*DjangoAdminLog{}\n\tfor q.Next() {\n\t\tdal := DjangoAdminLog{\n\t\t\t_exists: true,\n\t\t}\n\n\t\t// scan\n\t\terr = q.Scan(&dal.ID, &dal.ActionTime, &dal.ObjectID, &dal.ObjectRepr, &dal.ActionFlag, &dal.ChangeMessage, &dal.ContentTypeID, &dal.UserID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres = append(res, &dal)\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "def validate_attribute_value(access, value)\n      return unless fields[access] && value\n      validatable_types = [ Hash, Array ]\n      if validatable_types.include? fields[access].type\n        unless value.is_a? fields[access].type\n          raise Mongoid::Errors::InvalidValue.new(fields[access].type, value.class)\n        end\n      end\n    end", "label": 4}
{"code": "def context(self):\n        \"\"\"Get the context.\"\"\"\n        stats = status_codes_by_date_stats()\n\n        attacks_data = [{\n            'type': 'line',\n            'zIndex': 9,\n            'name': _('Attacks'),\n            'data': [(v[0], v[1]['attacks'])\n                     for v in stats]\n        }]\n\n        codes_data = [{\n            'zIndex': 4,\n            'name': '2xx',\n            'data': [(v[0], v[1][200]) for v in stats]\n        }, {\n            'zIndex': 5,\n            'name': '3xx',\n            'data': [(v[0], v[1][300]) for v in stats]\n        }, {\n            'zIndex': 6,\n            'name': '4xx',\n            'data': [(v[0], v[1][400]) for v in stats]\n        }, {\n            'zIndex': 8,\n            'name': '5xx',\n            'data': [(v[0], v[1][500]) for v in stats]\n        }]\n\n        return {'generic_chart': json.dumps(status_codes_by_date_chart()),\n                'attacks_data': json.dumps(attacks_data),\n                'codes_data': json.dumps(codes_data)}", "label": 1}
{"code": "def put(self):\n        \"\"\"\n        Provides move, copy, and rename functionality. An action must be\n        specified when calling this method.\n        \"\"\"\n        self.fp = self.get_body_argument('filepath')\n        self.action = self.get_body_argument('action')\n\n        try:\n            ptype = self.fs.get_type_from_path(self.fp)\n        except OSError:\n            raise tornado.web.HTTPError(404)\n        if ptype == 'directory':\n            self.handler_name = 'filesystem:directories-details'\n        else:\n            self.handler_name = 'filesystem:files-details'\n\n        if self.action['action'] == 'move':\n            newpath = self._move()\n            self.write({'filepath':newpath})\n        elif self.action['action'] == 'copy':\n            newpath = self._copy()\n            self.write({'filepath':newpath})\n        elif self.action['action'] == 'rename':\n            newpath = self._rename()\n            self.write({'filepath':newpath})\n        else:\n            raise tornado.web.HTTPError(400)", "label": 1}
{"code": "public void loadClassifier(String loadPath, Properties props) throws ClassCastException, IOException, ClassNotFoundException {\r\n    InputStream is;\r\n    // ms, 10-04-2010: check first is this path exists in our CLASSPATH. This\r\n    // takes priority over the file system.\r\n    if ((is = loadStreamFromClasspath(loadPath)) != null) {\r\n      Timing.startDoing(\"Loading classifier from \" + loadPath);\r\n      loadClassifier(is);\r\n      is.close();\r\n      Timing.endDoing();\r\n    } else {\r\n      loadClassifier(new File(loadPath), props);\r\n    }\r\n  }", "label": 0}
{"code": "public static dnsaaaarec[] get(nitro_service service, dnsaaaarec_args args) throws Exception{\n\t\tdnsaaaarec obj = new dnsaaaarec();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tdnsaaaarec[] response = (dnsaaaarec[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (l *httpFileSystem) GetFileInfo(filePath string) (FileInfo, error) {\n\treturn &httpFileInfo{\n\t\tname: l.fileName,\n\t\tpath: l.fileName,\n\t\tsize: l.fileSize,\n\t}, nil\n}", "label": 5}
{"code": "function prepareOptions(value) {\n        var options = {};\n\n        if (isType(value, 'String')) {\n            XRegExp.forEach(value, /[^\\s,]+/, function(match) {\n                options[match] = true;\n            });\n\n            return options;\n        }\n\n        return value;\n    }", "label": 3}
{"code": "def tocvx(B):\n    \"\"\" Converts a sparse SciPy matrix into a sparse CVXOPT matrix.\n    \"\"\"\n    Bcoo = B.tocoo()\n    return spmatrix(Bcoo.data, Bcoo.row.tolist(), Bcoo.col.tolist())", "label": 1}
{"code": "func (g *GRPCServer) authenticate(ctx context.Context) (*grpcContext, error) {\n\t// HTTPS server expects auth  context to be set by the auth middleware\n\tauthContext, err := g.Authorizer.Authorize(ctx)\n\tif err != nil {\n\t\t// propagate connection problem error so we can differentiate\n\t\t// between connection failed and access denied\n\t\tif trace.IsConnectionProblem(err) {\n\t\t\treturn nil, trace.ConnectionProblem(err, \"[10] failed to connect to the database\")\n\t\t} else if trace.IsAccessDenied(err) {\n\t\t\t// don't print stack trace, just log the warning\n\t\t\tlog.Warn(err)\n\t\t} else {\n\t\t\tlog.Warn(trace.DebugReport(err))\n\t\t}\n\t\treturn nil, trace.AccessDenied(\"[10] access denied\")\n\t}\n\treturn &grpcContext{\n\t\tAuthContext: authContext,\n\t\tAuthWithRoles: &AuthWithRoles{\n\t\t\tauthServer: g.AuthServer,\n\t\t\tuser:       authContext.User,\n\t\t\tchecker:    authContext.Checker,\n\t\t\tsessions:   g.SessionService,\n\t\t\talog:       g.AuthServer.IAuditLog,\n\t\t},\n\t}, nil\n}", "label": 5}
{"code": "def list_categories(location_id, opts = {})\n      data, _status_code, _headers = list_categories_with_http_info(location_id, opts)\n      return data\n    end", "label": 4}
{"code": "public static base_response add(nitro_service client, policyexpression resource) throws Exception {\n\t\tpolicyexpression addresource = new policyexpression();\n\t\taddresource.name = resource.name;\n\t\taddresource.value = resource.value;\n\t\taddresource.description = resource.description;\n\t\taddresource.comment = resource.comment;\n\t\taddresource.clientsecuritymessage = resource.clientsecuritymessage;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def discharge_required_response(macaroon, path, cookie_suffix_name,\n                                message=None):\n    ''' Get response content and headers from a discharge macaroons error.\n\n    @param macaroon may hold a macaroon that, when discharged, may\n    allow access to a service.\n    @param path holds the URL path to be associated with the macaroon.\n    The macaroon is potentially valid for all URLs under the given path.\n    @param cookie_suffix_name holds the desired cookie name suffix to be\n    associated with the macaroon. The actual name used will be\n    (\"macaroon-\" + CookieName). Clients may ignore this field -\n    older clients will always use (\"macaroon-\" + macaroon.signature() in hex)\n    @return content(bytes) and the headers to set on the response(dict).\n    '''\n    if message is None:\n        message = 'discharge required'\n    content = json.dumps(\n        {\n            'Code': 'macaroon discharge required',\n            'Message': message,\n            'Info': {\n                'Macaroon': macaroon.to_dict(),\n                'MacaroonPath': path,\n                'CookieNameSuffix': cookie_suffix_name\n            },\n        }\n    ).encode('utf-8')\n    return content, {\n        'WWW-Authenticate': 'Macaroon',\n        'Content-Type': 'application/json'\n    }", "label": 1}
{"code": "public function setAgents($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dialogflow\\V2\\Agent::class);\n        $this->agents = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function() {\n      if (common.inlinescripts.length > 0) {\n        var script_text = '';\n        for (var i = 0; i < common.inlinescripts.length; i++) {\n          if (!common.inlinescripts[i] || typeof common.inlinescripts[i] == 'undefined') \n            continue;\n          else\n            script_text += common.inlinescripts[i] + '\\n';\n        }\n        try {\n          eval(script_text);\n        } catch(e) {\n          batch.callback(script_text);\n        }\n      }\n    }", "label": 3}
{"code": "public function setStackFrames($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Trace\\V2\\StackTrace_StackFrames::class);\n        $this->stack_frames = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "private String getPropertyName(Expression expression) {\n\t\tif (!(expression instanceof PropertyName)) {\n\t\t\tthrow new IllegalArgumentException(\"Expression \" + expression + \" is not a PropertyName.\");\n\t\t}\n\t\tString name = ((PropertyName) expression).getPropertyName();\n\t\tif (name.endsWith(FilterService.ATTRIBUTE_ID)) {\n\t\t\t// replace by Hibernate id property, always refers to the id, even if named differently\n\t\t\tname = name.substring(0, name.length() - FilterService.ATTRIBUTE_ID.length()) + HIBERNATE_ID;\n\t\t}\n\t\treturn name;\n\t}", "label": 0}
{"code": "public static base_response update(nitro_service client, tmtrafficaction resource) throws Exception {\n\t\ttmtrafficaction updateresource = new tmtrafficaction();\n\t\tupdateresource.name = resource.name;\n\t\tupdateresource.apptimeout = resource.apptimeout;\n\t\tupdateresource.sso = resource.sso;\n\t\tupdateresource.formssoaction = resource.formssoaction;\n\t\tupdateresource.persistentcookie = resource.persistentcookie;\n\t\tupdateresource.initiatelogout = resource.initiatelogout;\n\t\tupdateresource.kcdaccount = resource.kcdaccount;\n\t\tupdateresource.samlssoprofile = resource.samlssoprofile;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def amendments_for(amendable)\n      return unless amendable.amendable? && amendable.emendations.count.positive?\n\n      content = content_tag(:h2, class: \"section-heading\", id: \"amendments\") do\n        t(\"section_heading\", scope: \"decidim.amendments.amendable\", count: amendable.emendations.count)\n      end\n\n      content << cell(\"decidim/collapsible_list\",\n                      amendable.emendations,\n                      cell_options: { context: { current_user: current_user } },\n                      list_class: \"row small-up-1 medium-up-2 card-grid\",\n                      size: 4).to_s\n\n      content_tag :div, content.html_safe, class: \"section\"\n    end", "label": 4}
{"code": "func CleanKeyLocks(lockDir string) error {\n\tf, err := os.Open(lockDir)\n\tif err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error opening lockDir\"), err)\n\t}\n\tdefer f.Close()\n\tfiles, err := f.Readdir(0)\n\tif err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error getting lock files list\"), err)\n\t}\n\tfor _, f := range files {\n\t\tfilename := filepath.Join(lockDir, f.Name())\n\t\tkeyLock, err := TryExclusiveKeyLock(lockDir, f.Name())\n\t\tif err == ErrLocked {\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = os.Remove(filename)\n\t\tif err != nil {\n\t\t\tkeyLock.Close()\n\t\t\treturn errwrap.Wrap(errors.New(\"error removing lock file\"), err)\n\t\t}\n\t\tkeyLock.Close()\n\t}\n\treturn nil\n}", "label": 5}
{"code": "public static base_responses update(nitro_service client, nspbr6 resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tnspbr6 updateresources[] = new nspbr6[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new nspbr6();\n\t\t\t\tupdateresources[i].name = resources[i].name;\n\t\t\t\tupdateresources[i].action = resources[i].action;\n\t\t\t\tupdateresources[i].srcipv6 = resources[i].srcipv6;\n\t\t\t\tupdateresources[i].srcipop = resources[i].srcipop;\n\t\t\t\tupdateresources[i].srcipv6val = resources[i].srcipv6val;\n\t\t\t\tupdateresources[i].srcport = resources[i].srcport;\n\t\t\t\tupdateresources[i].srcportop = resources[i].srcportop;\n\t\t\t\tupdateresources[i].srcportval = resources[i].srcportval;\n\t\t\t\tupdateresources[i].destipv6 = resources[i].destipv6;\n\t\t\t\tupdateresources[i].destipop = resources[i].destipop;\n\t\t\t\tupdateresources[i].destipv6val = resources[i].destipv6val;\n\t\t\t\tupdateresources[i].destport = resources[i].destport;\n\t\t\t\tupdateresources[i].destportop = resources[i].destportop;\n\t\t\t\tupdateresources[i].destportval = resources[i].destportval;\n\t\t\t\tupdateresources[i].srcmac = resources[i].srcmac;\n\t\t\t\tupdateresources[i].protocol = resources[i].protocol;\n\t\t\t\tupdateresources[i].protocolnumber = resources[i].protocolnumber;\n\t\t\t\tupdateresources[i].vlan = resources[i].vlan;\n\t\t\t\tupdateresources[i].Interface = resources[i].Interface;\n\t\t\t\tupdateresources[i].priority = resources[i].priority;\n\t\t\t\tupdateresources[i].msr = resources[i].msr;\n\t\t\t\tupdateresources[i].monitor = resources[i].monitor;\n\t\t\t\tupdateresources[i].nexthop = resources[i].nexthop;\n\t\t\t\tupdateresources[i].nexthopval = resources[i].nexthopval;\n\t\t\t\tupdateresources[i].nexthopvlan = resources[i].nexthopvlan;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function (item, state, char) {\n                if (state.count < item.min() // Not enough match\n                        // or at least two characters went through\n                    || state.length > state.matchingLength + 1) {\n                    // Terminal error\n                    return PatternItem.WRITE_NO_MATCH;\n                }\n                item = this._getItem(state, state.index + 1);\n                if (null === item) {\n                    return PatternItem.WRITE_NO_MATCH;\n                }\n                ++state.index;\n                this._reset(item, state);\n                return this.write(state, char); // Try with this one\n            }", "label": 3}
{"code": "def finish(self, status):\n        '''\n        Move laggard tasks over\n\n        :param activity: The virtualenv status\n        :type  activity: ``str``\n        '''\n        retox_log.info(\"Completing %s with status %s\" % (self.name, status))\n        result = Screen.COLOUR_GREEN if not status else Screen.COLOUR_RED\n        self.palette['title'] = (Screen.COLOUR_WHITE, Screen.A_BOLD, result)\n        for item in list(self._task_view.options):\n            self._task_view.options.remove(item)\n            self._completed_view.options.append(item)\n        self.refresh()", "label": 1}
{"code": "func (tl TypeLoader) SchemaName(args *ArgType) (string, error) {\n\tif tl.Schema != nil {\n\t\treturn tl.Schema(args)\n\t}\n\n\treturn \"\", nil\n}", "label": 5}
{"code": "public function setDateTimeFrom($date = null)\n    {\n        $date = $this->resolveCarbon($date);\n\n        return $this->modify($date->rawFormat('Y-m-d H:i:s.u'));\n    }", "label": 2}
{"code": "def run_star(job, fastqs, univ_options, star_options):\n    \"\"\"\n    This module uses STAR to align the RNA fastqs to the reference\n\n    ARGUMENTS\n    1. fastqs: REFER RETURN VALUE of run_cutadapt()\n    2. univ_options: Dict of universal arguments used by almost all tools\n         univ_options\n              +- 'dockerhub': <dockerhub to use>\n    3. star_options: Dict of parameters specific to STAR\n         star_options\n             |- 'index_tar': <JSid for the STAR index tarball>\n             +- 'n': <number of threads to allocate>\n    RETURN VALUES\n    1. output_files: Dict of aligned bams\n         output_files\n             |- 'rnaAligned.toTranscriptome.out.bam': <JSid>\n             +- 'rnaAligned.sortedByCoord.out.bam': Dict of genome bam + bai\n                                |- 'rna_fix_pg_sorted.bam': <JSid>\n                                +- 'rna_fix_pg_sorted.bam.bai': <JSid>\n\n    This module corresponds to node 9 on the tree\n    \"\"\"\n    assert star_options['type'] in ('star', 'starlong')\n    job.fileStore.logToMaster('Running STAR on %s' %univ_options['patient'])\n    work_dir = job.fileStore.getLocalTempDir()\n    input_files = {\n        'rna_cutadapt_1.fastq': fastqs['rna_cutadapt_1.fastq'],\n        'rna_cutadapt_2.fastq': fastqs['rna_cutadapt_2.fastq'],\n        'star_index.tar.gz': star_options['index_tar']}\n    input_files = get_files_from_filestore(job, input_files, work_dir,\n                                           docker=True)\n    parameters = ['--runThreadN', str(star_options['n']),\n                  '--genomeDir', input_files['star_index'],\n                  '--outFileNamePrefix', 'rna',\n                  '--readFilesIn',\n                  input_files['rna_cutadapt_1.fastq'],\n                  input_files['rna_cutadapt_2.fastq'],\n                  '--outSAMattributes', 'NH', 'HI', 'AS', 'NM', 'MD',\n                  '--outSAMtype', 'BAM', 'SortedByCoordinate',\n                  '--quantMode', 'TranscriptomeSAM',\n                  '--outSAMunmapped', 'Within']\n    if star_options['type'] == 'star':\n        docker_call(tool='star', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'])\n    else:\n        docker_call(tool='starlong', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'])\n    output_files = defaultdict()\n    for bam_file in ['rnaAligned.toTranscriptome.out.bam',\n                     'rnaAligned.sortedByCoord.out.bam']:\n        output_files[bam_file] = job.fileStore.writeGlobalFile('/'.join([\n            work_dir, bam_file]))\n    job.fileStore.deleteGlobalFile(fastqs['rna_cutadapt_1.fastq'])\n    job.fileStore.deleteGlobalFile(fastqs['rna_cutadapt_2.fastq'])\n    index_star = job.wrapJobFn(index_bamfile,\n                               output_files['rnaAligned.sortedByCoord.out.bam'],\n                               'rna', univ_options, disk='120G')\n    job.addChild(index_star)\n    output_files['rnaAligned.sortedByCoord.out.bam'] = index_star.rv()\n    return output_files", "label": 1}
{"code": "def include(self, node):\n        \"\"\"Include the defined yaml file.\"\"\"\n        result = None\n        if isinstance(node, ScalarNode):\n            result = Loader.include_file(self.construct_scalar(node))\n        else:\n            raise RuntimeError(\"Not supported !include on type %s\" % type(node))\n        return result", "label": 1}
{"code": "def num_cells_in_range(str)\n      cells = str.split(':')\n      return 1 if cells.count == 1\n      raise ArgumentError.new(\"invalid range string: #{str}. Supported range format 'A1:B2'\") if cells.count != 2\n      x1, y1 = extract_coordinate(cells[0])\n      x2, y2 = extract_coordinate(cells[1])\n      (x2 - (x1 - 1)) * (y2 - (y1 - 1))\n    end", "label": 4}
{"code": "def read_module\n      mod_name = read_string(cache: false)\n      result = safe_const_get(mod_name)\n      unless result.class == Module\n        raise ArgumentError, \"#{mod_name} does not refer to a Module\"\n      end\n      @object_cache << result\n      result\n    end", "label": 4}
{"code": "private void ensurePrecisionAndScale(FieldDescriptorDef fieldDef, String checkLevel)\r\n    {\r\n        fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_PRECISION, null);\r\n        fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_SCALE, null);\r\n        if (!fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_PRECISION))\r\n        {\r\n            String defaultPrecision = JdbcTypeHelper.getDefaultPrecisionFor(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE));\r\n\r\n            if (defaultPrecision != null)\r\n            {\r\n                LogHelper.warn(true,\r\n                               FieldDescriptorConstraints.class,\r\n                               \"ensureLength\",\r\n                               \"The field \"+fieldDef.getName()+\" in class \"+fieldDef.getOwner().getName()+\" has no precision setting though its jdbc type requires it (in most databases); using default precision of \"+defaultPrecision);\r\n                fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_PRECISION, defaultPrecision);\r\n            }\r\n            else if (fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_SCALE))\r\n            {\r\n                fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_PRECISION, \"1\");\r\n            }\r\n        }\r\n        if (!fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_SCALE))\r\n         {\r\n            String defaultScale = JdbcTypeHelper.getDefaultScaleFor(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE));\r\n\r\n            if (defaultScale != null)\r\n            {\r\n                LogHelper.warn(true,\r\n                               FieldDescriptorConstraints.class,\r\n                               \"ensureLength\",\r\n                               \"The field \"+fieldDef.getName()+\" in class \"+fieldDef.getOwner().getName()+\" has no scale setting though its jdbc type requires it (in most databases); using default scale of \"+defaultScale);\r\n                fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_SCALE, defaultScale);\r\n            }\r\n            else if (fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_PRECISION) || fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_PRECISION))\r\n            {\r\n                fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_SCALE, \"0\");\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "function DOMMouseMoveTracker(\nonMove,\n    /*function*/ onMoveEnd,\n    /*DOMElement*/ domNode) {\n    this.$DOMMouseMoveTracker_isDragging = false;\n    this.$DOMMouseMoveTracker_animationFrameID = null;\n    this.$DOMMouseMoveTracker_domNode = domNode;\n    this.$DOMMouseMoveTracker_onMove = onMove;\n    this.$DOMMouseMoveTracker_onMoveEnd = onMoveEnd;\n    this.$DOMMouseMoveTracker_onMouseMove = this.$DOMMouseMoveTracker_onMouseMove.bind(this);\n    this.$DOMMouseMoveTracker_onMouseUp = this.$DOMMouseMoveTracker_onMouseUp.bind(this);\n    this.$DOMMouseMoveTracker_didMouseMove = this.$DOMMouseMoveTracker_didMouseMove.bind(this);\n  }", "label": 3}
{"code": "def font_size\n      return sz if sz\n      font = styles.fonts[styles.cellXfs[style].fontId] || styles.fonts[0]\n      (font.b || (defined?(@b) && @b)) ? (font.sz * 1.5) : font.sz\n    end", "label": 4}
{"code": "def failed(self, **kwargs):\n        \"\"\"Finish event as failed with optional additional information.\"\"\"\n        self.finished = datetime.now()\n        self.status = 'failed'\n        self.information.update(kwargs)\n        self.logger.info(\"Failed - took %f seconds.\", self.duration())\n        self.update_report_collector(int(time.mktime(self.finished.timetuple())))", "label": 1}
{"code": "function type (prop) {\n  var rs = Object.prototype.toString.call(prop);\n  return rs.slice(8, rs.length - 1).toLowerCase();\n}", "label": 3}
{"code": "def list_inventory(location_id, opts = {})\n      data, _status_code, _headers = list_inventory_with_http_info(location_id, opts)\n      return data\n    end", "label": 4}
{"code": "def fields_hash\n      @fields_hash ||=\n        begin\n          field_sets_hash = Hash.new { |h, k| h[k] = Set.new }\n          @types.each do |type|\n            Setup.for(type).fields.each do |field|\n              field_sets_hash[field.name.to_sym] << field\n            end\n          end\n          fields_hash = {}\n          field_sets_hash.each_pair do |field_name, set|\n            if set.length == 1\n              fields_hash[field_name] = set.to_a.first\n            end\n          end\n          fields_hash\n        end\n    end", "label": 4}
{"code": "func (a *Agent) processRequests(conn *ssh.Client) error {\n\tdefer conn.Close()\n\tticker := time.NewTicker(defaults.ReverseTunnelAgentHeartbeatPeriod)\n\tdefer ticker.Stop()\n\n\thb, reqC, err := conn.OpenChannel(chanHeartbeat, nil)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tnewTransportC := conn.HandleChannelOpen(chanTransport)\n\tnewDiscoveryC := conn.HandleChannelOpen(chanDiscovery)\n\n\t// send first ping right away, then start a ping timer:\n\thb.SendRequest(\"ping\", false, nil)\n\n\tfor {\n\t\tselect {\n\t\t// need to exit:\n\t\tcase <-a.ctx.Done():\n\t\t\treturn trace.ConnectionProblem(nil, \"heartbeat: agent is stopped\")\n\t\t// time to ping:\n\t\tcase <-ticker.C:\n\t\t\tbytes, _ := a.Clock.Now().UTC().MarshalText()\n\t\t\t_, err := hb.SendRequest(\"ping\", false, bytes)\n\t\t\tif err != nil {\n\t\t\t\ta.Error(err)\n\t\t\t\treturn trace.Wrap(err)\n\t\t\t}\n\t\t\ta.Debugf(\"Ping -> %v.\", conn.RemoteAddr())\n\t\t// ssh channel closed:\n\t\tcase req := <-reqC:\n\t\t\tif req == nil {\n\t\t\t\treturn trace.ConnectionProblem(nil, \"heartbeat: connection closed\")\n\t\t\t}\n\t\t// new transport request:\n\t\tcase nch := <-newTransportC:\n\t\t\tif nch == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ta.Debugf(\"Transport request: %v.\", nch.ChannelType())\n\t\t\tch, req, err := nch.Accept()\n\t\t\tif err != nil {\n\t\t\t\ta.Warningf(\"Failed to accept request: %v.\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo proxyTransport(&transportParams{\n\t\t\t\tlog:          a.Entry,\n\t\t\t\tcloseContext: a.ctx,\n\t\t\t\tauthClient:   a.Client,\n\t\t\t\tkubeDialAddr: a.KubeDialAddr,\n\t\t\t\tchannel:      ch,\n\t\t\t\trequestCh:    req,\n\t\t\t\tsconn:        conn.Conn,\n\t\t\t\tserver:       a.Server,\n\t\t\t\tcomponent:    teleport.ComponentReverseTunnelAgent,\n\t\t\t})\n\t\t// new discovery request\n\t\tcase nch := <-newDiscoveryC:\n\t\t\tif nch == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ta.Debugf(\"discovery request: %v\", nch.ChannelType())\n\t\t\tch, req, err := nch.Accept()\n\t\t\tif err != nil {\n\t\t\t\ta.Warningf(\"failed to accept request: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo a.handleDiscovery(ch, req)\n\t\t}\n\t}\n}", "label": 5}
{"code": "public function setType($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Trace\\V2\\Span_Link_Type::class);\n        $this->type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function send(callable $request, array $args, $whitelisted = false)\n    {\n        $requestOptions = $this->pluckArray([\n            'grpcOptions',\n            'retries',\n            'requestTimeout'\n        ], $args[count($args) - 1]);\n\n        try {\n            return $this->requestWrapper->send($request, $args, $requestOptions);\n        } catch (NotFoundException $e) {\n            if ($whitelisted) {\n                throw $this->modifyWhitelistedError($e);\n            }\n\n            throw $e;\n        }\n    }", "label": 2}
{"code": "def clip_rule(rule)\n      Kernel.raise ArgumentError, \"Unknown clipping rule #{rule}\" unless %w[evenodd nonzero].include?(rule.downcase)\n      primitive \"clip-rule #{rule}\"\n    end", "label": 4}
{"code": "def _pwl1_to_poly(self, generators):\n        \"\"\" Converts single-block piecewise-linear costs into linear\n        polynomial.\n        \"\"\"\n        for g in generators:\n            if (g.pcost_model == PW_LINEAR) and (len(g.p_cost) == 2):\n                g.pwl_to_poly()\n\n        return generators", "label": 1}
{"code": "def get_requirements():\n    '''returns requirements array for package'''\n    packages = []\n    with open(\"requirements.txt\", \"r\") as req_doc:\n        for package in req_doc:\n            packages.append(package.replace(\"\\n\", \"\"))\n    return packages", "label": 1}
{"code": "public static linkset_interface_binding[] get(nitro_service service, String id) throws Exception{\n\t\tlinkset_interface_binding obj = new linkset_interface_binding();\n\t\tobj.set_id(id);\n\t\tlinkset_interface_binding response[] = (linkset_interface_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def international(formatted = true, prefix = '+')\n      prefix = formatted if formatted.is_a?(String)\n      return nil if sanitized.empty?\n      return \"#{prefix}#{country_prefix_or_not}#{sanitized}\" unless valid?\n      return country_code + @national_number unless formatted\n\n      fmt = @data[country][:format]\n      national = @national_number\n      if (matches = @national_number.match(cr(fmt[Core::PATTERN])))\n        fmt = fmt[:intl_format] || fmt[:format]\n        national = fmt.gsub(/\\$\\d/) { |el| matches[el[1].to_i] } unless fmt == 'NA'\n      end\n\n      \"#{prefix}#{country_code} #{national}\"\n    end", "label": 4}
{"code": "def community_responsify(schema_class, mimetype):\n    \"\"\"Create a community response serializer.\n\n    :param serializer: Serializer instance.\n    :param mimetype: MIME type of response.\n    \"\"\"\n    def view(data, code=200, headers=None, links_item_factory=None,\n             page=None, urlkwargs=None, links_pagination_factory=None):\n        \"\"\"Generate the response object.\"\"\"\n        if isinstance(data, Community):\n            last_modified = data.updated\n            response_data = schema_class(\n                context=dict(item_links_factory=links_item_factory)\n            ).dump(data).data\n        else:\n            last_modified = None\n            response_data = schema_class(\n                context=dict(\n                    total=data.query.count(),\n                    item_links_factory=links_item_factory,\n                    page=page,\n                    urlkwargs=urlkwargs,\n                    pagination_links_factory=links_pagination_factory)\n            ).dump(data.items, many=True).data\n\n        response = current_app.response_class(\n            json.dumps(response_data, **_format_args()),\n            mimetype=mimetype)\n        response.status_code = code\n\n        if last_modified:\n            response.last_modified = last_modified\n\n        if headers is not None:\n            response.headers.extend(headers)\n        return response\n    return view", "label": 1}
{"code": "function compareDates(a, b) {\n    var aTimestamp = convertToTimestamp(a);\n    var bTimestamp = convertToTimestamp(b);\n\n    if (isNaN(aTimestamp) || isNaN(bTimestamp)) {\n      return NaN;\n    } else {\n      return aTimestamp - bTimestamp;\n    }\n  }", "label": 3}
{"code": "def [](undefined: true, **)\n      null = (undefined == false) ? nil : UNDEFINED\n      Module.new.tap do |mod|\n        mod.extend DSL\n        mod.include self\n        mod.send(:instance_variable_set, :@null, null)\n      end\n    end", "label": 4}
{"code": "def run(document)\n      @document = document\n      @lints = []\n      visit(document.tree)\n      @lints\n    rescue Parser::SyntaxError => e\n      location = e.diagnostic.location\n      @lints <<\n        HamlLint::Lint.new(\n          HamlLint::Linter::Syntax.new(config),\n          document.file,\n          location.line,\n          e.to_s,\n          :error\n        )\n    end", "label": 4}
{"code": "function writeChangelog(changelog) {\n      var fileContents = null;\n      var firstLineFile = null;\n      var firstLineFileHeader = null;\n      var regex = null;\n\n      if (options.insertType && grunt.file.exists(options.dest)) {\n        fileContents = grunt.file.read(options.dest);\n        firstLineFile = fileContents.split('\\n')[0];\n        grunt.log.debug('firstLineFile = ' + firstLineFile);\n\n        switch (options.insertType) {\n          case 'prepend':\n            changelog = changelog + '\\n' + fileContents;\n            break;\n          case 'append':\n            changelog = fileContents + '\\n' + changelog;\n            break;\n          default:\n            grunt.fatal('\"' + options.insertType + '\" is not a valid insertType. Please use \"append\" or \"prepend\".');\n            return false;\n        }\n      }\n\n      if (options.fileHeader) {\n        firstLineFileHeader = options.fileHeader.split('\\n')[0];\n        grunt.log.debug('firstLineFileHeader = ' + firstLineFileHeader);\n\n        if (options.insertType === 'prepend') {\n          if (firstLineFile !== firstLineFileHeader) {\n            changelog = options.fileHeader + '\\n\\n' + changelog;\n          } else {\n            regex = new RegExp(options.fileHeader+'\\n\\n','m');\n            changelog = options.fileHeader + '\\n\\n' + changelog.replace(regex, '');\n          }\n\n        // insertType === 'append' || undefined\n        } else {\n          if (firstLineFile !== firstLineFileHeader) {\n            changelog = options.fileHeader + '\\n\\n' + changelog;\n          }\n        }\n\n      }\n\n\n      grunt.file.write(options.dest, changelog);\n\n      // Log the results.\n      grunt.log.ok(changelog);\n      grunt.log.writeln();\n      grunt.log.writeln('Changelog created at '+ options.dest.toString().cyan + '.');\n    }", "label": 3}
{"code": "public function setUnderExposedLikelihood($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Vision\\V1\\Likelihood::class);\n        $this->under_exposed_likelihood = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_responses delete(nitro_service client, appfwlearningdata resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tappfwlearningdata deleteresources[] = new appfwlearningdata[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tdeleteresources[i] = new appfwlearningdata();\n\t\t\t\tdeleteresources[i].profilename = resources[i].profilename;\n\t\t\t\tdeleteresources[i].starturl = resources[i].starturl;\n\t\t\t\tdeleteresources[i].cookieconsistency = resources[i].cookieconsistency;\n\t\t\t\tdeleteresources[i].fieldconsistency = resources[i].fieldconsistency;\n\t\t\t\tdeleteresources[i].formactionurl_ffc = resources[i].formactionurl_ffc;\n\t\t\t\tdeleteresources[i].crosssitescripting = resources[i].crosssitescripting;\n\t\t\t\tdeleteresources[i].formactionurl_xss = resources[i].formactionurl_xss;\n\t\t\t\tdeleteresources[i].sqlinjection = resources[i].sqlinjection;\n\t\t\t\tdeleteresources[i].formactionurl_sql = resources[i].formactionurl_sql;\n\t\t\t\tdeleteresources[i].fieldformat = resources[i].fieldformat;\n\t\t\t\tdeleteresources[i].formactionurl_ff = resources[i].formactionurl_ff;\n\t\t\t\tdeleteresources[i].csrftag = resources[i].csrftag;\n\t\t\t\tdeleteresources[i].csrfformoriginurl = resources[i].csrfformoriginurl;\n\t\t\t\tdeleteresources[i].xmldoscheck = resources[i].xmldoscheck;\n\t\t\t\tdeleteresources[i].xmlwsicheck = resources[i].xmlwsicheck;\n\t\t\t\tdeleteresources[i].xmlattachmentcheck = resources[i].xmlattachmentcheck;\n\t\t\t\tdeleteresources[i].totalxmlrequests = resources[i].totalxmlrequests;\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function registerPartials(src, options, prefix = '') {\n  return readFiles(src.glob, options).then(partialFiles => {\n    partialFiles.forEach(partialFile => {\n      const partialKey = resourceId(partialFile, src.basedir, prefix);\n      if (options.handlebars.partials.hasOwnProperty(partialKey)) {\n        DrizzleError.error(\n          new DrizzleError(\n            `Partial key '${partialKey}' already\nregistered on Handlebars instance: is this intentional?`,\n            DrizzleError.LEVELS.WARN\n          ),\n          options\n        );\n      }\n      options.handlebars.registerPartial(partialKey, partialFile.contents);\n    });\n  });\n}", "label": 3}
{"code": "def created_at\n      time = @attrs[:created_at]\n      return if time.nil?\n      time = Time.parse(time) unless time.is_a?(Time)\n      time.utc\n    end", "label": 4}
{"code": "def start\n      return if running?\n\n      raise \"Cannot re-start stopped server\" if stopped?\n\n      check_default_host\n\n      logger.info \"RPC server is starting...\"\n\n      @start_thread = Thread.new { grpc_server.run }\n\n      grpc_server.wait_till_running\n\n      logger.info \"RPC server is listening on #{host}\"\n    end", "label": 4}
{"code": "func setupAppImage(cfg RunConfig, appName types.ACName, img types.Hash, cdir string, useOverlay bool) error {\n\tad := common.AppPath(cdir, appName)\n\tif useOverlay {\n\t\terr := os.MkdirAll(ad, common.DefaultRegularDirPerm)\n\t\tif err != nil {\n\t\t\treturn errwrap.Wrap(errors.New(\"error creating image directory\"), err)\n\t\t}\n\t\ttreeStoreID, err := ioutil.ReadFile(common.AppTreeStoreIDPath(cdir, appName))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := copyAppManifest(cdir, appName, ad); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := overlayRender(cfg, string(treeStoreID), cdir, ad, appName.String()); err != nil {\n\t\t\treturn errwrap.Wrap(errors.New(\"error rendering overlay filesystem\"), err)\n\t\t}\n\t}\n\treturn ensureMtabExists(filepath.Join(ad, \"rootfs\"))\n}", "label": 5}
{"code": "public RedwoodConfiguration captureStdout(){\r\n    tasks.add(new Runnable() { public void run() { Redwood.captureSystemStreams(true, false); } });\r\n    return this;\r\n  }", "label": 0}
{"code": "func (t *Text) Draw() {\n\tv := t.view\n\tif v == nil {\n\t\treturn\n\t}\n\n\twidth, height := v.Size()\n\tif width == 0 || height == 0 {\n\t\treturn\n\t}\n\n\tt.clear()\n\n\t// Note that we might wind up with a negative X if the width\n\t// is larger than the length.  That's OK, and correct even.\n\t// The view will clip it properly in that case.\n\n\t// We align to the left & top by default.\n\ty := t.calcY(height)\n\tr := rune(0)\n\tw := 0\n\tx := 0\n\tvar styl tcell.Style\n\tvar comb []rune\n\tline := 0\n\tnewline := true\n\tfor i, l := range t.text {\n\n\t\tif newline {\n\t\t\tx = t.calcX(width, line)\n\t\t\tnewline = false\n\t\t}\n\t\tif l == '\\n' {\n\t\t\tif w != 0 {\n\t\t\t\tv.SetContent(x, y, r, comb, styl)\n\t\t\t}\n\t\t\tnewline = true\n\t\t\tw = 0\n\t\t\tcomb = nil\n\t\t\tline++\n\t\t\ty++\n\t\t\tcontinue\n\t\t}\n\t\tif t.widths[i] == 0 {\n\t\t\tcomb = append(comb, l)\n\t\t\tcontinue\n\t\t}\n\t\tif w != 0 {\n\t\t\tv.SetContent(x, y, r, comb, styl)\n\t\t\tx += w\n\t\t}\n\t\tr = l\n\t\tw = t.widths[i]\n\t\tstyl = t.styles[i]\n\t\tcomb = nil\n\t}\n\tif w != 0 {\n\t\tv.SetContent(x, y, r, comb, styl)\n\t}\n}", "label": 5}
{"code": "def _home_assistant_config(self):\n        \"\"\" Creates home assistant configuration for the known devices \"\"\"\n        devices = {}\n        for scs_id, dev in self._devices.items():\n            devices[dev['ha_id']] = {\n                'name': dev['name'],\n                'scs_id': scs_id}\n\n        return {'devices': devices}", "label": 1}
{"code": "function addSubmissionFile(req, res, next) {\n  req.addingNewSubmissionFile = true;\n\n  updateSubmissionFile(req, res, next);\n}", "label": 3}
{"code": "public static InputStream getContentStream(String stringUrl) throws MalformedURLException, IOException {\n        URL url = new URL(stringUrl);\n        \n        URLConnection urlConnection = url.openConnection();\n        \n        InputStream is = urlConnection.getInputStream();\n        if (\"gzip\".equals(urlConnection.getContentEncoding())) {\n           is = new GZIPInputStream(is);\n        }\n\n        return is;\n    }", "label": 0}
{"code": "def logger(self):\n        \"\"\"\n        Instantiates and returns a ServiceLogger instance\n        \"\"\"\n        if not hasattr(self, '_logger') or not self._logger:\n            self._logger = ServiceLogger()\n        return self._logger", "label": 1}
{"code": "def remove_all(*classes)\n      classes.flatten!\n      if classes.empty?\n        @deletes += 1\n        indexer.remove_all\n      else\n        @deletes += classes.length\n        classes.each { |clazz| indexer.remove_all(clazz) }\n      end\n    end", "label": 4}
{"code": "public static function get($version)\n    {\n        if (!isset(self::$profiles[$version])) {\n            throw new ClientException(\"Unknown server profile: '$version'.\");\n        }\n\n        $profile = self::$profiles[$version];\n\n        return new $profile();\n    }", "label": 2}
{"code": "function _sanitizeDimensions(dimensions) {\n  if (dimensions == undefined) {\n    dimensions = {};\n  }\n  for (let property in Utils.DEFAULT_ROOM_DIMENSIONS) {\n    if (!(dimensions.hasOwnProperty(property))) {\n      dimensions[property] = Utils.DEFAULT_ROOM_DIMENSIONS[property];\n    }\n  }\n  return dimensions;\n}", "label": 3}
{"code": "def update_guild_role(data)\n      role_data = data['role']\n      server_id = data['guild_id'].to_i\n      server = @servers[server_id]\n      new_role = Role.new(role_data, self, server)\n      role_id = role_data['id'].to_i\n      old_role = server.roles.find { |r| r.id == role_id }\n      old_role.update_from(new_role)\n    end", "label": 4}
{"code": "func NewAuthServer(cfg *InitConfig, opts ...AuthServerOption) (*AuthServer, error) {\n\tif cfg.Trust == nil {\n\t\tcfg.Trust = local.NewCAService(cfg.Backend)\n\t}\n\tif cfg.Presence == nil {\n\t\tcfg.Presence = local.NewPresenceService(cfg.Backend)\n\t}\n\tif cfg.Provisioner == nil {\n\t\tcfg.Provisioner = local.NewProvisioningService(cfg.Backend)\n\t}\n\tif cfg.Identity == nil {\n\t\tcfg.Identity = local.NewIdentityService(cfg.Backend)\n\t}\n\tif cfg.Access == nil {\n\t\tcfg.Access = local.NewAccessService(cfg.Backend)\n\t}\n\tif cfg.ClusterConfiguration == nil {\n\t\tcfg.ClusterConfiguration = local.NewClusterConfigurationService(cfg.Backend)\n\t}\n\tif cfg.Events == nil {\n\t\tcfg.Events = local.NewEventsService(cfg.Backend)\n\t}\n\tif cfg.AuditLog == nil {\n\t\tcfg.AuditLog = events.NewDiscardAuditLog()\n\t}\n\n\tlimiter, err := limiter.NewConnectionsLimiter(limiter.LimiterConfig{\n\t\tMaxConnections: defaults.LimiterMaxConcurrentSignatures,\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tcloseCtx, cancelFunc := context.WithCancel(context.TODO())\n\tas := AuthServer{\n\t\tbk:              cfg.Backend,\n\t\tlimiter:         limiter,\n\t\tAuthority:       cfg.Authority,\n\t\tAuthServiceName: cfg.AuthServiceName,\n\t\toidcClients:     make(map[string]*oidcClient),\n\t\tsamlProviders:   make(map[string]*samlProvider),\n\t\tgithubClients:   make(map[string]*githubClient),\n\t\tcancelFunc:      cancelFunc,\n\t\tcloseCtx:        closeCtx,\n\t\tAuthServices: AuthServices{\n\t\t\tTrust:                cfg.Trust,\n\t\t\tPresence:             cfg.Presence,\n\t\t\tProvisioner:          cfg.Provisioner,\n\t\t\tIdentity:             cfg.Identity,\n\t\t\tAccess:               cfg.Access,\n\t\t\tClusterConfiguration: cfg.ClusterConfiguration,\n\t\t\tIAuditLog:            cfg.AuditLog,\n\t\t\tEvents:               cfg.Events,\n\t\t},\n\t}\n\tfor _, o := range opts {\n\t\to(&as)\n\t}\n\tif as.clock == nil {\n\t\tas.clock = clockwork.NewRealClock()\n\t}\n\n\treturn &as, nil\n}", "label": 5}
{"code": "protected function applyFilterToMediaCollection(Collection $media, $filter): Collection\n    {\n        if (is_array($filter)) {\n            $filter = $this->getDefaultFilterFunction($filter);\n        }\n\n        return $media->filter($filter);\n    }", "label": 2}
{"code": "static public String bb2hex(byte[] bb) {\n\t\tString result = \"\";\n\t\tfor (int i=0; i<bb.length; i++) {\n\t\t\tresult = result + String.format(\"%02X \", bb[i]);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public void ifPropertyValueEquals(String template, Properties attributes) throws XDocletException\r\n    {\r\n        String value    = getPropertyValue(attributes.getProperty(ATTRIBUTE_LEVEL), attributes.getProperty(ATTRIBUTE_NAME));\r\n        String expected = attributes.getProperty(ATTRIBUTE_VALUE);\r\n\r\n        if (value == null)\r\n        {\r\n            value = attributes.getProperty(ATTRIBUTE_DEFAULT);\r\n        }\r\n        if (expected.equals(value))\r\n        {\r\n            generate(template);\r\n        }\r\n    }", "label": 0}
{"code": "function measure(measureName, startMarkName, endMarkName) {\n            if (enabled) {\n                var end = endMarkName && marks[endMarkName] || ts.timestamp();\n                var start = startMarkName && marks[startMarkName] || profilerStart;\n                measures[measureName] = (measures[measureName] || 0) + (end - start);\n            }\n        }", "label": 3}
{"code": "func (s *Server) handleKeepAlive(req *ssh.Request) {\n\tlog.Debugf(\"Received %q: WantReply: %v\", req.Type, req.WantReply)\n\n\t// only reply if the sender actually wants a response\n\tif req.WantReply {\n\t\terr := req.Reply(true, nil)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Unable to reply to %q request: %v\", req.Type, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tlog.Debugf(\"Replied to %q\", req.Type)\n}", "label": 5}
{"code": "function getFilters(resourceName, adapterName, operation) {\n    var filterConfig = injector.loadModule('filterConfig');\n    var filters = { before: [], after: [] };\n\n    if (!filterConfig) { return filters; }\n\n    var levels = [resourceName, adapterName, operation, 'before'];\n    filters.before = (traverseFilters(filterConfig, levels, 0) || []).map(function (name) {\n        return injector.loadModule(name + 'Filter');\n    });\n\n    levels = [resourceName, adapterName, operation, 'after'];\n    filters.after = (traverseFilters(filterConfig, levels, 0) || []).map(function (name) {\n        return injector.loadModule(name + 'Filter');\n    });\n\n    return filters;\n}", "label": 3}
{"code": "func (c *udpAnnounce) request(action Action, args interface{}, options []byte) (*bytes.Buffer, error) {\n\ttid := newTransactionId()\n\tif err := errors.Wrap(\n\t\tc.write(\n\t\t\t&RequestHeader{\n\t\t\t\tConnectionId:  c.connectionId,\n\t\t\t\tAction:        action,\n\t\t\t\tTransactionId: tid,\n\t\t\t}, args, options),\n\t\t\"writing request\",\n\t); err != nil {\n\t\treturn nil, err\n\t}\n\tc.socket.SetReadDeadline(time.Now().Add(timeout(c.contiguousTimeouts)))\n\tb := make([]byte, 0x800) // 2KiB\n\tfor {\n\t\tvar (\n\t\t\tn        int\n\t\t\treadErr  error\n\t\t\treadDone = make(chan struct{})\n\t\t)\n\t\tgo func() {\n\t\t\tdefer close(readDone)\n\t\t\tn, readErr = c.socket.Read(b)\n\t\t}()\n\t\tctx := c.a.Context\n\t\tif ctx == nil {\n\t\t\tctx = context.Background()\n\t\t}\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tcase <-readDone:\n\t\t}\n\t\tif opE, ok := readErr.(*net.OpError); ok && opE.Timeout() {\n\t\t\tc.contiguousTimeouts++\n\t\t}\n\t\tif readErr != nil {\n\t\t\treturn nil, errors.Wrap(readErr, \"reading from socket\")\n\t\t}\n\t\tbuf := bytes.NewBuffer(b[:n])\n\t\tvar h ResponseHeader\n\t\terr := binary.Read(buf, binary.BigEndian, &h)\n\t\tswitch err {\n\t\tdefault:\n\t\t\tpanic(err)\n\t\tcase io.ErrUnexpectedEOF, io.EOF:\n\t\t\tcontinue\n\t\tcase nil:\n\t\t}\n\t\tif h.TransactionId != tid {\n\t\t\tcontinue\n\t\t}\n\t\tc.contiguousTimeouts = 0\n\t\tif h.Action == ActionError {\n\t\t\terr = errors.New(buf.String())\n\t\t}\n\t\treturn buf, err\n\t}\n}", "label": 5}
{"code": "public function count()\n    {\n        if ($this->isInitialized()) {\n            return $this->collection->count();\n        }\n\n        // Return cached result in case count query was already executed\n        if ($this->count !== null) {\n            return $this->count;\n        }\n\n        return $this->count = $this->entityPersister->count($this->criteria);\n    }", "label": 2}
{"code": "function createEventBufferer(eventName, bufferedEvents) {\n    return function () { // ...\n        bufferedEvents.push([eventName].concat(Array.prototype.slice.call(arguments)));\n    };\n}", "label": 3}
{"code": "func setupClientTLS() (*tls.Config, error) {\n\tstorage, err := auth.NewProcessStorage(filepath.Join(\"/var/lib/teleport\", teleport.ComponentProcess))\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tdefer storage.Close()\n\n\tidentity, err := storage.ReadIdentity(auth.IdentityCurrent, teleport.RoleAdmin)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn identity.TLSConfig(nil)\n}", "label": 5}
{"code": "function selectDimensionsAndMaterials() {\n  let reverbLength = document.getElementById('reverbLengthSelect').value;\n  switch (reverbLength) {\n    case 'none':\n    default:\n    {\n      return {\n        dimensions: {\n          width: 0,\n          height: 0,\n          depth: 0,\n        },\n        materials: {\n          left: 'transparent',\n          right: 'transparent',\n          front: 'transparent',\n          back: 'transparent',\n          up: 'transparent',\n          down: 'transparent',\n        },\n      };\n    }\n    break;\n    case 'short':\n    {\n      return {\n        dimensions: {\n          width: 1.5,\n          height: 1.5,\n          depth: 1.5,\n        },\n        materials: {\n          left: 'uniform',\n          right: 'uniform',\n          front: 'uniform',\n          back: 'uniform',\n          up: 'uniform',\n          down: 'uniform',\n        },\n      };\n    }\n    break;\n    case 'medium':\n    {\n      return {\n        dimensions: {\n          width: 6,\n          height: 6,\n          depth: 6,\n        },\n        materials: {\n          left: 'uniform',\n          right: 'uniform',\n          front: 'uniform',\n          back: 'uniform',\n          up: 'uniform',\n          down: 'uniform',\n        },\n      };\n    }\n    break;\n    case 'long':\n    {\n      return {\n        dimensions: {\n          width: 24,\n          height: 24,\n          depth: 24,\n        },\n        materials: {\n          left: 'uniform',\n          right: 'uniform',\n          front: 'uniform',\n          back: 'uniform',\n          up: 'uniform',\n          down: 'uniform',\n        },\n      };\n    }\n    break;\n  }\n}", "label": 3}
{"code": "func applySSHConfig(fc *FileConfig, cfg *service.Config) error {\n\tif fc.SSH.ListenAddress != \"\" {\n\t\taddr, err := utils.ParseHostPortAddr(fc.SSH.ListenAddress, int(defaults.SSHServerListenPort))\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tcfg.SSH.Addr = *addr\n\t}\n\tif fc.SSH.Labels != nil {\n\t\tcfg.SSH.Labels = make(map[string]string)\n\t\tfor k, v := range fc.SSH.Labels {\n\t\t\tcfg.SSH.Labels[k] = v\n\t\t}\n\t}\n\tif fc.SSH.Commands != nil {\n\t\tcfg.SSH.CmdLabels = make(services.CommandLabels)\n\t\tfor _, cmdLabel := range fc.SSH.Commands {\n\t\t\tcfg.SSH.CmdLabels[cmdLabel.Name] = &services.CommandLabelV2{\n\t\t\t\tPeriod:  services.NewDuration(cmdLabel.Period),\n\t\t\t\tCommand: cmdLabel.Command,\n\t\t\t\tResult:  \"\",\n\t\t\t}\n\t\t}\n\t}\n\tif fc.SSH.Namespace != \"\" {\n\t\tcfg.SSH.Namespace = fc.SSH.Namespace\n\t}\n\tif fc.SSH.PermitUserEnvironment {\n\t\tcfg.SSH.PermitUserEnvironment = true\n\t}\n\tif fc.SSH.PAM != nil {\n\t\tcfg.SSH.PAM = fc.SSH.PAM.Parse()\n\n\t\t// If PAM is enabled, make sure that Teleport was built with PAM support\n\t\t// and the PAM library was found at runtime.\n\t\tif cfg.SSH.PAM.Enabled {\n\t\t\tif !pam.BuildHasPAM() {\n\t\t\t\terrorMessage := \"Unable to start Teleport: PAM was enabled in file configuration but this \\n\" +\n\t\t\t\t\t\"Teleport binary was built without PAM support. To continue either download a \\n\" +\n\t\t\t\t\t\"Teleport binary build with PAM support from https://gravitational.com/teleport \\n\" +\n\t\t\t\t\t\"or disable PAM in file configuration.\"\n\t\t\t\treturn trace.BadParameter(errorMessage)\n\t\t\t}\n\t\t\tif !pam.SystemHasPAM() {\n\t\t\t\terrorMessage := \"Unable to start Teleport: PAM was enabled in file configuration but this \\n\" +\n\t\t\t\t\t\"system does not have the needed PAM library installed. To continue either \\n\" +\n\t\t\t\t\t\"install libpam or disable PAM in file configuration.\"\n\t\t\t\treturn trace.BadParameter(errorMessage)\n\t\t\t}\n\t\t}\n\t}\n\tif len(fc.SSH.PublicAddr) != 0 {\n\t\taddrs, err := fc.SSH.PublicAddr.Addrs(defaults.SSHServerListenPort)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tcfg.SSH.PublicAddrs = addrs\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "func (s *MockStore) DeleteTree(prefix string) error {\n\tdelete(s.db, prefix)\n\treturn nil\n}", "label": 5}
{"code": "public static PersistenceBroker createPersistenceBroker(String jcdAlias,\r\n                                                            String user,\r\n                                                            String password) throws PBFactoryException\r\n    {\r\n        return PersistenceBrokerFactoryFactory.instance().\r\n                   createPersistenceBroker(jcdAlias, user, password);\r\n    }", "label": 0}
{"code": "function parse(str, opts) {\n  var parser = new Parser(str, opts);\n  return {attrs: parser._readProtocol(), imports: parser._imports};\n}", "label": 3}
{"code": "function finisher(error, output, callback)\n{\n  // signal end of the stream\n  // only for successfully finished streams\n  if (!error)\n  {\n    this.push(null);\n  }\n\n  // back to original track\n  callback(error, output);\n}", "label": 3}
{"code": "function matches(regex) {\n\treturn function(val) {\n\t\tregex.lastIndex = 0;\n\t\treturn isString(val) && regex.test(val);\n\t};\n}", "label": 3}
{"code": "def main():\n    \"\"\"\n    This generates the research document based on the results of \n    the various programs and includes RST imports for introduction\n    and summary\n    \"\"\"\n    print(\"Generating research notes...\")\n    if os.path.exists(fname):\n       os.remove(fname)\n    append_rst('================================================\\n')\n    append_rst('Comparison of Information Aggregation Techniques\\n')\n    append_rst('================================================\\n\\n')\n    append_rst('.. contents::\\n\\n')\n       \n    # import header\n    append_rst(open('res_core_data_HEADER.rst', 'r').read())\n    append_rst(res_core_data_mthd1.get_method())\n    append_rst(res_core_data_mthd2.get_method())\n    \n    # call programs\n    append_rst('Results\\n')\n    append_rst('=====================================\\n')\n    for dat in data_files:\n        append_rst('\\nData File : ' + dat + '\\n---------------------------------------\\n\\n')\n        res_core_data_mthd1.get_results(fname, dat)\n        res_core_data_mthd2.get_results(fname, dat)\n    \n    \n    # import footer\n    append_rst(open('res_core_data_FOOTER.rst', 'r').read())    \n    print(\"Done!\")", "label": 1}
{"code": "function watchFile(filepath) {\n\t\t\tif (!watchedFiles[filepath]) {\n\t\t\t\t// add a new file to watched files\n\t\t\t\tvar statStructure = null;\n\t\t\t\ttry {\n\t\t\t\t\tstatStructure = fs.statSync(filepath);\n\t\t\t\t} catch (e) { // StatSync can throw an error if the file has dissapeared in between\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\twatchedFiles[filepath] = statStructure;\n\t\t\t\tmtimes[filepath] = +watchedFiles[filepath].mtime;\n\t\t\t}\n\t\t}", "label": 3}
{"code": "def extract_handler_and_format_and_variant(path)\n        pieces = File.basename(path).split(\".\")\n        pieces.shift\n\n        extension = pieces.pop\n\n        handler = Template.handler_for_extension(extension)\n        format, variant = pieces.last.split(EXTENSIONS[:variants], 2) if pieces.last\n        format = if format\n          Template::Types[format]&.ref\n        else\n          if handler.respond_to?(:default_format) # default_format can return nil\n            handler.default_format\n          else\n            nil\n          end\n        end\n\n        # Template::Types[format] and handler.default_format can return nil\n        [handler, format, variant]\n      end", "label": 4}
{"code": "public static base_responses update(nitro_service client, appfwlearningsettings resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tappfwlearningsettings updateresources[] = new appfwlearningsettings[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new appfwlearningsettings();\n\t\t\t\tupdateresources[i].profilename = resources[i].profilename;\n\t\t\t\tupdateresources[i].starturlminthreshold = resources[i].starturlminthreshold;\n\t\t\t\tupdateresources[i].starturlpercentthreshold = resources[i].starturlpercentthreshold;\n\t\t\t\tupdateresources[i].cookieconsistencyminthreshold = resources[i].cookieconsistencyminthreshold;\n\t\t\t\tupdateresources[i].cookieconsistencypercentthreshold = resources[i].cookieconsistencypercentthreshold;\n\t\t\t\tupdateresources[i].csrftagminthreshold = resources[i].csrftagminthreshold;\n\t\t\t\tupdateresources[i].csrftagpercentthreshold = resources[i].csrftagpercentthreshold;\n\t\t\t\tupdateresources[i].fieldconsistencyminthreshold = resources[i].fieldconsistencyminthreshold;\n\t\t\t\tupdateresources[i].fieldconsistencypercentthreshold = resources[i].fieldconsistencypercentthreshold;\n\t\t\t\tupdateresources[i].crosssitescriptingminthreshold = resources[i].crosssitescriptingminthreshold;\n\t\t\t\tupdateresources[i].crosssitescriptingpercentthreshold = resources[i].crosssitescriptingpercentthreshold;\n\t\t\t\tupdateresources[i].sqlinjectionminthreshold = resources[i].sqlinjectionminthreshold;\n\t\t\t\tupdateresources[i].sqlinjectionpercentthreshold = resources[i].sqlinjectionpercentthreshold;\n\t\t\t\tupdateresources[i].fieldformatminthreshold = resources[i].fieldformatminthreshold;\n\t\t\t\tupdateresources[i].fieldformatpercentthreshold = resources[i].fieldformatpercentthreshold;\n\t\t\t\tupdateresources[i].xmlwsiminthreshold = resources[i].xmlwsiminthreshold;\n\t\t\t\tupdateresources[i].xmlwsipercentthreshold = resources[i].xmlwsipercentthreshold;\n\t\t\t\tupdateresources[i].xmlattachmentminthreshold = resources[i].xmlattachmentminthreshold;\n\t\t\t\tupdateresources[i].xmlattachmentpercentthreshold = resources[i].xmlattachmentpercentthreshold;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public function upload($data, array $options = [])\n    {\n        if ($this->isObjectNameRequired($data) && !isset($options['name'])) {\n            throw new \\InvalidArgumentException('A name is required when data is of type string or null.');\n        }\n\n        $encryptionKey = isset($options['encryptionKey']) ? $options['encryptionKey'] : null;\n        $encryptionKeySHA256 = isset($options['encryptionKeySHA256']) ? $options['encryptionKeySHA256'] : null;\n\n        $response = $this->connection->insertObject(\n            $this->formatEncryptionHeaders($options) + $this->identity + [\n                'data' => $data\n            ]\n        )->upload();\n\n        return new StorageObject(\n            $this->connection,\n            $response['name'],\n            $this->identity['bucket'],\n            $response['generation'],\n            $response,\n            $encryptionKey,\n            $encryptionKeySHA256\n        );\n    }", "label": 2}
{"code": "public static Double getAsDouble(Object value) {\n\t\tDouble result = null;\n\n\t\ttry {\n\t\t\tif (value instanceof String) {\n\t\t\t\tresult = Double.valueOf((String) value);\n\t\t\t} else if (value instanceof Number) {\n\t\t\t\tresult = ((Number) value).doubleValue();\n\t\t\t} else {\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tresult = null;\n\t\t}\n\n\t\treturn result == null ? 0 : result;\n\t}", "label": 0}
{"code": "public function setKubernetesDashboard($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Container\\V1\\KubernetesDashboard::class);\n        $this->kubernetes_dashboard = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def awesome_active_record_instance(object)\n      return object.inspect if !defined?(::ActiveSupport::OrderedHash)\n      return awesome_object(object) if @options[:raw]\n\n      data = if object.class.column_names != object.attributes.keys\n               object.attributes\n             else\n               object.class.column_names.inject(::ActiveSupport::OrderedHash.new) do |hash, name|\n                 if object.has_attribute?(name) || object.new_record?\n                   value = object.respond_to?(name) ? object.send(name) : object.read_attribute(name)\n                   hash[name.to_sym] = value\n                 end\n                 hash\n               end\n             end\n      \"#{object} \" << awesome_hash(data)\n    end", "label": 4}
{"code": "def opacity(opacity)\n      if opacity.is_a?(Numeric)\n        Kernel.raise ArgumentError, 'opacity must be >= 0 and <= 1.0' if opacity < 0 || opacity > 1.0\n      end\n      primitive \"opacity #{opacity}\"\n    end", "label": 4}
{"code": "public function setHotwordRegex($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\CustomInfoType_Regex::class);\n        $this->hotword_regex = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def iuwt_decomposition(in1, scale_count, scale_adjust=0, mode='ser', core_count=2, store_smoothed=False,\n                       store_on_gpu=False):\n    \"\"\"\n    This function serves as a handler for the different implementations of the IUWT decomposition. It allows the\n    different methods to be used almost interchangeably.\n\n    INPUTS:\n    in1                 (no default):       Array on which the decomposition is to be performed.\n    scale_count         (no default):       Maximum scale to be considered.\n    scale_adjust        (default=0):        Adjustment to scale value if first scales are of no interest.\n    mode                (default='ser'):    Implementation of the IUWT to be used - 'ser', 'mp' or 'gpu'.\n    core_count          (default=1):        Additional option for multiprocessing - specifies core count.\n    store_smoothed      (default=False):    Boolean specifier for whether the smoothed image is stored or not.\n    store_on_gpu        (default=False):    Boolean specifier for whether the decomposition is stored on the gpu or not.\n\n    OUTPUTS:\n    Returns the decomposition with the additional smoothed coefficients if specified.\n    \"\"\"\n\n    if mode=='ser':\n        return ser_iuwt_decomposition(in1, scale_count, scale_adjust, store_smoothed)\n    elif mode=='mp':\n        return mp_iuwt_decomposition(in1, scale_count, scale_adjust, store_smoothed, core_count)\n    elif mode=='gpu':\n        return gpu_iuwt_decomposition(in1, scale_count, scale_adjust, store_smoothed, store_on_gpu)", "label": 1}
{"code": "def flatten(hash)\n        hash.each_with_object({}) do |(key, value), h|\n          if value.instance_of?(Hash)\n            value.map do |k, v|\n              # We could add recursion here if we ever had more than 2 levels\n              h[\"#{key}.#{k}\"] = v\n            end\n          else\n            h[key] = value\n          end\n        end\n      end", "label": 4}
{"code": "func RandomDuration(max time.Duration) time.Duration {\n\trandomVal, err := rand.Int(rand.Reader, big.NewInt(int64(max)))\n\tif err != nil {\n\t\treturn max / 2\n\t}\n\treturn time.Duration(randomVal.Int64())\n}", "label": 5}
{"code": "func (c *Client) GetWebSessionInfo(user string, sid string) (services.WebSession, error) {\n\tout, err := c.Get(\n\t\tc.Endpoint(\"users\", user, \"web\", \"sessions\", sid), url.Values{})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn services.GetWebSessionMarshaler().UnmarshalWebSession(out.Bytes())\n}", "label": 5}
{"code": "func (b *BoxLayout) Draw() {\n\n\tif b.view == nil {\n\t\treturn\n\t}\n\tif b.changed {\n\t\tb.layout()\n\t}\n\tb.view.Fill(' ', b.style)\n\tfor i := range b.cells {\n\t\tb.cells[i].widget.Draw()\n\t}\n}", "label": 5}
{"code": "def create_secret_id(role_name, options = {})\n      headers = extract_headers!(options)\n      if options[:secret_id]\n        json = client.post(\"/v1/auth/approle/role/#{encode_path(role_name)}/custom-secret-id\", JSON.fast_generate(options), headers)\n      else\n        json = client.post(\"/v1/auth/approle/role/#{encode_path(role_name)}/secret-id\", JSON.fast_generate(options), headers)\n      end\n      return Secret.decode(json)\n    end", "label": 4}
{"code": "def normalize(alias):\n    \"\"\" Normalizes an alias by removing adverbs defined in IGNORED_WORDS\n    \"\"\"\n    # Convert from CamelCase to snake_case\n    alias = re.sub(r'([a-z])([A-Z])', r'\\1_\\2', alias)\n    # Ignore words\n    words = alias.lower().split('_')\n    words = filter(lambda w: w not in IGNORED_WORDS, words)\n    return '_'.join(words)", "label": 1}
{"code": "function accessor(k) {\n\tPopup.prototype[k] = function(v) {\n\t\tif (typeof v == \"undefined\") return this[\"_\" + k];\n\t\tthis[\"_\" + k] = v;\n\t\treturn this;\n\t};\n}", "label": 3}
{"code": "function isSticking(stickyElement) {\n  const topSentinel = stickyElement.previousElementSibling;\n\n  const stickyOffset = stickyElement.getBoundingClientRect().top;\n  const topSentinelOffset = topSentinel.getBoundingClientRect().top;\n  const difference = Math.round(Math.abs(stickyOffset - topSentinelOffset));\n\n  const topSentinelTopPosition = Math.abs(parseInt(window.getComputedStyle(topSentinel).getPropertyValue('top')));\n\n  return difference !== topSentinelTopPosition;\n}", "label": 3}
{"code": "def match(event)\n      dummy_handler = EventContainer.handler_class(@type).new(@attributes, @bot)\n      return [nil, nil] unless event.instance_of?(@type) && dummy_handler.matches?(event)\n\n      should_delete = nil\n      should_delete = true if (@block && @block.call(event) != false) || !@block\n\n      [@key, should_delete]\n    end", "label": 4}
{"code": "function () {\n      if (options['offline']) {\n        options.drupalDistroRelease = '0.0.0';\n      }\n      else {\n        // Find the latest stable release for the Drupal distro version.\n        var done = this.async();\n        options.drupalDistro.releaseVersion(options.drupalDistroVersion, done, function(err, version, done) {\n          if (err) {\n            this.env.error('Could not retrieve distribution project info: ' + err);\n            return done(err);\n          }\n          options.drupalDistroRelease = version;\n          done();\n        }.bind(this));\n      }\n    }", "label": 3}
{"code": "function _getSelected(select) {\n    const arr = [];\n\n    _slice.call(select.options).map((el) => {\n        if (el.selected) {\n            arr.push(el.value);\n        }\n    });\n\n    return arr;\n}", "label": 3}
{"code": "public static route6[] get(nitro_service service) throws Exception{\n\t\troute6 obj = new route6();\n\t\troute6[] response = (route6[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private function snapshotPosition(DocumentSnapshot $snapshot, array $orderBy)\n    {\n        $appendName = true;\n        foreach ($orderBy as $order) {\n            if ($order['field']['fieldPath'] === self::DOCUMENT_ID) {\n                $appendName = false;\n                break;\n            }\n        }\n\n        if ($appendName) {\n            // If there is inequality filter (anything other than equals),\n            // append orderBy(the last inequality filter\u2019s path, ascending).\n            if (!$orderBy && $this->queryHas('where')) {\n                $filters = $this->query['where']['compositeFilter']['filters'];\n                $inequality = array_filter($filters, function ($filter) {\n                    $type = array_keys($filter)[0];\n                    return !in_array($filter[$type]['op'], [\n                        self::OP_EQUAL,\n                        self::OP_ARRAY_CONTAINS\n                    ]);\n                });\n\n                if ($inequality) {\n                    $filter = end($inequality);\n                    $type = array_keys($filter)[0];\n                    $orderBy[] = [\n                        'field' => [\n                            'fieldPath' => $filter[$type]['field']['fieldPath'],\n                        ],\n                        'direction' => self::DIR_ASCENDING\n                    ];\n                }\n            }\n\n            // If the query has existing orderBy constraints\n            if ($orderBy) {\n                // Append orderBy(__name__, direction of last orderBy clause)\n                $lastOrderDirection = end($orderBy)['direction'];\n                $orderBy[] = [\n                    'field' => [\n                        'fieldPath' => self::DOCUMENT_ID\n                    ],\n                    'direction' => $lastOrderDirection\n                ];\n            } else {\n                // no existing orderBy constraints\n                // Otherwise append orderBy(__name__, \u2018asc\u2019)\n                $orderBy[] = [\n                    'field' => [\n                        'fieldPath' => self::DOCUMENT_ID\n                    ],\n                    'direction' => self::DIR_ASCENDING\n                ];\n            }\n        }\n\n        $fieldValues = $this->snapshotCursorValues($snapshot, $orderBy);\n\n        return [\n            $fieldValues,\n            $orderBy\n        ];\n    }", "label": 2}
{"code": "public void processReference(String template, Properties attributes) throws XDocletException\r\n    {\r\n        String                 name   = OjbMemberTagsHandler.getMemberName();\r\n        XClass                 type   = OjbMemberTagsHandler.getMemberType();\r\n        int                    dim    = OjbMemberTagsHandler.getMemberDimension();\r\n        ReferenceDescriptorDef refDef = _curClassDef.getReference(name);\r\n        String                 attrName;\r\n\r\n        if (refDef == null)\r\n        {\r\n            refDef = new ReferenceDescriptorDef(name);\r\n            _curClassDef.addReference(refDef);\r\n        }\r\n        LogHelper.debug(false, OjbTagsHandler.class, \"processReference\", \"  Processing reference \"+refDef.getName());\r\n\r\n        for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )\r\n        {\r\n            attrName = (String)attrNames.nextElement();\r\n            refDef.setProperty(attrName, attributes.getProperty(attrName));\r\n        }\r\n        // storing default info for later use\r\n        if (type == null)\r\n        {\r\n            throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r\n                                       XDocletModulesOjbMessages.COULD_NOT_DETERMINE_TYPE_OF_MEMBER,\r\n                                       new String[]{name}));\r\n        }\r\n        if (dim > 0)\r\n        {\r\n            throw new XDocletException(Translator.getString(XDocletModulesOjbMessages.class,\r\n                                       XDocletModulesOjbMessages.MEMBER_CANNOT_BE_A_REFERENCE,\r\n                                       new String[]{name, _curClassDef.getName()}));\r\n        }\r\n\r\n        refDef.setProperty(PropertyHelper.OJB_PROPERTY_VARIABLE_TYPE, type.getQualifiedName());\r\n\r\n        // searching for default type\r\n        String typeName = searchForPersistentSubType(type);\r\n\r\n        if (typeName != null)\r\n        {\r\n            refDef.setProperty(PropertyHelper.OJB_PROPERTY_DEFAULT_CLASS_REF, typeName);\r\n        }\r\n\r\n        _curReferenceDef = refDef;\r\n        generate(template);\r\n        _curReferenceDef = null;\r\n    }", "label": 0}
{"code": "def check_collision!\n      paths = self.routes.map(&:path)\n      collision = Jets::Resource::ApiGateway::RestApi::Routes::Collision.new\n      collide = collision.collision?(paths)\n      raise collision.exception if collide\n    end", "label": 4}
{"code": "public static long count(nitro_service service, String zonename) throws Exception{\n\t\tdnszone_domain_binding obj = new dnszone_domain_binding();\n\t\tobj.set_zonename(zonename);\n\t\toptions option = new options();\n\t\toption.set_count(true);\n\t\tdnszone_domain_binding response[] = (dnszone_domain_binding[]) obj.get_resources(service,option);\n\t\tif (response != null) {\n\t\t\treturn response[0].__count;\n\t\t}\n\t\treturn 0;\n\t}", "label": 0}
{"code": "def define_singleton_method(method_name, content=Proc.new)\n      (class << self; self; end).class_eval do\n        undef_method(method_name) if method_defined?(method_name)\n        if String === content\n          class_eval(\"def #{method_name}() #{content}; end\")\n        else\n          define_method(method_name, &content)\n        end\n      end\n    end", "label": 4}
{"code": "public static void main(String[] args) {\r\n    TreebankLanguagePack tlp = new PennTreebankLanguagePack();\r\n    System.out.println(\"Start symbol: \" + tlp.startSymbol());\r\n    String start = tlp.startSymbol();\r\n    System.out.println(\"Should be true: \" + (tlp.isStartSymbol(start)));\r\n    String[] strs = {\"-\", \"-LLB-\", \"NP-2\", \"NP=3\", \"NP-LGS\", \"NP-TMP=3\"};\r\n    for (String str : strs) {\r\n      System.out.println(\"String: \" + str + \" basic: \" + tlp.basicCategory(str) + \" basicAndFunc: \" + tlp.categoryAndFunction(str));\r\n    }\r\n  }", "label": 0}
{"code": "public function UpdateInstance(\\Google\\Cloud\\Redis\\V1\\UpdateInstanceRequest $argument,\n      $metadata = [], $options = []) {\n        return $this->_simpleRequest('/google.cloud.redis.v1.CloudRedis/UpdateInstance',\n        $argument,\n        ['\\Google\\LongRunning\\Operation', 'decode'],\n        $metadata, $options);\n    }", "label": 2}
{"code": "function loadModulePlugins(modulePlugins) {\n        var serverModules = {};\n        var me = this;\n\n        // add modules from each plugin to the serverModules map\n        _.each(modulePlugins, function (modulePlugin) {\n            _.extend(serverModules, me.loadModules(modulePlugin.rootDir, modulePlugin.serverModuleDirs));\n        });\n\n        return serverModules;\n    }", "label": 3}
{"code": "function normalizeIso8601TimeZone(value) {\n    if (value === 'Z') {\n      return 0;\n    }\n\n    var regex = /^([+-])(\\d\\d):?(\\d\\d)$/;\n    var matches = regex.exec(value);\n    if (matches === null) {\n      return NaN;\n    } else {\n      var multiplicationFactor = (matches[1] === '+') ? 1 : -1;\n      var hour = parseInt(matches[2], 10);\n      var minute = parseInt(matches[3], 10);\n\n      return multiplicationFactor * ((hour * 60) + minute);\n    }\n  }", "label": 3}
{"code": "func stringEnd(data []byte) (int, bool) {\n\tescaped := false\n\tfor i, c := range data {\n\t\tif c == '\"' {\n\t\t\tif !escaped {\n\t\t\t\treturn i + 1, false\n\t\t\t} else {\n\t\t\t\tj := i - 1\n\t\t\t\tfor {\n\t\t\t\t\tif j < 0 || data[j] != '\\\\' {\n\t\t\t\t\t\treturn i + 1, true // even number of backslashes\n\t\t\t\t\t}\n\t\t\t\t\tj--\n\t\t\t\t\tif j < 0 || data[j] != '\\\\' {\n\t\t\t\t\t\tbreak // odd number of backslashes\n\t\t\t\t\t}\n\t\t\t\t\tj--\n\n\t\t\t\t}\n\t\t\t}\n\t\t} else if c == '\\\\' {\n\t\t\tescaped = true\n\t\t}\n\t}\n\n\treturn -1, escaped\n}", "label": 5}
{"code": "def get_version_history_for_file(self, filepath):\n        \"\"\" Return a dict representation of this file's commit history\n\n        This uses specially formatted git-log output for easy parsing, as described here:\n            http://blog.lost-theory.org/post/how-to-parse-git-log-output/\n        For a full list of available fields, see:\n            http://linux.die.net/man/1/git-log\n\n        \"\"\"\n        # define the desired fields for logout output, matching the order in these lists!\n        GIT_COMMIT_FIELDS = ['id',\n                             'author_name',\n                             'author_email',\n                             'date',\n                             'date_ISO_8601',\n                             'relative_date',\n                             'message_subject',\n                             'message_body']\n        GIT_LOG_FORMAT = ['%H', '%an', '%ae', '%aD', '%ai', '%ar', '%s', '%b']\n        # make the final format string, using standard ASCII field/record delimiters\n        GIT_LOG_FORMAT = '%x1f'.join(GIT_LOG_FORMAT) + '%x1e'\n        try:\n            log = git(self.gitdir,\n                      self.gitwd,\n                      '--no-pager',\n                      'log',\n                      '--format=%s' % GIT_LOG_FORMAT,\n                      '--follow',  # Track file's history when moved/renamed...\n                      '--find-renames=100%',  # ... but only if the contents are identical!\n                      '--',\n                      filepath)\n            # _LOG.debug('log said \"{}\"'.format(log))\n            log = log.strip('\\n\\x1e').split(\"\\x1e\")\n            log = [row.strip().split(\"\\x1f\") for row in log]\n            log = [dict(zip(GIT_COMMIT_FIELDS, row)) for row in log]\n        except:\n            _LOG.exception('git log failed')\n            raise\n        return log", "label": 1}
{"code": "public static function taskName($project, $location, $queue, $task)\n    {\n        return self::getTaskNameTemplate()->render([\n            'project' => $project,\n            'location' => $location,\n            'queue' => $queue,\n            'task' => $task,\n        ]);\n    }", "label": 2}
{"code": "def load_configuration(self):\n        \"\"\"Loading configuration.\"\"\"\n        filename = os.path.join(os.path.dirname(__file__), 'templates/spline-loc.yml.j2')\n        with open(filename) as handle:\n            return Adapter(safe_load(handle)).configuration", "label": 1}
{"code": "func taskName(info *types.TaskInfo) string {\n\tname := strings.TrimSuffix(info.Name, \"_Task\")\n\tswitch name {\n\tcase \"\":\n\t\treturn info.DescriptionId\n\tcase \"Destroy\", \"Rename\":\n\t\treturn info.Entity.Type + \".\" + name\n\tdefault:\n\t\treturn name\n\t}\n}", "label": 5}
{"code": "protected function updateInternalState()\n    {\n        if (!$this->hasFilter(static::END_DATE_FILTER)) {\n            $this->endDate = null;\n        }\n\n        if (!$this->hasFilter(static::RECURRENCES_FILTER)) {\n            $this->recurrences = null;\n        }\n    }", "label": 2}
{"code": "public static function makeFromExisting(IlluminateResponse $old)\n    {\n        $new = static::create($old->getOriginalContent(), $old->getStatusCode());\n\n        $new->headers = $old->headers;\n\n        return $new;\n    }", "label": 2}
{"code": "private function decorateWithHashes(Stream $stream, array &$data)\n    {\n        // Decorate source with a hashing stream\n        $hash = new PhpHash('sha256');\n        return new HashingStream($stream, $hash, function ($result) use (&$data) {\n            $data['ContentSHA256'] = bin2hex($result);\n        });\n    }", "label": 2}
{"code": "protected function storeExceptions(Collection $exceptions)\n    {\n        $this->table('telescope_entries')->insert($exceptions->map(function ($exception) {\n            $occurrences = $this->table('telescope_entries')\n                    ->where('type', EntryType::EXCEPTION)\n                    ->where('family_hash', $exception->familyHash())\n                    ->count();\n\n            $this->table('telescope_entries')\n                    ->where('type', EntryType::EXCEPTION)\n                    ->where('family_hash', $exception->familyHash())\n                    ->update(['should_display_on_index' => false]);\n\n            return array_merge($exception->toArray(), [\n                'family_hash' => $exception->familyHash(),\n                'content' => json_encode(array_merge(\n                    $exception->content, ['occurrences' => $occurrences + 1]\n                )),\n            ]);\n        })->toArray());\n\n        $this->storeTags($exceptions->pluck('tags', 'uuid'));\n    }", "label": 2}
{"code": "func CreateSignupLink(client auth.ClientI, token string) (string, string) {\n\tproxyHost := \"<proxyhost>:3080\"\n\n\tproxies, err := client.GetProxies()\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to retrieve proxy list: %v\", err)\n\t}\n\n\tif len(proxies) > 0 {\n\t\tproxyHost = proxies[0].GetPublicAddr()\n\t\tif proxyHost == \"\" {\n\t\t\tproxyHost = fmt.Sprintf(\"%v:%v\", proxies[0].GetHostname(), defaults.HTTPListenPort)\n\t\t\tlog.Debugf(\"public_address not set for proxy, returning proxyHost: %q\", proxyHost)\n\t\t}\n\t}\n\n\tu := &url.URL{\n\t\tScheme: \"https\",\n\t\tHost:   proxyHost,\n\t\tPath:   \"web/newuser/\" + token,\n\t}\n\treturn u.String(), proxyHost\n}", "label": 5}
{"code": "def split_type(cls, type_name):\n        \"\"\"Split type of a type name with CardinalityField suffix into its parts.\n\n        :param type_name:  Type name (as string).\n        :return: Tuple (type_basename, cardinality)\n        \"\"\"\n        if cls.matches_type(type_name):\n            basename = type_name[:-1]\n            cardinality = cls.from_char_map[type_name[-1]]\n        else:\n            # -- ASSUME: Cardinality.one\n            cardinality = Cardinality.one\n            basename = type_name\n        return (basename, cardinality)", "label": 1}
{"code": "function assertObject(attr, data) {\n  if (data === null || data === undefined) {\n    return null;\n  }\n\n  if (typeof data !== 'object' || Array.isArray(data)) {\n    throw new ParseError(`Attribute ${attr} must be of type \"object\"`);\n  }\n\n  return data;\n}", "label": 3}
{"code": "protected static void main(String args[]) {\r\n\tint from = Integer.parseInt(args[0]);\t\r\n\tint to = Integer.parseInt(args[1]);\r\n\t\r\n\tstatistics(from,to);\r\n}", "label": 0}
{"code": "def set_custom_image(user_context, app_id, image_path):\n  \"\"\"Sets the custom image for `app_id` to be the image located at\n  `image_path`. If there already exists a custom image for `app_id` it will\n  be deleted. Returns True is setting the image was successful.\"\"\"\n  if image_path is None:\n    return False\n\n  if not os.path.exists(image_path):\n    return False\n\n  (root, ext) = os.path.splitext(image_path)\n  if not is_valid_extension(ext):\n    # TODO: Maybe log that this happened?\n    return False\n  # If we don't remove the old image then theres no guarantee that Steam will\n  # show our new image when it launches.\n  if has_custom_image(user_context, app_id):\n    img = get_custom_image(user_context, app_id)\n    assert(img is not None)\n    os.remove(img)\n  \n  # Set the new image\n  parent_dir = paths.custom_images_directory(user_context)\n  new_path = os.path.join(parent_dir, app_id + ext)\n  shutil.copyfile(image_path, new_path)\n  return True", "label": 1}
{"code": "public function snapshot($name, array $info = [])\n    {\n        return new Snapshot($this->connection, $this->projectId, $name, $this->encode, $info);\n    }", "label": 2}
{"code": "function async(callback)\n{\n  var isAsync = false;\n\n  // check if async happened\n  defer(function() { isAsync = true; });\n\n  return function async_callback(err, result)\n  {\n    if (isAsync)\n    {\n      callback(err, result);\n    }\n    else\n    {\n      defer(function nextTick_callback()\n      {\n        callback(err, result);\n      });\n    }\n  };\n}", "label": 3}
{"code": "private function getManifest($manifestPath)\n    {\n        if (self::$__manifest) {\n            $manifest = self::$__manifest;\n        } else {\n            $manifest = json_decode(file_get_contents($manifestPath), true);\n\n            if (json_last_error() !== JSON_ERROR_NONE) {\n                throw new \\RuntimeException('Could not decode manifest json');\n            }\n\n            self::$__manifest = $manifest;\n        }\n\n        return $manifest;\n    }", "label": 2}
{"code": "function(token, newPassword, options) {\n      options = opts(this, options);\n      options.applevel = true;\n      var payload = JSON.stringify({\n        password: newPassword\n      });\n\n      return new APICall({\n        action: \"account/password/reset/\" + token,\n        type: 'POST',\n        data: payload,\n        processResponse: APICall.basicResponse,\n        options: options\n      });\n    }", "label": 3}
{"code": "func (p *Peer) fromDictInterface(d map[string]interface{}) {\n\tp.IP = net.ParseIP(d[\"ip\"].(string))\n\tif _, ok := d[\"peer id\"]; ok {\n\t\tp.ID = []byte(d[\"peer id\"].(string))\n\t}\n\tp.Port = int(d[\"port\"].(int64))\n}", "label": 5}
{"code": "def _parse_file(self, file):\n        \"\"\" Parses the given file-like object.\n        \"\"\"\n        case = Case()\n        file.seek(0)\n\n        line = file.readline().split()\n        if line[0] != \"function\":\n            logger.error(\"Invalid data file header.\")\n            return case\n        if line[1] != \"mpc\":\n            self._is_struct = False\n            base = \"\"\n        else:\n            base = \"mpc.\"\n        case.name = line[-1]\n\n        for line in file:\n            if line.startswith(\"%sbaseMVA\" % base):\n                case_data = line.rstrip(\";\\n\").split()\n                case.base_mva = float(case_data[-1])\n            elif line.startswith(\"%sbus\" % base):\n                self._parse_buses(case, file)\n            elif line.startswith(\"%sgencost\" % base):\n                self._parse_gencost(case, file)\n            elif line.startswith(\"%sgen\" % base):\n                self._parse_generators(case, file)\n            elif line.startswith(\"%sbranch\" % base):\n                self._parse_branches(case, file)\n\n        return case", "label": 1}
{"code": "public static Module createModule(final String name,final String version){\n        final Module module = new Module();\n\n        module.setName(name);\n        module.setVersion(version);\n        module.setPromoted(false);\n\n        return module;\n\n    }", "label": 0}
{"code": "public static cacheglobal_binding get(nitro_service service) throws Exception{\n\t\tcacheglobal_binding obj = new cacheglobal_binding();\n\t\tcacheglobal_binding response = (cacheglobal_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def _get_csrf_disabled_param():\n    \"\"\"Return the right param to disable CSRF depending on WTF-Form version.\n\n    From Flask-WTF 0.14.0, `csrf_enabled` param has been deprecated in favor of\n    `meta={csrf: True/False}`.\n    \"\"\"\n    import flask_wtf\n    from pkg_resources import parse_version\n    supports_meta = parse_version(flask_wtf.__version__) >= parse_version(\n        \"0.14.0\")\n    return dict(meta={'csrf': False}) if supports_meta else \\\n        dict(csrf_enabled=False)", "label": 1}
{"code": "def activate(self, plugins=[]):\n        \"\"\"\n        Activates given plugins.\n\n        This calls mainly plugin.activate() and plugins register needed resources like commands, signals or\n        documents.\n\n        If given plugins have not been initialised, this is also done via :func:`_load`.\n\n        :param plugins: List of plugin names\n        :type plugins: list of strings\n        \"\"\"\n        self._log.debug(\"Plugins Activation started\")\n\n        if not isinstance(plugins, list):\n            raise AttributeError(\"plugins must be a list, not %s\" % type(plugins))\n\n        self._log.debug(\"Plugins to activate: %s\" % \", \".join(plugins))\n\n        plugins_activated = []\n        for plugin_name in plugins:\n            if not isinstance(plugin_name, str):\n                raise AttributeError(\"plugin name must be a str, not %s\" % type(plugin_name))\n\n            if plugin_name not in self._plugins.keys() and plugin_name in self.classes._classes.keys():\n                self._log.debug(\"Initialisation needed before activation.\")\n                try:\n                    self.initialise_by_names([plugin_name])\n                except Exception as e:\n                    self._log.error(\"Couldn't initialise plugin %s. Reason %s\" % (plugin_name, e))\n                    if self._app.strict:\n                        error = \"Couldn't initialise plugin %s\" % plugin_name\n                        if sys.version_info[0] < 3:\n                            error += \"Reason: %s\" % e\n                        raise_from(Exception(error), e)\n                    else:\n                        continue\n            if plugin_name in self._plugins.keys():\n                self._log.debug(\"Activating plugin %s\" % plugin_name)\n                if not self._plugins[plugin_name].active:\n                    try:\n                        self._plugins[plugin_name].activate()\n                    except Exception as e:\n                        raise_from(\n                            PluginNotActivatableException(\"Plugin %s could not be activated: %s\" % (plugin_name,\n                                                                                                    e)), e)\n                    else:\n                        self._log.debug(\"Plugin %s activated\" % plugin_name)\n                        plugins_activated.append(plugin_name)\n                else:\n                    self._log.warning(\"Plugin %s got already activated.\" % plugin_name)\n                    if self._app.strict:\n                        raise PluginNotInitialisableException()\n\n        self._log.info(\"Plugins activated: %s\" % \", \".join(plugins_activated))", "label": 1}
{"code": "public static appfwprofile get(nitro_service service, String name) throws Exception{\n\t\tappfwprofile obj = new appfwprofile();\n\t\tobj.set_name(name);\n\t\tappfwprofile response = (appfwprofile) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def add_tasks_r(addon_module, package_module, package_name):\n    '''Recursively iterate through 'package_module' and add every fabric task\n    to the 'addon_module' keeping the task hierarchy.\n\n    Args:\n        addon_module(types.ModuleType)\n        package_module(types.ModuleType)\n        package_name(str): Required, to avoid redundant addition of tasks\n\n    Return: None\n    '''\n    module_dict = package_module.__dict__\n    for attr_name, attr_val in module_dict.items():\n\n        if isinstance(attr_val, fabric.tasks.WrappedCallableTask):\n            addon_module.__dict__[attr_name] = attr_val\n\n        elif attr_name != package_name \\\n                and isinstance(attr_val, types.ModuleType) \\\n                and attr_val.__name__.startswith('fabsetup_') \\\n                and attr_name.split('.')[-1] != package_name:\n\n            submodule_name = flo('{addon_module.__name__}.{attr_name}')\n            submodule = get_or_create_module_r(submodule_name)\n            package_module = attr_val\n\n            add_tasks_r(submodule, package_module, package_name)\n            addon_module.__dict__[attr_name] = submodule", "label": 1}
{"code": "func (cfg *ScopeCfg) IsValid() bool {\n\tif cfg == nil ||\n\t\tstrings.TrimSpace(cfg.Client.Provider) == \"\" ||\n\t\tstrings.TrimSpace(cfg.Client.Address) == \"\" {\n\t\treturn false\n\t}\n\n\treturn true\n}", "label": 5}
{"code": "public function onChannelPreDelete(ResourceControllerEvent $event): void\n    {\n        $channel = $event->getSubject();\n\n        if (!$channel instanceof ChannelInterface) {\n            throw new UnexpectedTypeException(\n                $channel,\n                ChannelInterface::class\n            );\n        }\n\n        $results = $this->channelRepository->findBy(['enabled' => true]);\n\n        if (!$results || (count($results) === 1 && current($results) === $channel)) {\n            $event->stop('sylius.channel.delete_error');\n        }\n    }", "label": 2}
{"code": "func UnmarshalCertRoles(data string) ([]string, error) {\n\tvar certRoles CertRoles\n\tif err := utils.UnmarshalWithSchema(CertRolesSchema, &certRoles, []byte(data)); err != nil {\n\t\treturn nil, trace.BadParameter(err.Error())\n\t}\n\treturn certRoles.Roles, nil\n}", "label": 5}
{"code": "def name_to_system_object(self, name):\n        \"\"\"\n            Give SystemObject instance corresponding to the name\n        \"\"\"\n        if isinstance(name, str):\n            if self.allow_name_referencing:\n                name = name\n            else:\n                raise NameError('System.allow_name_referencing is set to False, cannot convert string to name')\n        elif isinstance(name, Object):\n            name = str(name)\n        return self.namespace.get(name, None)", "label": 1}
{"code": "def extract(self):\n        \"\"\"\n        Creates a copy of this tabarray in the form of a numpy ndarray.\n\n        Useful if you want to do math on array elements, e.g. if you have a \n        subset of the columns that are all numerical, you can construct a \n        numerical matrix and do matrix operations.\n\n        \"\"\"\n        return np.vstack([self[r] for r in self.dtype.names]).T.squeeze()", "label": 1}
{"code": "public function setAutoscaling($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Container\\V1\\NodePoolAutoscaling::class);\n        $this->autoscaling = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function getAliases(name, flapjack) {\n    var moduleInfo = getModuleInfo(flapjack) || {};\n    var aliases = moduleInfo[name] || {};\n    return aliases === true ? {} : aliases;\n}", "label": 3}
{"code": "public Set<Class<?>> getPrevented() {\n        if (this.prevent == null) {\n            return Collections.emptySet();\n        }\n        return Collections.unmodifiableSet(this.prevent);\n    }", "label": 0}
{"code": "public function setExclusions($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Logging\\V2\\LogExclusion::class);\n        $this->exclusions = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (c *Manager) DeployLibraryItem(ctx context.Context, libraryItemID string, deploy Deploy) (Deployment, error) {\n\turl := internal.URL(c, internal.VCenterOVFLibraryItem).WithID(libraryItemID).WithAction(\"deploy\")\n\tvar res Deployment\n\treturn res, c.Do(ctx, url.Request(http.MethodPost, deploy), &res)\n}", "label": 5}
{"code": "public synchronized static SQLiteDatabase getConnection(Context context) {\n\t\tif (database == null) {\n\t\t\t// Construct the single helper and open the unique(!) db connection for the app\n\t\t\tdatabase = new CupboardDbHelper(context.getApplicationContext()).getWritableDatabase();\n\t\t}\n\t\treturn database;\n\t}", "label": 0}
{"code": "def get_unmatched_population_keys(target, source)\n      return [] if target.length == source.length\n      all_target_keys = target.values.map(&:id)\n      with_ref_keys = source.values.map(&:id).map {|key| @population_criteria_by_id[@population_reference[key]].id if @population_criteria_by_id[@population_reference[key]]}\n      # if we have a population without a reference, we cannot trust the results.\n      return [] if with_ref_keys.include? nil\n      all_target_keys - with_ref_keys\n    end", "label": 4}
{"code": "def writeGTF(inGTF,file_path):\n    \"\"\"\n    Write a GTF dataframe into a file\n\n    :param inGTF: GTF dataframe to be written. It should either have 9 columns with the last one being the \"attributes\" section or more than 9 columns where all columns after the 8th will be colapsed into one.\n    :param file_path: path/to/the/file.gtf\n    :returns: nothing\n    \"\"\"\n    cols=inGTF.columns.tolist()\n    if len(cols) == 9:\n        if 'attribute' in cols:\n            df=inGTF\n    else:\n        df=inGTF[cols[:8]]\n        df['attribute']=\"\"\n        for c in cols[8:]:\n            if c == cols[len(cols)-1]:\n                df['attribute']=df['attribute']+c+' \"'+inGTF[c].astype(str)+'\";'\n            else:\n                df['attribute']=df['attribute']+c+' \"'+inGTF[c].astype(str)+'\"; '\n    df.to_csv(file_path, sep=\"\\t\",header=None,index=None,quoting=csv.QUOTE_NONE)", "label": 1}
{"code": "func (d *driver) restoreEndpoints() error {\n\tif d.localStore == nil {\n\t\tlogrus.Warn(\"Cannot restore overlay endpoints because local datastore is missing\")\n\t\treturn nil\n\t}\n\tkvol, err := d.localStore.List(datastore.Key(overlayEndpointPrefix), &endpoint{})\n\tif err != nil && err != datastore.ErrKeyNotFound {\n\t\treturn fmt.Errorf(\"failed to read overlay endpoint from store: %v\", err)\n\t}\n\n\tif err == datastore.ErrKeyNotFound {\n\t\treturn nil\n\t}\n\tfor _, kvo := range kvol {\n\t\tep := kvo.(*endpoint)\n\t\tn := d.network(ep.nid)\n\t\tif n == nil {\n\t\t\tlogrus.Debugf(\"Network (%.7s) not found for restored endpoint (%.7s)\", ep.nid, ep.id)\n\t\t\tlogrus.Debugf(\"Deleting stale overlay endpoint (%.7s) from store\", ep.id)\n\t\t\tif err := d.deleteEndpointFromStore(ep); err != nil {\n\t\t\t\tlogrus.Debugf(\"Failed to delete stale overlay endpoint (%.7s) from store\", ep.id)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tn.addEndpoint(ep)\n\n\t\ts := n.getSubnetforIP(ep.addr)\n\t\tif s == nil {\n\t\t\treturn fmt.Errorf(\"could not find subnet for endpoint %s\", ep.id)\n\t\t}\n\n\t\tif err := n.joinSandbox(s, true, true); err != nil {\n\t\t\treturn fmt.Errorf(\"restore network sandbox failed: %v\", err)\n\t\t}\n\n\t\tIfaces := make(map[string][]osl.IfaceOption)\n\t\tvethIfaceOption := make([]osl.IfaceOption, 1)\n\t\tvethIfaceOption = append(vethIfaceOption, n.sbox.InterfaceOptions().Master(s.brName))\n\t\tIfaces[\"veth+veth\"] = vethIfaceOption\n\n\t\terr := n.sbox.Restore(Ifaces, nil, nil, nil)\n\t\tif err != nil {\n\t\t\tn.leaveSandbox()\n\t\t\treturn fmt.Errorf(\"failed to restore overlay sandbox: %v\", err)\n\t\t}\n\n\t\td.peerAdd(ep.nid, ep.id, ep.addr.IP, ep.addr.Mask, ep.mac, net.ParseIP(d.advertiseAddress), false, false, true)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "private OJBIterator getReportQueryIteratorFromQuery(Query query, ClassDescriptor cld) throws PersistenceBrokerException\n    {\n        RsIteratorFactory factory = ReportRsIteratorFactoryImpl.getInstance();\n        OJBIterator result = getRsIteratorFromQuery(query, cld, factory);\n\n        if (query.usePaging())\n        {\n            result = new PagingIterator(result, query.getStartAtIndex(), query.getEndAtIndex());\n        }\n\n        return result;\n    }", "label": 0}
{"code": "protected boolean isStoredProcedure(String sql)\r\n    {\r\n        /*\r\n        Stored procedures start with\r\n        {?= call <procedure-name>[<arg1>,<arg2>, ...]}\r\n        or\r\n        {call <procedure-name>[<arg1>,<arg2>, ...]}\r\n        but also statements with white space like\r\n        { ?= call <procedure-name>[<arg1>,<arg2>, ...]}\r\n        are possible.\r\n        */\r\n        int k = 0, i = 0;\r\n        char c;\r\n        while(k < 3 && i < sql.length())\r\n        {\r\n            c = sql.charAt(i);\r\n            if(c != ' ')\r\n            {\r\n                switch (k)\r\n                {\r\n                    case 0:\r\n                        if(c != '{') return false;\r\n                        break;\r\n                    case 1:\r\n                        if(c != '?' && c != 'c') return false;\r\n                        break;\r\n                    case 2:\r\n                        if(c != '=' && c != 'a') return false;\r\n                        break;\r\n                }\r\n                k++;\r\n            }\r\n            i++;\r\n        }\r\n        return true;\r\n    }", "label": 0}
{"code": "def remove(self, **kwargs):\n        \"\"\"\n        Remove an instance of this resource definition.\n        \"\"\"\n        self.helper.remove(self.inner(), **kwargs)\n        self._inner = None", "label": 1}
{"code": "public static nd6ravariables[] get(nitro_service service, Long vlan[]) throws Exception{\n\t\tif (vlan !=null && vlan.length>0) {\n\t\t\tnd6ravariables response[] = new nd6ravariables[vlan.length];\n\t\t\tnd6ravariables obj[] = new nd6ravariables[vlan.length];\n\t\t\tfor (int i=0;i<vlan.length;i++) {\n\t\t\t\tobj[i] = new nd6ravariables();\n\t\t\t\tobj[i].set_vlan(vlan[i]);\n\t\t\t\tresponse[i] = (nd6ravariables) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "def for_consecutive_items(items, satisfies, min_consecutive = 2)\n      current_index = -1\n\n      while (current_index += 1) < items.count\n        next unless satisfies[items[current_index]]\n\n        count = count_consecutive(items, current_index, &satisfies)\n        next unless count >= min_consecutive\n\n        # Yield the chunk of consecutive items\n        yield items[current_index...(current_index + count)]\n\n        current_index += count # Skip this patch of consecutive items to find more\n      end\n    end", "label": 4}
{"code": "func (h *Heartbeat) ForceSend(timeout time.Duration) error {\n\ttimeoutC := time.After(timeout)\n\tselect {\n\tcase h.sendC <- struct{}{}:\n\tcase <-timeoutC:\n\t\treturn trace.ConnectionProblem(nil, \"timeout waiting for send\")\n\t}\n\tselect {\n\tcase <-h.announceC:\n\t\treturn nil\n\tcase <-timeoutC:\n\t\treturn trace.ConnectionProblem(nil, \"timeout waiting for announce to be sent\")\n\t}\n}", "label": 5}
{"code": "private function emitSocketError()\n    {\n        $errno = socket_last_error();\n        $errstr = socket_strerror($errno);\n\n        $this->disconnect();\n\n        $this->onConnectionError(trim($errstr), $errno);\n    }", "label": 2}
{"code": "function( thing, value, options ) {\n\n                var thingItem, thingValue,\n                    thingIsObject = $.isPlainObject( thing ),\n                    thingObject = thingIsObject ? thing : {}\n\n                // Make sure we have usable options.\n                options = thingIsObject && $.isPlainObject( value ) ? value : options || {}\n\n                if ( thing ) {\n\n                    // If the thing isn\u2019t an object, make it one.\n                    if ( !thingIsObject ) {\n                        thingObject[ thing ] = value\n                    }\n\n                    // Go through the things of items to set.\n                    for ( thingItem in thingObject ) {\n\n                        // Grab the value of the thing.\n                        thingValue = thingObject[ thingItem ]\n\n                        // First, if the item exists and there\u2019s a value, set it.\n                        if ( thingItem in P.component.item ) {\n                            if ( thingValue === undefined ) thingValue = null\n                            P.component.set( thingItem, thingValue, options )\n                        }\n\n                        // Then, check to update the element value and broadcast a change.\n                        if ( thingItem == 'select' || thingItem == 'clear' ) {\n                            $ELEMENT.\n                                val( thingItem == 'clear' ? '' : P.get( thingItem, SETTINGS.format ) ).\n                                trigger( 'change' )\n                        }\n                    }\n\n                    // Render a new picker.\n                    P.render()\n                }\n\n                // When the method isn\u2019t muted, trigger queued \u201cset\u201d events and pass the `thingObject`.\n                return options.muted ? P : P.trigger( 'set', thingObject )\n            }", "label": 3}
{"code": "public function setCells($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Bigtable\\V2\\Cell::class);\n        $this->cells = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "private function urlStatDirectory()\n    {\n        $stats = [];\n        // 1. try to look up the directory as a file\n        try {\n            $this->object = $this->bucket->object($this->file);\n            $info = $this->object->info();\n\n            // equivalent to 40777 and 40444 in octal\n            $stats['mode'] = $this->bucket->isWritable()\n                ? self::DIRECTORY_WRITABLE_MODE\n                : self::DIRECTORY_READABLE_MODE;\n            $this->statsFromFileInfo($info, $stats);\n\n            return $this->makeStatArray($stats);\n        } catch (NotFoundException $e) {\n        } catch (ServiceException $e) {\n            return false;\n        }\n\n        // 2. try list files in that directory\n        try {\n            $objects = $this->bucket->objects([\n                'prefix' => $this->file,\n            ]);\n\n            if (!$objects->current()) {\n                // can't list objects or doesn't exist\n                return false;\n            }\n        } catch (ServiceException $e) {\n            return false;\n        }\n\n        // equivalent to 40777 and 40444 in octal\n        $mode = $this->bucket->isWritable()\n            ? self::DIRECTORY_WRITABLE_MODE\n            : self::DIRECTORY_READABLE_MODE;\n        return $this->makeStatArray([\n            'mode'    => $mode\n        ]);\n    }", "label": 2}
{"code": "def search_customers(body, opts = {})\n      data, _status_code, _headers = search_customers_with_http_info(body, opts)\n      return data\n    end", "label": 4}
{"code": "public static <E> double max(Counter<E> c) {\r\n    double max = Double.NEGATIVE_INFINITY;\r\n    for (double v : c.values()) {\r\n      max = Math.max(max, v);\r\n    }\r\n    return max;\r\n  }", "label": 0}
{"code": "func (i *Handle) UpdateDestination(s *Service, d *Destination) error {\n\treturn i.doCmd(s, d, ipvsCmdSetDest)\n}", "label": 5}
{"code": "func InsecureSkipHostKeyChecking(host string, remote net.Addr, key ssh.PublicKey) error {\n\treturn nil\n}", "label": 5}
{"code": "public Collection getAllObjects(Class target)\r\n    {\r\n        PersistenceBroker broker = getBroker();\r\n        Collection result;\r\n        try\r\n        {\r\n            Query q = new QueryByCriteria(target);\r\n            result = broker.getCollectionByQuery(q);\r\n        }\r\n        finally\r\n        {\r\n            if (broker != null) broker.close();\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "function objectTypeRelatedTo(source, originalSource, target, reportErrors) {\n                if (overflow) {\n                    return 0 /* False */;\n                }\n                var id = relation !== identityRelation || source.id < target.id ? source.id + \",\" + target.id : target.id + \",\" + source.id;\n                var related = relation[id];\n                if (related !== undefined) {\n                    if (reportErrors && related === 2 /* Failed */) {\n                        // We are elaborating errors and the cached result is an unreported failure. Record the result as a reported\n                        // failure and continue computing the relation such that errors get reported.\n                        relation[id] = 3 /* FailedAndReported */;\n                    }\n                    else {\n                        return related === 1 /* Succeeded */ ? -1 /* True */ : 0 /* False */;\n                    }\n                }\n                if (depth > 0) {\n                    for (var i = 0; i < depth; i++) {\n                        // If source and target are already being compared, consider them related with assumptions\n                        if (maybeStack[i][id]) {\n                            return 1 /* Maybe */;\n                        }\n                    }\n                    if (depth === 100) {\n                        overflow = true;\n                        return 0 /* False */;\n                    }\n                }\n                else {\n                    sourceStack = [];\n                    targetStack = [];\n                    maybeStack = [];\n                    expandingFlags = 0;\n                }\n                sourceStack[depth] = source;\n                targetStack[depth] = target;\n                maybeStack[depth] = ts.createMap();\n                maybeStack[depth][id] = 1 /* Succeeded */;\n                depth++;\n                var saveExpandingFlags = expandingFlags;\n                if (!(expandingFlags & 1) && isDeeplyNestedGeneric(source, sourceStack, depth))\n                    expandingFlags |= 1;\n                if (!(expandingFlags & 2) && isDeeplyNestedGeneric(target, targetStack, depth))\n                    expandingFlags |= 2;\n                var result;\n                if (expandingFlags === 3) {\n                    result = 1 /* Maybe */;\n                }\n                else {\n                    result = propertiesRelatedTo(source, target, reportErrors);\n                    if (result) {\n                        result &= signaturesRelatedTo(source, target, 0 /* Call */, reportErrors);\n                        if (result) {\n                            result &= signaturesRelatedTo(source, target, 1 /* Construct */, reportErrors);\n                            if (result) {\n                                result &= indexTypesRelatedTo(source, originalSource, target, 0 /* String */, reportErrors);\n                                if (result) {\n                                    result &= indexTypesRelatedTo(source, originalSource, target, 1 /* Number */, reportErrors);\n                                }\n                            }\n                        }\n                    }\n                }\n                expandingFlags = saveExpandingFlags;\n                depth--;\n                if (result) {\n                    var maybeCache = maybeStack[depth];\n                    // If result is definitely true, copy assumptions to global cache, else copy to next level up\n                    var destinationCache = (result === -1 /* True */ || depth === 0) ? relation : maybeStack[depth - 1];\n                    ts.copyProperties(maybeCache, destinationCache);\n                }\n                else {\n                    // A false result goes straight into global cache (when something is false under assumptions it\n                    // will also be false without assumptions)\n                    relation[id] = reportErrors ? 3 /* FailedAndReported */ : 2 /* Failed */;\n                }\n                return result;\n            }", "label": 3}
{"code": "function ProblemLogger(options) {\n\toptions = options || {};\n\tConsoleLogger.call(this);\n\tconst tmpdir = require('os').tmpdir();\n\tthis.filename = path.join(tmpdir, 'logger-' + (+new Date()) + '.log');\n\tthis.name = options.problemLogName || ((options.name || 'problem') + '.log');\n\tthis.stream = fs.createWriteStream(this.filename);\n\tthis.write({ level: bunyan.TRACE, msg: util.format('log file opened') });\n\tstreams.push(this);\n}", "label": 3}
{"code": "public static function productSetName($project, $location, $productSet)\n    {\n        return self::getProductSetNameTemplate()->render([\n            'project' => $project,\n            'location' => $location,\n            'product_set' => $productSet,\n        ]);\n    }", "label": 2}
{"code": "def instance(instance_group_name, index_or_id, options = { deployment_name: Deployments::DEFAULT_DEPLOYMENT_NAME })\n      find_instance(instances(options), instance_group_name, index_or_id)\n    end", "label": 4}
{"code": "private void tokenStatsAdd(int min, int max) {\n    tokenStatsNumber++;\n    if (tokenStatsMinPos == null) {\n      tokenStatsMinPos = min;\n    } else {\n      tokenStatsMinPos = Math.min(tokenStatsMinPos, min);\n    }\n    if (tokenStatsMaxPos == null) {\n      tokenStatsMaxPos = max;\n    } else {\n      tokenStatsMaxPos = Math.max(tokenStatsMaxPos, max);\n    }\n  }", "label": 0}
{"code": "public static base_responses add(nitro_service client, vpnurl resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tvpnurl addresources[] = new vpnurl[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new vpnurl();\n\t\t\t\taddresources[i].urlname = resources[i].urlname;\n\t\t\t\taddresources[i].linkname = resources[i].linkname;\n\t\t\t\taddresources[i].actualurl = resources[i].actualurl;\n\t\t\t\taddresources[i].clientlessaccess = resources[i].clientlessaccess;\n\t\t\t\taddresources[i].comment = resources[i].comment;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def disconnect(remote_app):\n    \"\"\"Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in current_oauthclient.disconnect_handlers:\n        return abort(404)\n\n    ret = current_oauthclient.disconnect_handlers[remote_app]()\n    db.session.commit()\n    return ret", "label": 1}
{"code": "async function getPreferredMcpLanguages(accessToken) {\n    const mcpSettings = await getMcpSettings(accessToken);\n    const twoLetterArray = mcpSettings.language || [];\n\n    return twoLetterArray.map((twoLetter) => {\n        let language = countryLanguage.getLanguages().find((a) => a.iso639_1 === twoLetter);\n        return {\n            lang: twoLetter,\n            iso639_1: language ? language.iso639_1 : twoLetter,\n            iso639_2: language ? language.iso639_2 : undefined,\n            iso639_3: language ? language.iso639_3 : undefined,\n        };\n    });\n}", "label": 3}
{"code": "function(data) {\n\n    var errors = [];\n\n    // data.Errors is populated by sails-hook-validations and data.invalidAttributes is the default\n    var targetAttributes = (data.Errors !== undefined)  ? data.Errors : data.invalidAttributes;\n\n    for (var attributeName in targetAttributes) {\n\n      var attributes = targetAttributes[attributeName];\n\n      for (var index in attributes) {\n\n        var error = attributes[index];\n\n        errors.push({\n          detail: error.message,\n          source: {\n            pointer: \"data/attributes/\" + this._convertCase(attributeName, this.getAttributesSerializedCaseSetting())\n          }\n        });\n      }\n    }\n\n    return errors;\n  }", "label": 3}
{"code": "def schema_event_items():\n        \"\"\"Schema for event items.\"\"\"\n        return {\n            'timestamp': And(int, lambda n: n > 0),\n            Optional('information', default={}): {\n                Optional(Regex(r'([a-z][_a-z]*)')): object\n            }\n        }", "label": 1}
{"code": "function() {\n      var updateEventsIsArray = _.isArray(this.updateEvents);\n      var updateEventsIsSingleValue = !updateEventsIsArray && (_.isObject(this.updateEvents) || _.isString(this.updateEvents));\n      var updateEventsIsUndefined = _.isUndefined(this.updateEvents);\n      var updateEventsIsValidType = updateEventsIsArray || updateEventsIsSingleValue || updateEventsIsUndefined;\n\n      if (updateEventsIsSingleValue) {\n        this.updateEvents = [this.updateEvents];\n      }\n\n      if (!updateEventsIsValidType) {\n        throw new Error('Update events are not an array, string or object.  Please see parameters for examples of how to define updateEvents.  Configured UpdateEvents: ', this.updateEvents);\n      }\n\n      // Remove any random falsey values (mostly to get rid of undefined events).\n      this.updateEvents = _.compact(this.updateEvents);\n      _.each(this.updateEvents, this.__validUpdateEvent);\n    }", "label": 3}
{"code": "function renderSourceCode(sourceCode, messages, parentIndex) {\n\treturn codeWrapperTemplate({\n\t\tparentIndex,\n\t\tsourceCode: _.map(sourceCode.split('\\n'), function(code, lineNumber) {\n\t\t\tconst lineMessages = _.filter(messages, {line: lineNumber + 1}),\n\t\t\t\tseverity = _.get(lineMessages[0], 'severity') || 0;\n\n\t\t\tlet template = '';\n\n\t\t\t// checks if there is a problem on the current line and renders it\n\t\t\tif (!_.isEmpty(lineMessages)) {\n\t\t\t\ttemplate += _.map(lineMessages, renderIssue).join('');\n\t\t\t}\n\n\t\t\t// adds a line of code to the template (with line number and severity color if appropriate\n\t\t\ttemplate += codeTemplate({\n\t\t\t\tlineNumber: lineNumber + 1,\n\t\t\t\tcode,\n\t\t\t\tseverity: severityString(severity)\n\t\t\t});\n\n\t\t\treturn template;\n\t\t}).join('\\n')\n\t});\n}", "label": 3}
{"code": "def sub!(pat, rep)\n      each_with_index { |fn, i| self[i] = fn.sub(pat, rep) }\n      self\n    end", "label": 4}
{"code": "def proj(vec, vec_onto):\n    \"\"\" Vector projection.\n\n    Calculated as:\n\n    .. math::\n\n         \\\\mathsf{vec\\\\_onto} * \\\\frac{\\\\mathsf{vec}\\\\cdot\\\\mathsf{vec\\\\_onto}}\n         {\\\\mathsf{vec\\\\_onto}\\\\cdot\\\\mathsf{vec\\\\_onto}}\n\n    Parameters\n    ----------\n    vec\n        length-R |npfloat_| --\n        Vector to project\n\n    vec_onto\n        length-R |npfloat_| --\n        Vector onto which `vec` is to be projected\n\n    Returns\n    -------\n    proj_vec\n        length-R |npfloat_| --\n        Projection of `vec` onto `vec_onto`\n\n    \"\"\"\n\n    # Imports\n    import numpy as np\n\n    # Ensure vectors\n    if not len(vec.shape) == 1:\n        raise ValueError(\"'vec' is not a vector\")\n    ## end if\n    if not len(vec_onto.shape) == 1:\n        raise ValueError(\"'vec_onto' is not a vector\")\n    ## end if\n    if not vec.shape[0] == vec_onto.shape[0]:\n        raise ValueError(\"Shape mismatch between vectors\")\n    ## end if\n\n    # Calculate the projection and return\n    proj_vec = np.float_(np.asscalar(np.dot(vec.T, vec_onto))) / \\\n                np.float_(np.asscalar(np.dot(vec_onto.T, vec_onto))) * vec_onto\n    return proj_vec", "label": 1}
{"code": "public static server_binding get(nitro_service service, String name) throws Exception{\n\t\tserver_binding obj = new server_binding();\n\t\tobj.set_name(name);\n\t\tserver_binding response = (server_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static base_response delete(nitro_service client, String ipv6address) throws Exception {\n\t\tnsip6 deleteresource = new nsip6();\n\t\tdeleteresource.ipv6address = ipv6address;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "function() {\n      _.each(this.modelsToRender(), function(model) {\n        var itemView = this.getItemViewFromModel(model);\n        if (itemView) {\n          itemView.delegateEvents();\n          if (!itemView.__attachedCallbackInvoked && itemView.isAttached()) {\n            itemView.__invokeAttached();\n          }\n          itemView.activate();\n        } else {\n          // Shouldn't get here. Item view is missing...\n        }\n      }, this);\n    }", "label": 3}
{"code": "public DbLicense resolve(final String licenseId) {\n\n        for (final Entry<String, DbLicense> regexp : licensesRegexp.entrySet()) {\n            try {\n                if (licenseId.matches(regexp.getKey())) {\n                    return regexp.getValue();\n                }\n            } catch (PatternSyntaxException e) {\n                LOG.error(\"Wrong pattern for the following license \" + regexp.getValue().getName(), e);\n                continue;\n            }\n        }\n\n        if(LOG.isWarnEnabled()) {\n            LOG.warn(String.format(\"No matching pattern for license %s\", licenseId));\n        }\n        return null;\n    }", "label": 0}
{"code": "public static base_responses delete(nitro_service client, String fipskeyname[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (fipskeyname != null && fipskeyname.length > 0) {\n\t\t\tsslfipskey deleteresources[] = new sslfipskey[fipskeyname.length];\n\t\t\tfor (int i=0;i<fipskeyname.length;i++){\n\t\t\t\tdeleteresources[i] = new sslfipskey();\n\t\t\t\tdeleteresources[i].fipskeyname = fipskeyname[i];\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function accountOrIdStep(obj, name) {\n    return function (accountOrId) {\n        if (typeof accountOrId === 'string') {\n            // W3C obfuscated id\n            return idStep(obj, name)(accountOrId);\n        } else {\n            // accountOrId expected to be {type: 'github', id: 123456}\n            var ctx = new obj();\n            ctx.steps.push(name);\n            ctx.steps.push(\"connected\");\n            ctx.steps.push(accountOrId.type);\n            ctx.steps.push(accountOrId.id);\n            return ctx;\n        }\n    };\n}", "label": 3}
{"code": "func (t *Torrent) updatePiecePriorities(begin, end pieceIndex) {\n\tfor i := begin; i < end; i++ {\n\t\tt.updatePiecePriority(i)\n\t}\n}", "label": 5}
{"code": "def at_version(version)\n      return self if log_data.version == version\n\n      log_entry = log_data.find_by_version(version)\n      return nil unless log_entry\n\n      build_dup(log_entry)\n    end", "label": 4}
{"code": "private function readOptions(array $options = [])\n    {\n        $options += [\n            'readConsistency' => null,\n            'transaction' => null\n        ];\n\n        $readOptions = array_filter([\n            'readConsistency' => $options['readConsistency'],\n            'transaction' => $options['transaction']\n        ]);\n\n        return array_filter([\n            'readOptions' => $readOptions\n        ]);\n    }", "label": 2}
{"code": "def prune_to_ingroup(self):\n        \"\"\"Remove nodes and edges from tree if they are not the ingroup or a descendant of it.\"\"\"\n        # Prune to just the ingroup\n        if not self._ingroup_node_id:\n            _LOG.debug('No ingroup node was specified.')\n            self._ingroup_node_id = self.root_node_id\n        elif self._ingroup_node_id != self.root_node_id:\n            self._do_prune_to_ingroup()\n            self.root_node_id = self._ingroup_node_id\n        else:\n            _LOG.debug('Ingroup node is root.')\n        return self.root_node_id", "label": 1}
{"code": "public function objectToRequest(EntityInterface $entity)\n    {\n        $data = $entity->get();\n\n        $properties = [];\n        foreach ($data as $key => $value) {\n            $exclude = in_array($key, $entity->excludedProperties());\n            $meaning = (isset($entity->meanings()[$key]))\n                ? $entity->meanings()[$key]\n                : null;\n\n            $properties[$key] = $this->valueObject(\n                $value,\n                $exclude,\n                $meaning\n            );\n        }\n\n        $key = $entity->key()\n            ? $entity->key()->keyObject()\n            : null;\n\n        return array_filter([\n            'key' => $key,\n            'properties' => $properties\n        ]);\n    }", "label": 2}
{"code": "def find_resource(obj)\n      resources.detect do |r|\n        r.resource_name.to_s == obj.to_s\n      end || resources.detect do |r|\n        r.resource_class.to_s == obj.to_s\n      end ||\n      if obj.respond_to? :base_class\n        resources.detect { |r| r.resource_class.to_s == obj.base_class.to_s }\n      end\n    end", "label": 4}
{"code": "public static systembackup get(nitro_service service, String filename) throws Exception{\n\t\tsystembackup obj = new systembackup();\n\t\tobj.set_filename(filename);\n\t\tsystembackup response = (systembackup) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (s *SubnetKey) String() string {\n\tk := fmt.Sprintf(\"%s/%s\", s.AddressSpace, s.Subnet)\n\tif s.ChildSubnet != \"\" {\n\t\tk = fmt.Sprintf(\"%s/%s\", k, s.ChildSubnet)\n\t}\n\treturn k\n}", "label": 5}
{"code": "function selectRenderingMode(event) {\n  if (!audioReady)\n    return;\n\n  switch (document.getElementById('renderingMode').value) {\n    case 'toa':\n    {\n      noneGain.gain.value = 0;\n      pannerGain.gain.value = 0;\n      foaGain.gain.value = 0;\n      toaGain.gain.value = 1;\n    }\n    break;\n    case 'foa':\n    {\n      noneGain.gain.value = 0;\n      pannerGain.gain.value = 0;\n      foaGain.gain.value = 1;\n      toaGain.gain.value = 0;\n    }\n    break;\n    case 'panner-node':\n    {\n      noneGain.gain.value = 0;\n      pannerGain.gain.value = 1;\n      foaGain.gain.value = 0;\n      toaGain.gain.value = 0;\n    }\n    break;\n    case 'none':\n    default:\n    {\n      noneGain.gain.value = 1;\n      pannerGain.gain.value = 0;\n      foaGain.gain.value = 0;\n      toaGain.gain.value = 0;\n    }\n    break;\n  }\n}", "label": 3}
{"code": "public static String termValue(String term) {\n    int i = term.indexOf(MtasToken.DELIMITER);\n    String value = null;\n    if (i >= 0) {\n      value = term.substring((i + MtasToken.DELIMITER.length()));\n      value = (value.length() > 0) ? value : null;\n    }\n    return (value == null) ? null : value.replace(\"\\u0000\", \"\");\n  }", "label": 0}
{"code": "func (nDB *NetworkDB) mRandomNodes(m int, nodes []string) []string {\n\tn := len(nodes)\n\tmNodes := make([]string, 0, m)\nOUTER:\n\t// Probe up to 3*n times, with large n this is not necessary\n\t// since k << n, but with small n we want search to be\n\t// exhaustive\n\tfor i := 0; i < 3*n && len(mNodes) < m; i++ {\n\t\t// Get random node\n\t\tidx := randomOffset(n)\n\t\tnode := nodes[idx]\n\n\t\tif node == nDB.config.NodeID {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if we have this node already\n\t\tfor j := 0; j < len(mNodes); j++ {\n\t\t\tif node == mNodes[j] {\n\t\t\t\tcontinue OUTER\n\t\t\t}\n\t\t}\n\n\t\t// Append the node\n\t\tmNodes = append(mNodes, node)\n\t}\n\n\treturn mNodes\n}", "label": 5}
{"code": "function bundle() {\n  return new Promise((resolve, reject) => {\n    webpack(webpackConfig).run((err, stats) => {\n      if (err) {\n        return reject(err);\n      }\n\n      console.log(stats.toString(webpackConfig[0].stats));\n      return resolve();\n    });\n  });\n}", "label": 3}
{"code": "function isKnownProperty(type, name) {\n                if (type.flags & 2588672 /* ObjectType */) {\n                    var resolved = resolveStructuredTypeMembers(type);\n                    if ((relation === assignableRelation || relation === comparableRelation) && (type === globalObjectType || isEmptyObjectType(resolved)) ||\n                        resolved.stringIndexInfo ||\n                        (resolved.numberIndexInfo && isNumericLiteralName(name)) ||\n                        getPropertyOfType(type, name)) {\n                        return true;\n                    }\n                }\n                else if (type.flags & 1572864 /* UnionOrIntersection */) {\n                    for (var _i = 0, _a = type.types; _i < _a.length; _i++) {\n                        var t = _a[_i];\n                        if (isKnownProperty(t, name)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }", "label": 3}
{"code": "public function authorize(Request $request): Response\n    {\n        return $this->auth->authorize($request)\n            ? $this->broadcastManager->authorized($request)\n            : $this->broadcastManager->unauthorized($request);\n    }", "label": 2}
{"code": "func (s *Store) GetImageManifestJSON(key string) ([]byte, error) {\n\tkey, err := s.ResolveKey(key)\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"error resolving image ID\"), err)\n\t}\n\tkeyLock, err := lock.SharedKeyLock(s.imageLockDir, key)\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"error locking image\"), err)\n\t}\n\tdefer keyLock.Close()\n\n\timj, err := s.stores[imageManifestType].Read(key)\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"error retrieving image manifest\"), err)\n\t}\n\treturn imj, nil\n}", "label": 5}
{"code": "def process_input(self, question):\n        \"\"\"\n        takes a question and returns the best answer based on known skills\n        \"\"\"\n        ans = ''\n        if self.status == 'EXIT':\n            print('bye')\n            sys.exit()\n        \n        if '?' in question:\n            ans = self.info.find_answer(question)\n        elif question.startswith(':LIST'):\n            ans = 'List of Raw Input\\n'\n            for i in self.info.raw_input:\n                ans += str(i) + '\\n'\n            \n            \n        else:\n            #ans = 'I dont'' know'\n            ans = 'Adding info..'\n            self.info.raw_input.append(question)\n        self.lg.record_process('aggie.py', 'Question > ' +  question)\n        self.lg.record_process('aggie.py', 'Answer > ' + ans)\n        return ans", "label": 1}
{"code": "func (c *Client) DeleteSAMLConnector(connectorID string) error {\n\tif connectorID == \"\" {\n\t\treturn trace.BadParameter(\"missing connector id\")\n\t}\n\t_, err := c.Delete(c.Endpoint(\"saml\", \"connectors\", connectorID))\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "function (str, options, cb) {\n    var self = this;\n    if (self.cache(options)) return cb(null, self.cache(options));\n    if (options.filename) {\n      options.paths = options.paths || [dirname(options.filename)];\n    }\n\n    // If this.cache is enabled, compress by default\n    if (options.compress !== true && options.compress !== false) {\n      options.compress = options.cache || false;\n    }\n\n    var initial = this.engine(str);\n\n    // Special handling for stylus js api functions\n    // given { define: { foo: 'bar', baz: 'quux' } }\n    // runs initial.define('foo', 'bar').define('baz', 'quux')\n\n    var allowed = ['set', 'include', 'import', 'define', 'use'];\n    var special = {}\n    var normal = clone(options);\n    for (var v in options) {\n      if (allowed.indexOf(v) > -1) { special[v] = options[v]; delete normal[v]; }\n    }\n\n    // special options through their function names\n    for (var k in special) {\n      for (var v in special[k]) { initial[k](v, special[k][v]); }\n    }\n\n    // normal options through set()\n    for (var k in normal) {\n      initial.set(k, normal[k]);\n    }\n\n    initial.render(function (err, res) {\n      if (err) return cb(err);\n      self.cache(options, res);\n      cb(null, res);\n    });\n  }", "label": 3}
{"code": "function (key, timeInterval, limit) {\n        //Validate rate limiter settings\n        if (!_.isNumber(timeInterval) || parseInt(timeInterval) <= 0 || !_.isNumber(limit) || parseInt(limit) <= 0) {\n            return Q.reject();\n        }\n        var cacheKey = Encryption.md5(\"MiaJSRateLimit\" + key + _calculateCurrentTimeInterval(timeInterval));\n        return _validateRateLimit(cacheKey, timeInterval, limit).then(function (value) {\n            return Q({\n                limit: limit,\n                remaining: limit - value,\n                timeInterval: timeInterval,\n                timeTillReset: _getTimeLeftTillReset(timeInterval)\n            });\n        });\n    }", "label": 3}
{"code": "def build_node\n      Chef::Log.trace(\"Building node object for #{@node_name}\")\n      @node = Chef::Node.find_or_create(node_name)\n      ohai_data = @ohai.data.merge(@node.automatic_attrs)\n      @node.consume_external_attrs(ohai_data, nil)\n      @run_list_expansion = @node.expand!(\"server\")\n      @expanded_run_list_with_versions = @run_list_expansion.recipes.with_version_constraints_strings\n      Chef::Log.info(\"Run List is [#{@node.run_list}]\")\n      Chef::Log.info(\"Run List expands to [#{@expanded_run_list_with_versions.join(', ')}]\")\n      @node\n    end", "label": 4}
{"code": "function toBemjson(tree, options) {\n    const transform = transformFactory(tree, options);\n\n    return traverse(transform, tree);\n}", "label": 3}
{"code": "public static dnssrvrec[] get(nitro_service service) throws Exception{\n\t\tdnssrvrec obj = new dnssrvrec();\n\t\tdnssrvrec[] response = (dnssrvrec[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def managed_access\n      return I18n.t('hyrax.dashboard.my.collection_list.managed_access.manage') if current_ability.can?(:edit, solr_document)\n      return I18n.t('hyrax.dashboard.my.collection_list.managed_access.deposit') if current_ability.can?(:deposit, solr_document)\n      return I18n.t('hyrax.dashboard.my.collection_list.managed_access.view') if current_ability.can?(:read, solr_document)\n      ''\n    end", "label": 4}
{"code": "public function setContentLocations($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\ContentLocation::class);\n        $this->content_locations = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def translation_generator(\n        variant_sequences,\n        reference_contexts,\n        min_transcript_prefix_length,\n        max_transcript_mismatches,\n        include_mismatches_after_variant,\n        protein_sequence_length=None):\n    \"\"\"\n    Given all detected VariantSequence objects for a particular variant\n    and all the ReferenceContext objects for that locus, translate\n    multiple protein sequences, up to the number specified by the argument\n    max_protein_sequences_per_variant.\n\n    Parameters\n    ----------\n    variant_sequences : list of VariantSequence objects\n        Variant sequences overlapping a single original variant\n\n    reference_contexts : list of ReferenceContext objects\n        Reference sequence contexts from the same variant as the variant_sequences\n\n    min_transcript_prefix_length : int\n        Minimum number of nucleotides before the variant to test whether\n        our variant sequence can use the reading frame from a reference\n        transcript.\n\n    max_transcript_mismatches : int\n        Maximum number of mismatches between coding sequence before variant\n        and reference transcript we're considering for determing the reading\n        frame.\n\n    include_mismatches_after_variant : bool\n        If true, mismatches occurring after the variant locus will also count\n        toward max_transcript_mismatches filtering.\n\n    protein_sequence_length : int, optional\n        Truncate protein to be at most this long.\n\n    Yields a sequence of Translation objects.\n    \"\"\"\n    for reference_context in reference_contexts:\n        for variant_sequence in variant_sequences:\n            translation = Translation.from_variant_sequence_and_reference_context(\n                variant_sequence=variant_sequence,\n                reference_context=reference_context,\n                min_transcript_prefix_length=min_transcript_prefix_length,\n                max_transcript_mismatches=max_transcript_mismatches,\n                include_mismatches_after_variant=include_mismatches_after_variant,\n                protein_sequence_length=protein_sequence_length)\n            if translation is not None:\n                yield translation", "label": 1}
{"code": "func (m *MockIndex) Summary(arg0 *bytes.Buffer, arg1 io.Writer) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Summary\", arg0, arg1)\n}", "label": 5}
{"code": "function (prop, setter) {\n                  // jQuery 1.8 style\n                  if ($.Tween) {\n                      $.Tween.propHooks[prop] = {\n                          set: setter\n                      };\n                      // pre 1.8\n                  } else {\n                      $.fx.step[prop] = setter;\n                  }\n              }", "label": 3}
{"code": "protected TemporaryBrokerWrapper getBroker() throws PBFactoryException\r\n    {\r\n        PersistenceBrokerInternal broker;\r\n        boolean needsClose = false;\r\n\r\n        if (getBrokerKey() == null)\r\n        {\r\n            /*\r\n            arminw:\r\n            if no PBKey is set we throw an exception, because we don't\r\n            know which PB (connection) should be used.\r\n            */\r\n            throw new OJBRuntimeException(\"Can't find associated PBKey. Need PBKey to obtain a valid\" +\r\n                                          \"PersistenceBroker instance from intern resources.\");\r\n        }\r\n        // first try to use the current threaded broker to avoid blocking\r\n        broker = PersistenceBrokerThreadMapping.currentPersistenceBroker(getBrokerKey());\r\n        // current broker not found, create a intern new one\r\n        if ((broker == null) || broker.isClosed())\r\n        {\r\n            broker = (PersistenceBrokerInternal) PersistenceBrokerFactory.createPersistenceBroker(getBrokerKey());\r\n            /** Specifies whether we obtained a fresh broker which we have to close after we used it */\r\n            needsClose = true;\r\n        }\r\n        return new TemporaryBrokerWrapper(broker, needsClose);\r\n    }", "label": 0}
{"code": "public static base_response unset(nitro_service client, responderpolicy resource, String[] args) throws Exception{\n\t\tresponderpolicy unsetresource = new responderpolicy();\n\t\tunsetresource.name = resource.name;\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "function generate_exports (module) {\n  // # 85\n  // Before module factory being invoked, mark the module as `loaded`\n  // so we will not execute the factory function again.\n\n  // `mod.loaded` indicates that a module has already been `require()`d\n  // When there are cyclic dependencies, neuron will not fail.\n  module.loaded = true;\n\n  // During the execution of factory,\n  // the reference of `module.exports` might be changed.\n  // But we still set the `module.exports` as `{}`,\n  // because the module might be `require()`d during the execution of factory\n  // if cyclic dependency occurs.\n  var exports = module.exports = {};\n\n  // TODO:\n  // Calculate `filename` ahead of time\n  var __filename\n    // = module.filename\n    = NEURON_CONF.resolve(module.id);\n  var __dirname = dirname(__filename);\n\n  // to keep the object mod away from the executing context of factory,\n  // use `factory` instead `mod.factory`,\n  // preventing user from fetching runtime data by 'this'\n  var factory = module.factory;\n  factory(create_require(module), exports, module, __filename, __dirname);\n  return module.exports;\n}", "label": 3}
{"code": "function (groupId, operation, req, res) {\n        const validateSections = function (group) {\n            let valid = true;\n            const sections = server.state.get('sections');\n            group.forEach(function (e) {\n                if (Utils.isNullOrEmpty(sections[e])) {\n                    valid = false;\n                }\n            });\n            return valid;\n        };\n        if (!req.body || !req.body.length || !validateSections(req.body)) {\n            log.error('Invalid Group', 'request:', JSON.stringify(req.body));\n            Utils.sendMessage(res, HttpStatus.BAD_REQUEST, JSON.stringify({ error: 'invalid group' }));\n        } else {\n            server.state.set('groups[' + groupId + ']', req.body.slice());\n            log.info('Successfully ' + operation + 'd group:', groupId);\n            Utils.sendMessage(res, HttpStatus.OK, JSON.stringify({ id: parseInt(groupId, 10) }));\n        }\n    }", "label": 3}
{"code": "function (searchElement) {\n                var result = -1;\n                _gpfArrayEveryOwn(this, function (value, index) {\n                    if (value === searchElement) {\n                        result = index;\n                        return false;\n                    }\n                    return true;\n                }, _gpfArrayGetFromIndex(arguments));\n                return result;\n            }", "label": 3}
{"code": "public function fromFile($filename)\n    {\n        if (function_exists('opcache_get_status') && function_exists('opcache_get_configuration')) {\n            if (empty($GLOBALS['openapi_opcache_warning'])) {\n                $GLOBALS['openapi_opcache_warning'] = true;\n                $status = opcache_get_status();\n                $config = opcache_get_configuration();\n                if ($status['opcache_enabled'] && $config['directives']['opcache.save_comments'] == false) {\n                    Logger::warning(\"php.ini \\\"opcache.save_comments = 0\\\" interferes with extracting annotations.\\n[LINK] http://php.net/manual/en/opcache.configuration.php#ini.opcache.save-comments\");\n                }\n            }\n        }\n        $tokens = token_get_all(file_get_contents($filename));\n\n        return $this->fromTokens($tokens, new Context(['filename' => $filename]));\n    }", "label": 2}
{"code": "public void promoteModule(final String name, final String version, final String user, final String password) throws GrapesCommunicationException, AuthenticationException{\n        final Client client = getClient(user, password);\n        final WebResource resource = client.resource(serverURL).path(RequestUtils.promoteModulePath(name, version));\n        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class);\n\n        client.destroy();\n        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){\n            final String message = String.format(FAILED_TO_GET_MODULE, \"promote module\", name, version);\n            if(LOG.isErrorEnabled()) {\n                LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, message, response.getStatus()));\n            }\n            throw new GrapesCommunicationException(message, response.getStatus());\n        }\n    }", "label": 0}
{"code": "func (s *PresenceService) DeleteTrustedCluster(name string) error {\n\tif name == \"\" {\n\t\treturn trace.BadParameter(\"missing trusted cluster name\")\n\t}\n\terr := s.Delete(context.TODO(), backend.Key(trustedClustersPrefix, name))\n\tif err != nil {\n\t\tif trace.IsNotFound(err) {\n\t\t\treturn trace.NotFound(\"trusted cluster %q is not found\", name)\n\t\t}\n\t}\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "function ScalarMultiple(bytes, discrim) {\n\tvar order = ec.curve.n;\n\tfor (var i = 0; i <= 0xFFFFFFFF; i++) {\n\t\t// We hash the bytes to find a 256 bit number, looping until we are sure it\n\t\t// is less than the order of the curve.\n\t\tvar hasher = new Sha512().add(bytes);\n\t\t// If the optional discriminator index was passed in, update the hash.\n\t\tif (discrim !== undefined) {\n\t\t\thasher.addU32(discrim);\n\t\t}\n\t\thasher.addU32(i);\n\t\tvar key = hasher.first256BN();\n\t\t/* istanbul ignore next */\n\t\tif (key.cmpn(0) > 0 && key.cmp(order) < 0) {\n\t\t\treturn key;\n\t\t}\n\t}\n\n\t/* istanbul ignore next */\n\tthrow new Error('impossible space search)');\n}", "label": 3}
{"code": "def guess(span, mode = :middle)\n      return span if not mode\n      return span.begin + span.width / 2 if span.width > 1 and (mode == true or mode == :middle)\n      return span.end if mode == :end\n      span.begin\n    end", "label": 4}
{"code": "function returnFile(cb) {\n\t\t\tfs.readFile(fileToLoad, function (err, fileBuf) {\n\t\t\t\tif (err || ! fileBuf) {\n\t\t\t\t\tcreateFile(function (err) {\n\t\t\t\t\t\tif (err) return cb(err);\n\t\t\t\t\t\treturnFile(cb);\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcb(null, fileBuf, fileToLoad);\n\t\t\t});\n\t\t}", "label": 3}
{"code": "func (info *HostCertificateInfo) Write(w io.Writer) error {\n\ttw := tabwriter.NewWriter(w, 2, 0, 2, ' ', 0)\n\n\ts := func(val string) string {\n\t\tif val != \"\" {\n\t\t\treturn val\n\t\t}\n\t\treturn \"<Not Part Of Certificate>\"\n\t}\n\n\tss := func(val []string) string {\n\t\treturn s(strings.Join(val, \",\"))\n\t}\n\n\tname := func(n *pkix.Name) {\n\t\tfmt.Fprintf(tw, \"  Common Name (CN):\\t%s\\n\", s(n.CommonName))\n\t\tfmt.Fprintf(tw, \"  Organization (O):\\t%s\\n\", ss(n.Organization))\n\t\tfmt.Fprintf(tw, \"  Organizational Unit (OU):\\t%s\\n\", ss(n.OrganizationalUnit))\n\t}\n\n\tstatus := info.Status\n\tif info.Err != nil {\n\t\tstatus = fmt.Sprintf(\"ERROR %s\", info.Err)\n\t}\n\tfmt.Fprintf(tw, \"Certificate Status:\\t%s\\n\", status)\n\n\tfmt.Fprintln(tw, \"Issued To:\\t\")\n\tname(info.SubjectName())\n\n\tfmt.Fprintln(tw, \"Issued By:\\t\")\n\tname(info.IssuerName())\n\n\tfmt.Fprintln(tw, \"Validity Period:\\t\")\n\tfmt.Fprintf(tw, \"  Issued On:\\t%s\\n\", info.NotBefore)\n\tfmt.Fprintf(tw, \"  Expires On:\\t%s\\n\", info.NotAfter)\n\n\tif info.ThumbprintSHA1 != \"\" {\n\t\tfmt.Fprintln(tw, \"Thumbprints:\\t\")\n\t\tif info.ThumbprintSHA256 != \"\" {\n\t\t\tfmt.Fprintf(tw, \"  SHA-256 Thumbprint:\\t%s\\n\", info.ThumbprintSHA256)\n\t\t}\n\t\tfmt.Fprintf(tw, \"  SHA-1 Thumbprint:\\t%s\\n\", info.ThumbprintSHA1)\n\t}\n\n\treturn tw.Flush()\n}", "label": 5}
{"code": "func UserMessageFromError(err error) string {\n\t// untrusted cert?\n\tswitch innerError := trace.Unwrap(err).(type) {\n\tcase x509.HostnameError:\n\t\treturn fmt.Sprintf(\"Cannot establish https connection to %s:\\n%s\\n%s\\n\",\n\t\t\tinnerError.Host,\n\t\t\tinnerError.Error(),\n\t\t\t\"try a different hostname for --proxy or specify --insecure flag if you know what you're doing.\")\n\tcase x509.UnknownAuthorityError:\n\t\treturn `WARNING:\n\n  The proxy you are connecting to has presented a certificate signed by a\n  unknown authority. This is most likely due to either being presented\n  with a self-signed certificate or the certificate was truly signed by an\n  authority not known to the client.\n\n  If you know the certificate is self-signed and would like to ignore this\n  error use the --insecure flag.\n\n  If you have your own certificate authority that you would like to use to\n  validate the certificate chain presented by the proxy, set the\n  SSL_CERT_FILE and SSL_CERT_DIR environment variables respectively and try\n  again.\n\n  If you think something malicious may be occurring, contact your Teleport\n  system administrator to resolve this issue.\n`\n\tcase x509.CertificateInvalidError:\n\t\treturn fmt.Sprintf(`WARNING:\n\n  The certificate presented by the proxy is invalid: %v.\n\n  Contact your Teleport system administrator to resolve this issue.`, innerError)\n\t}\n\tif log.GetLevel() == log.DebugLevel {\n\t\treturn trace.DebugReport(err)\n\t}\n\tif err != nil {\n\t\t// If the error is a trace error, check if it has a user message embedded in\n\t\t// it. If a user message is embedded in it, print the user message and the\n\t\t// original error. Otherwise return the original with a generic \"A fatal\n\t\t// error occurred\" message.\n\t\tif er, ok := err.(*trace.TraceErr); ok {\n\t\t\tif er.Message != \"\" {\n\t\t\t\treturn fmt.Sprintf(\"error: %v\", EscapeControl(er.Message))\n\t\t\t}\n\t\t}\n\t\treturn fmt.Sprintf(\"error: %v\", EscapeControl(err.Error()))\n\t}\n\treturn \"\"\n}", "label": 5}
{"code": "def parse_global_options\n      parser = options.inject(OptionParser.new) do |options, option|\n        options.on(*option[:args], &global_option_proc(option[:switches], &option[:proc]))\n      end\n\n      options = @args.dup\n      begin\n        parser.parse!(options)\n      rescue OptionParser::InvalidOption => e\n        # Remove the offending args and retry.\n        options = options.reject { |o| e.args.include?(o) }\n        retry\n      end\n    end", "label": 4}
{"code": "public static function indexName($project, $database, $collectionId, $indexId)\n    {\n        return self::getIndexNameTemplate()->render([\n            'project' => $project,\n            'database' => $database,\n            'collection_id' => $collectionId,\n            'index_id' => $indexId,\n        ]);\n    }", "label": 2}
{"code": "def fetch_rows(op_handle, orientation = :first, max_rows = 1000)\n      fetch_req = prepare_fetch_results(op_handle, orientation, max_rows)\n      fetch_results = @client.FetchResults(fetch_req)\n      raise_error_if_failed!(fetch_results)\n      rows = fetch_results.results.rows\n      TCLIResultSet.new(rows, TCLISchemaDefinition.new(get_schema_for(op_handle), rows.first))\n    end", "label": 4}
{"code": "def facets(self):\n        \"\"\"Provides facets support. REQUIRES VALID HTTPS!\"\"\"\n        self.verify_integrity()\n\n        if self.__facets_enabled:\n            data = json.dumps({\n                'trustedFacets' : [{\n                    'version': { 'major': 1, 'minor' : 0 },\n                    'ids': self.__facets_list\n                }]\n            }, sort_keys=True, indent=2, separators=(',', ': '))\n\n            mime = 'application/fido.trusted-apps+json'\n            resp = Response(data, mimetype=mime)\n\n            return resp, 200\n        else:\n            return jsonify({}), 404", "label": 1}
{"code": "public function getPartition($region, $service)\n    {\n        foreach ($this->partitions as $partition) {\n            if ($partition->isRegionMatch($region, $service)) {\n                return $partition;\n            }\n        }\n\n        return $this->getPartitionByName($this->defaultPartition);\n    }", "label": 2}
{"code": "public ArrayList getFields(String fieldNames) throws NoSuchFieldException\r\n    {\r\n        ArrayList          result    = new ArrayList();\r\n        FieldDescriptorDef fieldDef;\r\n        String             name;\r\n\r\n        for (CommaListIterator it = new CommaListIterator(fieldNames); it.hasNext();)\r\n        {\r\n            name = it.getNext();\r\n            fieldDef = getField(name);\r\n            if (fieldDef == null)\r\n            {\r\n                throw new NoSuchFieldException(name);\r\n            }\r\n            result.add(fieldDef);\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "protected long getUniqueLong(FieldDescriptor field) throws SequenceManagerException\r\n    {\r\n        long result;\r\n        // lookup sequence name\r\n        String sequenceName = calculateSequenceName(field);\r\n        try\r\n        {\r\n            result = buildNextSequence(field.getClassDescriptor(), sequenceName);\r\n        }\r\n        catch (Throwable e)\r\n        {\r\n            // maybe the sequence was not created\r\n            try\r\n            {\r\n                log.info(\"Create DB sequence key '\"+sequenceName+\"'\");\r\n                createSequence(field.getClassDescriptor(), sequenceName);\r\n            }\r\n            catch (Exception e1)\r\n            {\r\n                throw new SequenceManagerException(\r\n                        SystemUtils.LINE_SEPARATOR +\r\n                        \"Could not grab next id, failed with \" + SystemUtils.LINE_SEPARATOR +\r\n                        e.getMessage() + SystemUtils.LINE_SEPARATOR +\r\n                        \"Creation of new sequence failed with \" +\r\n                        SystemUtils.LINE_SEPARATOR + e1.getMessage() + SystemUtils.LINE_SEPARATOR\r\n                        , e1);\r\n            }\r\n            try\r\n            {\r\n                result = buildNextSequence(field.getClassDescriptor(), sequenceName);\r\n            }\r\n            catch (Throwable e1)\r\n            {\r\n                throw new SequenceManagerException(\"Could not grab next id, sequence seems to exist\", e);\r\n            }\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "func (t *TestTLSServer) NewClientFromWebSession(sess services.WebSession) (*Client, error) {\n\ttlsConfig, err := t.Identity.TLSConfig(t.AuthServer.CipherSuites)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttlsCert, err := tls.X509KeyPair(sess.GetTLSCert(), sess.GetPriv())\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err, \"failed to parse TLS cert and key\")\n\t}\n\ttlsConfig.Certificates = []tls.Certificate{tlsCert}\n\taddrs := []utils.NetAddr{utils.FromAddr(t.Listener.Addr())}\n\treturn NewTLSClient(ClientConfig{Addrs: addrs, TLS: tlsConfig})\n}", "label": 5}
{"code": "public static base_responses add(nitro_service client, snmpuser resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tsnmpuser addresources[] = new snmpuser[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new snmpuser();\n\t\t\t\taddresources[i].name = resources[i].name;\n\t\t\t\taddresources[i].group = resources[i].group;\n\t\t\t\taddresources[i].authtype = resources[i].authtype;\n\t\t\t\taddresources[i].authpasswd = resources[i].authpasswd;\n\t\t\t\taddresources[i].privtype = resources[i].privtype;\n\t\t\t\taddresources[i].privpasswd = resources[i].privpasswd;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function(m) {\n\t\t\t\t\tvar conditionValue = (typeof m === \"object\") ?\n\t\t\t\t\t\treadMemberExpression(conditionExport, m) : m;\n\n\t\t\t\t\tif (substitution) {\n\t\t\t\t\t\tif (typeof conditionValue !== \"string\") {\n\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\"The condition value for \" +\n\t\t\t\t\t\t\t\t\tconditionalMatch[0] +\n\t\t\t\t\t\t\t\t\t\" doesn't resolve to a string.\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tname = name.replace(conditionalRegEx, conditionValue);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (typeof conditionValue !== \"boolean\") {\n\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\"The condition value for \" +\n\t\t\t\t\t\t\t\t\tconditionalMatch[0] +\n\t\t\t\t\t\t\t\t\t\" isn't resolving to a boolean.\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (booleanNegation) {\n\t\t\t\t\t\t\tconditionValue = !conditionValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!conditionValue) {\n\t\t\t\t\t\t\tname = \"@empty\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tname = name.replace(conditionalRegEx, \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (name === \"@empty\") {\n\t\t\t\t\t\treturn normalize.call(loader, name, parentName, parentAddress, pluginNormalize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// call the full normalize in case the module name\n\t\t\t\t\t\t// is an npm package (that needs to be normalized)\n\t\t\t\t\t\treturn loader.normalize.call(loader, name, parentName, parentAddress, pluginNormalize);\n\t\t\t\t\t}\n\t\t\t\t}", "label": 3}
{"code": "def _validate_isvalid_history(self, isvalid_history, field, value):\n        \"\"\"Checks that the given time history is properly formatted.\n\n        Args:\n            isvalid_history (`bool`): flag from schema indicating units to be checked.\n            field (`str`): property associated with history in question.\n            value (`dict`): dictionary of values from file associated with this property.\n\n        The rule's arguments are validated against this schema:\n            {'isvalid_history': {'type': 'bool'}, 'field': {'type': 'str'},\n             'value': {'type': 'dict'}}\n        \"\"\"\n        # Check the type has appropriate units\n        history_type = value['type']\n        if history_type.endswith('emission'):\n            history_type = 'emission'\n        elif history_type.endswith('absorption'):\n            history_type = 'absorption'\n        quantity = 1.0*(units(value['quantity']['units']))\n        try:\n            quantity.to(property_units[history_type])\n        except pint.DimensionalityError:\n            self._error(field, 'incompatible units; should be consistent '\n                        'with ' + property_units[history_type])\n\n        # Check that time has appropriate units\n        time = 1.0*(units(value['time']['units']))\n        try:\n            time.to(property_units['time'])\n        except pint.DimensionalityError:\n            self._error(field, 'incompatible units; should be consistent '\n                        'with ' + property_units['time'])\n\n        # Check that the values have the right number of columns\n        n_cols = len(value['values'][0])\n        max_cols = max(value['time']['column'],\n                       value['quantity']['column'],\n                       value.get('uncertainty', {}).get('column', 0)) + 1\n        if n_cols > max_cols:\n            self._error(field, 'too many columns in the values')\n        elif n_cols < max_cols:\n            self._error(field, 'not enough columns in the values')", "label": 1}
{"code": "public function createAudioStreamFromResource($resource, $chunkSize = 32000)\n    {\n        while (!feof($resource)) {\n            $chunk = fread($resource, $chunkSize);\n            if (strlen($chunk) > 0) {\n                yield $chunk;\n            }\n        }\n    }", "label": 2}
{"code": "public function mergePost(MergeableInterface $post)\n    {\n        $lastPost = $this->posts()->latest()->first();\n\n        $post = $post->saveAfter($lastPost);\n\n        return $this->modifiedPosts[] = $post;\n    }", "label": 2}
{"code": "public static boolean unzipFileOrFolder(File zipFile, String unzippedFolder){\n\t\tInputStream is;\n\t\tArchiveInputStream in = null;\n\t\tOutputStream out  = null;\n\t\t\n\t\tif(!zipFile.isFile()){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(unzippedFolder == null){\n\t\t\tunzippedFolder = FilenameUtils.removeExtension(zipFile.getAbsolutePath());\n\t\t}\n\t\ttry {\n\t\t\tis = new FileInputStream(zipFile);\n\t\t\tnew File(unzippedFolder).mkdir();\n\t\t\t\n\t\t\tin = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n\t\t\t\n\t\t\tZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n\t\t\twhile(entry != null){\n\t\t\t\tif(entry.isDirectory()){\n\t\t\t\t\tnew File(unzippedFolder,entry.getName()).mkdir();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout = new FileOutputStream(new File(unzippedFolder, entry.getName()));\n\t\t\t\t\tIOUtils.copy(in, out);\n\t\t\t\t\tout.close();\n\t\t\t\t\tout = null;\n\t\t\t\t}\n\t\t\t\tentry = (ZipArchiveEntry)in.getNextEntry();\n\t\t\t}\t\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t} catch (ArchiveException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t\tfinally{\n\t\t\tif(out != null){\n\t\t\t\ttry {\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (IOException e) {}\n\t\t\t}\n\t\t\tif(in != null){\n\t\t\t\ttry {\n\t\t\t\t\tin.close();\n\t\t\t\t} catch (IOException e) {}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "label": 0}
{"code": "function iniFileGet(file, section, key, options) {\n  options = _.sanitize(options, {encoding: 'utf-8', default: ''});\n  if (!exists(file)) {\n    return '';\n  } else if (!isFile(file)) {\n    throw new Error(`File '${file}' is not a file`);\n  }\n  const config = ini.parse(read(file, _.pick(options, 'encoding')));\n  let value;\n  if (section in config) {\n    value = config[section][key];\n  } else if (_.isEmpty(section)) {\n    // global section\n    value = config[key];\n  }\n  return _.isUndefined(value) ? options.default : value;\n}", "label": 3}
{"code": "public static vpnvserver_vpntrafficpolicy_binding[] get(nitro_service service, String name) throws Exception{\n\t\tvpnvserver_vpntrafficpolicy_binding obj = new vpnvserver_vpntrafficpolicy_binding();\n\t\tobj.set_name(name);\n\t\tvpnvserver_vpntrafficpolicy_binding response[] = (vpnvserver_vpntrafficpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "protected void beforeLoading()\r\n    {\r\n        if (_listeners != null)\r\n        {\r\n            CollectionProxyListener listener;\r\n\r\n            if (_perThreadDescriptorsEnabled) {\r\n                loadProfileIfNeeded();\r\n            }\r\n            for (int idx = _listeners.size() - 1; idx >= 0; idx--)\r\n            {\r\n                listener = (CollectionProxyListener)_listeners.get(idx);\r\n                listener.beforeLoading(this);\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "function _gpfEventsTriggerHandler (event, eventsHandler, resolvePromise) {\n    var eventHandler = _getEventHandler(event, eventsHandler);\n    eventHandler(event);\n    if (undefined !== resolvePromise) {\n        resolvePromise(event);\n    }\n}", "label": 3}
{"code": "private File getWorkDir() throws IOException\r\n    {\r\n        if (_workDir == null)\r\n        {    \r\n            File   dummy   = File.createTempFile(\"dummy\", \".log\");\r\n            String workDir = dummy.getPath().substring(0, dummy.getPath().lastIndexOf(File.separatorChar));\r\n    \r\n            if ((workDir == null) || (workDir.length() == 0))\r\n            {\r\n                workDir = \".\";\r\n            }\r\n            dummy.delete();\r\n            _workDir = new File(workDir);\r\n        }\r\n        return _workDir;\r\n    }", "label": 0}
{"code": "def adjust_attribute_sequence(*fields):\n\t\"\"\"Move marrow.schema fields around to control positional instantiation order.\"\"\"\n\t\n\tamount = None\n\t\n\tif fields and isinstance(fields[0], int):\n\t\tamount, fields = fields[0], fields[1:]\n\t\n\tdef adjust_inner(cls):\n\t\tfor field in fields:\n\t\t\tif field not in cls.__dict__:\n\t\t\t\t# TODO: Copy the field definition.\n\t\t\t\traise TypeError(\"Can only override sequence on non-inherited attributes.\")\n\t\t\t\n\t\t\t# Adjust the sequence to re-order the field.\n\t\t\tif amount is None:\n\t\t\t\tcls.__dict__[field].__sequence__ = ElementMeta.sequence\n\t\t\telse:\n\t\t\t\tcls.__dict__[field].__sequence__ += amount  # Add the given amount.\n\t\t\n\t\t# Update the attribute collection.\n\t\tcls.__attributes__ = OrderedDict(\n\t\t\t\t\t(k, v) for k, v in \\\n\t\t\t\t\tsorted(cls.__attributes__.items(),\n\t\t\t\t\t\tkey=lambda i: i[1].__sequence__)\n\t\t\t\t)\n\t\t\n\t\treturn cls\n\t\n\treturn adjust_inner", "label": 1}
{"code": "public static base_response update(nitro_service client, responderaction resource) throws Exception {\n\t\tresponderaction updateresource = new responderaction();\n\t\tupdateresource.name = resource.name;\n\t\tupdateresource.target = resource.target;\n\t\tupdateresource.bypasssafetycheck = resource.bypasssafetycheck;\n\t\tupdateresource.htmlpage = resource.htmlpage;\n\t\tupdateresource.comment = resource.comment;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def merge_mutect(job, perchrom_rvs):\n    \"\"\"\n    This module will merge the per-chromosome mutect files created by spawn_mutect into a genome\n    vcf.  It will make 2 vcfs, one for PASSing non-germline calls, and one for all calls.\n\n    ARGUMENTS\n    1. perchrom_rvs: REFER RETURN VALUE of spawn_mutect()\n\n    RETURN VALUES\n    1. output_files: <JSid for mutect_passing_calls.vcf>\n\n    This module corresponds to node 11 on the tree\n    \"\"\"\n    job.fileStore.logToMaster('Running merge_mutect')\n    work_dir = job.fileStore.getLocalTempDir()\n    # We need to squash the input dict of dicts to a single dict such that it can be passed to\n    # get_files_from_filestore\n    input_files = {filename: jsid for perchrom_files in perchrom_rvs.values()\n                   for filename, jsid in perchrom_files.items()}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n    chromosomes = [''.join(['chr', str(x)]) for x in range(1, 23) + ['X', 'Y']]\n    with open('/'.join([work_dir, 'mutect_calls.vcf']), 'w') as mutvcf, \\\n            open('/'.join([work_dir, 'mutect_calls.out']), 'w') as mutout, \\\n            open('/'.join([work_dir, 'mutect_passing_calls.vcf']), 'w') as mutpassvcf:\n        out_header_not_printed = True\n        for chrom in chromosomes:\n            with open(input_files[''.join(['mutect_', chrom, '.vcf'])], 'r') as mutfile:\n                for line in mutfile:\n                    line = line.strip()\n                    if line.startswith('#'):\n                        if chrom == 'chr1':\n                            print(line, file=mutvcf)\n                            print(line, file=mutpassvcf)\n                        continue\n                    else:\n                        print(line, file=mutvcf)\n                        line = line.split('\\t')\n                        if line[6] != 'REJECT':\n                            print('\\t'.join(line), file=mutpassvcf)\n            with open(input_files[''.join(['mutect_', chrom,\n                                           '.out'])], 'r') as mutfile:\n                for line in mutfile:\n                    line = line.strip()\n                    if line.startswith('#'):\n                        if chrom == 'chr1':\n                            print(line, file=mutout)\n                        continue\n                    elif out_header_not_printed:\n                        print(line, file=mutout)\n                        out_header_not_printed = False\n                    else:\n                        print(line, file=mutout)\n    output_file = job.fileStore.writeGlobalFile(mutpassvcf.name)\n    return output_file", "label": 1}
{"code": "function Sasl(mechanism, handler) {\n  if (!mechanism || !handler) {\n    throw new errors.NotImplementedError('Need both the mechanism and the handler');\n  }\n  this.mechanism = mechanism;\n  this.handler = handler;\n  this.receivedHeader = false;\n}", "label": 3}
{"code": "public function setConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dataproc\\V1beta2\\ClusterConfig::class);\n        $this->config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public PortComponentMetaData getPortComponentByWsdlPort(String name)\n   {\n      ArrayList<String> pcNames = new ArrayList<String>();\n      for (PortComponentMetaData pc : portComponents)\n      {\n         String wsdlPortName = pc.getWsdlPort().getLocalPart();\n         if (wsdlPortName.equals(name))\n            return pc;\n\n         pcNames.add(wsdlPortName);\n      }\n\n      Loggers.METADATA_LOGGER.cannotGetPortComponentName(name, pcNames);\n      return null;\n   }", "label": 0}
{"code": "public static appflowpolicylabel[] get(nitro_service service) throws Exception{\n\t\tappflowpolicylabel obj = new appflowpolicylabel();\n\t\tappflowpolicylabel[] response = (appflowpolicylabel[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function setForm($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Language\\V1beta2\\PartOfSpeech_Form::class);\n        $this->form = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def fixed_and_mobile_keys(data)\n      if data[Core::FIXED_LINE] == data[Core::MOBILE]\n        [Core::FIXED_OR_MOBILE]\n      else\n        [Core::FIXED_LINE, Core::MOBILE]\n      end\n    end", "label": 4}
{"code": "function(opts) {\n  if(!opts) opts = {};\n  var libpath = opts['path'];\n  var key = opts['key'];\n\n  this._library = this._createLibrary(libpath);\n  this._initKey(key);\n  this._initHandle(this._key);\n}", "label": 3}
{"code": "func IsDeviceNode(path string) bool {\n\td, err := os.Lstat(path)\n\tif err == nil {\n\t\tm := d.Mode()\n\t\treturn m&os.ModeDevice == os.ModeDevice\n\t}\n\treturn false\n}", "label": 5}
{"code": "def add_await!(type, attributes = {})\n      raise \"You can't await an AwaitEvent!\" if type == Discordrb::Events::AwaitEvent\n\n      timeout = attributes[:timeout]\n      raise ArgumentError, 'Timeout must be a number > 0' if timeout&.is_a?(Numeric) && !timeout&.positive?\n\n      mutex = Mutex.new\n      cv = ConditionVariable.new\n      response = nil\n      block = lambda do |event|\n        mutex.synchronize do\n          response = event\n          cv.signal\n        end\n      end\n\n      handler = register_event(type, attributes, block)\n\n      if timeout\n        Thread.new do\n          sleep timeout\n          mutex.synchronize { cv.signal }\n        end\n      end\n\n      mutex.synchronize { cv.wait(mutex) }\n\n      remove_handler(handler)\n      raise 'ConditionVariable was signaled without returning an event!' if response.nil? && timeout.nil?\n\n      response\n    end", "label": 4}
{"code": "def _index_action(self, payload):\n        \"\"\"Bulk index action.\n\n        :param payload: Decoded message body.\n        :returns: Dictionary defining an Elasticsearch bulk 'index' action.\n        \"\"\"\n        record = Record.get_record(payload['id'])\n        index, doc_type = self.record_to_index(record)\n\n        return {\n            '_op_type': 'index',\n            '_index': index,\n            '_type': doc_type,\n            '_id': str(record.id),\n            '_version': record.revision_id,\n            '_version_type': self._version_type,\n            '_source': self._prepare_record(record, index, doc_type),\n        }", "label": 1}
{"code": "def runtime\n      @runtime ||= begin\n        if ExecJS.eval(\"typeof Uint8Array\") != \"function\"\n          if ExecJS.runtime.name.start_with?(\"therubyracer\")\n            raise \"ExecJS::RubyRacerRuntime is not supported. \" \\\n              \"Please replace therubyracer with mini_racer \" \\\n              \"in your Gemfile or use Node.js as ExecJS runtime.\"\n          else\n            raise \"#{ExecJS.runtime.name} runtime does\u2019t support ES6. \" \\\n              \"Please update or replace your current ExecJS runtime.\"\n          end\n        end\n\n        if ExecJS.runtime == ExecJS::Runtimes::Node\n          version = ExecJS.runtime.eval(\"process.version\")\n          first = version.match(/^v(\\d+)/)[1].to_i\n          if first < 6\n            raise \"Autoprefixer doesn\u2019t support Node #{version}. Update it.\"\n          end\n        end\n\n        ExecJS.compile(build_js)\n      end\n    end", "label": 4}
{"code": "def save\n      data = json_encode(@data)\n      FileUtils.mkdir_p File.dirname(@filename)\n      PathUtils.atomic_write(@filename) do |f|\n        f.write(data)\n      end\n    end", "label": 4}
{"code": "def merge source\n      result = nil\n      mutex.synchronize do\n        result = workspace.merge(source)\n        @synchronized = !result if synchronized?\n      end\n      result\n    end", "label": 4}
{"code": "func isIPv6(fl FieldLevel) bool {\n\n\tip := net.ParseIP(fl.Field().String())\n\n\treturn ip != nil && ip.To4() == nil\n}", "label": 5}
{"code": "func ComparePDFFiles(file1Str, file2Str string, printDiff bool) (err error) {\n\tvar sl1, sl2 []byte\n\tsl1, err = ioutil.ReadFile(file1Str)\n\tif err == nil {\n\t\tsl2, err = ioutil.ReadFile(file2Str)\n\t\tif err == nil {\n\t\t\terr = CompareBytes(sl1, sl2, printDiff)\n\t\t} else {\n\t\t\t// Second file is missing; treat this as success\n\t\t\terr = nil\n\t\t}\n\t}\n\treturn\n}", "label": 5}
{"code": "private static BundleCapability getExportedPackage(BundleContext context, String packageName) {\n        List<BundleCapability> packages = new ArrayList<BundleCapability>();\n        for (Bundle bundle : context.getBundles()) {\n            BundleRevision bundleRevision = bundle.adapt(BundleRevision.class);\n            for (BundleCapability packageCapability : bundleRevision.getDeclaredCapabilities(BundleRevision.PACKAGE_NAMESPACE)) {\n                String pName = (String) packageCapability.getAttributes().get(BundleRevision.PACKAGE_NAMESPACE);\n                if (pName.equalsIgnoreCase(packageName)) {\n                    packages.add(packageCapability);\n                }\n            }\n        }\n\n        Version max = Version.emptyVersion;\n        BundleCapability maxVersion = null;\n        for (BundleCapability aPackage : packages) {\n            Version version = (Version) aPackage.getAttributes().get(\"version\");\n            if (max.compareTo(version) <= 0) {\n                max = version;\n                maxVersion = aPackage;\n            }\n        }\n\n        return maxVersion;\n    }", "label": 0}
{"code": "public function recordEvent($eventName, $payload)\n    {\n        if (! Telescope::isRecording() || $this->shouldIgnore($eventName)) {\n            return;\n        }\n\n        $formattedPayload = $this->extractPayload($eventName, $payload);\n\n        Telescope::recordEvent(IncomingEntry::make([\n            'name' => $eventName,\n            'payload' => empty($formattedPayload) ? null : $formattedPayload,\n            'listeners' => $this->formatListeners($eventName),\n            'broadcast' => class_exists($eventName)\n                        ? in_array(ShouldBroadcast::class, (array) class_implements($eventName))\n                        : false,\n        ])->tags(class_exists($eventName) && isset($payload[0]) ? ExtractTags::from($payload[0]) : []));\n    }", "label": 2}
{"code": "func NormalizePath(path string) (string, error) {\n\ts, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn \"\", trace.ConvertSystemError(err)\n\t}\n\tabs, err := filepath.EvalSymlinks(s)\n\tif err != nil {\n\t\treturn \"\", trace.ConvertSystemError(err)\n\t}\n\treturn abs, nil\n}", "label": 5}
{"code": "function (soajs) {\n        if (soajs.inputmaskData && soajs.inputmaskData.isOwner) {\n            soajs.mongoDb = new Mongo(soajs.meta.tenantDB(soajs.registry.tenantMetaDB, 'urac', soajs.inputmaskData.tCode));\n        }\n        else {\n            let tcode = soajs.tenant.code;\n            if (soajs.tenant.roaming && soajs.tenant.roaming.code) {\n                tcode = soajs.tenant.roaming.code;\n            }\n            let tenantMetaDB = soajs.registry.tenantMetaDB;\n            if (soajs.tenant.roaming && soajs.tenant.roaming.tenantMetaDB) {\n                tenantMetaDB = soajs.tenant.roaming.tenantMetaDB;\n            }\n\n            let config = soajs.meta.tenantDB(tenantMetaDB, 'urac', tcode);\n            soajs.mongoDb = new Mongo(config);\n        }\n    }", "label": 3}
{"code": "def equalspairs(X, Y):\n    \"\"\"\n    Indices of elements in a sorted numpy array equal to those in another.\n\n    Given numpy array `X` and sorted numpy array `Y`, determine the indices in \n    Y equal to indices in X.\n\n    Returns `[A,B]` where `A` and `B` are numpy arrays of indices in `X` such \n    that::\n\n            Y[A[i]:B[i]] = Y[Y == X[i]]`\n\n    `A[i] = B[i] = 0` if `X[i]` is not in `Y`.\n\n    **Parameters**\n\n            **X** :  numpy array\n\n                    Numpy array to compare to the sorted numpy array `Y`.\n\n            **Y** :  numpy array\n\n                    Sorted numpy array.  Determine the indices of elements of \n                    `Y` equal to those in numpy array `X`.\n\n    **Returns**\n\n            **A** :  numpy array\n\n                    List of indices in `Y`, `len(A) = len(Y)`.\n\n            **B** :  numpy array\n\n                    List of indices in `Y`, `len(B) = len(Y)`.\n\n    **See Also:**\n\n            :func:`tabular.fast.recarrayequalspairs`\n\n    \"\"\"\n    T = Y.copy()\n    R = (T[1:] != T[:-1]).nonzero()[0]\n    R = np.append(R,np.array([len(T)-1]))\n    M = R[R.searchsorted(range(len(T)))]\n    D = T.searchsorted(X)\n    T = np.append(T,np.array([0]))\n    M = np.append(M,np.array([0]))\n    A = (T[D] == X) * D\n    B = (T[D] == X) * (M[D] + 1)\n    return [A,B]", "label": 1}
{"code": "public static base_response unset(nitro_service client, nslimitselector resource, String[] args) throws Exception{\n\t\tnslimitselector unsetresource = new nslimitselector();\n\t\tunsetresource.selectorname = resource.selectorname;\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "function filter(array, f) {\n        if (array) {\n            var len = array.length;\n            var i = 0;\n            while (i < len && f(array[i]))\n                i++;\n            if (i < len) {\n                var result = array.slice(0, i);\n                i++;\n                while (i < len) {\n                    var item = array[i];\n                    if (f(item)) {\n                        result.push(item);\n                    }\n                    i++;\n                }\n                return result;\n            }\n        }\n        return array;\n    }", "label": 3}
{"code": "function tryGetObjectLikeCompletionContainer(contextToken) {\n                if (contextToken) {\n                    switch (contextToken.kind) {\n                        case 15 /* OpenBraceToken */: // const x = { |\n                        case 24 /* CommaToken */:\n                            var parent_19 = contextToken.parent;\n                            if (parent_19 && (parent_19.kind === 171 /* ObjectLiteralExpression */ || parent_19.kind === 167 /* ObjectBindingPattern */)) {\n                                return parent_19;\n                            }\n                            break;\n                    }\n                }\n                return undefined;\n            }", "label": 3}
{"code": "public function commit($projectId, $mode, $mutations, array $optionalArgs = [])\n    {\n        $request = new CommitRequest();\n        $request->setProjectId($projectId);\n        $request->setMode($mode);\n        $request->setMutations($mutations);\n        if (isset($optionalArgs['transaction'])) {\n            $request->setTransaction($optionalArgs['transaction']);\n        }\n\n        $requestParams = new RequestParamsHeaderDescriptor([\n          'project_id' => $request->getProjectId(),\n        ]);\n        $optionalArgs['headers'] = isset($optionalArgs['headers'])\n            ? array_merge($requestParams->getHeader(), $optionalArgs['headers'])\n            : $requestParams->getHeader();\n\n        return $this->startCall(\n            'Commit',\n            CommitResponse::class,\n            $optionalArgs,\n            $request\n        )->wait();\n    }", "label": 2}
{"code": "func CompareBytes(sl1, sl2 []byte, printDiff bool) (err error) {\n\tvar posStart, posEnd, len1, len2, length int\n\tvar diffs bool\n\n\tlen1 = len(sl1)\n\tlen2 = len(sl2)\n\tlength = len1\n\tif length > len2 {\n\t\tlength = len2\n\t}\n\tfor posStart < length-1 {\n\t\tposEnd = posStart + 16\n\t\tif posEnd > length {\n\t\t\tposEnd = length\n\t\t}\n\t\tif !checkBytes(posStart, sl1[posStart:posEnd], sl2[posStart:posEnd], printDiff) {\n\t\t\tdiffs = true\n\t\t}\n\t\tposStart = posEnd\n\t}\n\tif diffs {\n\t\terr = fmt.Errorf(\"documents are different\")\n\t}\n\treturn\n}", "label": 5}
{"code": "def extract_logs(self, fname, prg):\n        \"\"\"\n        read a logfile and return entries for a program\n        \"\"\"\n        op = []\n        with open(fname, 'r') as f:\n            for line in f:\n                if prg in line:\n                    op.append(line)\n        return op", "label": 1}
{"code": "public static base_responses delete(nitro_service client, String prefix[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (prefix != null && prefix.length > 0) {\n\t\t\tnsxmlnamespace deleteresources[] = new nsxmlnamespace[prefix.length];\n\t\t\tfor (int i=0;i<prefix.length;i++){\n\t\t\t\tdeleteresources[i] = new nsxmlnamespace();\n\t\t\t\tdeleteresources[i].prefix = prefix[i];\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public function setInstanceConfigs($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Spanner\\Admin\\Instance\\V1\\InstanceConfig::class);\n        $this->instance_configs = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def toggle_object_status(self, objname):\n        \"\"\"\n            Toggle boolean-valued sensor status between ``True`` and ``False``.\n        \"\"\"\n        o = getattr(self.system, objname)\n        o.status = not o.status\n        self.system.flush()\n        return o.status", "label": 1}
{"code": "def ortho_basis(normal, ref_vec=None):\n    \"\"\"Generates an orthonormal basis in the plane perpendicular to `normal`\n\n    The orthonormal basis generated spans the plane defined with `normal` as\n    its normal vector.  The handedness of `on1` and `on2` in the returned\n    basis is such that:\n\n    .. math::\n\n            \\\\mathsf{on1} \\\\times \\\\mathsf{on2} =\n            {\\\\mathsf{normal} \\\\over \\\\left\\\\| \\\\mathsf{normal}\\\\right\\\\|}\n\n    `normal` must be expressible as a one-dimensional |nparray| of length 3.\n\n    Parameters\n    ----------\n    normal\n        length-3 |npfloat_| --\n        The orthonormal basis output will span the plane perpendicular\n        to `normal`.\n\n    ref_vec\n        length-3 |npfloat_|, optional --\n        If specified, `on1` will be the normalized projection of `ref_vec`\n        onto the plane perpendicular to `normal`. Default is |None|.\n\n    Returns\n    -------\n    on1\n        length-3 |npfloat_| --\n        First vector defining the orthonormal basis in the plane\n        normal to `normal`\n\n    on2\n        length-3 |npfloat_| --\n        Second vector defining the orthonormal basis in the plane\n        normal to `normal`\n\n    Raises\n    ------\n    ~exceptions.ValueError\n        If `normal` or `ref_vec` is not expressible as a 1-D vector\n        with 3 elements\n\n    ~opan.error.VectorError\n        (typecode :attr:`~opan.error.VectorError.NONPRL`)\n        If `ref_vec` is specified and it is insufficiently non-\n        parallel with respect to `normal`\n\n    \"\"\"\n\n    # Imports for library functions\n    import numpy as np\n    from scipy import linalg as spla\n    from scipy import random as sprnd\n    from ..const import PRM\n    from ..error import VectorError\n\n    # Internal parameters\n    # Magnitude of the perturbation from 'normal' in constructing a random rv\n    RAND_MAG = 0.25\n\n    # Test 'normal' for shape and length\n    if not len(normal.shape) == 1:\n        raise ValueError(\"'normal' is not a vector\")\n    ## end if\n    if not normal.shape[0] == 3:\n        raise ValueError(\"Length of 'normal' is not three\")\n    ## end if\n\n    # Normalize to concise variable 'nv'\n    nv = normal / spla.norm(normal)\n\n    # Test for specification of ref_vec in the function call\n    if ref_vec is None:\n        # ref_vec not specified.\n        #\n        # Generate reference vector by generation of a random perturbation\n        #  vector suitably non-parallel to norm_vec\n        # Generate suitable randomizer, looping as needed\n        rv = nv\n        while parallel_check(nv, rv):\n            rv = np.float64(1.0 - RAND_MAG + 2 * RAND_MAG * sprnd.rand(3))\n        ## do loop\n\n        # Calculate rejection of perturbed vector on the normal, then\n        #  normalize\n        rv = rej(rv, nv)\n        rv = rv / spla.norm(rv)\n\n    else:\n        # ref_vec specified, go ahead and use.  Start with validity check.\n        if not len(ref_vec.shape) == 1:\n            raise ValueError(\"ref_vec is not a vector\")\n        ## end if\n        if not ref_vec.shape[0] == 3:\n            raise ValueError(\"ref_vec length is not three\")\n        ## end if\n\n        # Normalize ref_vec to 'rv'\n        rv = ref_vec / spla.norm(ref_vec)\n\n        # Check for collinearity of nv and rv; raise error if too close\n        if parallel_check(nv, rv):\n            # Essentially equal or opposite vectors, making them too nearly\n            #  parallel.\n            raise VectorError(VectorError.NONPRL,\n                    \"'normal' and 'ref_vec' are too nearly parallel.\", \"\")\n        ## end if\n\n        # rv is ok to use from here\n\n    ## end try\n\n    # on2 is the unit vector parallel to nv x rv\n    on2 = np.cross(nv, rv)\n    on2 = on2 / spla.norm(on2)\n\n    # on1 is on2 x nv (normalization should not be necessary here, but is\n    #  performed just in case)\n    on1 = np.cross(on2, nv)\n    on1 = on1 / spla.norm(on1)\n\n    # Return the spanning vectors\n    return on1, on2", "label": 1}
{"code": "public static lbvserver_servicegroupmember_binding[] get(nitro_service service, String name) throws Exception{\n\t\tlbvserver_servicegroupmember_binding obj = new lbvserver_servicegroupmember_binding();\n\t\tobj.set_name(name);\n\t\tlbvserver_servicegroupmember_binding response[] = (lbvserver_servicegroupmember_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static appfwhtmlerrorpage get(nitro_service service, String name) throws Exception{\n\t\tappfwhtmlerrorpage obj = new appfwhtmlerrorpage();\n\t\tobj.set_name(name);\n\t\tappfwhtmlerrorpage response = (appfwhtmlerrorpage) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def stop\n      GRPC.logger.info('stopping, will wait for all the workers to exit')\n      @stop_mutex.synchronize do  # wait @keep_alive seconds for workers to stop\n        @stopped = true\n        loop do\n          break unless ready_for_work?\n          worker_queue = @ready_workers.pop\n          worker_queue << [proc { throw :exit }, []]\n        end\n        @stop_cond.wait(@stop_mutex, @keep_alive) if @workers.size > 0\n      end\n      forcibly_stop_workers\n      GRPC.logger.info('stopped, all workers are shutdown')\n    end", "label": 4}
{"code": "public static autoscalepolicy_stats[] get(nitro_service service) throws Exception{\n\t\tautoscalepolicy_stats obj = new autoscalepolicy_stats();\n\t\tautoscalepolicy_stats[] response = (autoscalepolicy_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "async function bundleProgram (dirPath, destFile) {\n  await validateDirPathForCLI(dirPath);\n  return collecticonsBundle({\n    dirPath,\n    destFile\n  });\n}", "label": 3}
{"code": "public function setIndexes($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Firestore\\Admin\\V1\\Index::class);\n        $this->indexes = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function injectableWrapper(obj, provide, injects, isTransientScope) {\n    // TODO(@davequick): discuss with @halfspiral whether isTransientScope might just better\n    // be an array of Annotations\n    var wrappedObject = function wrapOrCreateObject() {\n      if(isFunction(obj) && (exists(obj.$provide) || exists(obj.$inject) || provide || injects)){\n        var instance = Object.create(obj.prototype);\n        return obj.apply(instance,arguments) || instance;\n      }\n      return obj;\n    };\n    return _wrapper(obj, wrappedObject, provide, injects, isTransientScope);\n  }", "label": 3}
{"code": "public static lbvserver_servicegroup_binding[] get(nitro_service service, String name) throws Exception{\n\t\tlbvserver_servicegroup_binding obj = new lbvserver_servicegroup_binding();\n\t\tobj.set_name(name);\n\t\tlbvserver_servicegroup_binding response[] = (lbvserver_servicegroup_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function setWebDetection($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Vision\\V1\\WebDetection::class);\n        $this->web_detection = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def ops_entity(self, ops):\n        ''' Returns a new multi-op entity name string that represents\n        all the given operations and caveats. It returns the same value\n        regardless of the ordering of the operations. It assumes that the\n        operations have been canonicalized and that there's at least one\n        operation.\n\n        :param ops:\n        :return: string that represents all the given operations and caveats.\n        '''\n        # Hash the operations, removing duplicates as we go.\n        hash_entity = hashlib.sha256()\n        for op in ops:\n            hash_entity.update('{}\\n{}\\n'.format(\n                op.action, op.entity).encode())\n        hash_encoded = base64.urlsafe_b64encode(hash_entity.digest())\n        return 'multi-' + hash_encoded.decode('utf-8').rstrip('=')", "label": 1}
{"code": "function getResourceNames() {\n        var resourceNames = {};\n        var resourcesDir = this.injector.rootDir + '/' + this.injector.servicesDir + '/resources';\n\n        if (!fs.existsSync(path.normalize(resourcesDir))) {\n            return resourceNames;\n        }\n\n        var names = fs.readdirSync(path.normalize(resourcesDir));\n        _.each(names, function (name) {\n            if (name.substring(name.length - 3) !== '.js') {  // only dirs, not js files\n                resourceNames[utils.getPascalCase(name)] = utils.getCamelCase(name);\n            }\n        });\n\n        return resourceNames;\n    }", "label": 3}
{"code": "@PostConstruct\n\tprotected void postConstruct() {\n\t\tif (null == authenticationServices) {\n\t\t\tauthenticationServices = new ArrayList<AuthenticationService>();\n\t\t}\n\t\tif (!excludeDefault) {\n\t\t\tauthenticationServices.add(staticAuthenticationService);\n\t\t}\n\t}", "label": 0}
{"code": "public function connect(ConnectionContext $ctx, string $header = ''): Promise\n    {\n        $this->in_seq_no = -1;\n        $this->out_seq_no = -1;\n        $this->stream = new HashedBufferedStream();\n        $this->stream->setExtra('crc32b_rev');\n\n        return $this->stream->connect($ctx, $header);\n    }", "label": 2}
{"code": "public List<String> getArtifactVersions(final String gavc) {\n        final DbArtifact artifact = getArtifact(gavc);\n        return repositoryHandler.getArtifactVersions(artifact);\n    }", "label": 0}
{"code": "def store_modified_times\n      @modified_times = {}\n\n      staged_files = modified_files\n      unstaged_files = Overcommit::GitRepo.modified_files(staged: false)\n\n      (staged_files + unstaged_files).each do |file|\n        next if Overcommit::Utils.broken_symlink?(file)\n        next unless File.exist?(file) # Ignore renamed files (old file no longer exists)\n        @modified_times[file] = File.mtime(file)\n      end\n    end", "label": 4}
{"code": "func MakeHeadlessTable(columnCount int) Table {\n\treturn Table{\n\t\tcolumns: make([]column, columnCount),\n\t\trows:    make([][]string, 0),\n\t}\n}", "label": 5}
{"code": "async function setPreferredMcpLanguage(accessToken, languageCode) {\n    let language = getValidLanguageOrThrow(languageCode);\n\n    let currentLanguages = await getPreferredMcpLanguages(accessToken);\n\n    return mcpCustomizr.putSettings(accessToken, {\n        language: updatePreferredLanguage(language, currentLanguages),\n    });\n}", "label": 3}
{"code": "async def container_load(self, container_type, params=None, container=None, obj=None):\n        \"\"\"\n        Loads container of elements from the reader. Supports the container ref.\n        Returns loaded container.\n        Blob array writer as in XMRRPC is serialized without size serialization.\n\n        :param container_type:\n        :param params:\n        :param container:\n        :param obj:\n        :return:\n        \"\"\"\n        elem_type = x.container_elem_type(container_type, params)\n        elem_size = await self.get_element_size(elem_type=elem_type, params=params)\n\n        # If container is of fixed size we know the size to load from the input.\n        # Otherwise we have to read to the end\n        data_left = len(self.iobj.buffer)\n        c_len = container_type.SIZE\n        if not container_type.FIX_SIZE:\n            if data_left == 0:\n                return None\n            if data_left % elem_size != 0:\n                raise helpers.ArchiveException('Container size mod elem size not 0')\n            c_len = data_left // elem_size\n\n        res = container if container else []\n        for i in range(c_len):\n            try:\n                self.tracker.push_index(i)\n                fvalue = await self._load_field(elem_type,\n                                                params[1:] if params else None,\n                                                x.eref(res, i) if container else None)\n                self.tracker.pop()\n            except Exception as e:\n                raise helpers.ArchiveException(e, tracker=self.tracker) from e\n\n            if not container:\n                res.append(fvalue)\n        return res", "label": 1}
{"code": "public function mergeProperties($object)\n    {\n        $defaultValues = get_class_vars(get_class($this));\n        $currentValues = get_object_vars($this);\n        foreach ($object as $property => $value) {\n            if ($property === '_context') {\n                continue;\n            }\n            if ($currentValues[$property] === $defaultValues[$property]) { // Overwrite default values\n                $this->$property = $value;\n                continue;\n            }\n            if ($property === '_unmerged') {\n                $this->_unmerged = array_merge($this->_unmerged, $value);\n                continue;\n            }\n            if ($currentValues[$property] !== $value) { // New value is not the same?\n                if ($defaultValues[$property] === $value) { // but is the same as the default?\n                    continue; // Keep current, no notice\n                }\n                $identity = method_exists($object, 'identity') ? $object->identity() : get_class($object);\n                $context1 = $this->_context;\n                $context2 = property_exists($object, '_context') ? $object->_context : 'unknown';\n                if (is_object($this->$property) && $this->$property instanceof AbstractAnnotation) {\n                    $context1 = $this->$property->_context;\n                }\n                Logger::warning('Multiple definitions for ' . $identity . '->' . $property . \"\\n     Using: \" . $context1 . \"\\n  Skipping: \" . $context2);\n            }\n        }\n    }", "label": 2}
{"code": "def next_node(node)\n      return unless node\n      siblings = node.parent ? node.parent.children : [node]\n\n      next_sibling = siblings[siblings.index(node) + 1] if siblings.count > 1\n      return next_sibling if next_sibling\n\n      next_node(node.parent)\n    end", "label": 4}
{"code": "private function getApiVersionMiddleware()\n    {\n        return function (callable $handler) {\n            return function (\n                CommandInterface $command,\n                RequestInterface $request = null\n            ) use ($handler) {\n                return $handler($command, $request->withHeader(\n                    'x-amz-glacier-version',\n                    $this->getApi()->getMetadata('apiVersion')\n                ));\n            };\n        };\n    }", "label": 2}
{"code": "public static base_responses delete(nitro_service client, String sitename[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (sitename != null && sitename.length > 0) {\n\t\t\tgslbsite deleteresources[] = new gslbsite[sitename.length];\n\t\t\tfor (int i=0;i<sitename.length;i++){\n\t\t\t\tdeleteresources[i] = new gslbsite();\n\t\t\t\tdeleteresources[i].sitename = sitename[i];\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function threeParts(before, item1, defaultItem1, middle, item2, after) {\n    item2 = stringify(item2);\n    item1 = stringify(item1);\n    if (!item2) {\n        return '';\n    }\n    return before + (item1 || defaultItem1) + middle + item2 + after;\n}", "label": 3}
{"code": "func GenerateSchedule(clock clockwork.Clock, gracePeriod time.Duration) (*RotationSchedule, error) {\n\tif gracePeriod <= 0 {\n\t\treturn nil, trace.BadParameter(\"invalid grace period %q, provide value > 0\", gracePeriod)\n\t}\n\treturn &RotationSchedule{\n\t\tUpdateClients: clock.Now().UTC().Add(gracePeriod / 3).UTC(),\n\t\tUpdateServers: clock.Now().UTC().Add((gracePeriod * 2) / 3).UTC(),\n\t\tStandby:       clock.Now().UTC().Add(gracePeriod).UTC(),\n\t}, nil\n}", "label": 5}
{"code": "function writableBy(file, user) {\n  function _writableBy(f, userData) {\n    if (!exists(f)) {\n      return _writableBy(path.dirname(f), userData);\n    } else {\n      return _accesibleByUser(userData, f, fs.W_OK);\n    }\n  }\n  const uData = findUser(user);\n  // root can always write\n  if (uData.id === 0) {\n    return true;\n  } else if (uData.id === process.getuid()) {\n    return writable(file);\n  } else {\n    return _writableBy(file, uData);\n  }\n}", "label": 3}
{"code": "public function prependInit(callable $middleware, $name = null)\n    {\n        $this->add(self::INIT, $name, $middleware, true);\n    }", "label": 2}
{"code": "public static Module unserializeModule(final String module) throws IOException {\n        final ObjectMapper mapper = new ObjectMapper();\n        mapper.disable(MapperFeature.USE_GETTERS_AS_SETTERS);\n        return mapper.readValue(module, Module.class);\n    }", "label": 0}
{"code": "func (v *ViewPort) Resize(x, y, width, height int) {\n\tif v.v == nil {\n\t\treturn\n\t}\n\tpx, py := v.v.Size()\n\tif x >= 0 && x < px {\n\t\tv.physx = x\n\t}\n\tif y >= 0 && y < py {\n\t\tv.physy = y\n\t}\n\tif width < 0 {\n\t\twidth = px - x\n\t}\n\tif height < 0 {\n\t\theight = py - y\n\t}\n\tif width <= x+px {\n\t\tv.width = width\n\t}\n\tif height <= y+py {\n\t\tv.height = height\n\t}\n}", "label": 5}
{"code": "public static base_response sync(nitro_service client, gslbconfig resource) throws Exception {\n\t\tgslbconfig syncresource = new gslbconfig();\n\t\tsyncresource.preview = resource.preview;\n\t\tsyncresource.debug = resource.debug;\n\t\tsyncresource.forcesync = resource.forcesync;\n\t\tsyncresource.nowarn = resource.nowarn;\n\t\tsyncresource.saveconfig = resource.saveconfig;\n\t\tsyncresource.command = resource.command;\n\t\treturn syncresource.perform_operation(client,\"sync\");\n\t}", "label": 0}
{"code": "func (cb *CellBuffer) Resize(w, h int) {\n\n\tif cb.h == h && cb.w == w {\n\t\treturn\n\t}\n\n\tnewc := make([]cell, w*h)\n\tfor y := 0; y < h && y < cb.h; y++ {\n\t\tfor x := 0; x < w && x < cb.w; x++ {\n\t\t\toc := &cb.cells[(y*cb.w)+x]\n\t\t\tnc := &newc[(y*w)+x]\n\t\t\tnc.currMain = oc.currMain\n\t\t\tnc.currComb = oc.currComb\n\t\t\tnc.currStyle = oc.currStyle\n\t\t\tnc.width = oc.width\n\t\t\tnc.lastMain = rune(0)\n\t\t}\n\t}\n\tcb.cells = newc\n\tcb.h = h\n\tcb.w = w\n}", "label": 5}
{"code": "function loadResources() {\n        var resources = {};\n        var resourcesDir = path.join(this.injector.rootDir, this.injector.servicesDir + '/resources');\n\n\n        if (!fs.existsSync(resourcesDir)) {\n            return resources;\n        }\n\n        var me = this;\n        var resourceNames = fs.readdirSync(resourcesDir);\n\n        _.each(resourceNames, function (resourceName) {\n            if (resourceName.substring(resourceName.length - 3) !== '.js') {  // only dirs, not js files\n                resources[resourceName] = me.injector.loadModule(utils.getCamelCase(resourceName + '.resource'));\n            }\n        });\n\n        return resources;\n    }", "label": 3}
{"code": "public static <E> E argmax(Counter<E> c) {\r\n    double max = Double.NEGATIVE_INFINITY;\r\n    E argmax = null;\r\n    for (E key : c.keySet()) {\r\n      double count = c.getCount(key);\r\n      if (argmax == null || count > max) {// || (count == max &&\r\n                                          // tieBreaker.compare(key, argmax) <\r\n                                          // 0)) {\r\n        max = count;\r\n        argmax = key;\r\n      }\r\n    }\r\n    return argmax;\r\n  }", "label": 0}
{"code": "func (fs *FileAddrStorage) GetAddresses() ([]NetAddr, error) {\n\tbytes, err := ioutil.ReadFile(fs.filePath)\n\tif err != nil {\n\t\treturn nil, trace.ConvertSystemError(err)\n\t}\n\tvar addrs []NetAddr\n\tif len(bytes) > 0 {\n\t\terr = json.Unmarshal(bytes, &addrs)\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t}\n\treturn addrs, nil\n}", "label": 5}
{"code": "func baseTwoKeys(key []byte) (string, string, error) {\n\tparts := bytes.Split(key, []byte{backend.Separator})\n\tif len(parts) < 2 {\n\t\treturn \"\", \"\", trace.NotFound(\"failed parsing %v\", string(key))\n\t}\n\treturn string(parts[len(parts)-2]), string(parts[len(parts)-1]), nil\n}", "label": 5}
{"code": "def build(self):\n        \"\"\"convert Markdown text as html. return the html file as string\"\"\"\n        markdown_html = markdown.markdown(self.markdown_text, extensions=[\n                TocExtension(), 'fenced_code', 'markdown_checklist.extension',\n                'markdown.extensions.tables'])\n        markdown_soup = BeautifulSoup(markdown_html, 'html.parser')\n\n        # include jquery & mermaid.js only if there are Mermaid graph\n        if markdown_soup.find('code', attrs={'class': 'mermaid'}):\n            self._add_mermaid_js()\n\n        # search in markdown html if there are Dot Graph & replace it with .svg result\n        for dot_tag in markdown_soup.find_all('code', attrs={'class': 'dotgraph'}):\n            grap_svg = self._text_to_graphiz(dot_tag.string)\n            graph_soup = BeautifulSoup(grap_svg, 'html.parser')\n            dot_tag.parent.replaceWith(graph_soup)\n\n        self.main_soup.body.append(markdown_soup)\n        return self.main_soup.prettify()", "label": 1}
{"code": "private int getLiteralId(String literal) throws PersistenceBrokerException\r\n    {\r\n        ////logger.debug(\"lookup: \" + literal);\r\n        try\r\n        {\r\n            return tags.getIdByTag(literal);\r\n        }\r\n        catch (NullPointerException t)\r\n        {\r\n            throw new MetadataException(\"unknown literal: '\" + literal + \"'\",t);\r\n        }\r\n\r\n    }", "label": 0}
{"code": "def matrix2dictionary(matrix):\n    \"\"\"\n    convert matrix to dictionary of comparisons\n    \"\"\"\n    pw = {}\n    for line in matrix:\n        line = line.strip().split('\\t')\n        if line[0].startswith('#'):\n            names = line[1:]\n            continue\n        a = line[0]\n        for i, pident in enumerate(line[1:]):\n            b = names[i]\n            if a not in pw:\n                pw[a] = {}\n            if b not in pw:\n                pw[b] = {}\n            if pident != '-':\n                pident = float(pident)\n            pw[a][b] = pident\n            pw[b][a] = pident\n    return pw", "label": 1}
{"code": "function _gpfIsLiteralObject (value) {\n    return value instanceof Object\n            && _gpfObjectToString.call(value) === \"[object Object]\"\n            && Object.getPrototypeOf(value) === Object.getPrototypeOf({});\n}", "label": 3}
{"code": "public function setImage($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Vision\\V1\\Image::class);\n        $this->image = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func wrapValue(rval reflect.Value, rtype reflect.Type) interface{} {\n\tpval := rval.Interface()\n\n\tif rval.Kind() == reflect.Slice {\n\t\t// Convert slice to types.ArrayOf*\n\t\tswitch v := pval.(type) {\n\t\tcase []string:\n\t\t\tpval = &types.ArrayOfString{\n\t\t\t\tString: v,\n\t\t\t}\n\t\tcase []uint8:\n\t\t\tpval = &types.ArrayOfByte{\n\t\t\t\tByte: v,\n\t\t\t}\n\t\tcase []int16:\n\t\t\tpval = &types.ArrayOfShort{\n\t\t\t\tShort: v,\n\t\t\t}\n\t\tcase []int32:\n\t\t\tpval = &types.ArrayOfInt{\n\t\t\t\tInt: v,\n\t\t\t}\n\t\tcase []int64:\n\t\t\tpval = &types.ArrayOfLong{\n\t\t\t\tLong: v,\n\t\t\t}\n\t\tdefault:\n\t\t\tkind := rtype.Elem().Name()\n\t\t\t// Remove govmomi interface prefix name\n\t\t\tkind = strings.TrimPrefix(kind, \"Base\")\n\t\t\takind, _ := defaultMapType(\"ArrayOf\" + kind)\n\t\t\ta := reflect.New(akind)\n\t\t\ta.Elem().FieldByName(kind).Set(rval)\n\t\t\tpval = a.Interface()\n\t\t}\n\t}\n\n\treturn pval\n}", "label": 5}
{"code": "def _threeDdot_simple(M,a):\n    \"Return Ma, where M is a 3x3 transformation matrix, for each pixel\"\n\n    result = np.empty(a.shape,dtype=a.dtype)\n\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            A = np.array([a[i,j,0],a[i,j,1],a[i,j,2]]).reshape((3,1))\n            L = np.dot(M,A)\n            result[i,j,0] = L[0]\n            result[i,j,1] = L[1]\n            result[i,j,2] = L[2]\n\n    return result", "label": 1}
{"code": "public static void writeStringToFile(String contents, String path, String encoding) throws IOException {\r\n\t\tOutputStream writer = null;\r\n\t\tif (path.endsWith(\".gz\")) {\r\n      writer = new GZIPOutputStream(new FileOutputStream(path));\r\n    } else {\r\n      writer = new BufferedOutputStream(new FileOutputStream(path));\r\n    }\r\n\t\twriter.write(contents.getBytes(encoding));\r\n\t}", "label": 0}
{"code": "public static base_responses renumber(nitro_service client, nspbr6 resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tnspbr6 renumberresources[] = new nspbr6[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\trenumberresources[i] = new nspbr6();\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, renumberresources,\"renumber\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "private static String get(Properties p, String key, String defaultValue, Set<String> used){\r\n    String rtn = p.getProperty(key, defaultValue);\r\n    used.add(key);\r\n    return rtn;\r\n  }", "label": 0}
{"code": "function _getHandlerAttribute (member, handlerAttributeArray) {\n        var attribute;\n        if (1 !== handlerAttributeArray.length()) {\n            gpf.Error.htmlHandlerMultiplicityError({\n                member: member\n            });\n        }\n        attribute = handlerAttributeArray.get(0);\n        if (!(attribute instanceof _HtmEvent)) {\n            return attribute;\n        }\n        return null;\n    }", "label": 3}
{"code": "function(callback) {\n          var page = apos.data.aposPages.page;\n          var _id = page._id;\n          $.get('/apos-pages/info', { _id: _id }, function(data) {\n            var newPathname = data.slug.replace(/^\\/\\//, '/');\n            apos.redirect(newPathname);\n          }).error(function() {\n            // If the page no longer exists, navigate away to home page\n            apos.redirect('/');\n          });\n        }", "label": 3}
{"code": "func New(cfg Config) (*Mux, error) {\n\tif err := cfg.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tctx, cancel := context.WithCancel(cfg.Context)\n\twaitContext, waitCancel := context.WithCancel(context.TODO())\n\treturn &Mux{\n\t\tEntry: log.WithFields(log.Fields{\n\t\t\ttrace.Component: teleport.Component(\"mx\", cfg.ID),\n\t\t}),\n\t\tConfig:      cfg,\n\t\tcontext:     ctx,\n\t\tcancel:      cancel,\n\t\tsshListener: newListener(ctx, cfg.Listener.Addr()),\n\t\ttlsListener: newListener(ctx, cfg.Listener.Addr()),\n\t\twaitContext: waitContext,\n\t\twaitCancel:  waitCancel,\n\t}, nil\n}", "label": 5}
{"code": "public function setActions($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\Action::class);\n        $this->actions = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function parsePlugins(config) {\n  let plugins = [];\n\n  function parse(plugins) {\n    return plugins.map(plugin => {\n      if ('string' == typeof plugin) plugin = path.resolve(plugin);\n      return plugin;\n    });\n  }\n\n  // Handle plugin paths defined in config file\n  if (config.plugins) {\n    plugins.push(...parse(config.plugins));\n    delete config.plugins;\n  }\n  // Handle plugin paths/functions defined in runtime options\n  if (config.runtimeOptions.plugins) {\n    plugins.push(...parse(config.runtimeOptions.plugins));\n    delete config.runtimeOptions.plugins;\n  }\n\n  return plugins;\n}", "label": 3}
{"code": "def update_from(other)\n      @permissions = other.permissions\n      @name = other.name\n      @hoist = other.hoist\n      @colour = other.colour\n      @position = other.position\n      @managed = other.managed\n    end", "label": 4}
{"code": "public static function genericMacro($macro, $priority = 0)\n    {\n        if (!isset(static::$globalGenericMacros[$priority])) {\n            static::$globalGenericMacros[$priority] = [];\n            krsort(static::$globalGenericMacros, SORT_NUMERIC);\n        }\n\n        static::$globalGenericMacros[$priority][] = $macro;\n    }", "label": 2}
{"code": "public SimpleFeatureSource getFeatureSource() throws LayerException {\n\t\ttry {\n\t\t\tif (dataStore instanceof WFSDataStore) {\n\t\t\t\treturn dataStore.getFeatureSource(featureSourceName.replace(\":\", \"_\"));\n\t\t\t} else {\n\t\t\t\treturn dataStore.getFeatureSource(featureSourceName);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new LayerException(e, ExceptionCode.FEATURE_MODEL_PROBLEM,\n\t\t\t\t\t\"Cannot find feature source \" + featureSourceName);\n\t\t} catch (NullPointerException e) {\n\t\t\tthrow new LayerException(e, ExceptionCode.FEATURE_MODEL_PROBLEM,\n\t\t\t\t\t\"Cannot find feature source \" + featureSourceName);\n\t\t}\n\t}", "label": 0}
{"code": "protected function get_custom_vendor_folder() {\n\t\t$maybe_composer_json = WP_CLI_ROOT . '/../../../composer.json';\n\t\tif ( ! is_readable( $maybe_composer_json ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$composer = json_decode( file_get_contents( $maybe_composer_json ) );\n\n\t\tif ( ! empty( $composer->config )\n\t\t\t&& ! empty( $composer->config->{'vendor-dir'} )\n\t\t) {\n\t\t\treturn $composer->config->{'vendor-dir'};\n\t\t}\n\n\t\treturn false;\n\t}", "label": 2}
{"code": "def handle_error(self, error, url):\n        '''Try to resolve the given error, which should be a response\n        to the given URL, by discharging any macaroon contained in\n        it. That is, if error.code is ERR_DISCHARGE_REQUIRED\n        then it will try to discharge err.info.macaroon. If the discharge\n        succeeds, the discharged macaroon will be saved to the client's cookie\n        jar, otherwise an exception will be raised.\n        '''\n        if error.info is None or error.info.macaroon is None:\n            raise BakeryException('unable to read info in discharge error '\n                                  'response')\n\n        discharges = bakery.discharge_all(\n            error.info.macaroon,\n            self.acquire_discharge,\n            self.key,\n        )\n        macaroons = '[' + ','.join(map(utils.macaroon_to_json_string,\n                                       discharges)) + ']'\n        all_macaroons = base64.urlsafe_b64encode(utils.to_bytes(macaroons))\n\n        full_path = urljoin(url, error.info.macaroon_path)\n        if error.info.cookie_name_suffix is not None:\n            name = 'macaroon-' + error.info.cookie_name_suffix\n        else:\n            name = 'macaroon-auth'\n        expires = checkers.macaroons_expiry_time(checkers.Namespace(), discharges)\n        self.cookies.set_cookie(utils.cookie(\n            name=name,\n            value=all_macaroons.decode('ascii'),\n            url=full_path,\n            expires=expires,\n        ))", "label": 1}
{"code": "def delete_action_cache(self, action_key):\n        \"\"\"Delete action needs and excludes from cache.\n\n        .. note:: It returns the action if a cache system is defined.\n\n        :param action_key: The unique action name.\n        \"\"\"\n        if self.cache:\n            self.cache.delete(\n                self.app.config['ACCESS_ACTION_CACHE_PREFIX'] +\n                action_key\n            )", "label": 1}
{"code": "def cull_nonmatching_trees(nexson, tree_id, curr_version=None):\n    \"\"\"Modifies `nexson` and returns it in version 1.2.1\n    with any tree that does not match the ID removed.\n\n    Note that this does not search through the NexSON for\n    every node, edge, tree that was deleted. So the resulting\n    NexSON may have broken references !\n    \"\"\"\n    if curr_version is None:\n        curr_version = detect_nexson_version(nexson)\n    if not _is_by_id_hbf(curr_version):\n        nexson = convert_nexson_format(nexson, BY_ID_HONEY_BADGERFISH)\n\n    nexml_el = get_nexml_el(nexson)\n    tree_groups = nexml_el['treesById']\n    tree_groups_to_del = []\n    for tgi, tree_group in tree_groups.items():\n        tbi = tree_group['treeById']\n        if tree_id in tbi:\n            trees_to_del = [i for i in tbi.keys() if i != tree_id]\n            for tid in trees_to_del:\n                tree_group['^ot:treeElementOrder'].remove(tid)\n                del tbi[tid]\n        else:\n            tree_groups_to_del.append(tgi)\n    for tgid in tree_groups_to_del:\n        nexml_el['^ot:treesElementOrder'].remove(tgid)\n        del tree_groups[tgid]\n    return nexson", "label": 1}
{"code": "def wsgi_app(self, environ, start_response):\n        \"\"\"A basic WSGI app\"\"\"\n        @_LOCAL_MANAGER.middleware\n        def _wrapped_app(environ, start_response):\n            request = Request(environ)\n            setattr(_local, _CURRENT_REQUEST_KEY, request)\n            response = self._dispatch_request(request)\n            return response(environ, start_response)\n        return _wrapped_app(environ, start_response)", "label": 1}
{"code": "function onLauncherConnect(slaveURL) {\n    var browsers = attester.config[\"run-browser\"];\n    if (browsers) {\n        if (!Array.isArray(browsers)) {\n            browsers = [browsers];\n        }\n        var args = [slaveURL];\n        for (var i = 0, l = browsers.length; i < l; i++) {\n            var curProcess = spawn(browsers[i], args, {\n                stdio: \"pipe\"\n            });\n            curProcess.stdout.pipe(process.stdout);\n            curProcess.stderr.pipe(process.stderr);\n        }\n    }\n}", "label": 3}
{"code": "func PgEnumByEnumtypidEnumlabel(db XODB, enumtypid pgtypes.Oid, enumlabel pgtypes.Name) (*PgEnum, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, enumtypid, enumsortorder, enumlabel ` +\n\t\t`FROM pg_catalog.pg_enum ` +\n\t\t`WHERE enumtypid = $1 AND enumlabel = $2`\n\n\t// run query\n\tXOLog(sqlstr, enumtypid, enumlabel)\n\tpe := PgEnum{}\n\n\terr = db.QueryRow(sqlstr, enumtypid, enumlabel).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Oid, &pe.Ctid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pe, nil\n}", "label": 5}
{"code": "func (c *controller) IsDiagnosticEnabled() bool {\n\tc.Lock()\n\tdefer c.Unlock()\n\treturn c.DiagnosticServer.IsDiagnosticEnabled()\n}", "label": 5}
{"code": "public void loadClassifier(File file, Properties props) throws ClassCastException, IOException,\r\n      ClassNotFoundException {\r\n    Timing.startDoing(\"Loading classifier from \" + file.getAbsolutePath());\r\n    BufferedInputStream bis;\r\n    if (file.getName().endsWith(\".gz\")) {\r\n      bis = new BufferedInputStream(new GZIPInputStream(new FileInputStream(file)));\r\n    } else {\r\n      bis = new BufferedInputStream(new FileInputStream(file));\r\n    }\r\n    loadClassifier(bis, props);\r\n    bis.close();\r\n    Timing.endDoing();\r\n  }", "label": 0}
{"code": "def request_setup req_or_uri # :nodoc:\n    req = if URI === req_or_uri then\n            Net::HTTP::Get.new req_or_uri.request_uri\n          else\n            req_or_uri\n          end\n\n    @headers.each do |pair|\n      req.add_field(*pair)\n    end\n\n    @override_headers.each do |name, value|\n      req[name] = value\n    end\n\n    unless req['Connection'] then\n      req.add_field 'Connection', 'keep-alive'\n      req.add_field 'Keep-Alive', @keep_alive\n    end\n\n    req\n  end", "label": 4}
{"code": "public static auditnslogpolicy_authenticationvserver_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauditnslogpolicy_authenticationvserver_binding obj = new auditnslogpolicy_authenticationvserver_binding();\n\t\tobj.set_name(name);\n\t\tauditnslogpolicy_authenticationvserver_binding response[] = (auditnslogpolicy_authenticationvserver_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "@Nonnull\n  public static XMLDSigValidationResult createReferenceErrors (@Nonnull @Nonempty final List <Integer> aInvalidReferences)\n  {\n    return new XMLDSigValidationResult (aInvalidReferences);\n  }", "label": 0}
{"code": "def row_style(index, style, options={})\n      offset = options.delete(:col_offset) || 0\n      cells = cols[(offset..-1)].map { |column| column[index] }.flatten.compact\n      cells.each { |cell| cell.style = style }\n    end", "label": 4}
{"code": "def update(self, permission):\n        \"\"\"In-place update of permissions.\"\"\"\n        self.needs.update(permission.needs)\n        self.excludes.update(permission.excludes)", "label": 1}
{"code": "func MakeIdentityFile(filePath string, key *Key, format IdentityFileFormat, certAuthorities []services.CertAuthority) (err error) {\n\tconst (\n\t\t// the files and the dir will be created with these permissions:\n\t\tfileMode = 0600\n\t\tdirMode  = 0700\n\t)\n\n\tif filePath == \"\" {\n\t\treturn trace.BadParameter(\"identity location is not specified\")\n\t}\n\n\tvar output io.Writer = os.Stdout\n\tswitch format {\n\t// dump user identity into a single file:\n\tcase IdentityFormatFile:\n\t\tf, err := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY, fileMode)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\toutput = f\n\t\tdefer f.Close()\n\n\t\t// write key:\n\t\tif _, err = output.Write(key.Priv); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\t// append cert:\n\t\tif _, err = output.Write(key.Cert); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\t// append trusted host certificate authorities\n\t\tfor _, ca := range certAuthorities {\n\t\t\tfor _, publicKey := range ca.GetCheckingKeys() {\n\t\t\t\tdata, err := sshutils.MarshalAuthorizedHostsFormat(ca.GetClusterName(), publicKey, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn trace.Wrap(err)\n\t\t\t\t}\n\t\t\t\tif _, err = output.Write([]byte(data)); err != nil {\n\t\t\t\t\treturn trace.Wrap(err)\n\t\t\t\t}\n\t\t\t\tif _, err = output.Write([]byte(\"\\n\")); err != nil {\n\t\t\t\t\treturn trace.Wrap(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// dump user identity into separate files:\n\tcase IdentityFormatOpenSSH:\n\t\tkeyPath := filePath\n\t\tcertPath := keyPath + \"-cert.pub\"\n\n\t\terr = ioutil.WriteFile(certPath, key.Cert, fileMode)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\n\t\terr = ioutil.WriteFile(keyPath, key.Priv, fileMode)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\tdefault:\n\t\treturn trace.BadParameter(\"unsupported identity format: %q, use either %q or %q\",\n\t\t\tformat, IdentityFormatFile, IdentityFormatOpenSSH)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "public static base_response unset(nitro_service client, filterhtmlinjectionparameter resource, String[] args) throws Exception{\n\t\tfilterhtmlinjectionparameter unsetresource = new filterhtmlinjectionparameter();\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "function unzipWorker(unzipTask, workerCb) {\n  var zipfile = unzipTask.zipfile;\n  var entry = unzipTask.entry;\n  var workingDir = unzipTask.workingDir;\n  if (/\\/$/.test(entry.fileName)) {\n    // directory file names end with '/'\n    makeExportDirectory({\n      entry: entry,\n      zipfile: zipfile,\n      workingDir: workingDir\n    }, workerCb);\n  } else {\n    // file entry\n    streamFileEntry({\n      zipfile: zipfile,\n      entry: entry,\n      workingDir: workingDir\n    }, workerCb);\n  }\n}", "label": 3}
{"code": "public static ComplexNumber Add(ComplexNumber z1, double scalar) {\r\n        return new ComplexNumber(z1.real + scalar, z1.imaginary);\r\n    }", "label": 0}
{"code": "def reload(options = nil)\n      self.class.connection.clear_query_cache\n\n      fresh_object =\n        if options && options[:lock]\n          self.class.unscoped { self.class.lock(options[:lock]).find(id) }\n        else\n          self.class.unscoped { self.class.find(id) }\n        end\n\n      @attributes = fresh_object.instance_variable_get(\"@attributes\")\n      @new_record = false\n      self\n    end", "label": 4}
{"code": "function paginateList(formSubmissionModel, params, callback) {\n  logger.debug(\"paginateList\", params);\n  var query = params.query || {};\n  var paginate = params.paginate || {};\n  var fieldModel = params.fieldModel;\n\n  //Sorting can be defined by the user\n  var sortBy = params.sortBy || {\n    submissionCompletedTimestamp: -1\n  };\n\n  formSubmissionModel.paginate(query, {\n    page: paginate.page,\n    limit: paginate.limit,\n    select: CONSTANTS.SUBMISSION_SUMMARY_FIELD_SELECTION,\n    populate: {\"path\": \"formFields.fieldId\", \"model\": fieldModel, \"select\": \"_id type name\"},\n    sortBy: sortBy,\n    lean: true\n  }, function(err, submissionsResult) {\n\n    //Returning pagination metadata. Useful for displaying tables etc.\n    var paginationResult = _.extend({\n      pages: submissionsResult.pages,\n      total: submissionsResult.total\n    }, params);\n\n    handleListResult(err, paginationResult, submissionsResult.docs, callback);\n  });\n}", "label": 3}
{"code": "public function setStorageConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\StorageConfig::class);\n        $this->storage_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function (state, transformation, res) {\n        if (!module.exports.operations.canTransform || !module.exports.operations.transform) {\n            log.warn('Transform State operation not implemented by application');\n            Utils.sendMessage(res, HttpStatus.NOT_IMPLEMENTED, JSON.stringify({ error: 'operation not implemented' }));\n            return state;\n        } else if (Utils.isNullOrEmpty(transformation)) {\n            log.error('Transformation not provided');\n            Utils.sendMessage(res, HttpStatus.BAD_REQUEST, JSON.stringify({ error: 'invalid transformation' }));\n            return state;\n        } else if (!module.exports.operations.canTransform(state, transformation)) {\n            log.error('Unable to apply transformation:', transformation);\n            Utils.sendMessage(res, HttpStatus.BAD_REQUEST, JSON.stringify({ error: 'invalid transformation' }));\n            return state;\n        }\n        const result = module.exports.operations.transform(state, transformation);\n        log.info('Successfully transformed state');\n        log.debug('Transformed state from:', state, 'into:', result, 'using transformation:', transformation);\n        Utils.sendMessage(res, HttpStatus.OK, JSON.stringify(result));\n        return result;\n    }", "label": 3}
{"code": "def to_hash\n      data = {}\n      data[:start_time] = TimeUtil.serialize_time(start_time)\n      data[:start_date] = data[:start_time] if IceCube.compatibility <= 11\n      data[:end_time] = TimeUtil.serialize_time(end_time) if end_time\n      data[:rrules] = recurrence_rules.map(&:to_hash)\n      if IceCube.compatibility <= 11 && exception_rules.any?\n        data[:exrules] = exception_rules.map(&:to_hash)\n      end\n      data[:rtimes] = recurrence_times.map do |rt|\n        TimeUtil.serialize_time(rt)\n      end\n      data[:extimes] = exception_times.map do |et|\n        TimeUtil.serialize_time(et)\n      end\n      data\n    end", "label": 4}
{"code": "function (char) {\n                var\n                    newState,\n                    tagsOpened = 0 < this._openedTags.length;\n                if (\"#\" === char) {\n                    this._hLevel = 1;\n                    newState = this._parseTitle;\n                } else if (\"*\" === char || \"0\" <= char && \"9\" >= char ) {\n                    if (char !== \"*\") {\n                        this._numericList = 1;\n                    } else {\n                        this._numericList = 0;\n                    }\n                    newState = this._parseList;\n                    tagsOpened = false; // Wait for disambiguation\n                } else if (\" \" !== char && \"\\t\" !== char && \"\\n\" !== char) {\n                    if (tagsOpened) {\n                        this._output(\" \");\n                        tagsOpened = false; // Avoid closing below\n                    } else {\n                        this._openTag(\"p\");\n                    }\n                    newState = this._parseContent(char);\n                    if (!newState) {\n                        newState = this._parseContent;\n                    }\n                }\n                if (tagsOpened) {\n                    this._closeTags();\n                }\n                return newState;\n            }", "label": 3}
{"code": "private function buildSubscription(array &$args, $required = false)\n    {\n        $pushConfig = $this->pluck('pushConfig', $args, $required);\n        $pushConfig = $pushConfig\n            ? $this->buildPushConfig($pushConfig)\n            : null;\n\n        return $this->serializer->decodeMessage(new Subscription(), array_filter([\n            'name' => $this->pluck('name', $args, $required),\n            'topic' => $this->pluck('topic', $args, $required),\n            'pushConfig' => $pushConfig,\n            'ackDeadlineSeconds' => $this->pluck('ackDeadlineSeconds', $args, $required),\n            'retainAckedMessages' => $this->pluck('retainAckedMessages', $args, $required),\n            'messageRetentionDuration' => $this->pluck('messageRetentionDuration', $args, $required),\n        ]));\n    }", "label": 2}
{"code": "def comment(text)\n      if text[0..1] == '!['\n        revealed = true\n        text = text[1..-1]\n      else\n        revealed = false\n      end\n\n      conditional, text = balance(text, ?[, ?]) if text[0] == ?[\n      text.strip!\n\n      if contains_interpolation?(text)\n        parse = true\n        text = unescape_interpolation(text)\n      else\n        parse = false\n      end\n\n      if block_opened? && !text.empty?\n        raise SyntaxError.new(Haml::Error.message(:illegal_nesting_content), @next_line.index)\n      end\n\n      ParseNode.new(:comment, @line.index + 1, :conditional => conditional, :text => text, :revealed => revealed, :parse => parse)\n    end", "label": 4}
{"code": "private int indexFor(int hash)\r\n    {\r\n        // mix the bits to avoid bucket collisions...\r\n        hash += ~(hash << 15);\r\n        hash ^= (hash >>> 10);\r\n        hash += (hash << 3);\r\n        hash ^= (hash >>> 6);\r\n        hash += ~(hash << 11);\r\n        hash ^= (hash >>> 16);\r\n        return hash & (table.length - 1);\r\n    }", "label": 0}
{"code": "func MsTableForeignKeys(db XODB, schema string, table string) ([]*ForeignKey, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`f.name AS foreign_key_name, ` +\n\t\t`c.name AS column_name, ` +\n\t\t`o.name AS ref_table_name, ` +\n\t\t`x.name AS ref_column_name ` +\n\t\t`FROM sysobjects f ` +\n\t\t`INNER JOIN sysobjects t ON f.parent_obj = t.id ` +\n\t\t`INNER JOIN sysreferences r ON f.id = r.constid ` +\n\t\t`INNER JOIN sysobjects o ON r.rkeyid = o.id ` +\n\t\t`INNER JOIN syscolumns c ON r.rkeyid = c.id AND r.rkey1 = c.colid ` +\n\t\t`INNER JOIN syscolumns x ON r.fkeyid = x.id AND r.fkey1 = x.colid ` +\n\t\t`WHERE f.type = 'F' AND t.type = 'U' AND SCHEMA_NAME(t.uid) = $1 AND t.name = $2`\n\n\t// run query\n\tXOLog(sqlstr, schema, table)\n\tq, err := db.Query(sqlstr, schema, table)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer q.Close()\n\n\t// load results\n\tres := []*ForeignKey{}\n\tfor q.Next() {\n\t\tfk := ForeignKey{}\n\n\t\t// scan\n\t\terr = q.Scan(&fk.ForeignKeyName, &fk.ColumnName, &fk.RefTableName, &fk.RefColumnName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres = append(res, &fk)\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "function getNodesToHide(node) {\n      node = node || this.clickedNode;\n      if(!this.config.constrained) {\n        return [];\n      }\n      var Geom = this.geom;\n      var graph = this.graph;\n      var canvas = this.canvas;\n      var level = node._depth, nodeArray = [];\n  \t  graph.eachNode(function(n) {\n          if(n.exist && !n.selected) {\n              if(n.isDescendantOf(node.id)) {\n                if(n._depth <= level) nodeArray.push(n);\n              } else {\n                nodeArray.push(n);\n              }\n          }\n  \t  });\n  \t  var leafLevel = Geom.getRightLevelToShow(node, canvas);\n  \t  node.eachLevel(leafLevel, leafLevel, function(n) {\n          if(n.exist && !n.selected) nodeArray.push(n);\n  \t  });\n  \t    \n  \t  for (var i = 0; i < nodesInPath.length; i++) {\n  \t    var n = this.graph.getNode(nodesInPath[i]);\n  \t    if(!n.isDescendantOf(node.id)) {\n  \t      nodeArray.push(n);\n  \t    }\n  \t  } \n  \t  return nodeArray;       \n    }", "label": 3}
{"code": "func PgEnumByOid(db XODB, oid pgtypes.Oid) (*PgEnum, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, enumtypid, enumsortorder, enumlabel ` +\n\t\t`FROM pg_catalog.pg_enum ` +\n\t\t`WHERE oid = $1`\n\n\t// run query\n\tXOLog(sqlstr, oid)\n\tpe := PgEnum{}\n\n\terr = db.QueryRow(sqlstr, oid).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Oid, &pe.Ctid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pe, nil\n}", "label": 5}
{"code": "def ready_to_send!\n      identify_and_set_transfer_encoding\n      parts.each do |part|\n        part.transport_encoding = transport_encoding\n        part.ready_to_send!\n      end\n      add_required_fields\n    end", "label": 4}
{"code": "function write(id, chunk) {\n        // They want to write to our real stream\n        var stream = streams[id];\n        if (!stream) return;\n        stream.write(chunk);\n    }", "label": 3}
{"code": "def parse_integer attr_name, xpath\n      v = parse_value xpath\n      v = v.to_i if v.respond_to?(:to_i)\n      send(\"#{attr_name}=\", v)\n    end", "label": 4}
{"code": "func (r *Registry) AppendReference(obj mo.Reference, field *[]types.ManagedObjectReference, ref ...types.ManagedObjectReference) {\n\tr.WithLock(obj, func() {\n\t\t*field = append(*field, ref...)\n\t})\n}", "label": 5}
{"code": "public static base_response delete(nitro_service client, String network) throws Exception {\n\t\troute6 deleteresource = new route6();\n\t\tdeleteresource.network = network;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "function importProjects(req, res, next) {\n  var options = req.connectionOptions;\n\n  var appFormsToImport = req.body || [];\n\n  if (!_.isArray(appFormsToImport)) {\n    return next(\"Expected An Array Of App Form Entries\");\n  }\n\n  forms.importAppForms(options, appFormsToImport, formsResultHandlers(constants.resultTypes.formProjects, req, next));\n}", "label": 3}
{"code": "public function setNetworkConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Container\\V1\\NetworkConfig::class);\n        $this->network_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def disconnect(self, id): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Close proxy connection to a device's management interface.\n\n        :param id: Device ID as an int.\n        \"\"\"\n        return self.service.post(self.base+str(id)+'/disconnect/')", "label": 1}
{"code": "private function buildTable(Mapping\\ClassMetadata $metadata)\n    {\n        $tableName     = $this->classToTableNames[$metadata->getClassName()];\n        $indexes       = $this->tables[$tableName]->getIndexes();\n        $tableMetadata = new Mapping\\TableMetadata();\n\n        $tableMetadata->setName($this->classToTableNames[$metadata->getClassName()]);\n\n        foreach ($indexes as $index) {\n            /** @var Index $index */\n            if ($index->isPrimary()) {\n                continue;\n            }\n\n            $tableMetadata->addIndex([\n                'name'    => $index->getName(),\n                'columns' => $index->getColumns(),\n                'unique'  => $index->isUnique(),\n                'options' => $index->getOptions(),\n                'flags'   => $index->getFlags(),\n            ]);\n        }\n\n        $metadata->setTable($tableMetadata);\n    }", "label": 2}
{"code": "public static base_response unset(nitro_service client, nstimeout resource, String[] args) throws Exception{\n\t\tnstimeout unsetresource = new nstimeout();\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "def which(bin)\n    if absolute_path?(bin)\n      return bin if FileTest.file? bin and FileTest.executable? bin\n    else\n      exts = Puppet::Util.get_env('PATHEXT')\n      exts = exts ? exts.split(File::PATH_SEPARATOR) : %w[.COM .EXE .BAT .CMD]\n      Puppet::Util.get_env('PATH').split(File::PATH_SEPARATOR).each do |dir|\n        begin\n          dest = File.expand_path(File.join(dir, bin))\n        rescue ArgumentError => e\n          # if the user's PATH contains a literal tilde (~) character and HOME is not set, we may get\n          # an ArgumentError here.  Let's check to see if that is the case; if not, re-raise whatever error\n          # was thrown.\n          if e.to_s =~ /HOME/ and (Puppet::Util.get_env('HOME').nil? || Puppet::Util.get_env('HOME') == \"\")\n            # if we get here they have a tilde in their PATH.  We'll issue a single warning about this and then\n            # ignore this path element and carry on with our lives.\n            #TRANSLATORS PATH and HOME are environment variables and should not be translated\n            Puppet::Util::Warnings.warnonce(_(\"PATH contains a ~ character, and HOME is not set; ignoring PATH element '%{dir}'.\") % { dir: dir })\n          elsif e.to_s =~ /doesn't exist|can't find user/\n            # ...otherwise, we just skip the non-existent entry, and do nothing.\n            #TRANSLATORS PATH is an environment variable and should not be translated\n            Puppet::Util::Warnings.warnonce(_(\"Couldn't expand PATH containing a ~ character; ignoring PATH element '%{dir}'.\") % { dir: dir })\n          else\n            raise\n          end\n        else\n          if Puppet::Util::Platform.windows? && File.extname(dest).empty?\n            exts.each do |ext|\n              destext = File.expand_path(dest + ext)\n              return destext if FileTest.file? destext and FileTest.executable? destext\n            end\n          end\n          return dest if FileTest.file? dest and FileTest.executable? dest\n        end\n      end\n    end\n    nil\n  end", "label": 4}
{"code": "public static function accessDenied($hint = null, $redirectUri = null, Throwable $previous = null)\n    {\n        return new static(\n            'The resource owner or authorization server denied the request.',\n            9,\n            'access_denied',\n            401,\n            $hint,\n            $redirectUri,\n            $previous\n        );\n    }", "label": 2}
{"code": "def download(self, id, seq, intf, inline=False): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Download a capture as a PCAP file.\n\n        :param id: Result ID as an int.\n        :param seq: TestResult sequence ID as an int.\n        :param intf: Interface name as string.\n        :param inline: (optional) Use inline version of capture file.\n        :rtype: tuple `(io.BytesIO, 'filename')`\n        \"\"\"\n        resp = self.service.get_id(self._base(id, seq), intf, params={'format': 'cap', 'inline': inline}, stream=True)\n        b = io.BytesIO()\n        stream.stream_response_to_file(resp, path=b)\n        resp.close()\n        b.seek(0)\n        return (b, self.service.filename(resp))", "label": 1}
{"code": "function(input, remoteData)\n    {\n      if ( input instanceof Model )\n      {\n        return input;\n      }\n\n      var discriminatedValue = isValue( input ) ? input[ this.discriminator ] : null;\n      var model = this.discriminatorsToModel[ discriminatedValue ];\n\n      return model ? model.Database.parseModel( input, remoteData ) : null;\n    }", "label": 3}
{"code": "public function access_request(\n        $realm,\n        $exclusive = false,\n        $passive = false,\n        $active = false,\n        $write = false,\n        $read = false\n    ) {\n        list($class_id, $method_id, $args) = $this->protocolWriter->accessRequest(\n            $realm,\n            $exclusive,\n            $passive,\n            $active,\n            $write,\n            $read\n        );\n\n        $this->send_method_frame(array($class_id, $method_id), $args);\n\n        return $this->wait(array(\n            $this->waitHelper->get_wait('access.request_ok')\n        ), false, $this->channel_rpc_timeout);\n    }", "label": 2}
{"code": "function (infos, silent) {\n\t\teach(infos, function (info) {\n\t\t\tinfo.key.destroy(silent);\n\t\t\tinfo.value.destroy(silent);\n\t\t\tinfo.index.destroy(silent);\n\t\t});\n\t}", "label": 3}
{"code": "def sub(pat, rep)\n      inject(self.class.new) { |res, fn| res << fn.sub(pat, rep) }\n    end", "label": 4}
{"code": "def task(func, *args, **kwargs):\n    '''Composition of decorator functions for inherent self-documentation on\n    task execution.\n\n    On execution, each task prints out its name and its first docstring line.\n    '''\n    prefix = '\\n# '\n    tail = '\\n'\n    return fabric.api.task(\n        print_full_name(color=magenta,\n                        prefix=prefix,\n                        tail=tail)(print_doc1(func)),\n        *args,\n        **kwargs)", "label": 1}
{"code": "public function sendSetPrivacySettings($category, $value)\n    {\n        $msgId = $this->createIqId();\n        $categoryNode = new ProtocolNode('category',\n            [\n                'name'  => $category,\n                'value' => $value,\n            ], null, null);\n\n        $privacyNode = new ProtocolNode('privacy', null, [$categoryNode], null);\n        $node = new ProtocolNode('iq',\n            [\n                'to'    => Constants::WHATSAPP_SERVER,\n                'type'  => 'set',\n                'id'    => $msgId,\n                'xmlns' => 'privacy',\n            ], [$privacyNode], null);\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "func NewBasicACI(dir string, name string) (*os.File, error) {\n\tmanifest := schema.ImageManifest{\n\t\tACKind:    schema.ImageManifestKind,\n\t\tACVersion: schema.AppContainerVersion,\n\t\tName:      types.ACIdentifier(name),\n\t}\n\n\tb, err := manifest.MarshalJSON()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewACI(dir, string(b), nil)\n}", "label": 5}
{"code": "def upgradeUpload(self, file):\n        \"\"\"Upgrade the firmware of the miner.\"\"\"\n        files = {'upfile': open(file, 'rb')}\n        return self.__post_files('/upgrade/upload',\n                                 files=files)", "label": 1}
{"code": "function( iframe, options ) {\n\t\tvar sandbox = iframe.getAttribute(\"sandbox\");\n\t\tif (typeof sandbox === \"string\" && !sandboxAllow.test(sandbox)) {\n\t\t\tif (options && options.force) {\n\t\t\t\tiframe.removeAttribute(\"sandbox\");\n\t\t\t} else if (!options || options.force !== false) {\n\t\t\t\tlogError(sandboxMsg);\n\t\t\t\tiframe.setAttribute(\"data-srcdoc-polyfill\", sandboxMsg);\n\t\t\t}\n\t\t}\n\t}", "label": 3}
{"code": "function getTypeForBindingElement(declaration) {\n            var pattern = declaration.parent;\n            var parentType = getTypeForBindingElementParent(pattern.parent);\n            // If parent has the unknown (error) type, then so does this binding element\n            if (parentType === unknownType) {\n                return unknownType;\n            }\n            // If no type was specified or inferred for parent, or if the specified or inferred type is any,\n            // infer from the initializer of the binding element if one is present. Otherwise, go with the\n            // undefined or any type of the parent.\n            if (!parentType || isTypeAny(parentType)) {\n                if (declaration.initializer) {\n                    return checkExpressionCached(declaration.initializer);\n                }\n                return parentType;\n            }\n            var type;\n            if (pattern.kind === 167 /* ObjectBindingPattern */) {\n                // Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)\n                var name_11 = declaration.propertyName || declaration.name;\n                if (isComputedNonLiteralName(name_11)) {\n                    // computed properties with non-literal names are treated as 'any'\n                    return anyType;\n                }\n                if (declaration.initializer) {\n                    getContextualType(declaration.initializer);\n                }\n                // Use type of the specified property, or otherwise, for a numeric name, the type of the numeric index signature,\n                // or otherwise the type of the string index signature.\n                var text = getTextOfPropertyName(name_11);\n                type = getTypeOfPropertyOfType(parentType, text) ||\n                    isNumericLiteralName(text) && getIndexTypeOfType(parentType, 1 /* Number */) ||\n                    getIndexTypeOfType(parentType, 0 /* String */);\n                if (!type) {\n                    error(name_11, ts.Diagnostics.Type_0_has_no_property_1_and_no_string_index_signature, typeToString(parentType), ts.declarationNameToString(name_11));\n                    return unknownType;\n                }\n            }\n            else {\n                // This elementType will be used if the specific property corresponding to this index is not\n                // present (aka the tuple element property). This call also checks that the parentType is in\n                // fact an iterable or array (depending on target language).\n                var elementType = checkIteratedTypeOrElementType(parentType, pattern, /*allowStringInput*/ false);\n                if (!declaration.dotDotDotToken) {\n                    // Use specific property type when parent is a tuple or numeric index type when parent is an array\n                    var propName = \"\" + ts.indexOf(pattern.elements, declaration);\n                    type = isTupleLikeType(parentType)\n                        ? getTypeOfPropertyOfType(parentType, propName)\n                        : elementType;\n                    if (!type) {\n                        if (isTupleType(parentType)) {\n                            error(declaration, ts.Diagnostics.Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2, typeToString(parentType), getTypeReferenceArity(parentType), pattern.elements.length);\n                        }\n                        else {\n                            error(declaration, ts.Diagnostics.Type_0_has_no_property_1, typeToString(parentType), propName);\n                        }\n                        return unknownType;\n                    }\n                }\n                else {\n                    // Rest element has an array type with the same element type as the parent type\n                    type = createArrayType(elementType);\n                }\n            }\n            // In strict null checking mode, if a default value of a non-undefined type is specified, remove\n            // undefined from the final type.\n            if (strictNullChecks && declaration.initializer && !(getFalsyFlags(checkExpressionCached(declaration.initializer)) & 2048 /* Undefined */)) {\n                type = getTypeWithFacts(type, 131072 /* NEUndefined */);\n            }\n            return declaration.initializer ?\n                getUnionType([type, checkExpressionCached(declaration.initializer)], /*subtypeReduction*/ true) :\n                type;\n        }", "label": 3}
{"code": "def run_and_transform\n      if output = check_for_requirements\n        status = :fail\n      else\n        result = Overcommit::Utils.with_environment(@config.fetch('env') { {} }) { run }\n        status, output = process_hook_return_value(result)\n      end\n\n      [transform_status(status), output]\n    end", "label": 4}
{"code": "def app\n      @app || @app_build_lock.synchronize {\n        @app ||= begin\n          stack = default_middleware_stack\n          config.middleware = build_middleware.merge_into(stack)\n          config.middleware.build(endpoint)\n        end\n      }\n    end", "label": 4}
{"code": "def connect(endpoint, port, ssrc)\n      @endpoint = endpoint\n      @endpoint = @endpoint[6..-1] if @endpoint.start_with? 'wss://'\n      @endpoint = @endpoint.gsub(':80', '') # The endpoint may contain a port, we don't want that\n      @endpoint = Resolv.getaddress @endpoint\n\n      @port = port\n      @ssrc = ssrc\n    end", "label": 4}
{"code": "def url_prefix=(url, encoder = nil)\n      uri = @url_prefix = Utils.URI(url)\n      self.path_prefix = uri.path\n\n      params.merge_query(uri.query, encoder)\n      uri.query = nil\n\n      with_uri_credentials(uri) do |user, password|\n        basic_auth user, password\n        uri.user = uri.password = nil\n      end\n    end", "label": 4}
{"code": "public static sslservice[] get(nitro_service service) throws Exception{\n\t\tsslservice obj = new sslservice();\n\t\tsslservice[] response = (sslservice[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static function signer(callable $credProvider, callable $signatureFunction)\n    {\n        return function (callable $handler) use ($signatureFunction, $credProvider) {\n            return function (\n                CommandInterface $command,\n                RequestInterface $request\n            ) use ($handler, $signatureFunction, $credProvider) {\n                $signer = $signatureFunction($command);\n                return $credProvider()->then(\n                    function (CredentialsInterface $creds)\n                    use ($handler, $command, $signer, $request) {\n                        return $handler(\n                            $command,\n                            $signer->signRequest($request, $creds)\n                        );\n                    }\n                );\n            };\n        };\n    }", "label": 2}
{"code": "function() {\n      Backbone.View.prototype.undelegateEvents.call(this);\n      _.each(this.getTrackedViews(), function(view) {\n        view.undelegateEvents();\n      });\n    }", "label": 3}
{"code": "func (d *downloader) Download(u *url.URL, out writeSyncer) error {\n\tclient, err := d.Session.Client()\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := d.Session.Request(u)\n\tif err != nil {\n\t\treturn err\n\t}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\n\tif stopNow, err := d.Session.HandleStatus(res); stopNow || err != nil {\n\t\treturn err\n\t}\n\n\treader, err := d.Session.BodyReader(res)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.Copy(out, reader); err != nil {\n\t\treturn errwrap.Wrap(fmt.Errorf(\"failed to download %q\", u.String()), err)\n\t}\n\n\tif err := out.Sync(); err != nil {\n\t\treturn errwrap.Wrap(fmt.Errorf(\"failed to sync data from %q to disk\", u.String()), err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "func (tt TemplateType) String() string {\n\tvar s string\n\tswitch tt {\n\tcase XOTemplate:\n\t\ts = \"xo_db\"\n\tcase EnumTemplate:\n\t\ts = \"enum\"\n\tcase ProcTemplate:\n\t\ts = \"proc\"\n\tcase TypeTemplate:\n\t\ts = \"type\"\n\tcase ForeignKeyTemplate:\n\t\ts = \"foreignkey\"\n\tcase IndexTemplate:\n\t\ts = \"index\"\n\tcase QueryTypeTemplate:\n\t\ts = \"querytype\"\n\tcase QueryTemplate:\n\t\ts = \"query\"\n\tdefault:\n\t\tpanic(\"unknown TemplateType\")\n\t}\n\treturn s\n}", "label": 5}
{"code": "public Object getObjectByIdentity(Identity id)\r\n            throws PersistenceBrokerException\r\n    {\r\n        checkOpen();\r\n        ObjectEnvelope envelope = objectEnvelopeTable.getByIdentity(id);\r\n        if (envelope != null)\r\n        {\r\n            return (envelope.needsDelete() ? null : envelope.getObject());\r\n        }\r\n        else\r\n        {\r\n            return getBroker().getObjectByIdentity(id);\r\n        }\r\n    }", "label": 0}
{"code": "def compare_name(given_name, family_name, question_name):\n    \"\"\"Compares a name in question to a specified name separated into given and family.\n\n    The name in question ``question_name`` can be of varying format, including\n    \"Kyle E. Niemeyer\", \"Kyle Niemeyer\", \"K. E. Niemeyer\", \"KE Niemeyer\", and\n    \"K Niemeyer\". Other possibilities include names with hyphens such as\n    \"Chih-Jen Sung\", \"C. J. Sung\", \"C-J Sung\".\n\n    Examples:\n        >>> compare_name('Kyle', 'Niemeyer', 'Kyle E Niemeyer')\n        True\n        >>> compare_name('Chih-Jen', 'Sung', 'C-J Sung')\n        True\n\n    Args:\n        given_name (`str`): Given (or first) name to be checked against.\n        family_name (`str`): Family (or last) name to be checked against.\n        question_name (`str`): The whole name in question.\n\n    Returns:\n        `bool`: The return value. True for successful comparison, False otherwise.\n    \"\"\"\n    # lowercase everything\n    given_name = given_name.lower()\n    family_name = family_name.lower()\n    question_name = question_name.lower()\n\n    # rearrange names given as \"last, first middle\"\n    if ',' in question_name:\n        name_split = question_name.split(',')\n        name_split.reverse()\n        question_name = ' '.join(name_split).strip()\n\n    # remove periods\n    question_name = question_name.replace('.', '')\n    given_name = given_name.replace('.', '')\n    family_name = family_name.replace('.', '')\n\n    # split names by , <space> - .\n    given_name = list(filter(None, re.split(r\"[, \\-.]+\", given_name)))\n    num_family_names = len(list(filter(None, re.split(\"[, .]+\", family_name))))\n\n    # split name in question by , <space> - .\n    name_split = list(filter(None, re.split(r\"[, \\-.]+\", question_name)))\n    first_name = [name_split[0]]\n    if len(name_split) > 2:\n        first_name += [n for n in name_split[1:-num_family_names]]\n\n    if len(first_name) > 1 and len(given_name) == len(first_name):\n        # both have same number of first and middle names/initials\n        for i in range(1, len(first_name)):\n            first_name[i] = first_name[i][0]\n            given_name[i] = given_name[i][0]\n    elif len(given_name) != len(first_name):\n        min_names = min(len(given_name), len(first_name))\n        first_name = first_name[:min_names]\n        given_name = given_name[:min_names]\n\n    # first initial\n    if len(first_name[0]) == 1 or len(given_name[0]) == 1:\n        given_name[0] = given_name[0][0]\n        first_name[0] = first_name[0][0]\n\n    # first and middle initials combined\n    if len(first_name[0]) > 1 or len(given_name[0]) > 1:\n        given_name[0] = given_name[0][0]\n        first_name[0] = name_split[0][0]\n\n    # Hyphenated last name may need to be reconnected\n    if num_family_names == 1 and '-' in family_name:\n        num_hyphen = family_name.count('-')\n        family_name_compare = '-'.join(name_split[-(num_hyphen + 1):])\n    else:\n        family_name_compare = ' '.join(name_split[-num_family_names:])\n\n    return given_name == first_name and family_name == family_name_compare", "label": 1}
{"code": "function shiftLinesLeft(text) {\n    // Determine type of linebreak\n    let linebreak = determineLinebreaks(text);\n    if (linebreak === \"\") return text;\n\n    let lines = [];\n    lines = text.split(linebreak);\n\n    // Find amount to shift lines\n    let commonPrefix = null;\n\n    for (let i = 0; i < lines.length; i++) {\n        if (!lines[i].length) continue;\n\n        let whitespace = lines[i].match(/^\\s*/);\n        if (whitespace) whitespace = whitespace[0];\n        else whitespace = \"\";\n\n        if (commonPrefix === null || commonPrefix.startsWith(whitespace)) commonPrefix = whitespace;\n    }\n\n    // Shift lines and return result\n    text = \"\";\n    let shift = commonPrefix.length;\n\n    for (let i = 0; i < lines.length; i++) {\n        if (lines[i].length) {\n            lines[i] = lines[i].slice(shift, lines[i].length);\n        }\n\n        text += lines[i] + linebreak;\n    }\n\n    return text;\n}", "label": 3}
{"code": "def allow(self, ctx, ops):\n        ''' Checks that the authorizer's request is authorized to\n        perform all the given operations. Note that allow does not check\n        first party caveats - if there is more than one macaroon that may\n        authorize the request, it will choose the first one that does\n        regardless.\n\n        If all the operations are allowed, an AuthInfo is returned holding\n        details of the decision and any first party caveats that must be\n        checked before actually executing any operation.\n\n        If operations include LOGIN_OP, the request should contain an\n        authentication macaroon proving the client's identity. Once an\n        authentication macaroon is chosen, it will be used for all other\n        authorization requests.\n\n        If an operation was not allowed, an exception will be raised which may\n        be:\n\n        - DischargeRequiredError holding the operations that remain to\n        be authorized in order to allow authorization to proceed\n        - PermissionDenied when no operations can be authorized and there's\n        no third party to discharge macaroons for.\n\n        @param ctx AuthContext\n        @param ops an array of Op\n        :return: an AuthInfo object.\n        '''\n        auth_info, _ = self.allow_any(ctx, ops)\n        return auth_info", "label": 1}
{"code": "def decorate(object, options = {})\n      return nil if object.nil?\n      Worker.new(decorator_class, object).call(options.reverse_merge(default_options))\n    end", "label": 4}
{"code": "def decidim_paginate(collection, paginate_params = {})\n      # Kaminari uses url_for to generate the url, but this doesn't play nice with our engine system\n      # and unless we remove these params they are added again as query string :(\n      default_params = {\n        participatory_process_id: nil,\n        component_id: nil\n      }\n\n      paginate collection, theme: \"decidim\", params: paginate_params.merge(default_params)\n    end", "label": 4}
{"code": "def _get_tool_str(self, tool):\n        \"\"\"\n        get a string representation of the tool\n        \"\"\"\n        res = tool['file'] \n        try:\n            res += '.' + tool['function']\n        except Exception as ex:\n            print('Warning - no function defined for tool ' + str(tool))\n        res += '\\n'\n        return res", "label": 1}
{"code": "public static base_responses update(nitro_service client, nsip6 resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tnsip6 updateresources[] = new nsip6[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new nsip6();\n\t\t\t\tupdateresources[i].ipv6address = resources[i].ipv6address;\n\t\t\t\tupdateresources[i].td = resources[i].td;\n\t\t\t\tupdateresources[i].nd = resources[i].nd;\n\t\t\t\tupdateresources[i].icmp = resources[i].icmp;\n\t\t\t\tupdateresources[i].vserver = resources[i].vserver;\n\t\t\t\tupdateresources[i].telnet = resources[i].telnet;\n\t\t\t\tupdateresources[i].ftp = resources[i].ftp;\n\t\t\t\tupdateresources[i].gui = resources[i].gui;\n\t\t\t\tupdateresources[i].ssh = resources[i].ssh;\n\t\t\t\tupdateresources[i].snmp = resources[i].snmp;\n\t\t\t\tupdateresources[i].mgmtaccess = resources[i].mgmtaccess;\n\t\t\t\tupdateresources[i].restrictaccess = resources[i].restrictaccess;\n\t\t\t\tupdateresources[i].state = resources[i].state;\n\t\t\t\tupdateresources[i].map = resources[i].map;\n\t\t\t\tupdateresources[i].dynamicrouting = resources[i].dynamicrouting;\n\t\t\t\tupdateresources[i].hostroute = resources[i].hostroute;\n\t\t\t\tupdateresources[i].ip6hostrtgw = resources[i].ip6hostrtgw;\n\t\t\t\tupdateresources[i].metric = resources[i].metric;\n\t\t\t\tupdateresources[i].vserverrhilevel = resources[i].vserverrhilevel;\n\t\t\t\tupdateresources[i].ospf6lsatype = resources[i].ospf6lsatype;\n\t\t\t\tupdateresources[i].ospfarea = resources[i].ospfarea;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function stackChain() {\n  this.extend = new TraceModifier();\n  this.filter = new TraceModifier();\n  this.format = new StackFormater();\n  this.version = require('./package.json').version;\n}", "label": 3}
{"code": "function DockerProc(docker, config) {\n  EventEmitter.call(this);\n\n  this.docker = docker;\n  this._createConfig = config.create;\n  this._startConfig = config.start;\n\n  this.stdout = new streams.PassThrough();\n  this.stderr = new streams.PassThrough();\n}", "label": 3}
{"code": "public void addConverter(int index, IConverter converter) {\r\n\t\tconverterList.add(index, converter);\r\n\t\tif (converter instanceof IContainerConverter) {\r\n\t\t\tIContainerConverter containerConverter = (IContainerConverter) converter;\r\n\t\t\tif (containerConverter.getElementConverter() == null) {\r\n\t\t\t\tcontainerConverter.setElementConverter(elementConverter);\r\n\t\t\t}\r\n\t\t}\r\n\t}", "label": 0}
{"code": "public Object getRealKey()\r\n    {\r\n        if(keyRealSubject != null)\r\n        {\r\n            return keyRealSubject;\r\n        }\r\n        else\r\n        {\r\n            TransactionExt tx = getTransaction();\r\n\r\n            if((tx != null) && tx.isOpen())\r\n            {\r\n                prepareKeyRealSubject(tx.getBroker());\r\n            }\r\n            else\r\n            {\r\n                if(getPBKey() != null)\r\n                {\r\n                    PBCapsule capsule = new PBCapsule(getPBKey(), null);\r\n\r\n                    try\r\n                    {\r\n                        prepareKeyRealSubject(capsule.getBroker());\r\n                    }\r\n                    finally\r\n                    {\r\n                        capsule.destroy();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    getLog().warn(\"No tx, no PBKey - can't materialise key with Identity \" + getKeyOid());\r\n                }\r\n            }\r\n        }\r\n        return keyRealSubject;\r\n    }", "label": 0}
{"code": "def make(self, host=\"localhost\", port=8082, protocol=\"http\", base_uri=\"\", os_auth_type=\"http\", **kwargs):\n        \"\"\"Initialize a session to Contrail API server\n\n        :param os_auth_type: auth plugin to use:\n            - http: basic HTTP authentification\n            - v2password: keystone v2 auth\n            - v3password: keystone v3 auth\n        :type os_auth_type: str\n        \"\"\"\n        loader = loading.base.get_plugin_loader(os_auth_type)\n        plugin_options = {opt.dest: kwargs.pop(\"os_%s\" % opt.dest)\n                          for opt in loader.get_options()\n                          if 'os_%s' % opt.dest in kwargs}\n        plugin = loader.load_from_options(**plugin_options)\n        return self.load_from_argparse_arguments(Namespace(**kwargs),\n                                                 host=host,\n                                                 port=port,\n                                                 protocol=protocol,\n                                                 base_uri=base_uri,\n                                                 auth=plugin)", "label": 1}
{"code": "public static function remove_deferred_addition( $name ) {\n\t\tif ( ! array_key_exists( $name, self::$deferred_additions ) ) {\n\t\t\tself::warning( \"Trying to remove a non-existent command addition '{$name}'.\" );\n\t\t}\n\n\t\tunset( self::$deferred_additions[ $name ] );\n\t}", "label": 2}
{"code": "public static base_responses add(nitro_service client, systemuser resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tsystemuser addresources[] = new systemuser[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new systemuser();\n\t\t\t\taddresources[i].username = resources[i].username;\n\t\t\t\taddresources[i].password = resources[i].password;\n\t\t\t\taddresources[i].externalauth = resources[i].externalauth;\n\t\t\t\taddresources[i].promptstring = resources[i].promptstring;\n\t\t\t\taddresources[i].timeout = resources[i].timeout;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public function connectAsync(ConnectionContext $ctx): \\Generator\n    {\n        $this->API->logger->logger(\"Trying connection via $ctx\", \\danog\\MadelineProto\\Logger::WARNING);\n\n        $this->ctx = $ctx->getCtx();\n        $this->datacenter = $ctx->getDc();\n        $this->stream = yield $ctx->getStream();\n        if (isset($this->old)) {\n            unset($this->old);\n        }\n\n        if (!isset($this->writer)) {\n            $this->writer = new WriteLoop($this->API, $this->datacenter);\n        }\n        if (!isset($this->reader)) {\n            $this->reader = new ReadLoop($this->API, $this->datacenter);\n        }\n        if (!isset($this->checker)) {\n            $this->checker = new CheckLoop($this->API, $this->datacenter);\n        }\n        if (!isset($this->waiter)) {\n            $this->waiter = new HttpWaitLoop($this->API, $this->datacenter);\n        }\n        if (!isset($this->updater)) {\n            $this->updater = new UpdateLoop($this->API, $this->datacenter);\n        }\n        foreach ($this->new_outgoing as $message_id) {\n            if ($this->outgoing_messages[$message_id]['unencrypted']) {\n                $promise = $this->outgoing_messages[$message_id]['promise'];\n                \\Amp\\Loop::defer(function () use ($promise) {\n                    $promise->fail(new Exception('Restart'));\n                });\n                unset($this->new_outgoing[$message_id]);\n                unset($this->outgoing_messages[$message_id]);\n            }\n        }\n        $this->http_req_count = 0;\n        $this->http_res_count = 0;\n\n        $this->writer->start();\n        $this->reader->start();\n        if (!$this->checker->start()) {\n            $this->checker->resume();\n        }\n        $this->waiter->start();\n\n        if ($this->datacenter === $this->API->settings['connection_settings']['default_dc']) {\n            $this->updater->start();\n        }\n    }", "label": 2}
{"code": "func (d proxyDial) Dial(network string, addr string, config *ssh.ClientConfig) (*ssh.Client, error) {\n\t// Build a proxy connection first.\n\tpconn, err := dialProxy(context.Background(), d.proxyHost, addr)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tif config.Timeout > 0 {\n\t\tpconn.SetReadDeadline(time.Now().Add(config.Timeout))\n\t}\n\t// Do the same as ssh.Dial but pass in proxy connection.\n\tc, chans, reqs, err := ssh.NewClientConn(pconn, addr, config)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tif config.Timeout > 0 {\n\t\tpconn.SetReadDeadline(time.Time{})\n\t}\n\treturn ssh.NewClient(c, chans, reqs), nil\n}", "label": 5}
{"code": "public static base_response unset(nitro_service client, rnat resource, String[] args) throws Exception{\n\t\trnat unsetresource = new rnat();\n\t\tunsetresource.network = resource.network;\n\t\tunsetresource.netmask = resource.netmask;\n\t\tunsetresource.td = resource.td;\n\t\tunsetresource.aclname = resource.aclname;\n\t\tunsetresource.redirectport = resource.redirectport;\n\t\tunsetresource.natip = resource.natip;\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "def render_proc(scope = Object.new, *local_names)\n      if scope.is_a?(Binding)\n        scope_object = eval(\"self\", scope)\n      else\n        scope_object = scope\n        scope = scope_object.instance_eval{binding}\n      end\n\n      begin\n        str = @temple_engine.precompiled_with_ambles(local_names)\n        eval(\n          \"Proc.new { |*_haml_locals| _haml_locals = _haml_locals[0] || {}; #{str}}\\n\",\n          scope,\n          @options.filename,\n          @options.line\n        )\n      rescue ::SyntaxError => e\n        raise SyntaxError, e.message\n      end\n    end", "label": 4}
{"code": "func (s *ServicesTestSuite) AuthPreference(c *check.C) {\n\tap, err := services.NewAuthPreference(services.AuthPreferenceSpecV2{\n\t\tType:         \"local\",\n\t\tSecondFactor: \"otp\",\n\t})\n\tc.Assert(err, check.IsNil)\n\n\terr = s.ConfigS.SetAuthPreference(ap)\n\tc.Assert(err, check.IsNil)\n\n\tgotAP, err := s.ConfigS.GetAuthPreference()\n\tc.Assert(err, check.IsNil)\n\n\tc.Assert(gotAP.GetType(), check.Equals, \"local\")\n\tc.Assert(gotAP.GetSecondFactor(), check.Equals, \"otp\")\n}", "label": 5}
{"code": "func (c *Client) Download(ctx context.Context, u *url.URL, param *Download) (io.ReadCloser, int64, error) {\n\tres, err := c.DownloadRequest(ctx, u, param)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tswitch res.StatusCode {\n\tcase http.StatusOK:\n\tdefault:\n\t\terr = errors.New(res.Status)\n\t}\n\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tr := res.Body\n\n\treturn r, res.ContentLength, nil\n}", "label": 5}
{"code": "protected void appendHavingClause(StringBuffer having, Criteria crit, StringBuffer stmt)\r\n    {\r\n        if (having.length() == 0)\r\n        {\r\n            having = null;\r\n        }\r\n\r\n        if (having != null || crit != null)\r\n        {\r\n            stmt.append(\" HAVING \");\r\n            appendClause(having, crit, stmt);\r\n        }\r\n    }", "label": 0}
{"code": "@Override\n    public boolean minimize(DifferentiableBatchFunction function, IntDoubleVector point) {\n        return minimize(function, point, null);\n    }", "label": 0}
{"code": "function func(ast) {\n  var params = list(ast[\"params\"])\n  var id = ast[\"id\"] ? to_s(ast[\"id\"]) : \"\"\n  return \"function \" + id + \"(\" + params + \") \" + to_s(ast[\"body\"])\n}", "label": 3}
{"code": "function(url, jsonObject, callback, options) {\n    var options = JSON.parse(JSON.stringify(options || {}));\n    options.headers = options.headers || {};\n    options.headers[\"Content-type\"] = \"application/json\";\n    return request(\n      url,\n      JSON.stringify(jsonObject),\n      function(err, content) {\n        if (err) {\n          return callback(err);\n        }\n        try {\n          var json = JSON.parse(content);\n        } catch (e) {\n          return callback(e);\n        }\n        callback(null, json);\n      },\n      options);\n  }", "label": 3}
{"code": "def check_route_connected_functions\n      return if Jets::Router.all_routes_valid\n\n      puts \"Deploy fail: The jets application contain invalid routes.\".color(:red)\n      puts \"Please double check the routes below map to valid controllers:\"\n      Jets::Router.invalid_routes.each do |route|\n        puts \"  /#{route.path} => #{route.controller_name}##{route.action_name}\"\n      end\n      exit 1\n    end", "label": 4}
{"code": "def performAction(self, action):\n        \"\"\" The action vector is stripped and the only element is cast to\n            integer and given to the super class.\n        \"\"\"\n        self.t += 1\n        super(ProfitTask, self).performAction(int(action[0]))\n        self.samples += 1", "label": 1}
{"code": "public static base_response delete(nitro_service client, appfwlearningdata resource) throws Exception {\n\t\tappfwlearningdata deleteresource = new appfwlearningdata();\n\t\tdeleteresource.profilename = resource.profilename;\n\t\tdeleteresource.starturl = resource.starturl;\n\t\tdeleteresource.cookieconsistency = resource.cookieconsistency;\n\t\tdeleteresource.fieldconsistency = resource.fieldconsistency;\n\t\tdeleteresource.formactionurl_ffc = resource.formactionurl_ffc;\n\t\tdeleteresource.crosssitescripting = resource.crosssitescripting;\n\t\tdeleteresource.formactionurl_xss = resource.formactionurl_xss;\n\t\tdeleteresource.sqlinjection = resource.sqlinjection;\n\t\tdeleteresource.formactionurl_sql = resource.formactionurl_sql;\n\t\tdeleteresource.fieldformat = resource.fieldformat;\n\t\tdeleteresource.formactionurl_ff = resource.formactionurl_ff;\n\t\tdeleteresource.csrftag = resource.csrftag;\n\t\tdeleteresource.csrfformoriginurl = resource.csrfformoriginurl;\n\t\tdeleteresource.xmldoscheck = resource.xmldoscheck;\n\t\tdeleteresource.xmlwsicheck = resource.xmlwsicheck;\n\t\tdeleteresource.xmlattachmentcheck = resource.xmlattachmentcheck;\n\t\tdeleteresource.totalxmlrequests = resource.totalxmlrequests;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "protected function addNodeToRing(&$ring, $node, $totalNodes, $replicas, $weightRatio)\n    {\n        $nodeObject = $node['object'];\n        $nodeHash = $this->getNodeHash($nodeObject);\n        $replicas = (int) round($weightRatio * $totalNodes * $replicas);\n\n        for ($i = 0; $i < $replicas; ++$i) {\n            $key = crc32(\"$nodeHash:$i\");\n            $ring[$key] = $nodeObject;\n        }\n    }", "label": 2}
{"code": "def message_verifier(verifier_name)\n      @message_verifiers[verifier_name] ||= begin\n        secret = key_generator.generate_key(verifier_name.to_s)\n        ActiveSupport::MessageVerifier.new(secret)\n      end\n    end", "label": 4}
{"code": "private String writeSchemata(File dir) throws IOException\r\n    {\r\n        writeCompressedTexts(dir, _torqueSchemata);\r\n\r\n        StringBuffer includes = new StringBuffer();\r\n\r\n        for (Iterator it = _torqueSchemata.keySet().iterator(); it.hasNext();)\r\n        {\r\n            includes.append((String)it.next());\r\n            if (it.hasNext())\r\n            {\r\n                includes.append(\",\");\r\n            }\r\n        }\r\n        return includes.toString();\r\n    }", "label": 0}
{"code": "function _createNewFacebookUser() {\n    var avatar = '',\n        excludedFields = ['link', 'email', 'first_name', 'last_name','picture'],\n        newUser;\n\n    //Set Image\n    if(this.socialUserInfo.picture && this.socialUserInfo.picture.data && this.socialUserInfo.picture.data.url !== ''){\n        avatar = this.socialUserInfo.picture.data.url;\n    }\n\n    newUser = {\n        role: 'external',\n        identities: {\n            facebook: {\n                id: this.socialUserInfo.id,\n                accessToken: this.creds.access_token,\n                expiresIn: this.creds.expires\n            }\n        },\n        linkedidentities: ['facebook'],\n        profile: {\n            picture: avatar\n        },\n        enabled: true,\n        email: this.socialUserInfo.email,\n        firstname: this.socialUserInfo.first_name,\n        lastname: this.socialUserInfo.last_name\n    };\n\n    _.each(profileFieldsArr, function(field){\n        if(excludedFields.indexOf(field) === -1){\n            newUser.profile[field] = this.socialUserInfo[field];\n        }\n    }.bind(this));\n\n    return db.users.insert(newUser);\n}", "label": 3}
{"code": "def reverse_geocode_ban_fr_params(query)\n      lat_lon = query.coordinates\n      params = {\n          lat: lat_lon.first,\n          lon: lat_lon.last\n      }\n      unless (type = query.options[:type]).nil? || !type_param_is_valid?(type)\n        params[:type] = type.downcase\n      end\n      params\n    end", "label": 4}
{"code": "public function setPoints($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Monitoring\\V3\\Point::class);\n        $this->points = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (r RoleMap) Check() error {\n\t_, err := r.parse()\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "func (proxy *ProxyClient) CurrentClusterAccessPoint(ctx context.Context, quiet bool) (auth.AccessPoint, error) {\n\t// get the current cluster:\n\tcluster, err := proxy.currentCluster()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn proxy.ClusterAccessPoint(ctx, cluster.Name, quiet)\n}", "label": 5}
{"code": "@Override\r\n  public void apply(TreeVisitor tp) {\r\n    for (int i = 0, size = parseTrees.size(); i < size; i++) {\r\n      tp.visitTree(parseTrees.get(i));\r\n    }\r\n    // or could do as Iterator but slower\r\n    // Iterator iter = parseTrees.iterator();\r\n    // while (iter.hasNext()) {\r\n    //    tp.visitTree((Tree) iter.next());\r\n    // }\r\n  }", "label": 0}
{"code": "function(token, this_, args){\n        //fconsole.log('getNamespace', arguments);\n        var namespace = args[0];\n        if (namespace && namespace.type == 'Literal')\n        {\n          var ns = getNamespace(namespace.value);\n          token.obj = ns.obj;\n          token.ref_ = ns.ref_;\n          if (args[1])\n            token.obj.setWrapper.run(token, this_, [args[1]]);\n        }\n      }", "label": 3}
{"code": "public static int cudnnActivationBackward(\n        cudnnHandle handle, \n        cudnnActivationDescriptor activationDesc, \n        Pointer alpha, \n        cudnnTensorDescriptor yDesc, \n        Pointer y, \n        cudnnTensorDescriptor dyDesc, \n        Pointer dy, \n        cudnnTensorDescriptor xDesc, \n        Pointer x, \n        Pointer beta, \n        cudnnTensorDescriptor dxDesc, \n        Pointer dx)\n    {\n        return checkResult(cudnnActivationBackwardNative(handle, activationDesc, alpha, yDesc, y, dyDesc, dy, xDesc, x, beta, dxDesc, dx));\n    }", "label": 0}
{"code": "def send_bulk(data, tag, chunk, bulk_message_count, extracted_values, info)\n      begin\n\n        log.on_trace { log.trace \"bulk request: #{data}\" }\n        response = client(info.host).bulk body: data, index: info.index\n        log.on_trace { log.trace \"bulk response: #{response}\" }\n\n        if response['errors']\n          error = Fluent::Plugin::ElasticsearchErrorHandler.new(self)\n          error.handle_error(response, tag, chunk, bulk_message_count, extracted_values)\n        end\n      rescue RetryStreamError => e\n        emit_tag = @retry_tag ? @retry_tag : tag\n        router.emit_stream(emit_tag, e.retry_stream)\n      rescue => e\n        ignore = @ignore_exception_classes.any? { |clazz| e.class <= clazz }\n\n        log.warn \"Exception ignored in tag #{tag}: #{e.class.name} #{e.message}\" if ignore\n\n        @_es = nil if @reconnect_on_error\n        @_es_info = nil if @reconnect_on_error\n\n        raise UnrecoverableRequestFailure if ignore && @exception_backup\n\n        # FIXME: identify unrecoverable errors and raise UnrecoverableRequestFailure instead\n        raise RecoverableRequestFailure, \"could not push logs to Elasticsearch cluster (#{connection_options_description(info.host)}): #{e.message}\" unless ignore\n      end\n    end", "label": 4}
{"code": "def deep_merge!(target, hash)\n      hash.each do |key, value|\n        target[key] = if value.is_a?(Hash) && target[key].is_a?(Hash)\n                        deep_merge(target[key], value)\n                      else\n                        value\n                      end\n      end\n      target\n    end", "label": 4}
{"code": "func Init(dc driverapi.DriverCallback, config map[string]interface{}) error {\n\tnewPluginHandler := func(name string, client *plugins.Client) {\n\t\t// negotiate driver capability with client\n\t\td := newDriver(name, client)\n\t\tc, err := d.(*driver).getCapabilities()\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error getting capability for %s due to %v\", name, err)\n\t\t\treturn\n\t\t}\n\t\tif err = dc.RegisterDriver(name, d, *c); err != nil {\n\t\t\tlogrus.Errorf(\"error registering driver for %s due to %v\", name, err)\n\t\t}\n\t}\n\n\t// Unit test code is unaware of a true PluginStore. So we fall back to v1 plugins.\n\thandleFunc := plugins.Handle\n\tif pg := dc.GetPluginGetter(); pg != nil {\n\t\thandleFunc = pg.Handle\n\t\tactivePlugins := pg.GetAllManagedPluginsByCap(driverapi.NetworkPluginEndpointType)\n\t\tfor _, ap := range activePlugins {\n\t\t\tclient, err := getPluginClient(ap)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnewPluginHandler(ap.Name(), client)\n\t\t}\n\t}\n\thandleFunc(driverapi.NetworkPluginEndpointType, newPluginHandler)\n\n\treturn nil\n}", "label": 5}
{"code": "def count_lines_in_file(self, fname=''):\n        \"\"\" you wont believe what this method does \"\"\"\n        i = 0\n        if fname == '':\n            fname = self.fullname\n        try:\n            #with open(fname, encoding=\"utf8\") as f:\n            with codecs.open(fname, \"r\",encoding='utf8', errors='ignore') as f:    \n                for i, _ in enumerate(f):\n                    pass\n            return i + 1    \n        except Exception as ex:\n            print('cant count lines in file in \"', fname, '\":', str(ex))\n            return 0", "label": 1}
{"code": "def _process_net_mhcii(mhc_file, normal=False):\n    \"\"\"\n    Process the results from running NetMHCIIpan binding predictions into a pandas dataframe.\n\n    :param str mhc_file: Output file containing netmhciipan mhcii:peptide binding predictions\n    :param bool normal: Is this processing the results of a normal?\n    :return: Results in a tabular format\n    :rtype: pandas.DataFrame\n    \"\"\"\n    results = pandas.DataFrame(columns=['allele', 'pept', 'tumor_pred', 'core', 'peptide_name'])\n    with open(mhc_file, 'r') as mf:\n        peptides = set()\n        # Get the allele from the first line and skip the second line\n        allele = re.sub('-DQB', '/DQB', mf.readline().strip())\n        _ = mf.readline()\n        for line in mf:\n            line = line.strip().split('\\t')\n            pept = line[1]\n            pred = line[5]\n            core = 'NOCORE'\n            peptide_name = line[2]\n            if float(pred) > 5.00 and not normal:\n                continue\n            results.loc[len(results)] = [allele, pept, pred, core, peptide_name]\n    results.drop_duplicates(inplace=True)\n    return results", "label": 1}
{"code": "def plugin_info_by_id(plugin_id, opts={})\n      found = all_plugins.find {|pe|\n        pe.respond_to?(:plugin_id) && pe.plugin_id.to_s == plugin_id\n      }\n      if found\n        get_monitor_info(found, opts)\n      else\n        nil\n      end\n    end", "label": 4}
{"code": "def process_send(exp, _parent)\n      process(exp)\n      case current_context\n      when Context::ModuleContext\n        handle_send_for_modules exp\n      when Context::MethodContext\n        handle_send_for_methods exp\n      end\n    end", "label": 4}
{"code": "def allowed?(name, ip)\n      if name or ip\n        # This is probably unnecessary, and can cause some weirdness in\n        # cases where we're operating over localhost but don't have a real\n        # IP defined.\n        raise Puppet::DevError, _(\"Name and IP must be passed to 'allowed?'\") unless name and ip\n        # else, we're networked and such\n      else\n        # we're local\n        return true\n      end\n\n      # yay insecure overrides\n      return true if globalallow?\n\n      if decl = declarations.find { |d| d.match?(name, ip) }\n        return decl.result\n      end\n\n      info _(\"defaulting to no access for %{name}\") % { name: name }\n      false\n    end", "label": 4}
{"code": "func (c *Cache) eraseAll() error {\n\tvar errors []error\n\tfor _, collection := range c.collections {\n\t\terrors = append(errors, collection.erase())\n\t}\n\treturn trace.NewAggregate(errors...)\n}", "label": 5}
{"code": "def undecorate(func):\n    \"\"\"Returns the decorator and the undecorated function of given object.\"\"\"\n    orig_call_wrapper = lambda x: x\n    for call_wrapper, unwrap in SUPPORTED_DECORATOR.items():\n        if isinstance(func, call_wrapper):\n            func = unwrap(func)\n            orig_call_wrapper = call_wrapper\n            break\n    return orig_call_wrapper, func", "label": 1}
{"code": "def exec_pg_success(self, cmd):\n        \"\"\"\n        Execute a command inside a running container as the postgres user,\n        asserting success.\n        \"\"\"\n        result = self.inner().exec_run(cmd, user='postgres')\n        assert result.exit_code == 0, result.output.decode('utf-8')\n        return result", "label": 1}
{"code": "protected function getPrefixKeys()\n    {\n        $options = $this->pubsub->getClient()->getOptions();\n\n        if (isset($options->prefix)) {\n            return $options->prefix->getPrefix();\n        }\n\n        return '';\n    }", "label": 2}
{"code": "public function reload(array $options = [])\n    {\n        return $this->info = $this->connection->getJob($options + $this->identity);\n    }", "label": 2}
{"code": "function tryComputeIndentationForListItem(startPos, endPos, parentStartLine, range, inheritedIndentation) {\n                if (ts.rangeOverlapsWithStartEnd(range, startPos, endPos) ||\n                    ts.rangeContainsStartEnd(range, startPos, endPos) /* Not to miss zero-range nodes e.g. JsxText */) {\n                    if (inheritedIndentation !== -1 /* Unknown */) {\n                        return inheritedIndentation;\n                    }\n                }\n                else {\n                    var startLine = sourceFile.getLineAndCharacterOfPosition(startPos).line;\n                    var startLinePosition = ts.getLineStartPositionForPosition(startPos, sourceFile);\n                    var column = formatting.SmartIndenter.findFirstNonWhitespaceColumn(startLinePosition, startPos, sourceFile, options);\n                    if (startLine !== parentStartLine || startPos === column) {\n                        // Use the base indent size if it is greater than\n                        // the indentation of the inherited predecessor.\n                        var baseIndentSize = formatting.SmartIndenter.getBaseIndentation(options);\n                        return baseIndentSize > column ? baseIndentSize : column;\n                    }\n                }\n                return -1 /* Unknown */;\n            }", "label": 3}
{"code": "private void addMembers(Collection memberNames, HashMap members, XClass type, String tagName, String paramName, String paramValue) throws XDocletException\r\n    {\r\n        if (!type.isInterface() && (type.getFields() != null)) {\r\n            XField field;\r\n\r\n            for (Iterator it = type.getFields().iterator(); it.hasNext(); ) {\r\n                field = (XField)it.next();\r\n                if (!field.isFinal() && !field.isStatic() && !field.isTransient()) {\r\n                    if (checkTagAndParam(field.getDoc(), tagName, paramName, paramValue)) {\r\n                        // already processed ?\r\n                        if (!members.containsKey(field.getName())) {\r\n                            memberNames.add(field.getName());\r\n                            members.put(field.getName(), field);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (type.getMethods() != null) {\r\n            XMethod method;\r\n            String propertyName;\r\n\r\n            for (Iterator it = type.getMethods().iterator(); it.hasNext(); ) {\r\n                method = (XMethod)it.next();\r\n                if (!method.isConstructor() && !method.isNative() && !method.isStatic()) {\r\n                    if (checkTagAndParam(method.getDoc(), tagName, paramName, paramValue)) {\r\n                        if (MethodTagsHandler.isGetterMethod(method) || MethodTagsHandler.isSetterMethod(method)) {\r\n                            propertyName = MethodTagsHandler.getPropertyNameFor(method);\r\n                            if (!members.containsKey(propertyName)) {\r\n                                memberNames.add(propertyName);\r\n                                members.put(propertyName, method);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "function formatTrace(level, context, message, args, err) {\n\n  var recontext = {\n    time: (new Date()).toISOString(),\n    lvl: level,\n    corr: context.corr || notAvailable,\n    trans: context.trans || notAvailable,\n    op: context.op || notAvailable\n  };\n\n  Object.keys(context)\n      .filter((key) => {\n        return !(context[key] && Object.prototype.toString.call(context[key]) === '[object Function]');\n      })\n      .forEach((key) => {\n        recontext[key] = context[key] || notAvailable;\n      });\n\n  if (message instanceof Date || message instanceof Error) {\n    // Node6 related hack. See https://github.com/telefonicaid/logops/issues/36\n    recontext.msg = util.format(message);\n  } else {\n    recontext.msg = message;\n  }\n\n  var str = Object.keys(recontext)\n      .map((key) => key + '=' + recontext[key])\n      .join(' | ');\n\n  args.unshift(str);\n  if (err && message !== '' + err) {\n    args.push(err);\n  }\n\n  return util.format.apply(global, args);\n}", "label": 3}
{"code": "def dump_string(s):\n    '''Stringize ``s``, adding double quotes and escaping as necessary\n\n    Backslash escape backslashes, double quotes, ``\\f``, ``\\n``, ``\\r``, and\n    ``\\t``. Escape all remaining unprintable characters in ``\\xFF``-style.\n    The returned string will be surrounded by double quotes.\n    '''\n\n    s = (s.replace('\\\\', '\\\\\\\\')\n          .replace('\"', '\\\\\"')\n          .replace('\\f', r'\\f')\n          .replace('\\n', r'\\n')\n          .replace('\\r', r'\\r')\n          .replace('\\t', r'\\t'))\n    s = UNPRINTABLE_CHARACTER_RE.sub(\n            lambda m: r'\\x{:02x}'.format(ord(m.group(0))),\n            s)\n    return '\"' + s + '\"'", "label": 1}
{"code": "public function setSentimentAnalysisRequestConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\SentimentAnalysisRequestConfig::class);\n        $this->sentiment_analysis_request_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def run(client)\n      with_child do\n        child.send_io client\n        child.gets or raise Errno::EPIPE\n      end\n\n      pid = child.gets.to_i\n\n      unless pid.zero?\n        log \"got worker pid #{pid}\"\n        pid\n      end\n    rescue Errno::ECONNRESET, Errno::EPIPE => e\n      log \"#{e} while reading from child; returning no pid\"\n      nil\n    ensure\n      client.close\n    end", "label": 4}
{"code": "def trigger?(message)\n      if @prefix.is_a? String\n        standard_prefix_trigger(message.content, @prefix)\n      elsif @prefix.is_a? Array\n        @prefix.map { |e| standard_prefix_trigger(message.content, e) }.reduce { |m, e| m || e }\n      elsif @prefix.respond_to? :call\n        @prefix.call(message)\n      end\n    end", "label": 4}
{"code": "function validateDataSource(connections, dataSource, cb) {\n  var dataSourceToValidate = _.clone(dataSource);\n  var DataSource = models.get(connections.mongooseConnection, models.MODELNAMES.DATA_SOURCE);\n\n  //Expect The Data Source To Have Data\n  var failure = validate(dataSourceToValidate).has(CONSTANTS.DATA_SOURCE_DATA);\n\n  if (failure) {\n    return cb(buildErrorResponse({\n      error: new Error(\"No Data Passed To Validate\"),\n      code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS\n    }));\n  }\n\n  //Generate A Hash\n  var hash = misc.generateHash(dataSourceToValidate.data);\n\n  //Populate A Cache Object\n  //LastRefreshed is populated just for the cache mongoose schema\n  var cache = {\n    dataHash: hash,\n    currentStatus: {\n      status: \"ok\"\n    },\n    data: dataSourceToValidate.data,\n    lastRefreshed: new Date().getTime(),\n    updateTimestamp: new Date().getTime()\n  };\n\n  dataSourceToValidate.cache = [cache];\n\n  //Create A New Mongoose. Note that this document is never saved. It is useful for consistent validation\n  var testDataSource = new DataSource(dataSourceToValidate);\n  //Validating Without Saving\n  testDataSource.validate(function(err) {\n    var valid = err ? false : true;\n    var dataSourceJSON = testDataSource.toJSON();\n\n    dataSourceJSON = processDataSourceResponse(dataSourceJSON);\n\n    dataSourceJSON = _.omit(dataSourceJSON, \"lastRefreshed\", \"currentStatus\", \"updateTimestamp\", CONSTANTS.DATA_SOURCE_ID);\n\n    dataSourceJSON.validationResult = {\n      valid: valid,\n      message: valid ? \"Data Source Is Valid\" : \"Invalid Data Source Update Data.\"\n    };\n\n    return cb(undefined, dataSourceJSON);\n  });\n}", "label": 3}
{"code": "public function setFileTypes($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::ENUM, \\Google\\Cloud\\Dlp\\V2\\FileType::class);\n        $this->file_types = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def schema_complete():\n        \"\"\"Schema for data in CollectorStage.\"\"\"\n        return Schema({\n            'stage': And(str, len),\n            'status': And(str, lambda s: s in ['started', 'succeeded', 'failed']),\n            Optional('events', default=[]): And(len, [CollectorStage.schema_event_items()])\n        })", "label": 1}
{"code": "def demodulize(path)\n      path = path.to_s\n      if i = path.rindex(\"::\")\n        path[(i + 2)..-1]\n      else\n        path\n      end\n    end", "label": 4}
{"code": "func (sink *influxdbSink) composeRawQuery(metricName string, labels map[string]string, metricKeys []core.HistoricalKey, start, end time.Time) string {\n\tseriesName, fieldName := sink.metricToSeriesAndField(metricName)\n\n\tqueries := make([]string, len(metricKeys))\n\tfor i, key := range metricKeys {\n\t\tpred := sink.keyToSelector(key)\n\t\tif labels != nil {\n\t\t\tpred += fmt.Sprintf(\" AND %s\", sink.labelsToPredicate(labels))\n\t\t}\n\t\tif !start.IsZero() {\n\t\t\tpred += fmt.Sprintf(\" AND time > '%s'\", start.Format(time.RFC3339))\n\t\t}\n\t\tif !end.IsZero() {\n\t\t\tpred += fmt.Sprintf(\" AND time < '%s'\", end.Format(time.RFC3339))\n\t\t}\n\t\tqueries[i] = fmt.Sprintf(\"SELECT time, %q FROM %q WHERE %s\", fieldName, seriesName, pred)\n\t}\n\n\treturn strings.Join(queries, \"; \")\n}", "label": 5}
{"code": "private function add($step, $name, callable $middleware, $prepend = false)\n    {\n        $this->sorted = null;\n\n        if ($prepend) {\n            $this->steps[$step][] = [$middleware, $name];\n        } else {\n            array_unshift($this->steps[$step], [$middleware, $name]);\n        }\n\n        if ($name) {\n            $this->named[$name] = $step;\n        }\n    }", "label": 2}
{"code": "func (t *Torrent) BytesCompleted() int64 {\n\tt.cl.rLock()\n\tdefer t.cl.rUnlock()\n\treturn t.bytesCompleted()\n}", "label": 5}
{"code": "func getDeviceInfo(mode os.FileMode, rdev uint64) (kind rune, major uint64, minor uint64, err error) {\n\tkind = 'b'\n\n\tif mode&os.ModeCharDevice != 0 {\n\t\tkind = 'c'\n\t}\n\n\tmajor = (rdev >> 8) & 0xfff\n\tminor = (rdev & 0xff) | ((rdev >> 12) & 0xfff00)\n\n\treturn\n}", "label": 5}
{"code": "def handle_base_populations(population_def, population)\n      {\n        HQMF::PopulationCriteria::IPP => 'initialPopulationCriteria',\n        HQMF::PopulationCriteria::DENOM => 'denominatorCriteria',\n        HQMF::PopulationCriteria::NUMER => 'numeratorCriteria',\n        HQMF::PopulationCriteria::NUMEX => 'numeratorExclusionCriteria',\n        HQMF::PopulationCriteria::DENEXCEP => 'denominatorExceptionCriteria',\n        HQMF::PopulationCriteria::DENEX => 'denominatorExclusionCriteria',\n        HQMF::PopulationCriteria::MSRPOPL => 'measurePopulationCriteria',\n        HQMF::PopulationCriteria::MSRPOPLEX => 'measurePopulationExclusionCriteria'\n      }.each_pair do |criteria_id, criteria_element_name|\n        criteria_def = population_def.at_xpath(\"cda:component[cda:#{criteria_element_name}]\", HQMF2::Document::NAMESPACES)\n        if criteria_def\n          build_population_criteria(criteria_def, criteria_id, population)\n        end\n      end\n    end", "label": 4}
{"code": "func isISBN13(fl FieldLevel) bool {\n\n\ts := strings.Replace(strings.Replace(fl.Field().String(), \"-\", \"\", 4), \" \", \"\", 4)\n\n\tif !iSBN13Regex.MatchString(s) {\n\t\treturn false\n\t}\n\n\tvar checksum int32\n\tvar i int32\n\n\tfactor := []int32{1, 3}\n\n\tfor i = 0; i < 12; i++ {\n\t\tchecksum += factor[i%2] * int32(s[i]-'0')\n\t}\n\n\treturn (int32(s[12]-'0'))-((10-(checksum%10))%10) == 0\n}", "label": 5}
{"code": "def parse(input_: Union[str, FileStream], source: str) -> Optional[str]:\n    \"\"\"Parse the text in infile and save the results in outfile\n\n    :param input_: string or stream to parse\n    :param source: source name for python file header\n    :return: python text if successful\n    \"\"\"\n\n    # Step 1: Tokenize the input stream\n    error_listener = ParseErrorListener()\n    if not isinstance(input_, FileStream):\n        input_ = InputStream(input_)\n    lexer = jsgLexer(input_)\n    lexer.addErrorListener(error_listener)\n    tokens = CommonTokenStream(lexer)\n    tokens.fill()\n    if error_listener.n_errors:\n        return None\n\n    # Step 2: Generate the parse tree\n    parser = jsgParser(tokens)\n    parser.addErrorListener(error_listener)\n    parse_tree = parser.doc()\n    if error_listener.n_errors:\n        return None\n\n    # Step 3: Transform the results the results\n    parser = JSGDocParser()\n    parser.visit(parse_tree)\n\n    if parser.undefined_tokens():\n        for tkn in parser.undefined_tokens():\n            print(\"Undefined token: \" + tkn)\n        return None\n\n    return parser.as_python(source)", "label": 1}
{"code": "def report_internal_error(exception)\n      log_error '[Rollbar] Reporting internal error encountered while sending data to Rollbar.'\n\n      configuration.execute_hook(:on_report_internal_error, exception)\n\n      begin\n        item = build_item('error', nil, exception, { :internal => true }, nil)\n      rescue StandardError => e\n        send_failsafe('build_item in exception_data', e)\n        log_error \"[Rollbar] Exception: #{exception}\"\n        return\n      end\n\n      begin\n        process_item(item)\n      rescue StandardError => e\n        send_failsafe('error in process_item', e)\n        log_error \"[Rollbar] Item: #{item}\"\n        return\n      end\n\n      begin\n        log_instance_link(item['data'])\n      rescue StandardError => e\n        send_failsafe('error logging instance link', e)\n        log_error \"[Rollbar] Item: #{item}\"\n        return\n      end\n    end", "label": 4}
{"code": "func suffixMatchLen(a, b []byte) int {\n\tif len(b) > len(a) {\n\t\tb = b[:len(a)]\n\t}\n\t// i is how much of b to try to match\n\tfor i := len(b); i > 0; i-- {\n\t\t// j is how many chars we've compared\n\t\tj := 0\n\t\tfor ; j < i; j++ {\n\t\t\tif b[i-1-j] != a[len(a)-1-j] {\n\t\t\t\tgoto shorter\n\t\t\t}\n\t\t}\n\t\treturn j\n\tshorter:\n\t}\n\treturn 0\n}", "label": 5}
{"code": "func (r *ForwardRecorder) Close() error {\n\tvar errors []error\n\terr := r.AuditLog.Close()\n\terrors = append(errors, err)\n\n\t// wait until all events from recorder get flushed, it is important\n\t// to do so before we send SessionEndEvent to advise the audit log\n\t// to release resources associated with this session.\n\t// not doing so will not result in memory leak, but could result\n\t// in missing playback events\n\tcontext, cancel := context.WithTimeout(context.TODO(), defaults.ReadHeadersTimeout)\n\tdefer cancel() // releases resources if slowOperation completes before timeout elapses\n\terr = r.AuditLog.WaitForDelivery(context)\n\tif err != nil {\n\t\terrors = append(errors, err)\n\t\tr.Warnf(\"Timeout waiting for session to flush events: %v\", trace.DebugReport(err))\n\t}\n\n\treturn trace.NewAggregate(errors...)\n}", "label": 5}
{"code": "func DeserializeTemplate(b []byte) (Template, error) {\n\ttpl := new(FpdfTpl)\n\tdec := gob.NewDecoder(bytes.NewBuffer(b))\n\terr := dec.Decode(tpl)\n\treturn tpl, err\n}", "label": 5}
{"code": "def post_build_app\n      command = BuildCommandGenerator.post_build\n\n      return if command.empty?\n\n      print_command(command, \"Generated Post-Build Command\") if FastlaneCore::Globals.verbose?\n      FastlaneCore::CommandExecutor.execute(command: command,\n                                          print_all: true,\n                                      print_command: !Gym.config[:silent],\n                                              error: proc do |output|\n                                                ErrorHandler.handle_build_error(output)\n                                              end)\n    end", "label": 4}
{"code": "def get_q_experiment(case, minor=1):\n    \"\"\" Returns an experiment that uses Q-learning.\n    \"\"\"\n    gen = case.generators\n\n    profile = array([1.0])\n    maxSteps = len(profile)\n\n    if minor == 1:\n        alpha = 0.3 # Learning rate.\n        gamma = 0.99 # Discount factor\n        # The closer epsilon gets to 0, the more greedy and less explorative.\n        epsilon = 0.9\n        decay = 0.97\n\n        tau = 150.0 # Boltzmann temperature.\n        qlambda = 0.9\n    elif minor == 2:\n        alpha = 0.1 # Learning rate.\n        gamma = 0.99 # Discount factor\n        # The closer epsilon gets to 0, the more greedy and less explorative.\n        epsilon = 0.9\n        decay = 0.99\n\n        tau = 150.0 # Boltzmann temperature.\n        qlambda = 0.9\n    else:\n        raise ValueError\n\n    market = pyreto.SmartMarket(case, priceCap=cap, decommit=decommit,\n                                auctionType=auctionType)\n\n    experiment = pyreto.continuous.MarketExperiment([], [], market, profile)\n\n    for g in gen[0:2]:\n        learner = Q(alpha, gamma)\n    #    learner = QLambda(alpha, gamma, qlambda)\n    #    learner = SARSA(alpha, gamma)\n\n        learner.explorer.epsilon = epsilon\n        learner.explorer.decay = decay\n#        learner.explorer = BoltzmannExplorer(tau, decay)\n\n        task, agent = get_discrete_task_agent([g], market, nStates, nOffer,\n            markups, withholds, maxSteps, learner)\n\n        experiment.tasks.append(task)\n        experiment.agents.append(agent)\n\n    # Passive agent.\n    task, agent = get_zero_task_agent(gen[2:3], market, nOffer, maxSteps)\n    experiment.tasks.append(task)\n    experiment.agents.append(agent)\n\n    return experiment", "label": 1}
{"code": "func (s *Server) Close() error {\n\tconns := []io.Closer{\n\t\ts.sconn,\n\t\ts.clientConn,\n\t\ts.serverConn,\n\t\ts.targetConn,\n\t\ts.remoteClient,\n\t}\n\n\tvar errs []error\n\n\tfor _, c := range conns {\n\t\tif c == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\terr := c.Close()\n\t\tif err != nil {\n\t\t\terrs = append(errs, err)\n\t\t}\n\t}\n\n\t// Signal to waiting goroutines that the server is closing (for example,\n\t// the keep alive loop).\n\ts.closeCancel()\n\n\treturn trace.NewAggregate(errs...)\n}", "label": 5}
{"code": "def lock(self, lock=True, changelist=0):\n        \"\"\"Locks or unlocks the file\n\n        :param lock: Lock or unlock the file\n        :type lock: bool\n        :param changelist: Optional changelist to checkout the file into\n        :type changelist: :class:`.Changelist`\n        \"\"\"\n\n        cmd = 'lock' if lock else 'unlock'\n        if changelist:\n            self._connection.run([cmd, '-c', changelist, self.depotFile])\n        else:\n            self._connection.run([cmd, self.depotFile])\n\n        self.query()", "label": 1}
{"code": "public function refund($order): Collection\n    {\n        $this->payload = Support::filterPayload($this->payload, $order, true);\n\n        Events::dispatch(Events::METHOD_CALLED, new Events\\MethodCalled('Wechat', 'Refund', $this->gateway, $this->payload));\n\n        return Support::requestApi(\n            'secapi/pay/refund',\n            $this->payload,\n            true\n        );\n    }", "label": 2}
{"code": "def style_settings_from_preset=(preset_style_name)\n      preset_style = Pwb::PresetStyle.where(name: preset_style_name).first\n      if preset_style\n        style_variables_for_theme[\"vic\"] = preset_style.attributes.as_json\n      end\n    end", "label": 4}
{"code": "def base0_interval_for_variant(variant):\n    \"\"\"\n    Inteval of interbase offsets of the affected reference positions for a\n    particular variant.\n\n    Parameters\n    ----------\n    variant : varcode.Variant\n\n    Returns triplet of (base1_location, ref, alt)\n    \"\"\"\n    base1_location, ref, alt = trim_variant(variant)\n    return base0_interval_for_variant_fields(\n        base1_location=base1_location,\n        ref=ref,\n        alt=alt)", "label": 1}
{"code": "public function setTransform($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\V1beta1\\DocumentTransform::class);\n        $this->writeOneof(6, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_response update(nitro_service client, route6 resource) throws Exception {\n\t\troute6 updateresource = new route6();\n\t\tupdateresource.network = resource.network;\n\t\tupdateresource.gateway = resource.gateway;\n\t\tupdateresource.vlan = resource.vlan;\n\t\tupdateresource.weight = resource.weight;\n\t\tupdateresource.distance = resource.distance;\n\t\tupdateresource.cost = resource.cost;\n\t\tupdateresource.advertise = resource.advertise;\n\t\tupdateresource.msr = resource.msr;\n\t\tupdateresource.monitor = resource.monitor;\n\t\tupdateresource.td = resource.td;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "async function deploy() {\n  try {\n    await browserifyDBCP();\n    await uglify();\n    const ipfsHash = await deployToIPFS(`${ deploymentFolder}/${ browserifyName}`);\n    await pinToIPFS(ipfsHash);\n    const ipnsHash = await deployToIpns(ipfsHash);\n    deleteDeploymentFolder();\n\n    console.log(`\\nFinished deployment`);\n    console.log(`IPFS: ${ ipfsHash }`);\n    console.log(`IPNS: ${ ipnsHash }`);\n  } catch (ex) {\n    console.error(ex);\n  }\n}", "label": 3}
{"code": "function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content]), content: content, col: 0, pos: 0, cm: cm};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if ((ie || webkit) && cm.getOption(\"lineWrapping\"))\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\n      builder.content.className = \"cm-tab-wrap-hack\";\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\n    return builder;\n  }", "label": 3}
{"code": "def macaroon_ops(self, macaroons):\n        ''' This method makes the oven satisfy the MacaroonOpStore protocol\n        required by the Checker class.\n\n        For macaroons minted with previous bakery versions, it always\n        returns a single LoginOp operation.\n\n        :param macaroons:\n        :return:\n        '''\n        if len(macaroons) == 0:\n            raise ValueError('no macaroons provided')\n\n        storage_id, ops = _decode_macaroon_id(macaroons[0].identifier_bytes)\n        root_key = self.root_keystore_for_ops(ops).get(storage_id)\n        if root_key is None:\n            raise VerificationError(\n                'macaroon key not found in storage')\n        v = Verifier()\n        conditions = []\n\n        def validator(condition):\n            # Verify the macaroon's signature only. Don't check any of the\n            # caveats yet but save them so that we can return them.\n            conditions.append(condition)\n            return True\n        v.satisfy_general(validator)\n        try:\n            v.verify(macaroons[0], root_key, macaroons[1:])\n        except Exception as exc:\n            # Unfortunately pymacaroons doesn't control\n            # the set of exceptions that can be raised here.\n            # Possible candidates are:\n            # pymacaroons.exceptions.MacaroonUnmetCaveatException\n            # pymacaroons.exceptions.MacaroonInvalidSignatureException\n            # ValueError\n            # nacl.exceptions.CryptoError\n            #\n            # There may be others too, so just catch everything.\n            raise six.raise_from(\n                VerificationError('verification failed: {}'.format(str(exc))),\n                exc,\n            )\n\n        if (self.ops_store is not None\n            and len(ops) == 1\n                and ops[0].entity.startswith('multi-')):\n            # It's a multi-op entity, so retrieve the actual operations\n            # it's associated with.\n            ops = self.ops_store.get_ops(ops[0].entity)\n\n        return ops, conditions", "label": 1}
{"code": "protected function applySort(AbstractSearch $search, array $sort = null)\n    {\n        $sort = $sort ?: $search->getDefaultSort();\n\n        if (is_callable($sort)) {\n            $sort($search->getQuery());\n        } else {\n            foreach ($sort as $field => $order) {\n                if (is_array($order)) {\n                    foreach ($order as $value) {\n                        $search->getQuery()->orderByRaw(snake_case($field).' != ?', [$value]);\n                    }\n                } else {\n                    $search->getQuery()->orderBy(snake_case($field), $order);\n                }\n            }\n        }\n    }", "label": 2}
{"code": "public static cachepolicylabel_policybinding_binding[] get(nitro_service service, String labelname) throws Exception{\n\t\tcachepolicylabel_policybinding_binding obj = new cachepolicylabel_policybinding_binding();\n\t\tobj.set_labelname(labelname);\n\t\tcachepolicylabel_policybinding_binding response[] = (cachepolicylabel_policybinding_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (c *controller) StartDiagnostic(port int) {\n\tc.Lock()\n\tif !c.DiagnosticServer.IsDiagnosticEnabled() {\n\t\tc.DiagnosticServer.EnableDiagnostic(\"127.0.0.1\", port)\n\t}\n\tc.Unlock()\n}", "label": 5}
{"code": "public static sslglobal_sslpolicy_binding[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{\n\t\tsslglobal_sslpolicy_binding obj = new sslglobal_sslpolicy_binding();\n\t\toptions option = new options();\n\t\toption.set_filter(filter);\n\t\tsslglobal_sslpolicy_binding[] response = (sslglobal_sslpolicy_binding[]) obj.getfiltered(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def get_initkwargs(cls, *args, **kwargs):\n        \"\"\"\n        We require a url_name to reverse URLs later. Additionally users can\n        pass a done_step_name to change the URL name of the \"done\" view.\n        \"\"\"\n        assert 'url_name' in kwargs, 'URL name is needed to resolve correct wizard URLs'\n        extra_kwargs = {\n            'done_step_name': kwargs.pop('done_step_name', 'done'),\n            'url_name': kwargs.pop('url_name'),\n        }\n\n        initkwargs = super(NamedUrlWizardView, cls).get_initkwargs(*args, **kwargs)\n        initkwargs.update(extra_kwargs)\n\n        assert initkwargs['done_step_name'] not in initkwargs['form_list'], \\\n            'step name \"%s\" is reserved for \"done\" view' % initkwargs['done_step_name']\n        return initkwargs", "label": 1}
{"code": "func (l *localFileInfo) ReadDir() ([]FileInfo, error) {\n\tf, err := os.Open(l.filePath)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tfis, err := f.Readdir(0)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tinfos := make([]FileInfo, len(fis))\n\tfor i := range fis {\n\t\tfi := fis[i]\n\t\tinfo, err := makeFileInfo(filepath.Join(l.GetPath(), fi.Name()))\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tinfos[i] = info\n\t}\n\n\treturn infos, nil\n}", "label": 5}
{"code": "func (i *TeleInstance) StartNode(tconf *service.Config) (*service.TeleportProcess, error) {\n\tdataDir, err := ioutil.TempDir(\"\", \"cluster-\"+i.Secrets.SiteName)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttconf.DataDir = dataDir\n\n\tauthServer := utils.MustParseAddr(net.JoinHostPort(i.Hostname, i.GetPortAuth()))\n\ttconf.AuthServers = append(tconf.AuthServers, *authServer)\n\ttconf.Token = \"token\"\n\ttconf.UploadEventsC = i.UploadEventsC\n\tvar ttl time.Duration\n\ttconf.CachePolicy = service.CachePolicy{\n\t\tEnabled:   true,\n\t\tRecentTTL: &ttl,\n\t}\n\ttconf.SSH.PublicAddrs = []utils.NetAddr{\n\t\tutils.NetAddr{\n\t\t\tAddrNetwork: \"tcp\",\n\t\t\tAddr:        Loopback,\n\t\t},\n\t\tutils.NetAddr{\n\t\t\tAddrNetwork: \"tcp\",\n\t\t\tAddr:        Host,\n\t\t},\n\t}\n\ttconf.Auth.Enabled = false\n\ttconf.Proxy.Enabled = false\n\n\t// Create a new Teleport process and add it to the list of nodes that\n\t// compose this \"cluster\".\n\tprocess, err := service.NewTeleport(tconf)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ti.Nodes = append(i.Nodes, process)\n\n\t// Build a list of expected events to wait for before unblocking based off\n\t// the configuration passed in.\n\texpectedEvents := []string{\n\t\tservice.NodeSSHReady,\n\t}\n\n\t// Start the process and block until the expected events have arrived.\n\treceivedEvents, err := startAndWait(process, expectedEvents)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tlog.Debugf(\"Teleport node (in instance %v) started: %v/%v events received.\",\n\t\ti.Secrets.SiteName, len(expectedEvents), len(receivedEvents))\n\treturn process, nil\n}", "label": 5}
{"code": "public static vpnsessionpolicy_binding get(nitro_service service, String name) throws Exception{\n\t\tvpnsessionpolicy_binding obj = new vpnsessionpolicy_binding();\n\t\tobj.set_name(name);\n\t\tvpnsessionpolicy_binding response = (vpnsessionpolicy_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (s *Server) OpenFile(name string, mode int32) (File, error) {\n\tu := urlParse(name)\n\n\tif h, ok := s.schemes[u.Scheme]; ok {\n\t\tf, serr := h.Open(u, mode)\n\t\tif serr != os.ErrNotExist {\n\t\t\treturn f, serr\n\t\t}\n\t}\n\n\tswitch mode {\n\tcase OpenModeReadOnly:\n\t\treturn os.Open(filepath.Clean(name))\n\tcase OpenModeWriteOnly:\n\t\tflag := os.O_WRONLY | os.O_CREATE | os.O_TRUNC\n\t\treturn os.OpenFile(name, flag, 0600)\n\tdefault:\n\t\treturn nil, &Status{\n\t\t\tErr:  fmt.Errorf(\"open mode(%d) not supported for file %q\", mode, name),\n\t\t\tCode: StatusAccessDenied,\n\t\t}\n\t}\n}", "label": 5}
{"code": "public final int needArgumentsNumber() {\n    int number = 0;\n    for (int i : needArgument) {\n      number = Math.max(number, (i + 1));\n    }\n    return number;\n  }", "label": 0}
{"code": "func (a *allocator) RequestPool(addressSpace, pool, subPool string, options map[string]string, v6 bool) (string, *net.IPNet, map[string]string, error) {\n\tlogrus.Debugf(\"RequestPool(%s, %s, %s, %v, %t)\", addressSpace, pool, subPool, options, v6)\n\tif subPool != \"\" || v6 {\n\t\treturn \"\", nil, nil, types.InternalErrorf(\"This request is not supported by null ipam driver\")\n\t}\n\n\tvar ipNet *net.IPNet\n\tvar err error\n\n\tif pool != \"\" {\n\t\t_, ipNet, err = net.ParseCIDR(pool)\n\t\tif err != nil {\n\t\t\treturn \"\", nil, nil, err\n\t\t}\n\t} else {\n\t\tipNet = defaultPool\n\t}\n\n\treturn ipNet.String(), ipNet, nil, nil\n}", "label": 5}
{"code": "func StatDir(path string) (os.FileInfo, error) {\n\tfi, err := os.Stat(path)\n\tif err != nil {\n\t\treturn nil, trace.ConvertSystemError(err)\n\t}\n\tif !fi.IsDir() {\n\t\treturn nil, trace.BadParameter(\"%v is not a directory\", path)\n\t}\n\treturn fi, nil\n}", "label": 5}
{"code": "func (h *hawkularSink) expireCache(runId uint64) {\n\th.regLock.Lock()\n\tdefer h.regLock.Unlock()\n\n\tfor k, v := range h.expReg {\n\t\tif (v.ttl + h.cacheAge) <= runId {\n\t\t\tdelete(h.expReg, k)\n\t\t}\n\t}\n}", "label": 5}
{"code": "def remote_send(req, marshalled = false)\n      send_initial_metadata\n      GRPC.logger.debug(\"sending #{req}, marshalled? #{marshalled}\")\n      payload = marshalled ? req : @marshal.call(req)\n      @call.run_batch(SEND_MESSAGE => payload)\n    end", "label": 4}
{"code": "def run(delayed, concurrency, version_type=None, queue=None,\n        raise_on_error=True):\n    \"\"\"Run bulk record indexing.\"\"\"\n    if delayed:\n        celery_kwargs = {\n            'kwargs': {\n                'version_type': version_type,\n                'es_bulk_kwargs': {'raise_on_error': raise_on_error},\n            }\n        }\n        click.secho(\n            'Starting {0} tasks for indexing records...'.format(concurrency),\n            fg='green')\n        if queue is not None:\n            celery_kwargs.update({'queue': queue})\n        for c in range(0, concurrency):\n            process_bulk_queue.apply_async(**celery_kwargs)\n    else:\n        click.secho('Indexing records...', fg='green')\n        RecordIndexer(version_type=version_type).process_bulk_queue(\n            es_bulk_kwargs={'raise_on_error': raise_on_error})", "label": 1}
{"code": "public function setRoadTraffic($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Talent\\V4beta1\\CommuteFilter_RoadTraffic::class);\n        $this->writeOneof(5, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def all_version_library_instances\n      all_repos = all_version_repos.where(:library_instance_id => nil).pluck(\"#{Katello::Repository.table_name}.id\")\n      all_repos += all_version_repos.pluck(:library_instance_id)\n      Repository.where(:id => all_repos)\n    end", "label": 4}
{"code": "public static servicegroup_servicegroupentitymonbindings_binding[] get(nitro_service service, String servicegroupname) throws Exception{\n\t\tservicegroup_servicegroupentitymonbindings_binding obj = new servicegroup_servicegroupentitymonbindings_binding();\n\t\tobj.set_servicegroupname(servicegroupname);\n\t\tservicegroup_servicegroupentitymonbindings_binding response[] = (servicegroup_servicegroupentitymonbindings_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def apply(row, offset)\n      row.hidden = @filter.apply(row.cells[offset+col_id.to_i])\n    end", "label": 4}
{"code": "function (titleOptions, subtitleOptions, redraw) {\n            var chart = this,\n              options = chart.options,\n              chartTitleOptions,\n              chartSubtitleOptions;\n\n            chartTitleOptions = options.title = merge(options.title, titleOptions);\n            chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);\n\n            // add title and subtitle\n            each([\n                ['title', titleOptions, chartTitleOptions],\n                ['subtitle', subtitleOptions, chartSubtitleOptions]\n            ], function (arr) {\n                var name = arr[0],\n                  title = chart[name],\n                  titleOptions = arr[1],\n                  chartTitleOptions = arr[2];\n\n                if (title && titleOptions) {\n                    chart[name] = title = title.destroy(); // remove old\n                }\n\n                if (chartTitleOptions && chartTitleOptions.text && !title) {\n                    chart[name] = chart.renderer.text(\n                      chartTitleOptions.text,\n                      0,\n                      0,\n                      chartTitleOptions.useHTML\n                      )\n                      .attr({\n                          align: chartTitleOptions.align,\n                          'class': PREFIX + name,\n                          zIndex: chartTitleOptions.zIndex || 4\n                      })\n                      .css(chartTitleOptions.style)\n                      .add();\n                }\n            });\n            chart.layOutTitles(redraw);\n        }", "label": 3}
{"code": "function injectableFromFile(requireMe, provides, injects, directory) {\n    return  _require(requireMe, provides, injects, directory, injectableWrapper);\n  }", "label": 3}
{"code": "def print_unexpected_exception(exception) # rubocop:disable Metrics/AbcSize\n      log.bold_error exception.message\n      log.error exception.backtrace.join(\"\\n\")\n      log.warning 'Report this bug at ', false\n      log.info HamlLint::BUG_REPORT_URL\n      log.newline\n      log.success 'To help fix this issue, please include:'\n      log.log '- The above stack trace'\n      log.log '- Haml-Lint version: ', false\n      log.info HamlLint::VERSION\n      log.log '- Haml version: ', false\n      log.info Gem.loaded_specs['haml'].version\n      log.log '- RuboCop version: ', false\n      log.info Gem.loaded_specs['rubocop'].version\n      log.log '- Ruby version: ', false\n      log.info RUBY_VERSION\n    end", "label": 4}
{"code": "def dump_dict(cfg, f, indent=0):\n    '''Save a dictionary of attributes'''\n\n    for key in cfg:\n        if not isstr(key):\n            raise ConfigSerializeError(\"Dict keys must be strings: %r\" %\n                                       (key,))\n        dump_value(key, cfg[key], f, indent)\n        f.write(u';\\n')", "label": 1}
{"code": "public function getPartitionByName($name)\n    {\n        foreach ($this->partitions as $partition) {\n            if ($name === $partition->getName()) {\n                return $partition;\n            }\n        }\n    }", "label": 2}
{"code": "def load_tbl_from_csv(fname):\r\n\t\"\"\"\r\n\tread a CSV file to list without worrying about odd characters\r\n\t\"\"\"\r\n\timport csv\r\n\r\n\trows_to_load = []\r\n\r\n\twith open(fname, 'r', encoding='cp1252', errors='ignore') as csvfile:\r\n\t\tcsvreader = csv.reader(csvfile, delimiter = ',' )\r\n\r\n\t\treader = csv.reader(csvfile)\r\n\r\n\t\trows_to_load = list(reader)\r\n\r\n\treturn rows_to_load", "label": 1}
{"code": "def edit(*args)\n      arguments(args, required: [:owner, :repo, :id]) do\n        permit VALID_ASSET_PARAM_NAMES\n      end\n\n      patch_request(\"/repos/#{arguments.owner}/#{arguments.repo}/releases/assets/#{arguments.id}\", arguments.params)\n    end", "label": 4}
{"code": "func (s *AccessService) GetRoles() ([]services.Role, error) {\n\tresult, err := s.GetRange(context.TODO(), backend.Key(rolesPrefix), backend.RangeEnd(backend.Key(rolesPrefix)), backend.NoLimit)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tout := make([]services.Role, 0, len(result.Items))\n\tfor _, item := range result.Items {\n\t\trole, err := services.GetRoleMarshaler().UnmarshalRole(item.Value,\n\t\t\tservices.WithResourceID(item.ID), services.WithExpires(item.Expires))\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tout = append(out, role)\n\t}\n\tsort.Sort(services.SortedRoles(out))\n\treturn out, nil\n}", "label": 5}
{"code": "function mapToObject(input, mapFunc) {\n    const obj = {};\n    for (const element of input) {\n        obj[element] = mapFunc(element);\n    }\n    return obj;\n}", "label": 3}
{"code": "function preprocessRawResults(rawResults, resolvedConfig) {\n    rawResults.forEach((rawResult, resultId) => {\n        if (!rawResult.attributePath) return; // e.g. sub-filter results don't need indexing\n\n        // link resultIds into attribute tree (per DataSource):\n        const attrNode = getAttribute(rawResult.attributePath, resolvedConfig);\n        attrNode.dataSources[rawResult.dataSourceName].resultId = resultId;\n\n        // index rows by childKey if available\n        // (top-level result has no childKey and does not need to be indexed):\n        if (rawResult.childKey) {\n            const keyAttr = rawResult.childKey.length === 1 ? rawResult.childKey[0] : null;\n            rawResult.indexedData = {};\n            rawResult.data.forEach((row, i) => {\n                function dereferenceKeyAttr(keyAttrib) {\n                    const keyVal = row[keyAttrib];\n                    if (keyVal === undefined) {\n                        const attrPath =\n                            rawResult.attributePath.length > 0 ? rawResult.attributePath.join('.') : '{root}';\n                        throw new DataError(\n                            `Result-row ${i} of \"${attrPath}\" (DataSource \"${\n                                rawResult.dataSourceName\n                            }\") misses child key attribute \"${keyAttr}\"`\n                        );\n                    }\n                    return keyVal;\n                }\n\n                const key = keyAttr\n                    ? '' + dereferenceKeyAttr(keyAttr) // speed up non-composite keys\n                    : rawResult.childKey.map(dereferenceKeyAttr).join(keySeparator);\n\n                if (!rawResult.uniqueChildKey) {\n                    if (!rawResult.indexedData[key]) rawResult.indexedData[key] = [];\n                    rawResult.indexedData[key].push(row);\n                } else {\n                    if (rawResult.indexedData[key]) {\n                        const attrPath =\n                            rawResult.attributePath.length > 0 ? rawResult.attributePath.join('.') : '{root}';\n                        throw new DataError(\n                            `Result-row ${i} of \"${attrPath}\" (DataSource \"${\n                                rawResult.dataSourceName\n                            }\") has duplicate child key \"${key}\"`\n                        );\n                    }\n                    rawResult.indexedData[key] = row;\n                }\n            });\n        }\n    });\n}", "label": 3}
{"code": "public static <E> void retainAll(Collection<E> elems, Filter<? super E> filter) {\r\n    for (Iterator<E> iter = elems.iterator(); iter.hasNext();) {\r\n      E elem = iter.next();\r\n      if ( ! filter.accept(elem)) {\r\n        iter.remove();\r\n      }\r\n    }\r\n  }", "label": 0}
{"code": "function getModel(service, mixins) {\n\n        // model constructor takes in data and saves it along with the model mixins\n        var Model = function (data) {\n            _.extend(this, data, mixins);\n        };\n\n        if (service.save) {\n            Model.prototype.save = function () {\n                if (this._id) {\n                    return service.save({ where: { _id: this._id }, data: this });\n                }\n                else {\n                    return service.save({ data: this });\n                }\n            };\n        }\n        else if (service.create && service.update) {\n            Model.prototype.save = function () {\n                if (this._id) {\n                    return service.update({ where: { _id: this._id }, data: this });\n                }\n                else {\n                    return service.create({ data: this });\n                }\n            };\n        }\n\n        if (service.remove) {\n            Model.prototype.remove = function () {\n                return service.remove({ where: { _id: this._id } });\n            };\n        }\n\n        // the service methods are added as static references on the model\n        _.each(service, function (method, methodName) {\n            Model[methodName] = function () {\n                return service[methodName].apply(service, arguments);\n            };\n        });\n\n        return Model;\n    }", "label": 3}
{"code": "private function finalQueryPrepare(array $query)\n    {\n        if (isset($query['where']['compositeFilter']) && count($query['where']['compositeFilter']['filters']) === 1) {\n            $filter = $query['where']['compositeFilter']['filters'][0];\n            $query['where'] = $filter;\n        }\n\n        return $query;\n    }", "label": 2}
{"code": "def attach_reloader\n      Rails.application.config.after_initialize do |app|\n        ActiveSupport::Reloader.after_class_unload do\n          ActiveAdmin.application.unload!\n        end\n\n        admin_dirs = {}\n\n        load_paths.each do |path|\n          admin_dirs[path] = [:rb]\n        end\n\n        routes_reloader = app.config.file_watcher.new([], admin_dirs) do\n          app.reload_routes!\n        end\n\n        app.reloaders << routes_reloader\n\n        ActiveSupport::Reloader.to_prepare do\n          # Rails might have reloaded the routes for other reasons (e.g.\n          # routes.rb has changed), in which case Active Admin would have been\n          # loaded via the `ActiveAdmin.routes` call in `routes.rb`.\n          #\n          # Otherwise, we should check if any of the admin files are changed\n          # and force the routes to reload if necessary. This would again causes\n          # Active Admin to load via `ActiveAdmin.routes`.\n          #\n          # Finally, if Active Admin is still not loaded at this point, then we\n          # would need to load it manually.\n          unless ActiveAdmin.application.loaded?\n            routes_reloader.execute_if_updated\n            ActiveAdmin.application.load!\n          end\n        end\n      end\n    end", "label": 4}
{"code": "public Collection<QName> getPortComponentQNames()\n   {\n      //TODO:Check if there is just one QName that drives all portcomponents\n      //or each port component can have a distinct QName (namespace/prefix)\n      //Maintain uniqueness of the QName\n      Map<String, QName> map = new HashMap<String, QName>();\n      for (PortComponentMetaData pcm : portComponents)\n      {\n         QName qname = pcm.getWsdlPort();\n         map.put(qname.getPrefix(), qname);\n      }\n      return map.values();\n   }", "label": 0}
{"code": "public function watch($keys)\n    {\n        if (!$this->client->getProfile()->supportsCommand('WATCH')) {\n            throw new NotSupportedException('WATCH is not supported by the current profile.');\n        }\n\n        if ($this->state->isWatchAllowed()) {\n            throw new ClientException('Sending WATCH after MULTI is not allowed.');\n        }\n\n        $response = $this->call('WATCH', is_array($keys) ? $keys : array($keys));\n        $this->state->flag(MultiExecState::WATCH);\n\n        return $response;\n    }", "label": 2}
{"code": "def execute(params)\n      params = prepare_params(params)\n\n      Net::HTTP.post_form(URI(@url), params).body\n    end", "label": 4}
{"code": "def get_logo_url(self, obj):\n        \"\"\"Get the community logo URL.\"\"\"\n        if current_app and obj.logo_url:\n            return u'{site_url}{path}'.format(\n                site_url=current_app.config.get('THEME_SITEURL'),\n                path=obj.logo_url,\n            )", "label": 1}
{"code": "function setupStyleguide(options) {\n  let cwd = !!options && !!options.cwd ? options.cwd : process.cwd()\n  success('Styleguide.new:', 'initialize styleguide ...')\n  return new Styleguide()\n    .initialize(cwd)\n    .then(function (styleguide) {\n      success('Styleguide.new:', 'initialize finished')\n      if (!options || !options.prepare) {\n        success('Styleguide.prepare:', 'preparing the styleguide target ...')\n        return styleguide.prepare()\n      } else {\n        return Promise.resolve(styleguide)\n      }\n    })\n}", "label": 3}
{"code": "def read(*files, &block)\n      Kernel.raise ArgumentError, 'no files given' if files.length.zero?\n      files.each do |f|\n        Magick::Image.read(f, &block).each { |n| @images << n }\n      end\n      @scene = length - 1\n      self\n    end", "label": 4}
{"code": "def main(**options):\n    \"\"\"Spline loc tool.\"\"\"\n    application = Application(**options)\n    # fails application when your defined threshold is higher than your ratio of com/loc.\n    if not application.run():\n        sys.exit(1)\n    return application", "label": 1}
{"code": "function (match) {\n            var lengthOfMatchedString = match[_GPF_START].length, charAfterValue = this._content.charAt(lengthOfMatchedString);\n            if (charAfterValue) {\n                _gpfAssert(charAfterValue === this._separator, \"Positive lookahead works\");\n                return this._nextValue(++lengthOfMatchedString);\n            }\n            delete this._content;\n            return false;    // No value means end of content\n        }", "label": 3}
{"code": "function processRouteSampleData (o) {\n  if (parseInt(o.rawDataPacket[0]) === k.OBCIGanglionByteIdUncompressed) {\n    return processUncompressedData(o);\n  } else {\n    return processCompressedData(o);\n  }\n}", "label": 3}
{"code": "func GetDeviceInfo(path string) (kind rune, major uint64, minor uint64, err error) {\n\td, err := os.Lstat(path)\n\tif err != nil {\n\t\treturn\n\t}\n\tmode := d.Mode()\n\n\tif mode&os.ModeDevice == 0 {\n\t\terr = fmt.Errorf(\"not a device: %s\", path)\n\t\treturn\n\t}\n\tstat_t, ok := d.Sys().(*syscall.Stat_t)\n\tif !ok {\n\t\terr = fmt.Errorf(\"cannot determine device number\")\n\t\treturn\n\t}\n\treturn getDeviceInfo(mode, stat_t.Rdev)\n}", "label": 5}
{"code": "public static dnsview[] get(nitro_service service) throws Exception{\n\t\tdnsview obj = new dnsview();\n\t\tdnsview[] response = (dnsview[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function reload(array $options = [])\n    {\n        $this->info = $this->connection->getInstance($options + [\n            'name' => $this->name,\n            'projectId' => $this->projectId\n        ]);\n\n        return $this->info;\n    }", "label": 2}
{"code": "def iter_documents(self, fileids=None, categories=None, _destroy=False):\n        \"\"\" Return an iterator over corpus documents. \"\"\"\n        doc_ids = self._filter_ids(fileids, categories)\n        for doc in imap(self.get_document, doc_ids):\n            yield doc\n            if _destroy:\n                doc.destroy()", "label": 1}
{"code": "def convert_args_to_sets(f):\n    \"\"\"\n    Converts all args to 'set' type via self.setify function.\n    \"\"\"\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        args = (setify(x) for x in args)\n        return f(*args, **kwargs)\n    return wrapper", "label": 1}
{"code": "def config\n      @config ||= begin\n        raise(ConfigError, \"Cannot find config file: #{file_name}\") unless File.exist?(file_name)\n\n        env_config = YAML.load(ERB.new(File.new(file_name).read).result)[env]\n        raise(ConfigError, \"Cannot find environment: #{env} in config file: #{file_name}\") unless env_config\n\n        env_config = self.class.send(:deep_symbolize_keys, env_config)\n        self.class.send(:migrate_old_formats!, env_config)\n      end\n    end", "label": 4}
{"code": "func parseInterface(r api.CreateEndpointResponse) (*api.Interface, error) {\n\tvar outIf *api.Interface\n\n\tinIf := r.Interface\n\tif inIf != nil {\n\t\tvar err error\n\t\toutIf = &api.Interface{}\n\t\tif inIf.Address != \"\" {\n\t\t\tif outIf.Address, err = types.ParseCIDR(inIf.Address); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tif inIf.AddressIPv6 != \"\" {\n\t\t\tif outIf.AddressIPv6, err = types.ParseCIDR(inIf.AddressIPv6); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tif inIf.MacAddress != \"\" {\n\t\t\tif outIf.MacAddress, err = net.ParseMAC(inIf.MacAddress); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn outIf, nil\n}", "label": 5}
{"code": "def create(*args)\n      arguments(args, required: [:column_id])\n      params = arguments.params\n\n      params[\"accept\"] ||= ::Github::Client::Projects::PREVIEW_MEDIA\n\n      post_request(\"/projects/columns/#{arguments.column_id}/cards\", params)\n    end", "label": 4}
{"code": "public void setStatusBarMessage(final String message)\r\n    {\r\n        // Guaranteed to return a non-null array\r\n        Object[] listeners = listenerList.getListenerList();\r\n        // Process the listeners last to first, notifying\r\n        // those that are interested in this event\r\n        for (int i = listeners.length-2; i>=0; i-=2) {\r\n            if (listeners[i]==StatusMessageListener.class) \r\n            {\r\n                ((StatusMessageListener)listeners[i+1]).statusMessageReceived(message);\r\n            }          \r\n        }        \r\n    }", "label": 0}
{"code": "def arraydifference(X,Y):\n    \"\"\"\n    Elements of a numpy array that do not appear in another.\n\n    Fast routine for determining which elements in numpy array `X`\n    do not appear in numpy array `Y`.\n\n    **Parameters**\n\n            **X** :  numpy array\n\n                    Numpy array to comapare to numpy array `Y`.\n                    Return subset of `X` corresponding to elements not in `Y`.\n\n            **Y** :  numpy array\n\n                    Numpy array to which numpy array `X` is compared.\n                    Return subset of `X` corresponding to elements not in `Y`.\n\n    **Returns**\n\n            **Z** :  numpy array\n\n                    Subset of `X` corresponding to elements not in `Y`.\n\n    **See Also:**\n\n            :func:`tabular.fast.recarraydifference`, :func:`tabular.fast.isin`\n\n    \"\"\"\n    if len(Y) > 0:\n        Z = isin(X,Y)\n        return X[np.invert(Z)]\n    else:\n        return X", "label": 1}
{"code": "private function deleteSessions(array $sessions)\n    {\n        // gRPC calls appear to cancel when the corresponding UnaryCall object\n        // goes out of scope. Keeping the calls in scope allows time for the\n        // calls to complete at the expense of a small memory footprint.\n        $this->deleteCalls = [];\n\n        foreach ($sessions as $session) {\n            $this->deleteCalls[] = $this->database->connection()\n                ->deleteSessionAsync([\n                    'name' => $session['name'],\n                    'database' => $this->database->name()\n                ]);\n        }\n    }", "label": 2}
{"code": "function(){\n      return {\n        collection: configCollection,\n        data: config.data,\n        query: config.query,\n        offset: config.offset,\n        limit: config.limit,\n        where: config.where,\n        filter: config.filter,\n        filters: config.filters,\n        watch: config.watch,\n        sort: config.sort\n      };\n    }", "label": 3}
{"code": "function triggerHandler(eventName, event, target) {\n              var match = !bubbleSelector;\n              var el = bubbleSelector ? target : registeredOn;\n              if (bubbleSelector) {\n                var selectorFilter = getFilterFunc(bubbleSelector, registeredOn);\n                while (el && el != registeredOn && !(match = selectorFilter(el)))\n                  el = el['parentNode'];\n              }\n              return (!match) || (name != eventName) || ((handler.apply($(el), args || [event, index]) && prefix=='?') || prefix == '|');\n            }", "label": 3}
{"code": "public function setYarnMetrics($var)\n    {\n        $arr = GPBUtil::checkMapField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING, \\Google\\Protobuf\\Internal\\GPBType::INT64);\n        $this->yarn_metrics = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (ds *DjangoSession) Update(db XODB) error {\n\tvar err error\n\n\t// if doesn't exist, bail\n\tif !ds._exists {\n\t\treturn errors.New(\"update failed: does not exist\")\n\t}\n\n\t// if deleted, bail\n\tif ds._deleted {\n\t\treturn errors.New(\"update failed: marked for deletion\")\n\t}\n\n\t// sql query\n\tconst sqlstr = `UPDATE public.django_session SET (` +\n\t\t`session_data, expire_date` +\n\t\t`) = ( ` +\n\t\t`$1, $2` +\n\t\t`) WHERE session_key = $3`\n\n\t// run query\n\tXOLog(sqlstr, ds.SessionData, ds.ExpireDate, ds.SessionKey)\n\t_, err = db.Exec(sqlstr, ds.SessionData, ds.ExpireDate, ds.SessionKey)\n\treturn err\n}", "label": 5}
{"code": "public static nssimpleacl[] get(nitro_service service, String aclname[]) throws Exception{\n\t\tif (aclname !=null && aclname.length>0) {\n\t\t\tnssimpleacl response[] = new nssimpleacl[aclname.length];\n\t\t\tnssimpleacl obj[] = new nssimpleacl[aclname.length];\n\t\t\tfor (int i=0;i<aclname.length;i++) {\n\t\t\t\tobj[i] = new nssimpleacl();\n\t\t\t\tobj[i].set_aclname(aclname[i]);\n\t\t\t\tresponse[i] = (nssimpleacl) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "def attribute(type, method, attr)\n      typed_attributes[type] << [method, attr]\n      define_attribute(type, method, attr)\n    end", "label": 4}
{"code": "public function valid()\n    {\n        $page = $this->pageIterator->current();\n\n        if (isset($page[$this->pageIndex])) {\n            return true;\n        }\n\n        // If there are no results, but a token for the next page\n        // exists let's continue paging until there are results.\n        while ($this->nextResultToken()) {\n            $this->pageIterator->next();\n            $page = $this->pageIterator->current();\n\n            if (isset($page[$this->pageIndex])) {\n                return true;\n            }\n        }\n\n        return false;\n    }", "label": 2}
{"code": "def resources(name)\n      get \"#{name}\", to: \"#{name}#index\"\n      get \"#{name}/new\", to: \"#{name}#new\" unless api_mode?\n      get \"#{name}/:id\", to: \"#{name}#show\"\n      post \"#{name}\", to: \"#{name}#create\"\n      get \"#{name}/:id/edit\", to: \"#{name}#edit\" unless api_mode?\n      put \"#{name}/:id\", to: \"#{name}#update\"\n      post \"#{name}/:id\", to: \"#{name}#update\" # for binary uploads\n      patch \"#{name}/:id\", to: \"#{name}#update\"\n      delete \"#{name}/:id\", to: \"#{name}#delete\"\n    end", "label": 4}
{"code": "def dAbr_dV(dSf_dVa, dSf_dVm, dSt_dVa, dSt_dVm, Sf, St):\n    \"\"\" Partial derivatives of squared flow magnitudes w.r.t voltage.\n\n        Computes partial derivatives of apparent power w.r.t active and\n        reactive power flows.  Partial derivative must equal 1 for lines\n        with zero flow to avoid division by zero errors (1 comes from\n        L'Hopital).\n    \"\"\"\n    dAf_dPf = spdiag(2 * Sf.real())\n    dAf_dQf = spdiag(2 * Sf.imag())\n    dAt_dPt = spdiag(2 * St.real())\n    dAt_dQt = spdiag(2 * St.imag())\n\n    # Partial derivative of apparent power magnitude w.r.t voltage\n    # phase angle.\n    dAf_dVa = dAf_dPf * dSf_dVa.real() + dAf_dQf * dSf_dVa.imag()\n    dAt_dVa = dAt_dPt * dSt_dVa.real() + dAt_dQt * dSt_dVa.imag()\n    # Partial derivative of apparent power magnitude w.r.t. voltage\n    # amplitude.\n    dAf_dVm = dAf_dPf * dSf_dVm.real() + dAf_dQf * dSf_dVm.imag()\n    dAt_dVm = dAt_dPt * dSt_dVm.real() + dAt_dQt * dSt_dVm.imag()\n\n    return dAf_dVa, dAf_dVm, dAt_dVa, dAt_dVm", "label": 1}
{"code": "public static base_responses clear(nitro_service client, Interface resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tInterface clearresources[] = new Interface[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tclearresources[i] = new Interface();\n\t\t\t\tclearresources[i].id = resources[i].id;\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, clearresources,\"clear\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public static clusternodegroup[] get(nitro_service service) throws Exception{\n\t\tclusternodegroup obj = new clusternodegroup();\n\t\tclusternodegroup[] response = (clusternodegroup[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def directory_path\n      sanitized_path(\n        case namespace\n        when \"collections\"\n          File.join(collection.relative_directory, params[\"splat\"].first)\n        when \"data\"\n          File.join(DataFile.data_dir, params[\"splat\"].first)\n        when \"drafts\"\n          File.join(\"_drafts\", params[\"splat\"].first)\n        else\n          params[\"splat\"].first\n        end\n      )\n    end", "label": 4}
{"code": "func (s *PresenceService) UpsertNode(server services.Server) (*services.KeepAlive, error) {\n\tif server.GetNamespace() == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing node namespace\")\n\t}\n\tvalue, err := services.GetServerMarshaler().MarshalServer(server)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tlease, err := s.Put(context.TODO(), backend.Item{\n\t\tKey:     backend.Key(nodesPrefix, server.GetNamespace(), server.GetName()),\n\t\tValue:   value,\n\t\tExpires: server.Expiry(),\n\t\tID:      server.GetResourceID(),\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tif server.Expiry().IsZero() {\n\t\treturn &services.KeepAlive{}, nil\n\t}\n\treturn &services.KeepAlive{LeaseID: lease.ID, ServerName: server.GetName()}, nil\n}", "label": 5}
{"code": "protected function getControllers()\n    {\n        $controllers = new Collection;\n\n        if ($controller = $this->option('use-controller')) {\n            $this->addControllerIfNotExists($controllers, app($controller));\n\n            return $controllers;\n        }\n\n        foreach ($this->router->getRoutes() as $collections) {\n            foreach ($collections as $route) {\n                if ($controller = $route->getControllerInstance()) {\n                    $this->addControllerIfNotExists($controllers, $controller);\n                }\n            }\n        }\n\n        return $controllers;\n    }", "label": 2}
{"code": "public static InterceptorFactory getInstance()\r\n\t{\r\n\t\tif (instance == null)\r\n\t\t{\r\n\t\t\tinstance = new InterceptorFactory();\r\n\t\t\tOjbConfigurator.getInstance().configure(instance);\r\n\t\t}\r\n\t\treturn instance;\r\n\t}", "label": 0}
{"code": "private function convertArrayToArrayValue(array $value)\n    {\n        $values = [];\n        foreach ($value as $val) {\n            // ListValues may not contain nested ListValues.\n            // Therefore, if an empty array is provided as part of an array,\n            // we can encode it as an EntityValue.\n            if (is_array($val) && empty($val)) {\n                $val = (object) $val;\n            }\n\n            $values[] = $this->valueObject($val);\n        }\n\n        return [\n            'arrayValue' => [\n                'values' => $values\n            ]\n        ];\n    }", "label": 2}
{"code": "public static function logIn(string $provider, string $identifier): ?User\n    {\n        if ($provider = static::where(compact('provider', 'identifier'))->first()) {\n            $provider->touch();\n\n            return $provider->user;\n        }\n\n        return null;\n    }", "label": 2}
{"code": "def fit(self, X, y=None):\n        \"\"\"\n        Fit the inlier model given training data.\n\n        This function attempts to choose reasonable defaults for parameters\n        sigma and rho if none are specified, which could then be adjusted\n        to improve performance.\n\n        Parameters\n        ----------\n        X : array\n            Examples of inlier data, of dimension N times d (rows are\n            examples, columns are data dimensions)\n        y : array, optional\n            If the inliers have multiple classes, then y contains the class\n            assignments as a vector of length N. If this is specified then\n            the model will attempt to assign test data to one of the inlier\n            classes or to the outlier class.\n        \"\"\"\n        N = X.shape[0]\n\n        if y is None:\n            y = np.zeros(N)\n\n        self.classes = list(set(y))\n        self.classes.sort()\n        self.n_classes = len(self.classes)\n\n        # If no kernel parameters specified, try to choose some defaults\n        if not self.sigma:\n            self.sigma = median_kneighbour_distance(X)\n            self.gamma = self.sigma**-2\n\n        if not self.gamma:\n            self.gamma = self.sigma**-2\n\n        if not self.rho:\n            self.rho = 0.1\n\n        # choose kernel basis centres\n        if self.kernel_pos is None:\n            B = min(self.n_kernels_max, N)\n            kernel_idx = np.random.permutation(N)\n            self.kernel_pos = X[kernel_idx[:B]]\n        else:\n            B = self.kernel_pos.shape[0]\n\n        # fit coefficients\n        Phi = metrics.pairwise.rbf_kernel(X, self.kernel_pos, self.gamma)\n        theta = {}\n        Phi_PhiT = np.dot(Phi.T, Phi)\n        inverse_term = np.linalg.inv(Phi_PhiT + self.rho*np.eye(B))\n        for c in self.classes:\n            m = (y == c).astype(int)\n            theta[c] = np.dot(inverse_term, np.dot(Phi.T, m))\n\n        self.theta = theta", "label": 1}
{"code": "func VPX() *Model {\n\treturn &Model{\n\t\tServiceContent: vpx.ServiceContent,\n\t\tRootFolder:     vpx.RootFolder,\n\t\tAutostart:      true,\n\t\tDatacenter:     1,\n\t\tPortgroup:      1,\n\t\tHost:           1,\n\t\tCluster:        1,\n\t\tClusterHost:    3,\n\t\tDatastore:      1,\n\t\tMachine:        2,\n\t\tDelayConfig: DelayConfig{\n\t\t\tDelay:       0,\n\t\t\tDelayJitter: 0,\n\t\t\tMethodDelay: nil,\n\t\t},\n\t}\n}", "label": 5}
{"code": "function stopDetect() {\n    // clone current data to the store as the previous gesture\n    // used for the double tap gesture, since this is an other gesture detect session\n    this.previous = Hammer.utils.extend({}, this.current);\n\n    // reset the current\n    this.current = null;\n\n    // stopped!\n    this.stopped = true;\n  }", "label": 3}
{"code": "public boolean isUpToDate(final DbArtifact artifact) {\n        final List<String> versions = repoHandler.getArtifactVersions(artifact);\n        final String currentVersion = artifact.getVersion();\n\n        final String lastDevVersion = getLastVersion(versions);\n        final String lastReleaseVersion = getLastRelease(versions);\n\n        if(lastDevVersion == null || lastReleaseVersion == null) {\n            // Plain Text comparison against version \"strings\"\n            for(final String version: versions){\n                if(version.compareTo(currentVersion) > 0){\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return currentVersion.equals(lastDevVersion) || currentVersion.equals(lastReleaseVersion);\n        }\n    }", "label": 0}
{"code": "public function componentsManifest($componentId = null)\n    {\n        $manifest = $this->manifest ?: $this->loadManifest;\n        $modules = $manifest['modules'];\n\n        if ($componentId) {\n            $modules = array_filter($modules, function ($module) use ($componentId) {\n                return $module['id'] === $componentId;\n            });\n        }\n\n        return $modules;\n    }", "label": 2}
{"code": "public static InputStream openFile(File file) throws RuntimeIOException {\r\n    try {\r\n      InputStream is = new BufferedInputStream(new FileInputStream(file));\r\n      if (file.getName().endsWith(\".gz\")) {\r\n        is = new GZIPInputStream(is);\r\n      }\r\n      return is;\r\n    } catch (Exception e) {\r\n      throw new RuntimeIOException(e);\r\n    }\r\n  }", "label": 0}
{"code": "public void getDataDTD(Writer output) throws DataTaskException\r\n    {\r\n        try\r\n        {\r\n            output.write(\"<!ELEMENT dataset (\\n\");\r\n            for (Iterator it = _preparedModel.getElementNames(); it.hasNext();)\r\n            {\r\n                String elementName = (String)it.next();\r\n\r\n                output.write(\"    \");\r\n                output.write(elementName);\r\n                output.write(\"*\");\r\n                output.write(it.hasNext() ? \" |\\n\" : \"\\n\");\r\n            }\r\n            output.write(\")>\\n<!ATTLIST dataset\\n    name CDATA #REQUIRED\\n>\\n\");\r\n            for (Iterator it = _preparedModel.getElementNames(); it.hasNext();)\r\n            {\r\n                String elementName = (String)it.next();\r\n                List   classDescs  = _preparedModel.getClassDescriptorsMappingTo(elementName);\r\n\r\n                if (classDescs == null)\r\n                {\r\n                    output.write(\"\\n<!-- Indirection table\");\r\n                }\r\n                else\r\n                {\r\n                    output.write(\"\\n<!-- Mapped to : \");\r\n                    for (Iterator classDescIt = classDescs.iterator(); classDescIt.hasNext();)\r\n                    {\r\n                        ClassDescriptor classDesc = (ClassDescriptor)classDescIt.next();\r\n    \r\n                        output.write(classDesc.getClassNameOfObject());\r\n                        if (classDescIt.hasNext())\r\n                        {\r\n                            output.write(\"\\n                 \");\r\n                        }\r\n                    }\r\n                }\r\n                output.write(\" -->\\n<!ELEMENT \");\r\n                output.write(elementName);\r\n                output.write(\" EMPTY>\\n<!ATTLIST \");\r\n                output.write(elementName);\r\n                output.write(\"\\n\");\r\n\r\n                for (Iterator attrIt = _preparedModel.getAttributeNames(elementName); attrIt.hasNext();)\r\n                {\r\n                    String attrName = (String)attrIt.next();\r\n\r\n                    output.write(\"    \");\r\n                    output.write(attrName);\r\n                    output.write(\" CDATA #\");\r\n                    output.write(_preparedModel.isRequired(elementName, attrName) ? \"REQUIRED\" : \"IMPLIED\");\r\n                    output.write(\"\\n\");\r\n                }\r\n                output.write(\">\\n\");\r\n            }\r\n        }\r\n        catch (IOException ex)\r\n        {\r\n            throw new DataTaskException(ex);\r\n        }\r\n    }", "label": 0}
{"code": "def to_geocodeable_s\n      a = [street_address, district, city, state, zip, country_code].compact\n      a.delete_if { |e| !e || e == '' }\n      a.join(', ')\n    end", "label": 4}
{"code": "function Fireproof(firebaseRef, promise) {\n\n  if (!Fireproof.Promise) {\n\n    try {\n      Fireproof.Promise = Promise;\n    } catch(e) {\n      throw new Error('You must supply a Promise library to Fireproof!');\n    }\n\n  } else if (typeof Fireproof.Promise !== 'function') {\n    throw new Error('The supplied value of Fireproof.Promise is not a constructor (got ' +\n        Fireproof.Promise + ')');\n  }\n\n  this._ref = firebaseRef;\n  if (promise && promise.then) {\n    this.then = promise.then.bind(promise);\n  } else {\n\n    this.then = function(ok, fail) {\n\n      return this.once('value', function() {})\n      .then(ok || null, fail || null);\n\n    };\n\n  }\n\n}", "label": 3}
{"code": "def contains(self, index: Union[SchemaKey, int, str]) -> bool:\n        \"\"\"\n        Return whether the cache contains a schema for the input key, sequence number, or schema identifier.\n\n        :param index: schema key, sequence number, or sequence identifier\n        :return: whether the cache contains a schema for the input index\n        \"\"\"\n\n        LOGGER.debug('SchemaCache.contains >>> index: %s', index)\n\n        rv = None\n        if isinstance(index, SchemaKey):\n            rv = (index in self._schema_key2schema)\n        elif isinstance(index, int) or (isinstance(index, str) and ':2:' not in index):\n            rv = (int(index) in self._seq_no2schema_key)\n        elif isinstance(index, str):\n            rv = (schema_key(index) in self._schema_key2schema)\n        else:\n            rv = False\n\n        LOGGER.debug('SchemaCache.contains <<< %s', rv)\n        return rv", "label": 1}
{"code": "def format_tree(tree):\n    \"\"\"Format a python tree structure\n\n    Given the python tree::\n\n        tree = {\n            'node': ['ROOT', 'This is the root of the tree'],\n            'childs': [{\n                'node': 'A1',\n                'childs': [{\n                    'node': 'B1',\n                    'childs': [{\n                        'node': 'C1'\n                    }]\n                },\n                {\n                    'node': 'B2'\n                }]\n            },\n            {\n                'node': 'A2',\n                'childs': [{\n                    'node': 'B3',\n                    'childs': [{\n                        'node': ['C2', 'This is a leaf']\n                    },\n                    {\n                        'node': 'C3'\n                    }]\n                }]\n            },\n            {\n                'node': ['A3', 'This is a node'],\n                'childs': [{\n                    'node': 'B2'\n                }]\n            }]\n        }\n\n    `format_tree` will return::\n\n        ROOT            This is the root of the tree\n        \u251c\u2500\u2500 A1\n        \u2502   \u251c\u2500\u2500 B1\n        \u2502   \u2502   \u2514\u2500\u2500 C1\n        \u2502   \u2514\u2500\u2500 B2\n        \u251c\u2500\u2500 A2\n        \u2502   \u2514\u2500\u2500 B3\n        \u2502       \u251c\u2500\u2500 C2  This is a leaf\n        \u2502       \u2514\u2500\u2500 C3\n        \u2514\u2500\u2500 A3          This is a node\n            \u2514\u2500\u2500 B2\n\n    \"\"\"\n\n    def _traverse_tree(tree, parents=None):\n        tree['parents'] = parents\n        childs = tree.get('childs', [])\n        nb_childs = len(childs)\n        for index, child in enumerate(childs):\n            child_parents = list(parents) + [index == nb_childs - 1]\n            tree['childs'][index] = _traverse_tree(\n                tree['childs'][index],\n                parents=child_parents)\n        return tree\n\n    tree = _traverse_tree(tree, parents=[])\n\n    def _get_rows_data(tree, rows):\n        prefix = ''\n        for p in tree['parents'][:-1]:\n            if p is False:\n                prefix += '\u2502   '\n            else:\n                prefix += '    '\n        if not tree['parents']:\n            pass\n        elif tree['parents'][-1] is True:\n            prefix += '\u2514\u2500\u2500 '\n        else:\n            prefix += '\u251c\u2500\u2500 '\n        if isinstance(tree['node'], string_types):\n            tree['node'] = [tree['node']]\n        rows.append([prefix + tree['node'][0]] + tree['node'][1:])\n        for child in tree.get('childs', []):\n            rows = _get_rows_data(child, rows)\n        return rows\n\n    rows = _get_rows_data(tree, [])\n    return format_table(rows)", "label": 1}
{"code": "def colstack(self, new, mode='abort'):\n        \"\"\"\n        Horizontal stacking for tabarrays.\n\n        Stack tabarray(s) in `new` to the right of `self`.\n\n        **See also**\n\n                :func:`tabular.tabarray.tab_colstack`, \n                :func:`tabular.spreadsheet.colstack`\n\n        \"\"\"\n        if isinstance(new,list):\n            return tab_colstack([self] + new,mode)\n        else:\n            return tab_colstack([self, new], mode)", "label": 1}
{"code": "public static function invocationId()\n    {\n        return function (callable $handler) {\n            return function (\n                CommandInterface $command,\n                RequestInterface $request\n            ) use ($handler){\n                return $handler($command, $request->withHeader(\n                    'aws-sdk-invocation-id',\n                    md5(uniqid(gethostname(), true))\n                ));\n            };\n        };\n    }", "label": 2}
{"code": "def put_policy(name, rules)\n      client.put(\"/v1/sys/policy/#{encode_path(name)}\", JSON.fast_generate(\n        rules: rules,\n      ))\n      return true\n    end", "label": 4}
{"code": "func (app *Application) Refresh() {\n\tev := &eventAppRefresh{}\n\tev.SetEventNow()\n\tif scr := app.screen; scr != nil {\n\t\tgo func() { scr.PostEventWait(ev) }()\n\t}\n}", "label": 5}
{"code": "def text_align(alignment)\n      Kernel.raise ArgumentError, \"Unknown alignment constant: #{alignment}\" unless ALIGN_TYPE_NAMES.key?(alignment.to_i)\n      primitive \"text-align #{ALIGN_TYPE_NAMES[alignment.to_i]}\"\n    end", "label": 4}
{"code": "protected function assertSslSupport(ParametersInterface $parameters)\n    {\n        if (\n            filter_var($parameters->persistent, FILTER_VALIDATE_BOOLEAN) &&\n            version_compare(PHP_VERSION, '7.0.0beta') < 0\n        ) {\n            throw new \\InvalidArgumentException('Persistent SSL connections require PHP >= 7.0.0.');\n        }\n    }", "label": 2}
{"code": "function() {\n      var wasAttached;\n      if (this.isAttachedToParent()) {\n         wasAttached = this.isAttached();\n        // Detach view from DOM\n        this.trigger('before-dom-detach');\n        if (this.injectionSite) {\n          this.$el.replaceWith(this.injectionSite);\n          this.injectionSite = undefined;\n        } else {\n          this.$el.detach();\n        }\n        if (wasAttached) {\n          this.__invokeDetached();\n        }\n        this.undelegateEvents();\n        this.__isAttachedToParent = false;\n      }\n    }", "label": 3}
{"code": "def show\n      return if activities.blank?\n\n      activities.map do |activity|\n        activity.organization_lazy\n        activity.resource_lazy\n        activity.participatory_space_lazy\n        activity.component_lazy\n      end\n\n      render\n    end", "label": 4}
{"code": "public void writeAnswers(List<IN> doc, PrintWriter printWriter,\r\n                           DocumentReaderAndWriter<IN> readerAndWriter)\r\n    throws IOException {\r\n    if (flags.lowerNewgeneThreshold) {\r\n      return;\r\n    }\r\n    if (flags.numRuns <= 1) {\r\n      readerAndWriter.printAnswers(doc, printWriter);\r\n      // out.println();\r\n      printWriter.flush();\r\n    }\r\n  }", "label": 0}
{"code": "func CreateStandaloneHost(f *Folder, spec types.HostConnectSpec) (*HostSystem, types.BaseMethodFault) {\n\tif spec.HostName == \"\" {\n\t\treturn nil, &types.NoHost{}\n\t}\n\n\tpool := NewResourcePool()\n\thost := NewHostSystem(esx.HostSystem)\n\n\thost.Summary.Config.Name = spec.HostName\n\thost.Name = host.Summary.Config.Name\n\thost.Runtime.ConnectionState = types.HostSystemConnectionStateDisconnected\n\n\tsummary := new(types.ComputeResourceSummary)\n\taddComputeResource(summary, host)\n\n\tcr := &mo.ComputeResource{\n\t\tConfigurationEx: &types.ComputeResourceConfigInfo{\n\t\t\tVmSwapPlacement: string(types.VirtualMachineConfigInfoSwapPlacementTypeVmDirectory),\n\t\t},\n\t\tSummary:            summary,\n\t\tEnvironmentBrowser: newEnvironmentBrowser(),\n\t}\n\n\tMap.PutEntity(cr, Map.NewEntity(host))\n\thost.Summary.Host = &host.Self\n\n\tMap.PutEntity(cr, Map.NewEntity(pool))\n\n\tcr.Name = host.Name\n\tcr.Network = Map.getEntityDatacenter(f).defaultNetwork()\n\tcr.Host = append(cr.Host, host.Reference())\n\tcr.ResourcePool = &pool.Self\n\n\tf.putChild(cr)\n\tpool.Owner = cr.Self\n\thost.Network = cr.Network\n\n\treturn host, nil\n}", "label": 5}
{"code": "public String toStringByValue() {\r\n\tIntArrayList theKeys = new IntArrayList();\r\n\tkeysSortedByValue(theKeys);\r\n\r\n\tStringBuffer buf = new StringBuffer();\r\n\tbuf.append(\"[\");\r\n\tint maxIndex = theKeys.size() - 1;\r\n\tfor (int i = 0; i <= maxIndex; i++) {\r\n\t\tint key = theKeys.get(i);\r\n\t    buf.append(String.valueOf(key));\r\n\t\tbuf.append(\"->\");\r\n\t    buf.append(String.valueOf(get(key)));\r\n\t\tif (i < maxIndex) buf.append(\", \");\r\n\t}\r\n\tbuf.append(\"]\");\r\n\treturn buf.toString();\r\n}", "label": 0}
{"code": "func oauth2ConfigsEqual(a, b oauth2.Config) bool {\n\tif a.Credentials.ID != b.Credentials.ID {\n\t\treturn false\n\t}\n\tif a.Credentials.Secret != b.Credentials.Secret {\n\t\treturn false\n\t}\n\tif a.RedirectURL != b.RedirectURL {\n\t\treturn false\n\t}\n\tif len(a.Scope) != len(b.Scope) {\n\t\treturn false\n\t}\n\tfor i := range a.Scope {\n\t\tif a.Scope[i] != b.Scope[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tif a.AuthURL != b.AuthURL {\n\t\treturn false\n\t}\n\tif a.TokenURL != b.TokenURL {\n\t\treturn false\n\t}\n\tif a.AuthMethod != b.AuthMethod {\n\t\treturn false\n\t}\n\treturn true\n}", "label": 5}
{"code": "def write(self, file_or_filename):\n        \"\"\" Writes the case to file using pickle.\n        \"\"\"\n        if isinstance(file_or_filename, basestring):\n            fname = os.path.basename(file_or_filename)\n            logger.info(\"Pickling case [%s].\" % fname)\n\n            file = None\n            try:\n                file = open(file_or_filename, \"wb\")\n            except:\n                logger.error(\"Error opening '%s'.\" % (fname))\n                return False\n            finally:\n                if file is not None:\n                    pickle.dump(self.case, file)\n                    file.close()\n        else:\n            file = file_or_filename\n            pickle.dump(file, self.case)\n\n        return True", "label": 1}
{"code": "def delete_all\n      start do |pop3|\n        unless pop3.mails.empty?\n          pop3.delete_all\n          pop3.finish\n        end\n      end\n    end", "label": 4}
{"code": "function toggle(element, animation, callbackFn) {\n    var nowVisible = element.style.display != 'none' || element.offsetLeft > 0;\n\n    // create clone for reference\n    var clone = element.cloneNode(true);\n    var cleanup = function() {\n        element.removeAttribute('data-animated');\n        element.setAttribute('style', clone.getAttribute('style'));\n        element.style.display = nowVisible ? 'none' : '';\n\t\tif( callbackFn ) { callbackFn(); }\n    };\n\n    // store attribute so everyone knows we're animating this element\n    element.setAttribute('data-animated', \"true\");\n\n    // toggle element visiblity right away if we're making something visible\n    if( ! nowVisible ) {\n        element.style.display = '';\n    }\n\n    var hiddenStyles, visibleStyles;\n\n    // animate properties\n    if( animation === 'slide' ) {\n        hiddenStyles = initObjectProperties([\"height\", \"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"], 0);\n        visibleStyles = {};\n\n        if( ! nowVisible ) {\n            var computedStyles = window.getComputedStyle(element);\n            visibleStyles = copyObjectProperties([\"height\", \"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"], computedStyles);\n\n            // in some browsers, getComputedStyle returns \"auto\" value. this falls back to getBoundingClientRect() in those browsers since we need an actual height.\n            if(!isFinite(visibleStyles.height)) {\n              var clientRect = element.getBoundingClientRect();\n              visibleStyles.height = clientRect.height;\n            }\n            css(element, hiddenStyles);\n        }\n\n        // don't show a scrollbar during animation\n        element.style.overflowY = 'hidden';\n        animate(element, nowVisible ? hiddenStyles : visibleStyles, cleanup);\n    } else {\n        hiddenStyles = { opacity: 0 };\n        visibleStyles = { opacity: 1 };\n        if( ! nowVisible ) {\n            css(element, hiddenStyles);\n        }\n\n        animate(element, nowVisible ? hiddenStyles : visibleStyles, cleanup);\n    }\n}", "label": 3}
{"code": "public function commit(array $options = [])\n    {\n        unset($options['merge'], $options['precondition']);\n\n        $response = $this->connection->commit(array_filter([\n            'database' => $this->database,\n            'writes' => $this->writes,\n            'transaction' => $this->transaction\n        ]) + $options);\n\n        if (isset($response['commitTime'])) {\n            $time = $this->parseTimeString($response['commitTime']);\n            $response['commitTime'] = new Timestamp($time[0], $time[1]);\n        }\n\n        if (isset($response['writeResults'])) {\n            foreach ($response['writeResults'] as &$result) {\n                if (isset($result['updateTime'])) {\n                    $time = $this->parseTimeString($result['updateTime']);\n                    $result['updateTime'] = new Timestamp($time[0], $time[1]);\n                }\n            }\n        }\n\n        return $response;\n    }", "label": 2}
{"code": "def unicode_wrapper(self, property, default=ugettext('Untitled')):\n        \"\"\"\n        Wrapper to allow for easy unicode representation of an object by\n        the specified property. If this wrapper is not able to find the\n        right translation of the specified property, it will return the\n        default value instead.\n\n        Example::\n            def __unicode__(self):\n                return unicode_wrapper('name', default='Unnamed')\n\n        \"\"\"\n        # TODO: Test coverage!\n        try:\n            value = getattr(self, property)\n        except ValueError:\n            logger.warn(\n                u'ValueError rendering unicode for %s object.',\n                self._meta.object_name\n            )\n\n            value = None\n\n        if not value:\n            value = default\n\n        return value", "label": 1}
{"code": "public function setRetryConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Scheduler\\V1beta1\\RetryConfig::class);\n        $this->retry_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def table(name, identifier={:index => 0}, &block)\n      standard_methods(name, identifier, 'table_for', &block)\n      define_method(name) do\n        return platform.table_text_for identifier.clone unless block_given?\n        self.send(\"#{name}_element\").text\n      end\n    end", "label": 4}
{"code": "function rowsToCells (rows) {\n  if (!rows) {\n    return {}\n  }\n\n  const children = rows\n    .map((row) => {\n      return {\n        children: _.map(row, convertCell)\n      }\n    })\n\n  return {\n    children\n  }\n}", "label": 3}
{"code": "func UnicodeTranslatorFromFile(fileStr string) (f func(string) string, err error) {\n\tvar fl *os.File\n\tfl, err = os.Open(fileStr)\n\tif err == nil {\n\t\tf, err = UnicodeTranslator(fl)\n\t\tfl.Close()\n\t} else {\n\t\tf = doNothing\n\t}\n\treturn\n}", "label": 5}
{"code": "function makeFormData( payload ) {\n  let body = new FormData()\n  for( let k in (payload || {}) ) {\n    body.append( k, payload[k] )\n  }\n  return body\n}", "label": 3}
{"code": "def default_options\n      @default_options ||= Utils::Hash.symbolize({\n                                           PROJECT_NAME     => project_name,\n                                           TEST_KEY         => DEFAULT_TEST_SUITE,\n                                           TEMPLATE_KEY     => DEFAULT_TEMPLATE\n                                         }).freeze\n    end", "label": 4}
{"code": "public function setPublications($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Talent\\V4beta1\\Publication::class);\n        $this->publications = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def sanitize(val)\n      # TODO: check if there are cases where whitespace is not a separator\n      val = val.\n        gsub(/\\s*=\\s*/,'='). # remove whitespaces around equal sign\n        gsub(/[; ]+/, '; '). #use '; ' as a separator (or EOL)\n        gsub(/;\\s*$/,'') #remove trailing to keep examples below\n\n      if val =~ /(boundary=(\\S*))/i\n        val = \"#{$`.downcase}boundary=#{$2}#{$'.downcase}\"\n      else\n        val.downcase!\n      end\n\n      case\n      when val.chomp =~ /^\\s*([\\w\\-]+)\\/([\\w\\-]+)\\s*;\\s?(ISO[\\w\\-]+)$/i\n        # Microsoft helper:\n        # Handles 'type/subtype;ISO-8559-1'\n        \"#{$1}/#{$2}; charset=#{Utilities.quote_atom($3)}\"\n      when val.chomp =~ /^text;?$/i\n        # Handles 'text;' and 'text'\n        \"text/plain;\"\n      when val.chomp =~ /^(\\w+);\\s(.*)$/i\n        # Handles 'text; <parameters>'\n        \"text/plain; #{$2}\"\n      when val =~ /([\\w\\-]+\\/[\\w\\-]+);\\scharset=\"charset=\"(\\w+)\"\"/i\n        # Handles text/html; charset=\"charset=\"GB2312\"\"\n        \"#{$1}; charset=#{Utilities.quote_atom($2)}\"\n      when val =~ /([\\w\\-]+\\/[\\w\\-]+);\\s+(.*)/i\n        type = $1\n        # Handles misquoted param values\n        # e.g: application/octet-stream; name=archiveshelp1[1].htm\n        # and: audio/x-midi;\\r\\n\\sname=Part .exe\n        params = $2.to_s.split(/\\s+/)\n        params = params.map { |i| i.to_s.chomp.strip }\n        params = params.map { |i| i.split(/\\s*\\=\\s*/, 2) }\n        params = params.map { |i| \"#{i[0]}=#{Utilities.dquote(i[1].to_s.gsub(/;$/,\"\"))}\" }.join('; ')\n        \"#{type}; #{params}\"\n      when val =~ /^\\s*$/\n        'text/plain'\n      else\n        val\n      end\n    end", "label": 4}
{"code": "func (p DistributedVirtualPortgroup) EthernetCardBackingInfo(ctx context.Context) (types.BaseVirtualDeviceBackingInfo, error) {\n\tvar dvp mo.DistributedVirtualPortgroup\n\tvar dvs mo.DistributedVirtualSwitch\n\tprop := \"config.distributedVirtualSwitch\"\n\n\tif err := p.Properties(ctx, p.Reference(), []string{\"key\", prop}, &dvp); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// \"This property should always be set unless the user's setting does not have System.Read privilege on the object referred to by this property.\"\n\tif dvp.Config.DistributedVirtualSwitch == nil {\n\t\treturn nil, fmt.Errorf(\"no System.Read privilege on: %s.%s\", p.Reference(), prop)\n\t}\n\n\tif err := p.Properties(ctx, *dvp.Config.DistributedVirtualSwitch, []string{\"uuid\"}, &dvs); err != nil {\n\t\treturn nil, err\n\t}\n\n\tbacking := &types.VirtualEthernetCardDistributedVirtualPortBackingInfo{\n\t\tPort: types.DistributedVirtualSwitchPortConnection{\n\t\t\tPortgroupKey: dvp.Key,\n\t\t\tSwitchUuid:   dvs.Uuid,\n\t\t},\n\t}\n\n\treturn backing, nil\n}", "label": 5}
{"code": "func (c *ClusterConfigV3) SetDisconnectExpiredCert(b bool) {\n\tc.Spec.DisconnectExpiredCert = NewBool(b)\n}", "label": 5}
{"code": "func (r *RequestSecurityToken) toString(c14n bool) string {\n\tactas := \"\"\n\tif r.ActAs != nil {\n\t\ttoken := r.ActAs.Token\n\t\tif c14n {\n\t\t\tvar a Assertion\n\t\t\terr := Unmarshal([]byte(r.ActAs.Token), &a)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"decode ActAs: %s\", err)\n\t\t\t}\n\t\t\ttoken = a.C14N()\n\t\t}\n\n\t\tactas = fmt.Sprintf(`<wst:ActAs xmlns:wst=\"http://docs.oasis-open.org/ws-sx/ws-trust/200802\">%s</wst:ActAs>`, token)\n\t}\n\n\tbody := []string{\n\t\tfmt.Sprintf(`<RequestSecurityToken xmlns=\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\">`),\n\t\tfmt.Sprintf(`<TokenType>%s</TokenType>`, r.TokenType),\n\t\tfmt.Sprintf(`<RequestType>%s</RequestType>`, r.RequestType),\n\t\tr.Lifetime.C14N(),\n\t}\n\n\tif r.RenewTarget == nil {\n\t\tbody = append(body,\n\t\t\tfmt.Sprintf(`<Renewing Allow=\"%t\" OK=\"%t\"></Renewing>`, r.Renewing.Allow, r.Renewing.OK),\n\t\t\tfmt.Sprintf(`<Delegatable>%t</Delegatable>`, r.Delegatable),\n\t\t\tactas,\n\t\t\tfmt.Sprintf(`<KeyType>%s</KeyType>`, r.KeyType),\n\t\t\tfmt.Sprintf(`<SignatureAlgorithm>%s</SignatureAlgorithm>`, r.SignatureAlgorithm),\n\t\t\tfmt.Sprintf(`<UseKey Sig=\"%s\"></UseKey>`, r.UseKey.Sig))\n\t} else {\n\t\ttoken := r.RenewTarget.Token\n\t\tif c14n {\n\t\t\tvar a Assertion\n\t\t\terr := Unmarshal([]byte(r.RenewTarget.Token), &a)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"decode Renew: %s\", err)\n\t\t\t}\n\t\t\ttoken = a.C14N()\n\t\t}\n\n\t\tbody = append(body,\n\t\t\tfmt.Sprintf(`<UseKey Sig=\"%s\"></UseKey>`, r.UseKey.Sig),\n\t\t\tfmt.Sprintf(`<RenewTarget>%s</RenewTarget>`, token))\n\t}\n\n\treturn strings.Join(append(body, `</RequestSecurityToken>`), \"\")\n}", "label": 5}
{"code": "func Prepare(cfg PrepareConfig, dir string, uuid *types.UUID) error {\n\tif err := os.MkdirAll(common.AppsInfoPath(dir), common.DefaultRegularDirPerm); err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error creating apps info directory\"), err)\n\t}\n\tdebug(\"Preparing stage1\")\n\tif err := prepareStage1Image(cfg, dir); err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error preparing stage1\"), err)\n\t}\n\n\tvar pmb []byte\n\tvar err error\n\tif len(cfg.PodManifest) > 0 {\n\t\tpmb, err = validatePodManifest(cfg, dir)\n\t} else {\n\t\tpmb, err = generatePodManifest(cfg, dir)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcfg.CommonConfig.ManifestData = string(pmb)\n\n\t// create pod lock file for app add/rm operations.\n\tf, err := os.OpenFile(common.PodManifestLockPath(dir), os.O_CREATE|os.O_RDWR, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tf.Close()\n\n\tdebug(\"Writing pod manifest\")\n\tfn := common.PodManifestPath(dir)\n\tif err := ioutil.WriteFile(fn, pmb, common.DefaultRegularFilePerm); err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error writing pod manifest\"), err)\n\t}\n\n\tf, err = os.OpenFile(common.PodCreatedPath(dir), os.O_CREATE|os.O_RDWR, common.DefaultRegularFilePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\tf.Close()\n\n\tif cfg.UseOverlay {\n\t\t// mark the pod as prepared with overlay\n\t\tf, err := os.Create(filepath.Join(dir, common.OverlayPreparedFilename))\n\t\tif err != nil {\n\t\t\treturn errwrap.Wrap(errors.New(\"error writing overlay marker file\"), err)\n\t\t}\n\t\tdefer f.Close()\n\t}\n\n\tif cfg.PrivateUsers.Shift > 0 {\n\t\t// mark the pod as prepared for user namespaces\n\t\tuidrangeBytes := cfg.PrivateUsers.Serialize()\n\n\t\tif err := ioutil.WriteFile(filepath.Join(dir, common.PrivateUsersPreparedFilename), uidrangeBytes, common.DefaultRegularFilePerm); err != nil {\n\t\t\treturn errwrap.Wrap(errors.New(\"error writing userns marker file\"), err)\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def extract_noindex_attribute(name)\n      noindex       = extract(name)\n      noindex_name  = noindex.kind_of?(String) ? noindex : 'robots'\n      noindex_value = noindex ? name.to_s : nil\n\n      [ noindex_name, noindex_value ]\n    end", "label": 4}
{"code": "public static base_response update(nitro_service client, callhome resource) throws Exception {\n\t\tcallhome updateresource = new callhome();\n\t\tupdateresource.emailaddress = resource.emailaddress;\n\t\tupdateresource.proxymode = resource.proxymode;\n\t\tupdateresource.ipaddress = resource.ipaddress;\n\t\tupdateresource.port = resource.port;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "func (nDB *NetworkDB) WalkTable(tname string, fn func(string, string, []byte, bool) bool) error {\n\tnDB.RLock()\n\tvalues := make(map[string]interface{})\n\tnDB.indexes[byTable].WalkPrefix(fmt.Sprintf(\"/%s\", tname), func(path string, v interface{}) bool {\n\t\tvalues[path] = v\n\t\treturn false\n\t})\n\tnDB.RUnlock()\n\n\tfor k, v := range values {\n\t\tparams := strings.Split(k[1:], \"/\")\n\t\tnid := params[1]\n\t\tkey := params[2]\n\t\tif fn(nid, key, v.(*entry).value, v.(*entry).deleting) {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "function renderTemplateText(template, data, options) {\n    data = _.opts(data, {});\n    options = _.opts(options, {noEscape: true, compact: false});\n    // TODO: We should support recursively resolving, as in IB\n    return hb.compile(template, options)(_.defaults(data, globalSettings), {helpers: globalHelpers});\n  }", "label": 3}
{"code": "private Logger createLoggerInstance(String loggerName) throws Exception\r\n    {\r\n        Class loggerClass = getConfiguration().getLoggerClass();\r\n        Logger log = (Logger) ClassHelper.newInstance(loggerClass, String.class, loggerName);\r\n        log.configure(getConfiguration());\r\n        return log;\r\n    }", "label": 0}
{"code": "function(applicationId, start, end) {\n    return new Promise((resolve, reject) => {\n      this._start()\n          .uri('/api/report/daily-active-user')\n          .urlParameter('applicationId', applicationId)\n          .urlParameter('start', start)\n          .urlParameter('end', end)\n          .get()\n          .go(this._responseHandler(resolve, reject));\n    });\n  }", "label": 3}
{"code": "func (a *ArgType) TemplateLoader(name string) ([]byte, error) {\n\t// no template path specified\n\tif a.TemplatePath == \"\" {\n\t\treturn templates.Asset(name)\n\t}\n\n\treturn ioutil.ReadFile(path.Join(a.TemplatePath, name))\n}", "label": 5}
{"code": "def _compute_document_meta(self):\n        \"\"\"\n        Return documents meta information that can\n        be used for fast document lookups. Meta information\n        consists of documents titles, categories and positions\n        in file.\n        \"\"\"\n        meta = OrderedDict()\n\n        bounds_iter = xml_utils.bounds(self.filename,\n                            start_re=r'<text id=\"(\\d+)\"[^>]*name=\"([^\"]*)\"',\n                            end_re=r'</text>')\n\n        for match, bounds in bounds_iter:\n            doc_id, title = str(match.group(1)), match.group(2)\n            title = xml_utils.unescape_attribute(title)\n\n            # cache categories\n            xml_data = xml_utils.load_chunk(self.filename, bounds)\n            doc = Document(compat.ElementTree.XML(xml_data.encode('utf8')))\n\n            meta[doc_id] = _DocumentMeta(title, bounds, doc.categories())\n        return meta", "label": 1}
{"code": "function HubtelMobilePayment({\n  secretid = required('secretid'),\n  clientid = required('clientid'),\n  merchantaccnumber = required('merchantaccnumber'),\n}) {\n  this.config = {}\n  this.config['clientid'] = clientid\n  this.config['secretid'] = secretid\n  this.config['merchantaccnumber'] = merchantaccnumber\n  this.hubtelurl = 'https://api.hubtel.com/v1/merchantaccount/'\n}", "label": 3}
{"code": "function(token, userId, applicationId) {\n    return new Promise((resolve, reject) => {\n      this._start()\n          .uri('/api/jwt/refresh')\n          .urlParameter('token', token)\n          .urlParameter('userId', userId)\n          .urlParameter('applicationId', applicationId)\n          .delete()\n          .go(this._responseHandler(resolve, reject));\n    });\n  }", "label": 3}
{"code": "def remove_environment(env)\n      # Do not remove the content view environment, if there is still a view\n      # version in the environment.\n      if self.versions.in_environment(env).blank?\n        view_env = self.content_view_environments.where(:environment_id => env.id)\n        view_env.first.destroy unless view_env.blank?\n      end\n    end", "label": 4}
{"code": "func eventFilterChildren(event types.BaseEvent, self types.ManagedObjectReference) bool {\n\treturn doEntityEventArgument(event, func(ref types.ManagedObjectReference, _ *types.EntityEventArgument) bool {\n\t\tseen := false\n\n\t\tvar match func(types.ManagedObjectReference)\n\n\t\tmatch = func(child types.ManagedObjectReference) {\n\t\t\tif child == self {\n\t\t\t\tseen = true\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twalk(child, match)\n\t\t}\n\n\t\twalk(ref, match)\n\n\t\treturn seen\n\t})\n}", "label": 5}
{"code": "def create_zip_from_file(zip_file, fname):\n    \"\"\"\n    add a file to the archive\n    \"\"\"\n    with zipfile.ZipFile(zip_file, 'w') as myzip:\n        myzip.write(fname)", "label": 1}
{"code": "public function update(array $data, array $options = [])\n    {\n        return $this->writeResult(\n            $this->batchFactory()\n                ->update($this->name, $data, $options)\n                ->commit($options)\n        );\n    }", "label": 2}
{"code": "def get_file_from_url(job, any_url, encryption_key=None, per_file_encryption=True,\n                      write_to_jobstore=True):\n    \"\"\"\n    Download a supplied URL that points to a file on an http, https or ftp server.  If the file is\n    found to be an https s3 link then the file is downloaded using `get_file_from_s3`. The file is\n    downloaded and written to the jobstore if requested.\n    Encryption arguments are for passing to `get_file_from_s3` if required.\n\n    :param str any_url: URL for the file\n    :param str encryption_key: Path to the master key\n    :param bool per_file_encryption: If encrypted, was the file encrypted using the per-file method?\n    :param bool write_to_jobstore: Should the file be written to the job store?\n    :return: Path to the downloaded file or fsID (if write_to_jobstore was True)\n    :rtype: str|toil.fileStore.FileID\n    \"\"\"\n    work_dir = job.fileStore.getLocalTempDir()\n\n    filename = '/'.join([work_dir, str(uuid.uuid4())])\n    url = any_url\n    parsed_url = urlparse(any_url)\n    try:\n        response = urllib2.urlopen(url)\n    except urllib2.HTTPError:\n        if parsed_url.netloc.startswith(('s3', 'S3')):\n            job.fileStore.logToMaster(\"Detected https link is for an encrypted s3 file.\")\n            return get_file_from_s3(job, any_url, encryption_key=encryption_key,\n                                    per_file_encryption=per_file_encryption,\n                                    write_to_jobstore=write_to_jobstore)\n        else:\n            raise\n    else:\n        with open(filename, 'w') as f:\n            f.write(response.read())\n\n    if write_to_jobstore:\n        filename = job.fileStore.writeGlobalFile(filename)\n    return filename", "label": 1}
{"code": "def supported_territories\n      data = supported_countries\n      data.map { |country| Spaceship::Tunes::Territory.factory(country) }\n    end", "label": 4}
{"code": "def _update_model(self, case, B, Bsrc, v_angle, p_srcinj, p_ref, ref_idx):\n        \"\"\" Updates the case with values computed from the voltage phase\n            angle solution.\n        \"\"\"\n        iref = ref_idx\n        base_mva = case.base_mva\n        buses = case.connected_buses\n        branches = case.online_branches\n\n        p_from = (Bsrc * v_angle + p_srcinj) * base_mva\n        p_to = -p_from\n\n        for i, branch in enumerate(branches):\n            branch.p_from = p_from[i]\n            branch.p_to = p_to[i]\n            branch.q_from = 0.0\n            branch.q_to = 0.0\n\n        for j, bus in enumerate(buses):\n            bus.v_angle = v_angle[j] * (180 / pi)\n            bus.v_magnitude = 1.0\n\n        # Update Pg for swing generator.\n        g_ref = [g for g in case.generators if g.bus == buses[iref]][0]\n        # Pg = Pinj + Pload + Gs\n        # newPg = oldPg + newPinj - oldPinj\n        p_inj = (B[iref, :] * v_angle - p_ref) * base_mva\n        g_ref.p += p_inj[0]", "label": 1}
{"code": "function objectToDocument(entityObject, onlyDirty) {\n  expect(arguments).to.have.length.below(\n    3,\n    'Invalid arguments length when converting an entity object in a ' +\n    'MongoDB document (it has to be passed less than 3 arguments)'\n  );\n\n  expect(entityObject).to.be.an.instanceOf(\n    Entity,\n    'Invalid argument \"entityObject\" when converting an entity object in a ' +\n    'MongoDB document (it has to be an Entity instances)'\n  );\n\n  if (onlyDirty) {\n    expect(onlyDirty).to.be.a(\n      'boolean',\n      'Invalid argument \"onlyDirty\" when converting an entity object in a ' +\n      'MongoDB document (it has to be a boolean)'\n    );\n  }\n\n  var document = {};\n\n  var entityAttributes = entityObject.Entity.attributes;\n\n  for (var attributeName in entityAttributes) {\n    if (!onlyDirty || entityObject.isDirty(attributeName)) {\n      var attribute = entityAttributes[attributeName];\n      var attributeDataName = attribute.getDataName(entityObject.adapterName);\n      var attributeDataValue = attribute.getDataValue(\n        entityObject[attributeName]\n      );\n      document[attributeDataName] = attributeDataValue;\n    }\n  }\n\n  document.Entity = entityObject.Entity.specification.name;\n\n  if (!onlyDirty) {\n    document._id = entityObject.id;\n  }\n\n  delete document.id;\n\n  return document;\n}", "label": 3}
{"code": "public Archetype parse(String adl) {\n        try {\n            return parse(new StringReader(adl));\n        } catch (IOException e) {\n            // StringReader should never throw an IOException\n            throw new AssertionError(e);\n        }\n    }", "label": 0}
{"code": "func NewUserContext(user services.User, userRoles services.RoleSet) (*userContext, error) {\n\tctx := &services.Context{User: user}\n\tsessionAccess := newAccess(userRoles, ctx, services.KindSession)\n\troleAccess := newAccess(userRoles, ctx, services.KindRole)\n\tauthConnectors := newAccess(userRoles, ctx, services.KindAuthConnector)\n\ttrustedClusterAccess := newAccess(userRoles, ctx, services.KindTrustedCluster)\n\tlogins := getLogins(userRoles)\n\n\tacl := userACL{\n\t\tAuthConnectors:  authConnectors,\n\t\tTrustedClusters: trustedClusterAccess,\n\t\tSessions:        sessionAccess,\n\t\tRoles:           roleAccess,\n\t\tSSHLogins:       logins,\n\t}\n\n\t// local user\n\tauthType := authLocal\n\n\t// check for any SSO identities\n\tisSSO := len(user.GetOIDCIdentities()) > 0 ||\n\t\tlen(user.GetGithubIdentities()) > 0 ||\n\t\tlen(user.GetSAMLIdentities()) > 0\n\n\tif isSSO {\n\t\t// SSO user\n\t\tauthType = authSSO\n\t}\n\n\treturn &userContext{\n\t\tName:     user.GetName(),\n\t\tACL:      acl,\n\t\tAuthType: authType,\n\t\tVersion:  teleport.Version,\n\t}, nil\n}", "label": 5}
{"code": "private function getSysvKey($idNum)\n    {\n        $key = getenv('GOOGLE_CLOUD_SYSV_ID') ?: self::$productionKey;\n        $base = ftok(__FILE__, $key);\n        if ($base == PHP_INT_MAX) {\n            $base = 1;\n        }\n        return $base + $idNum;\n    }", "label": 2}
{"code": "public static base_response update(nitro_service client, autoscaleprofile resource) throws Exception {\n\t\tautoscaleprofile updateresource = new autoscaleprofile();\n\t\tupdateresource.name = resource.name;\n\t\tupdateresource.url = resource.url;\n\t\tupdateresource.apikey = resource.apikey;\n\t\tupdateresource.sharedsecret = resource.sharedsecret;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def post(path, options = {}, &block)\n      perform_request Net::HTTP::Post, path, options, &block\n    end", "label": 4}
{"code": "private GraphicsDocument createFeatureDocument(StringWriter writer) throws RenderException {\n\t\tif (TileMetadata.PARAM_SVG_RENDERER.equalsIgnoreCase(renderer)) {\n\t\t\tDefaultSvgDocument document = new DefaultSvgDocument(writer, false);\n\t\t\tdocument.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);\n\t\t\tdocument.registerWriter(InternalFeatureImpl.class, new SvgFeatureWriter(getTransformer()));\n\t\t\tdocument.registerWriter(InternalTileImpl.class, new SvgTileWriter());\n\t\t\treturn document;\n\t\t} else if (TileMetadata.PARAM_VML_RENDERER.equalsIgnoreCase(renderer)) {\n\t\t\tDefaultVmlDocument document = new DefaultVmlDocument(writer);\n\t\t\tint coordWidth = tile.getScreenWidth();\n\t\t\tint coordHeight = tile.getScreenHeight();\n\t\t\tdocument.registerWriter(InternalFeatureImpl.class, new VmlFeatureWriter(getTransformer(), coordWidth,\n\t\t\t\t\tcoordHeight));\n\t\t\tdocument.registerWriter(InternalTileImpl.class, new VmlTileWriter(coordWidth, coordHeight));\n\t\t\tdocument.setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);\n\t\t\treturn document;\n\t\t} else {\n\t\t\tthrow new RenderException(ExceptionCode.RENDERER_TYPE_NOT_SUPPORTED, renderer);\n\t\t}\n\t}", "label": 0}
{"code": "public static void init() {\n        reports.clear();\n        Reflections reflections = new Reflections(REPORTS_PACKAGE);\n        final Set<Class<? extends Report>> reportClasses = reflections.getSubTypesOf(Report.class);\n\n        for(Class<? extends Report> c : reportClasses) {\n            LOG.info(\"Report class: \" + c.getName());\n            try {\n                reports.add(c.newInstance());\n            } catch (IllegalAccessException | InstantiationException e) {\n                LOG.error(\"Error while loading report implementation classes\", e);\n            }\n        }\n\n        if(LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"Detected %s reports\", reports.size()));\n        }\n    }", "label": 0}
{"code": "def write_template(fn, lang=\"python\"):\n    \"\"\"\n    Write language-specific script template to file.\n\n    Arguments:\n\n      - fn(``string``) path to save the template to\n      - lang('python', 'bash') which programming language\n      \n    \"\"\"\n    with open(fn, \"wb\") as fh:\n        if lang == \"python\":\n            fh.write(PY_TEMPLATE)\n        elif lang == \"bash\":\n            fh.write(SH_TEMPLATE)", "label": 1}
{"code": "def get_bibtex(identifier):\n    \"\"\"\n    Try to fetch BibTeX from a found identifier.\n\n    .. note::\n\n        Calls the functions in the respective identifiers module.\n\n    :param identifier: a tuple (type, identifier) with a valid type.\n    :returns: A BibTeX string or ``None`` if an error occurred.\n    # TODO: Should return a BiBTeX object?\n    \"\"\"\n    identifier_type, identifier_id = identifier\n    if identifier_type not in __valid_identifiers__:\n        return None\n\n    # Dynamically call the ``get_bibtex`` method from the associated module.\n    module = sys.modules.get(\"libbmc.%s\" % (identifier_type,), None)\n    if module is None:\n        return None\n    return getattr(module, \"get_bibtex\")(identifier_id)", "label": 1}
{"code": "func (s *Server) closeConnChan(c net.Conn, done chan<- struct{}) {\n\tc.Close()\n\tif done != nil {\n\t\tdone <- struct{}{}\n\t}\n}", "label": 5}
{"code": "private function handleStream($response)\n    {\n        try {\n            foreach ($response->readAll() as $count => $result) {\n                $res = $this->serializer->encodeMessage($result);\n                yield $res;\n            }\n        } catch (\\Exception $ex) {\n            throw $this->convertToGoogleException($ex);\n        }\n    }", "label": 2}
{"code": "func SwitchLoggingtoSyslog() error {\n\tlog.StandardLogger().SetHooks(make(log.LevelHooks))\n\thook, err := logrusSyslog.NewSyslogHook(\"\", \"\", syslog.LOG_WARNING, \"\")\n\tif err != nil {\n\t\t// syslog is not available\n\t\tlog.SetOutput(os.Stderr)\n\t\treturn trace.Wrap(err)\n\t}\n\tlog.AddHook(hook)\n\t// ... and disable stderr:\n\tlog.SetOutput(ioutil.Discard)\n\treturn nil\n}", "label": 5}
{"code": "public static function loadDriver($driver, $explicit = false)\n    {\n        array_unshift(self::$drivers, $driver);\n        if (method_exists($driver, 'loadExtension')) {\n            call_user_func([$driver, 'loadExtension']);\n        }\n\n        if (method_exists($driver, 'additionalDrivers') && $explicit === false) {\n            $additionalDrivers = (array) call_user_func([$driver, 'additionalDrivers']);\n            foreach ($additionalDrivers as $additionalDriver) {\n                self::loadDriver($additionalDriver);\n            }\n        }\n\n        self::$drivers = array_unique(self::$drivers);\n    }", "label": 2}
{"code": "public static route[] get(nitro_service service, options option) throws Exception{\n\t\troute obj = new route();\n\t\troute[] response = (route[])obj.get_resources(service,option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function listClusters($projectId, $zone, array $optionalArgs = [])\n    {\n        $request = new ListClustersRequest();\n        $request->setProjectId($projectId);\n        $request->setZone($zone);\n        if (isset($optionalArgs['parent'])) {\n            $request->setParent($optionalArgs['parent']);\n        }\n\n        $requestParams = new RequestParamsHeaderDescriptor([\n          'parent' => $request->getParent(),\n        ]);\n        $optionalArgs['headers'] = isset($optionalArgs['headers'])\n            ? array_merge($requestParams->getHeader(), $optionalArgs['headers'])\n            : $requestParams->getHeader();\n\n        return $this->startCall(\n            'ListClusters',\n            ListClustersResponse::class,\n            $optionalArgs,\n            $request\n        )->wait();\n    }", "label": 2}
{"code": "public static base_responses reset(nitro_service client, Interface resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tInterface resetresources[] = new Interface[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tresetresources[i] = new Interface();\n\t\t\t\tresetresources[i].id = resources[i].id;\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, resetresources,\"reset\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "func NewLogMessage(bee string, message string, messageType uint) LogMessage {\n\treturn LogMessage{\n\t\tID:          UUID(),\n\t\tBee:         bee,\n\t\tMessage:     message,\n\t\tMessageType: messageType,\n\t\tTimestamp:   time.Now(),\n\t}\n}", "label": 5}
{"code": "public function DeleteInstance(\\Google\\Cloud\\Spanner\\Admin\\Instance\\V1\\DeleteInstanceRequest $argument,\n      $metadata = [], $options = []) {\n        return $this->_simpleRequest('/google.spanner.admin.instance.v1.InstanceAdmin/DeleteInstance',\n        $argument,\n        ['\\Google\\Protobuf\\GPBEmpty', 'decode'],\n        $metadata, $options);\n    }", "label": 2}
{"code": "private Envelope getBoundsLocal(Filter filter) throws LayerException {\n\t\ttry {\n\t\t\tSession session = getSessionFactory().getCurrentSession();\n\t\t\tCriteria criteria = session.createCriteria(getFeatureInfo().getDataSourceName());\n\t\t\tCriteriaVisitor visitor = new CriteriaVisitor((HibernateFeatureModel) getFeatureModel(), dateFormat);\n\t\t\tCriterion c = (Criterion) filter.accept(visitor, criteria);\n\t\t\tif (c != null) {\n\t\t\t\tcriteria.add(c);\n\t\t\t}\n\t\t\tcriteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);\n\t\t\tList<?> features = criteria.list();\n\t\t\tEnvelope bounds = new Envelope();\n\t\t\tfor (Object f : features) {\n\t\t\t\tEnvelope geomBounds = getFeatureModel().getGeometry(f).getEnvelopeInternal();\n\t\t\t\tif (!geomBounds.isNull()) {\n\t\t\t\t\tbounds.expandToInclude(geomBounds);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bounds;\n\t\t} catch (HibernateException he) {\n\t\t\tthrow new HibernateLayerException(he, ExceptionCode.HIBERNATE_LOAD_FILTER_FAIL, getFeatureInfo()\n\t\t\t\t\t.getDataSourceName(), filter.toString());\n\t\t}\n\t}", "label": 0}
{"code": "func (c *Manager) GetLibraryByID(ctx context.Context, id string) (*Library, error) {\n\turl := internal.URL(c, internal.LibraryPath).WithID(id)\n\tvar res Library\n\treturn &res, c.Do(ctx, url.Request(http.MethodGet), &res)\n}", "label": 5}
{"code": "def country_or_default_country(country)\n      country ||= (original_starts_with_plus? ? nil : Phonelib.default_country)\n      country && country.to_s.upcase\n    end", "label": 4}
{"code": "public static <ObjType, Hashable> Collection<ObjType> uniqueNonhashableObjects(Collection<ObjType> objects, Function<ObjType, Hashable> customHasher) {\r\n    Map<Hashable, ObjType> hashesToObjects = new HashMap<Hashable, ObjType>();\r\n    for (ObjType object : objects) {\r\n      hashesToObjects.put(customHasher.apply(object), object);\r\n    }\r\n    return hashesToObjects.values();\r\n  }", "label": 0}
{"code": "def external_link_checker(external_urls)\n      external_urls = Hash[external_urls.sort]\n\n      count = external_urls.length\n      check_text = pluralize(count, 'external link', 'external links')\n      @logger.log :info, \"Checking #{check_text}...\"\n\n      # Route log from Typhoeus/Ethon to our own logger\n      Ethon.logger = @logger\n\n      establish_queue(external_urls)\n\n      @hydra.run\n    end", "label": 4}
{"code": "function(pkg){\n\t\tvar pkg = pkg || this.getPackage();\n\t\tvar requestedVersion = this.requestedVersion;\n\n\t\treturn SemVer.validRange(requestedVersion) &&\n\t\t\tSemVer.valid(pkg.version) ?\n\t\t\tSemVer.satisfies(pkg.version, requestedVersion) : true;\n\t}", "label": 3}
{"code": "protected function prepareCountQuery()\n    {\n        $builder = clone $this->query;\n\n        if (! $this->isComplexQuery($builder)) {\n            $row_count = $this->wrap('row_count');\n            $builder->select($this->connection->raw(\"'1' as {$row_count}\"));\n            if (! $this->keepSelectBindings) {\n                $builder->setBindings([], 'select');\n            }\n        }\n\n        return $builder;\n    }", "label": 2}
{"code": "func OptionResolvConfPath(path string) SandboxOption {\n\treturn func(sb *sandbox) {\n\t\tsb.config.resolvConfPath = path\n\t}\n}", "label": 5}
{"code": "func openDB(args *internal.ArgType) error {\n\tvar err error\n\n\t// parse dsn\n\tu, err := dburl.Parse(args.DSN)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// save driver type\n\targs.LoaderType = u.Driver\n\n\t// grab loader\n\tvar ok bool\n\targs.Loader, ok = internal.SchemaLoaders[u.Driver]\n\tif !ok {\n\t\treturn errors.New(\"unsupported database type\")\n\t}\n\n\t// open database connection\n\targs.DB, err = sql.Open(u.Driver, u.DSN)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public function setRequestMetadata($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Audit\\RequestMetadata::class);\n        $this->request_metadata = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def sjoiner(inbox, s=None, join=\"\"):\n    \"\"\" \n    String joins input with indices in s.\n\n    Arguments:\n\n      - s(sequence) [default: ``None``] ``tuple`` or ``list`` of indices of the\n        elements which will be joined.\n      - join(``str``) [default: ``\"\"``] String which will join the elements of \n        the inbox i.e. ``join.join()``.\n\n    \"\"\"\n    return join.join([input_ for i, input_ in enumerate(inbox) if i in s])", "label": 1}
{"code": "def insert_content(object, location = -1)\n      object = { is_reference_only: true, referenced_object: { indirect_reference_id: 0, raw_stream_content: object } } if object.is_a?(String)\n      raise TypeError, 'expected a String or Hash object.' unless object.is_a?(Hash)\n      prep_content_array\n      self[:Contents].insert location, object\n      self[:Contents].flatten!\n      self\n    end", "label": 4}
{"code": "def adjust_tasks(klass)\n      class_name = @code_path.to_s.sub(/.*\\/functions\\//,'').sub(/\\.rb$/, '')\n      class_name = class_name.classify\n      klass.tasks.each do |task|\n        task.class_name = class_name\n        task.type = \"function\"\n      end\n    end", "label": 4}
{"code": "def set_schema_location(self, ns_uri, schema_location, replace=False):\n        \"\"\"Sets the schema location of the given namespace.\n\n        If ``replace`` is ``True``, then any existing schema location is\n        replaced.  Otherwise, if the schema location is already set to a\n        different value, an exception is raised.  If the schema location is set\n        to None, it is effectively erased from this set (this is not considered\n        \"replacement\".)\n\n        Args:\n            ns_uri (str): The namespace whose schema location is to be set\n            schema_location (str): The schema location URI to set, or None\n            replace (bool): Whether to replace any existing schema location\n\n        Raises:\n            NamespaceNotFoundError: If the given namespace isn't in this set.\n            ConflictingSchemaLocationError: If replace is False,\n                schema_location is not None, and the namespace already has a\n                different schema location in this set.\n        \"\"\"\n        ni = self.__lookup_uri(ns_uri)\n\n        if ni.schema_location == schema_location:\n            return\n        elif replace or ni.schema_location is None:\n            ni.schema_location = schema_location\n        elif schema_location is None:\n            ni.schema_location = None  # Not considered \"replacement\".\n        else:\n            raise ConflictingSchemaLocationError(ns_uri, ni.schema_location, schema_location)", "label": 1}
{"code": "def _inplace_sort_by_id(unsorted_list):\n    \"\"\"Takes a list of dicts each of which has an '@id' key,\n    sorts the elements in the list by the value of the @id key.\n    Assumes that @id is unique or the dicts have a meaningul < operator\n    \"\"\"\n    if not isinstance(unsorted_list, list):\n        return\n    sorted_list = [(i.get('@id'), i) for i in unsorted_list]\n    sorted_list.sort()\n    del unsorted_list[:]\n    unsorted_list.extend([i[1] for i in sorted_list])", "label": 1}
{"code": "public FieldDescriptorDef getField(String name)\r\n    {\r\n        FieldDescriptorDef fieldDef = null;\r\n\r\n        for (Iterator it = _fields.iterator(); it.hasNext(); )\r\n        {\r\n            fieldDef = (FieldDescriptorDef)it.next();\r\n            if (fieldDef.getName().equals(name))\r\n            {\r\n                return fieldDef;\r\n            }\r\n        }\r\n        return null;\r\n    }", "label": 0}
{"code": "function(obj) {\r\n    if (obj.normal) {\r\n      // obj is a plane\r\n      var A = this.anchor.elements, D = this.direction.elements;\r\n      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];\r\n      var newA = this.anchor.reflectionIn(obj).elements;\r\n      // Add the line's direction vector to its anchor, then mirror that in the plane\r\n      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;\r\n      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;\r\n      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];\r\n      return Line.create(newA, newD);\r\n    } else if (obj.direction) {\r\n      // obj is a line - reflection obtained by rotating PI radians about obj\r\n      return this.rotate(Math.PI, obj);\r\n    } else {\r\n      // obj is a point - just reflect the line's anchor in it\r\n      var P = obj.elements || obj;\r\n      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);\r\n    }\r\n  }", "label": 3}
{"code": "func ParseCertificateRequestPEM(bytes []byte) (*x509.CertificateRequest, error) {\n\tblock, _ := pem.Decode(bytes)\n\tif block == nil {\n\t\treturn nil, trace.BadParameter(\"expected PEM-encoded block\")\n\t}\n\tcsr, err := x509.ParseCertificateRequest(block.Bytes)\n\tif err != nil {\n\t\treturn nil, trace.BadParameter(err.Error())\n\t}\n\treturn csr, nil\n}", "label": 5}
{"code": "function(selector) {\n    for (var ii = 0; ii < document.styleSheets.length; ++ii) {\n      var styleSheet = document.styleSheets[ii];\n      var rules = styleSheet.cssRules || styleSheet.rules;\n      if (rules) {\n        for (var rr = 0; rr < rules.length; ++rr) {\n          var rule = rules[rr];\n          if (rule.selectorText === selector) {\n            return rule;\n          }\n        }\n      }\n    }\n  }", "label": 3}
{"code": "function warn() {\n    var _console2;\n\n    if (LatticeLogs.failFast(LatticeLogs.WARN)) return;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    (_console2 = console).warn.apply(_console2, (0, _toConsumableArray2.default)(args.map(LatticeLogs.argMapper)));\n  }", "label": 3}
{"code": "function(element, settings, bindingContext, fromBinding) {\n            if(!fromBinding){\n                settings = widget.getSettings(function() { return settings; }, element);\n            }\n\n            var compositionSettings = widget.createCompositionSettings(element, settings);\n\n            composition.compose(element, compositionSettings, bindingContext);\n        }", "label": 3}
{"code": "@AfterThrowing(pointcut = \"execution(* org.apache.cassandra.thrift.CassandraServer.doInsert(..))\", throwing = \"throwable\")\n    public void logErrorFromThrownException(final JoinPoint joinPoint, final Throwable throwable) {\n        final String className = joinPoint.getTarget().getClass().getName();\n        final String methodName = joinPoint.getSignature().getName();\n\n        logger.error(\"Could not write to cassandra! Method: \" + className + \".\"+ methodName + \"()\", throwable);\n    }", "label": 0}
{"code": "func (self *QueueCursor) ReadPacket() (pkt av.Packet, err error) {\n\tself.que.cond.L.Lock()\n\tbuf := self.que.buf\n\tif !self.gotpos {\n\t\tself.pos = self.init(buf, self.que.videoidx)\n\t\tself.gotpos = true\n\t}\n\tfor {\n\t\tif self.pos.LT(buf.Head) {\n\t\t\tself.pos = buf.Head\n\t\t} else if self.pos.GT(buf.Tail) {\n\t\t\tself.pos = buf.Tail\n\t\t}\n\t\tif buf.IsValidPos(self.pos) {\n\t\t\tpkt = buf.Get(self.pos)\n\t\t\tself.pos++\n\t\t\tbreak\n\t\t}\n\t\tif self.que.closed {\n\t\t\terr = io.EOF\n\t\t\tbreak\n\t\t}\n\t\tself.que.cond.Wait()\n\t}\n\tself.que.cond.L.Unlock()\n\treturn\n}", "label": 5}
{"code": "func (s SortedTrustedCluster) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}", "label": 5}
{"code": "func (cn *connection) request(r request, mw messageWriter) bool {\n\tif _, ok := cn.requests[r]; ok {\n\t\tpanic(\"chunk already requested\")\n\t}\n\tif !cn.PeerHasPiece(pieceIndex(r.Index)) {\n\t\tpanic(\"requesting piece peer doesn't have\")\n\t}\n\tif _, ok := cn.t.conns[cn]; !ok {\n\t\tpanic(\"requesting but not in active conns\")\n\t}\n\tif cn.closed.IsSet() {\n\t\tpanic(\"requesting when connection is closed\")\n\t}\n\tif cn.PeerChoked {\n\t\tif cn.peerAllowedFast.Get(int(r.Index)) {\n\t\t\ttorrent.Add(\"allowed fast requests sent\", 1)\n\t\t} else {\n\t\t\tpanic(\"requesting while choked and not allowed fast\")\n\t\t}\n\t}\n\tif cn.t.hashingPiece(pieceIndex(r.Index)) {\n\t\tpanic(\"piece is being hashed\")\n\t}\n\tif cn.t.pieceQueuedForHash(pieceIndex(r.Index)) {\n\t\tpanic(\"piece is queued for hash\")\n\t}\n\tif cn.requests == nil {\n\t\tcn.requests = make(map[request]struct{})\n\t}\n\tcn.requests[r] = struct{}{}\n\tif cn.validReceiveChunks == nil {\n\t\tcn.validReceiveChunks = make(map[request]struct{})\n\t}\n\tcn.validReceiveChunks[r] = struct{}{}\n\tcn.t.pendingRequests[r]++\n\tcn.t.lastRequested[r] = time.AfterFunc(cn.t.duplicateRequestTimeout, func() {\n\t\ttorrent.Add(\"duplicate request timeouts\", 1)\n\t\tcn.mu().Lock()\n\t\tdefer cn.mu().Unlock()\n\t\tdelete(cn.t.lastRequested, r)\n\t\tfor cn := range cn.t.conns {\n\t\t\tif cn.PeerHasPiece(pieceIndex(r.Index)) {\n\t\t\t\tcn.updateRequests()\n\t\t\t}\n\t\t}\n\t})\n\tcn.updateExpectingChunks()\n\treturn mw(pp.Message{\n\t\tType:   pp.Request,\n\t\tIndex:  r.Index,\n\t\tBegin:  r.Begin,\n\t\tLength: r.Length,\n\t})\n}", "label": 5}
{"code": "def symbol(currency, *, native=True):\n\t\"\"\" return symbol of currency \"\"\"\n\tcurrency = validate_currency(currency)\n\tif native:\n\t\treturn _currencies[currency]['symbol_native']\n\treturn _currencies[currency]['symbol']", "label": 1}
{"code": "function isLocalModule(modulePath) {\n  // TODO: handle alias module path like src\n  const alias = getModuleResolverAlias();\n  return /^\\./.test(modulePath) || _.keys(alias).some(a => modulePath === a || _.startsWith(modulePath, a + '/'));\n}", "label": 3}
{"code": "public function setTimestamps($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Protobuf\\Timestamp::class);\n        $this->timestamps = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (i *Idm) GetSpecificID(id uint64) error {\n\tif i.handle == nil {\n\t\treturn errors.New(\"ID set is not initialized\")\n\t}\n\n\tif id < i.start || id > i.end {\n\t\treturn errors.New(\"Requested id does not belong to the set\")\n\t}\n\n\treturn i.handle.Set(id - i.start)\n}", "label": 5}
{"code": "public function monitor(array $tags)\n    {\n        $tags = array_diff($tags, $this->monitoring());\n\n        if (empty($tags)) {\n            return;\n        }\n\n        $this->table('telescope_monitoring')\n                    ->insert(collect($tags)\n                    ->mapWithKeys(function ($tag) {\n                        return ['tag' => $tag];\n                    })->all());\n    }", "label": 2}
{"code": "public function submit($item, $idNum)\n    {\n        if (!$this->hasShutdownHookRegistered) {\n            register_shutdown_function([$this, 'shutdown']);\n            $this->hasShutdownHookRegistered = true;\n        }\n        if (!array_key_exists($idNum, $this->items)) {\n            $this->items[$idNum] = [];\n            $this->lastInvoked[$idNum] = $this->created;\n        }\n        $this->items[$idNum][] = $item;\n        $job = $this->config->getJobFromIdNum($idNum);\n        $batchSize = $job->getBatchSize();\n        $period = $job->getCallPeriod();\n        if ((count($this->items[$idNum]) >= $batchSize)\n             || (count($this->items[$idNum]) !== 0\n                 && microtime(true) > $this->lastInvoked[$idNum] + $period)) {\n            $this->flush($idNum);\n            $this->items[$idNum] = [];\n            $this->lastInvoked[$idNum] = microtime(true);\n        }\n    }", "label": 2}
{"code": "func generateMacAddress() (net.HardwareAddr, error) {\n\tmac := []byte{\n\t\t2,          // locally administered unicast\n\t\t0x65, 0x02, // OUI (randomly chosen by jell)\n\t\t0, 0, 0, // bytes to randomly overwrite\n\t}\n\n\t_, err := rand.Read(mac[3:6])\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"cannot generate random mac address\"), err)\n\t}\n\n\treturn mac, nil\n}", "label": 5}
{"code": "function isParameterAssigned(symbol) {\n            var func = ts.getRootDeclaration(symbol.valueDeclaration).parent;\n            var links = getNodeLinks(func);\n            if (!(links.flags & 4194304 /* AssignmentsMarked */)) {\n                links.flags |= 4194304 /* AssignmentsMarked */;\n                if (!hasParentWithAssignmentsMarked(func)) {\n                    markParameterAssignments(func);\n                }\n            }\n            return symbol.isAssigned || false;\n        }", "label": 3}
{"code": "public PBKey getPBKey()\r\n    {\r\n        if (pbKey == null)\r\n        {\r\n            this.pbKey = new PBKey(this.getJcdAlias(), this.getUserName(), this.getPassWord());\r\n        }\r\n        return pbKey;\r\n    }", "label": 0}
{"code": "public static appfwxmlcontenttype[] get(nitro_service service, String xmlcontenttypevalue[]) throws Exception{\n\t\tif (xmlcontenttypevalue !=null && xmlcontenttypevalue.length>0) {\n\t\t\tappfwxmlcontenttype response[] = new appfwxmlcontenttype[xmlcontenttypevalue.length];\n\t\t\tappfwxmlcontenttype obj[] = new appfwxmlcontenttype[xmlcontenttypevalue.length];\n\t\t\tfor (int i=0;i<xmlcontenttypevalue.length;i++) {\n\t\t\t\tobj[i] = new appfwxmlcontenttype();\n\t\t\t\tobj[i].set_xmlcontenttypevalue(xmlcontenttypevalue[i]);\n\t\t\t\tresponse[i] = (appfwxmlcontenttype) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "function(e) {\n      var tooltip = this.$(\".ui-tooltip-top\");\n      var val = this.input.val();\n      tooltip.fadeOut();\n      if (this.tooltipTimeout) clearTimeout(this.tooltipTimeout);\n      if (val == '' || val == this.input.attr('placeholder')) return;\n      var show = function(){ tooltip.show().fadeIn(); };\n      this.tooltipTimeout = _.delay(show, 1000);\n    }", "label": 3}
{"code": "def single_content_for(name, content = nil, &block)\n      @view_flow.set(name, ActiveSupport::SafeBuffer.new)\n      content_for(name, content, &block)\n    end", "label": 4}
{"code": "public function markAllAsRead(User $user)\n    {\n        Notification::where('user_id', $user->id)->update(['read_at' => Carbon::now()]);\n    }", "label": 2}
{"code": "func NotImplementedErrorf(format string, params ...interface{}) error {\n\treturn notImpl(fmt.Sprintf(format, params...))\n}", "label": 5}
{"code": "public static <T> List<T> makeList(T... items) {\r\n    List<T> s = new ArrayList<T>(items.length);\r\n    for (int i = 0; i < items.length; i++) {\r\n      s.add(items[i]);\r\n    }\r\n    return s;\r\n  }", "label": 0}
{"code": "def getResourceTypes(self):\n        \"\"\" Get the list of resource types supported by the HydroShare server\n\n        :return: A set of strings representing the HydroShare resource types\n\n        :raises: HydroShareHTTPException to signal an HTTP error\n        \"\"\"\n        url = \"{url_base}/resource/types\".format(url_base=self.url_base)\n\n        r = self._request('GET', url)\n        if r.status_code != 200:\n            raise HydroShareHTTPException((url, 'GET', r.status_code))\n\n        resource_types = r.json()\n        return set([t['resource_type'] for t in resource_types])", "label": 1}
{"code": "final void begin() {\n    if (LogFileCompressionStrategy.existsFor(this.properties)) {\n      final Thread thread = new Thread(this, \"Log4J File Compressor\");\n      thread.setDaemon(true);\n      thread.start();\n      this.threadRef = thread;\n    }\n  }", "label": 0}
{"code": "func (c *crontime) checkValues() {\n\tfor _, sec := range c.second {\n\t\tif sec >= 60 || sec < 0 {\n\t\t\tlog.Panicln(\"Cronbee: Your config seems messed up. Check the range of \\\"Second\\\".\")\n\t\t}\n\t}\n\n\tfor _, min := range c.second {\n\t\tif min >= 60 || min < 0 {\n\t\t\tlog.Panicln(\"Cronbee: Your config seems messed up. Check the range of \\\"Minute\\\".\")\n\t\t}\n\t}\n\n\tfor _, hour := range c.hour {\n\t\tif hour >= 24 || hour < 0 {\n\t\t\tlog.Panicln(\"Cronbee: Your config seems messed up. Check the range of \\\"Hour\\\".\")\n\t\t}\n\t}\n\n\tfor _, dow := range c.dow {\n\t\tif dow >= 7 || dow < 0 {\n\t\t\tlog.Panicln(\"Cronbee: Your config seems messed up. Check the range of \\\"DayOfWeek\\\".\")\n\t\t}\n\t}\n\n\tfor _, dom := range c.dom {\n\t\tif dom >= 32 || dom < 1 {\n\t\t\tlog.Panicln(\"Cronbee: Your config seems messed up. Check the range of \\\"DayOfMonth\\\".\")\n\t\t}\n\t}\n\n\tfor _, month := range c.month {\n\t\tif month >= 13 || month < 1 {\n\t\t\tlog.Panicln(\"Cronbee: Your config seems messed up. Check the range of \\\"Month\\\".\")\n\t\t}\n\t}\n}", "label": 5}
{"code": "function parseEncodedUrl(encodedUrl) {\n  var url = '';\n\n  for(var cChar = 0; cChar < (encodedUrl.length / 2); cChar++) {\n    var charCode = parseInt(encodedUrl.substr(cChar*2,2),16);\n    switch(charCode) {\n      case 0x00:\n        url += \".com/\";\n        break;\n      case 0x01:\n        url += \".org/\";\n        break;\n      case 0x02:\n        url += \".edu/\";\n        break;\n      case 0x03:\n        url += \".net/\";\n        break;\n      case 0x04:\n        url += \".info/\";\n        break;\n      case 0x05:\n        url += \".biz/\";\n        break;\n      case 0x06:\n        url += \".gov/\";\n        break;\n      case 0x07:\n        url += \".com\";\n        break;\n      case 0x08:\n        url += \".org\";\n        break;\n      case 0x09:\n        url += \".edu\";\n        break;\n      case 0x0a:\n        url += \".net\";\n        break;\n      case 0x0b:\n        url += \".info\";\n        break;\n      case 0x0c:\n        url += \".biz\";\n        break;\n      case 0x0d:\n        url += \".gov\";\n        break;\n      default:\n        url += String.fromCharCode(charCode);\n    }\n  }\n\n  return url;\n}", "label": 3}
{"code": "func (c *Manager) GetAttachedTags(ctx context.Context, ref mo.Reference) ([]Tag, error) {\n\tids, err := c.ListAttachedTags(ctx, ref)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"get attached tags %s: %s\", ref, err)\n\t}\n\n\tvar info []Tag\n\tfor _, id := range ids {\n\t\ttag, err := c.GetTag(ctx, id)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"get tag %s: %s\", id, err)\n\t\t}\n\t\tinfo = append(info, *tag)\n\t}\n\treturn info, nil\n}", "label": 5}
{"code": "public function flush($idNum)\n    {\n        if (isset($this->items[$idNum])) {\n            $job = $this->config->getJobFromIdNum($idNum);\n\n            if (!$job->flush($this->items[$idNum])) {\n                $this->handleFailure($idNum, $this->items[$idNum]);\n            }\n\n            $this->items[$idNum] = [];\n            $this->lastInvoked[$idNum] = microtime(true);\n        }\n\n        return true;\n    }", "label": 2}
{"code": "def register(resource, options = {}, &block)\n      ns = options.fetch(:namespace) { default_namespace }\n      namespace(ns).register resource, options, &block\n    end", "label": 4}
{"code": "public static base_responses add(nitro_service client, dnscnamerec resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tdnscnamerec addresources[] = new dnscnamerec[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new dnscnamerec();\n\t\t\t\taddresources[i].aliasname = resources[i].aliasname;\n\t\t\t\taddresources[i].canonicalname = resources[i].canonicalname;\n\t\t\t\taddresources[i].ttl = resources[i].ttl;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def dry_run\n      begin\n        Fluent::Engine.dry_run_mode = true\n        change_privilege\n        init_engine\n        run_configure\n      rescue Fluent::ConfigError => e\n        $log.error \"config error\", file: @config_path, error: e\n        $log.debug_backtrace\n        exit!(1)\n      ensure\n        Fluent::Engine.dry_run_mode = false\n      end\n    end", "label": 4}
{"code": "public function setExpressions($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\RecordCondition_Expressions::class);\n        $this->expressions = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function getIsoFormats($locale = null)\n    {\n        return [\n            'LT' => $this->getTranslationMessage('formats.LT', $locale, 'h:mm A'),\n            'LTS' => $this->getTranslationMessage('formats.LTS', $locale, 'h:mm:ss A'),\n            'L' => $this->getTranslationMessage('formats.L', $locale, 'MM/DD/YYYY'),\n            'LL' => $this->getTranslationMessage('formats.LL', $locale, 'MMMM D, YYYY'),\n            'LLL' => $this->getTranslationMessage('formats.LLL', $locale, 'MMMM D, YYYY h:mm A'),\n            'LLLL' => $this->getTranslationMessage('formats.LLLL', $locale, 'dddd, MMMM D, YYYY h:mm A'),\n        ];\n    }", "label": 2}
{"code": "func TunnelConnectionStatus(clock clockwork.Clock, conn TunnelConnection) string {\n\tdiff := clock.Now().Sub(conn.GetLastHeartbeat())\n\tif diff < defaults.ReverseTunnelOfflineThreshold {\n\t\treturn teleport.RemoteClusterStatusOnline\n\t}\n\treturn teleport.RemoteClusterStatusOffline\n}", "label": 5}
{"code": "func NewProcessRoundTrip() *Process {\n\treturn NewProcessFunc(func(ctx context.Context, host string) error {\n\t\tp, _ := ctx.Value(ProcessFuncIO).(*ProcessIO)\n\n\t\tclosers := []io.Closer{p.In.Closer}\n\n\t\tdefer func() {\n\t\t\tfor _, c := range closers {\n\t\t\t\t_ = c.Close()\n\t\t\t}\n\t\t}()\n\n\t\tc, err := new(net.Dialer).DialContext(ctx, \"tcp\", host)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tclosers = append(closers, c)\n\n\t\tgo func() {\n\t\t\t<-ctx.Done()\n\t\t\tif ctx.Err() == context.DeadlineExceeded {\n\t\t\t\t_ = c.Close()\n\t\t\t}\n\t\t}()\n\n\t\t_, err = io.Copy(c, p.In.Reader)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = io.Copy(p.Out, c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}).WithIO()\n}", "label": 5}
{"code": "def record_changed?(reflection, record, key)\n        record.new_record? ||\n          association_foreign_key_changed?(reflection, record, key) ||\n          record.will_save_change_to_attribute?(reflection.foreign_key)\n      end", "label": 4}
{"code": "def Phylesystem(repos_dict=None,\n                repos_par=None,\n                with_caching=True,\n                repo_nexml2json=None,\n                git_ssh=None,\n                pkey=None,\n                git_action_class=PhylesystemGitAction,\n                mirror_info=None,\n                new_study_prefix=None,\n                infrastructure_commit_author='OpenTree API <api@opentreeoflife.org>'):\n    \"\"\"Factory function for a _Phylesystem object.\n\n    A wrapper around the _Phylesystem class instantiation for\n    the most common use case: a singleton _Phylesystem.\n    If you need distinct _Phylesystem objects, you'll need to\n    call that class directly.\n    \"\"\"\n    if not repo_nexml2json:\n        repo_nexml2json = get_config_setting('phylesystem', 'repo_nexml2json')\n    global _THE_PHYLESYSTEM\n    if _THE_PHYLESYSTEM is None:\n        _THE_PHYLESYSTEM = _Phylesystem(repos_dict=repos_dict,\n                                        repos_par=repos_par,\n                                        with_caching=with_caching,\n                                        repo_nexml2json=repo_nexml2json,\n                                        git_ssh=git_ssh,\n                                        pkey=pkey,\n                                        git_action_class=git_action_class,\n                                        mirror_info=mirror_info,\n                                        new_study_prefix=new_study_prefix,\n                                        infrastructure_commit_author=infrastructure_commit_author)\n    return _THE_PHYLESYSTEM", "label": 1}
{"code": "def interfaces(self, addresses=False):\n        \"\"\"Get system interfaces.\n\n        :param addresses: (optional) If bool `True`, include interface addresses.\n        :return: :class:`system.Interface <system.Interface>` list\n        \"\"\"\n        schema = InterfaceSchema()\n        resp = self.service.get(self.base+'interfaces/', params={'addresses': addresses})\n        return self.service.decode(schema, resp, many=True)", "label": 1}
{"code": "def point_dist(pt1, pt2):\n    \"\"\" Calculate the Euclidean distance between two n-D points.\n\n    |pt1 - pt2|\n\n    .. todo:: Complete point_dist docstring\n\n    \"\"\"\n\n    # Imports\n    from scipy import linalg as spla\n\n    dist = spla.norm(point_displ(pt1, pt2))\n    return dist", "label": 1}
{"code": "def get_array_value_dtype(lst):\n    '''Return array value type, raise ConfigSerializeError for invalid arrays\n\n    Libconfig arrays must only contain scalar values and all elements must be\n    of the same libconfig data type. Raises ConfigSerializeError if these\n    invariants are not met.\n\n    Returns the value type of the array. If an array contains both int and\n    long int data types, the return datatype will be ``'i64'``.\n    '''\n\n    array_value_type = None\n    for value in lst:\n        dtype = get_dump_type(value)\n        if dtype not in {'b', 'i', 'i64', 'f', 's'}:\n            raise ConfigSerializeError(\n                \"Invalid datatype in array (may only contain scalars):\"\n                \"%r of type %s\" % (value, type(value)))\n\n        if array_value_type is None:\n            array_value_type = dtype\n            continue\n\n        if array_value_type == dtype:\n            continue\n\n        if array_value_type == 'i' and dtype == 'i64':\n            array_value_type = 'i64'\n            continue\n\n        if array_value_type == 'i64' and dtype == 'i':\n            continue\n\n        raise ConfigSerializeError(\n            \"Mixed types in array (all elements must have same type):\"\n            \"%r of type %s\" % (value, type(value)))\n\n    return array_value_type", "label": 1}
{"code": "func _pidAlive(pid int) bool {\n\tproc, err := os.FindProcess(pid)\n\tif err == nil {\n\t\terr = proc.Signal(syscall.Signal(0))\n\t}\n\n\treturn err == nil\n}", "label": 5}
{"code": "def add country_code, country\n      country_code = country_code.to_s\n      optimized_country_code_access = country_code.size\n\n      @countries ||= {}\n      @countries[optimized_country_code_access] ||= {}\n      @countries[optimized_country_code_access][country_code] = country\n    end", "label": 4}
{"code": "public static sslocspresponder[] get(nitro_service service) throws Exception{\n\t\tsslocspresponder obj = new sslocspresponder();\n\t\tsslocspresponder[] response = (sslocspresponder[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func PgSeclabelByObjoidClassoidObjsubidProvider(db XODB, objoid pgtypes.Oid, classoid pgtypes.Oid, objsubid int, provider string) (*PgSeclabel, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, ctid, objoid, classoid, objsubid, provider, label ` +\n\t\t`FROM pg_catalog.pg_seclabel ` +\n\t\t`WHERE objoid = $1 AND classoid = $2 AND objsubid = $3 AND provider = $4`\n\n\t// run query\n\tXOLog(sqlstr, objoid, classoid, objsubid, provider)\n\tps := PgSeclabel{}\n\n\terr = db.QueryRow(sqlstr, objoid, classoid, objsubid, provider).Scan(&ps.Tableoid, &ps.Cmax, &ps.Xmax, &ps.Cmin, &ps.Xmin, &ps.Ctid, &ps.Objoid, &ps.Classoid, &ps.Objsubid, &ps.Provider, &ps.Label)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ps, nil\n}", "label": 5}
{"code": "def select_where(self, where_col_list, where_value_list, col_name=''):\n        \"\"\" \n        selects rows from the array where col_list == val_list\n        \"\"\"\n        res = []        # list of rows to be returned\n        col_ids = []    # ids of the columns to check\n        #print('select_where  : arr = ',  len(self.arr), 'where_value_list = ',  where_value_list)\n        for col_id, col in enumerate(self.header):\n            if col in where_col_list:\n                col_ids.append([col_id, col])\n        #print('select_where    : col_ids = ',  col_ids)   # correctly prints [[0, 'TERM'], [2, 'ID']]\n        \n        for row_num, row in enumerate(self.arr):\n            keep_this_row = True\n            #print('col_ids=', col_ids, ' row = ', row_num, row)\n            for ndx, where_col in enumerate(col_ids):\n                #print('type where_value_list[ndx] = ', type(where_value_list[ndx]))\n                #print('type row[where_col[0]] = ', type(row[where_col[0]]))\n                \n                if row[where_col[0]] != where_value_list[ndx]:\n                    keep_this_row = False\n            if keep_this_row is True:\n                if col_name == '':\n                    res.append([row_num, row])\n                else:   # extracting a single column only\n                    l_dat = self.get_col_by_name(col_name)\n                    if l_dat is not None:\n                        res.append(row[l_dat])\n        return res", "label": 1}
{"code": "def pept_diff(p1, p2):\n    \"\"\"\n    Return the number of differences betweeen 2 peptides\n\n    :param str p1: Peptide 1\n    :param str p2: Peptide 2\n    :return: The number of differences between the pepetides\n    :rtype: int\n\n    >>> pept_diff('ABCDE', 'ABCDF')\n    1\n    >>> pept_diff('ABCDE', 'ABDFE')\n    2\n    >>> pept_diff('ABCDE', 'EDCBA')\n    4\n    >>> pept_diff('ABCDE', 'ABCDE')\n    0\n    \"\"\"\n    if len(p1) != len(p2):\n        return -1\n    else:\n        return sum([p1[i] != p2[i] for i in range(len(p1))])", "label": 1}
{"code": "func PgAuthidByOid(db XODB, oid pgtypes.Oid) (*PgAuthid, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolbypassrls, rolconnlimit, rolpassword, rolvaliduntil ` +\n\t\t`FROM pg_catalog.pg_authid ` +\n\t\t`WHERE oid = $1`\n\n\t// run query\n\tXOLog(sqlstr, oid)\n\tpa := PgAuthid{}\n\n\terr = db.QueryRow(sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Oid, &pa.Ctid, &pa.Rolname, &pa.Rolsuper, &pa.Rolinherit, &pa.Rolcreaterole, &pa.Rolcreatedb, &pa.Rolcanlogin, &pa.Rolreplication, &pa.Rolbypassrls, &pa.Rolconnlimit, &pa.Rolpassword, &pa.Rolvaliduntil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pa, nil\n}", "label": 5}
{"code": "def to_xml_string str=''\n      add_autofilter_defined_name_to_workbook\n      auto_filter.apply if auto_filter.range\n      str << '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n      str << worksheet_node\n      serializable_parts.each do |item|\n        item.to_xml_string(str) if item\n      end\n      str << '</worksheet>'\n    end", "label": 4}
{"code": "def wrap_rsem(job, star_bams, univ_options, rsem_options):\n    \"\"\"\n    A wrapper for run_rsem using the results from run_star as input.\n\n    :param dict star_bams: dict of results from star\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict rsem_options: Options specific to rsem\n    :return: Dict of gene- and isoform-level expression calls\n             output_files:\n                 |- 'rsem.genes.results': fsID\n                 +- 'rsem.isoforms.results': fsID\n    :rtype: dict\n    \"\"\"\n    rsem = job.addChildJobFn(run_rsem, star_bams['rna_transcriptome.bam'],\n                             univ_options, rsem_options, cores=rsem_options['n'],\n                             disk=PromisedRequirement(rsem_disk, star_bams,\n                                                      rsem_options['index']))\n\n    return rsem.rv()", "label": 1}
{"code": "function _run(init, rules, namespace) {\n    const size = _size();\n    let evts = rules || events;\n    let\ti;\n\n    // If breakpoint has been hit or resize logic initialized\n    if (size && (init || size !== current)) {\n        if (namespace) {\n            evts = evts.filter(obj => obj.namespace === namespace);\n        }\n\n        i = evts.length;\n\n        while (i--) {\n            const evt = evts[i];\n\n            if (_eq(evt, size, init)) {\n                const f = init && ! current;\n                const data = {\n                    dir: f ? 0 : (size > current ? 1 : -1),\n                    init: f,\n                    prev: current,\n                    size,\n                };\n\n                $exec(evt.callback, {\n                    args: evt.args ? [data].concat(evt.args) : [data],\n                    scope: evt.scope,\n                });\n\n                // Disable future execution if once\n                if (evt.once) {\n                    events = events.filter(obj => obj.i !== evt.i);\n                }\n            }\n        }\n\n        // Cache current value\n        current = size;\n    }\n}", "label": 3}
{"code": "def destroy\n      Hyrax::Actors::LeaseActor.new(curation_concern).destroy\n      flash[:notice] = curation_concern.lease_history.last\n      if curation_concern.work? && curation_concern.file_sets.present?\n        redirect_to confirm_permission_path\n      else\n        redirect_to edit_lease_path\n      end\n    end", "label": 4}
{"code": "def get_object_torrent(params = {}, options = {}, &block)\n      req = build_request(:get_object_torrent, params)\n      req.send_request(options, &block)\n    end", "label": 4}
{"code": "public void processAnonymousReference(Properties attributes) throws XDocletException\r\n    {\r\n        ReferenceDescriptorDef refDef = _curClassDef.getReference(\"super\");\r\n        String                 attrName;\r\n\r\n        if (refDef == null)\r\n        {\r\n            refDef = new ReferenceDescriptorDef(\"super\");\r\n            _curClassDef.addReference(refDef);\r\n        }\r\n        refDef.setAnonymous();\r\n        LogHelper.debug(false, OjbTagsHandler.class, \"processAnonymousReference\", \"  Processing anonymous reference\");\r\n\r\n        for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )\r\n        {\r\n            attrName = (String)attrNames.nextElement();\r\n            refDef.setProperty(attrName, attributes.getProperty(attrName));\r\n        }\r\n    }", "label": 0}
{"code": "func (m *EntityMetric) SampleInfoCSV() string {\n\tvals := make([]string, len(m.SampleInfo)*2)\n\n\ti := 0\n\n\tfor _, s := range m.SampleInfo {\n\t\tvals[i] = s.Timestamp.Format(time.RFC3339)\n\t\ti++\n\t\tvals[i] = strconv.Itoa(int(s.Interval))\n\t\ti++\n\t}\n\n\treturn strings.Join(vals, \",\")\n}", "label": 5}
{"code": "function unwrapElements(parent, wrapper) {\n  var el = wrapper.childNodes[0];\n\n  // ok, so this looks weird, right?\n  // turns out, appending nodes to another node will remove them\n  // from the live NodeList, so we can keep iterating over the\n  // first item in that list and grab all of them. Nice!\n  while (el) {\n    parent.appendChild(el);\n    el = wrapper.childNodes[0];\n  }\n\n  parent.removeChild(wrapper);\n}", "label": 3}
{"code": "def pattern(name, x, y, width, height)\n      push('defs')\n      push(\"pattern #{name} #{x} #{y} #{width} #{height}\")\n      push('graphic-context')\n      yield\n    ensure\n      pop('graphic-context')\n      pop('pattern')\n      pop('defs')\n    end", "label": 4}
{"code": "func (cl *Client) Torrent(ih metainfo.Hash) (t *Torrent, ok bool) {\n\tcl.lock()\n\tdefer cl.unlock()\n\tt, ok = cl.torrents[ih]\n\treturn\n}", "label": 5}
{"code": "function () {\n\n\tif (l_ip_port === undefined) {\n\t\tLOG.warn('not init (or already disposed), cannot connect to server');\n\t\treturn;\n\t}\n\n\tif (l_connector === undefined)    \n\t\tl_connector = new SR.Connector(l_config);\n\n    // establish connection\n\tLOG.warn('connecting to: ' + l_ip_port);\n\tl_connector.connect(l_ip_port, function (err, socket) {\n\t\t\n\t\tif (err) {\n\t\t\t// try-again later\n\t\t\tLOG.warn('attempt to re-connect in: ' + l_timeoutConnectRetry + 'ms');\n\t\t\tsetTimeout(l_connect, l_timeoutConnectRetry);\n\t\t\treturn;\n\t\t}\n\t\t\t\t\n\t\tLOG.warn('connection to: ' + socket.host + ':' + socket.port + ' established');\n        l_connector.send('SR_REGISTER_SERVER', l_para, 'SR_REGISTER_SERVER_R', function (res) {\n            console.log(res.data);\n        });\n\t});    \n}", "label": 3}
{"code": "def stored_signature\n      result = Overcommit::Utils.execute(\n        %w[git config --local --get] + [signature_config_key]\n      )\n\n      if result.status == 1 # Key doesn't exist\n        return ''\n      elsif result.status != 0\n        raise Overcommit::Exceptions::GitConfigError,\n              \"Unable to read from local repo git config: #{result.stderr}\"\n      end\n\n      result.stdout.chomp\n    end", "label": 4}
{"code": "func (s *PresenceService) DeleteNamespace(namespace string) error {\n\tif namespace == \"\" {\n\t\treturn trace.BadParameter(\"missing namespace name\")\n\t}\n\terr := s.Delete(context.TODO(), backend.Key(namespacesPrefix, namespace, paramsPrefix))\n\tif err != nil {\n\t\tif trace.IsNotFound(err) {\n\t\t\treturn trace.NotFound(\"namespace %q is not found\", namespace)\n\t\t}\n\t}\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "def format(file_metrics, build_metrics):\n    \"\"\"compute output in XML format.\"\"\"\n    def indent(elem, level=0):\n        i = \"\\n\" + level*\"  \"\n        if len(elem):\n            if not elem.text or not elem.text.strip():\n                elem.text = i + \"  \"\n            if not elem.tail or not elem.tail.strip():\n                elem.tail = i\n            for elem in elem:\n                indent(elem, level+1)\n            if not elem.tail or not elem.tail.strip():\n                elem.tail = i\n        else:\n            if level and (not elem.tail or not elem.tail.strip()):\n                elem.tail = i\n\n    root = ET.Element('metrics')\n\n    # file_metrics\n    files = ET.Element('files')\n    root.append(files)\n\n    for key in file_metrics.keys():\n        tmp_file = ET.SubElement(files, \"file\",\n                                 {'name': key, 'language': file_metrics[key]['language']})\n        for name in file_metrics[key].keys():\n            if name == 'language':\n                continue\n            tmp_metric = ET.SubElement(tmp_file, \"metric\",\n                                       {'name': name, 'value': str(file_metrics[key][name])})\n\n    # build_metrics\n    if build_metrics:\n        build = ET.Element('build')\n        root.append(build)\n        # TODO\n\n    indent(root)\n    if PY3:\n        body = ET.tostring(root, encoding='unicode')\n    else:\n        body = ET.tostring(root)\n    return body", "label": 1}
{"code": "private FieldDescriptor[] getExtentFieldDescriptors(TableAlias extAlias, FieldDescriptor[] fds)\r\n    {\r\n        FieldDescriptor[] result = new FieldDescriptor[fds.length];\r\n\r\n        for (int i = 0; i < fds.length; i++)\r\n        {\r\n            result[i] = extAlias.cld.getFieldDescriptorByName(fds[i].getAttributeName());\r\n        }\r\n\r\n        return result;\r\n    }", "label": 0}
{"code": "def process\n      status, headers, body = Jets.application.call(env)\n      convert_to_api_gateway(status, headers, body)\n    end", "label": 4}
{"code": "func (m *Memory) Update(ctx context.Context, i backend.Item) (*backend.Lease, error) {\n\tif len(i.Key) == 0 {\n\t\treturn nil, trace.BadParameter(\"missing parameter key\")\n\t}\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.removeExpired()\n\tif m.tree.Get(&btreeItem{Item: i}) == nil {\n\t\treturn nil, trace.NotFound(\"key %q is not found\", string(i.Key))\n\t}\n\tif !m.Mirror {\n\t\ti.ID = m.generateID()\n\t}\n\tevent := backend.Event{\n\t\tType: backend.OpPut,\n\t\tItem: i,\n\t}\n\tm.processEvent(event)\n\tif !m.EventsOff {\n\t\tm.buf.Push(event)\n\t}\n\treturn m.newLease(i), nil\n}", "label": 5}
{"code": "public function toArray()\n    {\n        return (array) array_merge([\n            'id'            => $this->getId(),\n            'version'       => $this->getVersion(),\n            'path'          => $this->path,\n            'icon'          => $this->getIcon(),\n            'hasAssets'     => $this->hasAssets(),\n            'hasMigrations' => $this->hasMigrations(),\n        ], $this->composerJson);\n    }", "label": 2}
{"code": "def send_text(hwnd, txt):\n    \"\"\"\n    sends the text 'txt' to the window handle hwnd using SendMessage\n    \"\"\"\n    try:\n        for c in txt:\n            if c == '\\n':\n                win32api.SendMessage(hwnd, win32con.WM_KEYDOWN, win32con.VK_RETURN, 0)\n                win32api.SendMessage(hwnd, win32con.WM_KEYUP, win32con.VK_RETURN, 0)\n            else:\n                win32api.SendMessage(hwnd, win32con.WM_CHAR, ord(c), 0)            \n    except Exception as ex:\n        print('error calling SendMessage ' + str(ex))", "label": 1}
{"code": "def add(severity, message = nil, progname = nil)\n      # Taken from Logger#add source\n      # https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html#method-i-add\n      if message.nil?\n        if block_given?\n          message = yield\n        else\n          message = progname\n          progname = @progname\n        end\n      end\n      # Put the message in the Jets::IO.buffer which will get flushed to CloudWatch.\n      # No need to include timestamp as CloudWatch already has a timestamp.\n      IO.buffer << message\n\n      super # original logical\n    end", "label": 4}
{"code": "func (a *HistoricalApi) availablePodContainerMetrics(request *restful.Request, response *restful.Response) {\n\tkey := core.HistoricalKey{\n\t\tObjectType:    core.MetricSetTypePodContainer,\n\t\tNamespaceName: request.PathParameter(\"namespace-name\"),\n\t\tPodName:       request.PathParameter(\"pod-name\"),\n\t\tContainerName: request.PathParameter(\"container-name\"),\n\t}\n\ta.processMetricNamesRequest(key, response)\n}", "label": 5}
{"code": "public function process()\n    {\n        switch ($this->inputs['action']) {\n            case 'login':\n                $this->webLogin();\n                break;\n            case 'logout':\n                $this->webLogout();\n                exit($this->showWebLoginForm());\n                break;\n            case 'getContacts':\n                $this->getContacts();\n                break;\n            case 'updateStatus':\n                $this->updateStatus();\n                break;\n            case 'sendMessage':\n                $this->sendMessage();\n                break;\n            case 'sendBroadcast':\n                $this->sendBroadcast();\n                break;\n            default:\n                if (isset($_SESSION['logged_in']) && $_SESSION['logged_in'] == true) {\n                    exit($this->showWebForm());\n                }\n                exit($this->showWebLoginForm());\n                break;\n        }\n    }", "label": 2}
{"code": "def update_report_collector(self, timestamp):\n        \"\"\"Updating report collector for pipeline details.\"\"\"\n        report_enabled = 'report' in self.information and self.information['report'] == 'html'\n        report_enabled = report_enabled and 'stage' in self.information\n        report_enabled = report_enabled and Event.collector_queue is not None\n\n        if report_enabled:\n            Event.collector_queue.put(CollectorUpdate(\n                matrix=self.information['matrix'] if 'matrix' in self.information else 'default',\n                stage=self.information['stage'],\n                status=self.status,\n                timestamp=timestamp,\n                information=self.information\n            ))", "label": 1}
{"code": "def add_line_number(node)\n      node.line ||= line if node.is_a?(::Sass::Script::Tree::Node)\n      node\n    end", "label": 4}
{"code": "public static dbdbprofile get(nitro_service service, String name) throws Exception{\n\t\tdbdbprofile obj = new dbdbprofile();\n\t\tobj.set_name(name);\n\t\tdbdbprofile response = (dbdbprofile) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function read(): Promise\n    {\n        return $this->stream ? $this->stream->read() : new \\Amp\\Success(null);\n    }", "label": 2}
{"code": "function finishBasicPromise (resolve, reject) {\n  return (err, res) => {\n    if (err) {\n      return reject(err);\n    } else {\n      return resolve(res);\n    }\n  };\n}", "label": 3}
{"code": "private function setup_skip_plugins_filters() {\n\t\t$wp_cli_filter_active_plugins = function( $plugins ) {\n\t\t\t$skipped_plugins = WP_CLI::get_runner()->config['skip-plugins'];\n\t\t\tif ( true === $skipped_plugins ) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\tif ( ! is_array( $plugins ) ) {\n\t\t\t\treturn $plugins;\n\t\t\t}\n\t\t\tforeach ( $plugins as $a => $b ) {\n\t\t\t\t// active_sitewide_plugins stores plugin name as the key.\n\t\t\t\tif ( false !== strpos( current_filter(), 'active_sitewide_plugins' ) && Utils\\is_plugin_skipped( $a ) ) {\n\t\t\t\t\tunset( $plugins[ $a ] );\n\t\t\t\t\t// active_plugins stores plugin name as the value.\n\t\t\t\t} elseif ( false !== strpos( current_filter(), 'active_plugins' ) && Utils\\is_plugin_skipped( $b ) ) {\n\t\t\t\t\tunset( $plugins[ $a ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Reindex because active_plugins expects a numeric index.\n\t\t\tif ( false !== strpos( current_filter(), 'active_plugins' ) ) {\n\t\t\t\t$plugins = array_values( $plugins );\n\t\t\t}\n\t\t\treturn $plugins;\n\t\t};\n\n\t\t$hooks = array(\n\t\t\t'pre_site_option_active_sitewide_plugins',\n\t\t\t'site_option_active_sitewide_plugins',\n\t\t\t'pre_option_active_plugins',\n\t\t\t'option_active_plugins',\n\t\t);\n\t\tforeach ( $hooks as $hook ) {\n\t\t\tWP_CLI::add_wp_hook( $hook, $wp_cli_filter_active_plugins, 999 );\n\t\t}\n\t\tWP_CLI::add_wp_hook(\n\t\t\t'plugins_loaded',\n\t\t\tfunction() use ( $hooks, $wp_cli_filter_active_plugins ) {\n\t\t\t\tforeach ( $hooks as $hook ) {\n\t\t\t\t\tremove_filter( $hook, $wp_cli_filter_active_plugins, 999 );\n\t\t\t\t}\n\t\t\t},\n\t\t\t0\n\t\t);\n\t}", "label": 2}
{"code": "def get_rate_for(self, currency: str, to: str, reverse: bool=False) -> Number:\n        \"\"\"Get current market rate for currency\"\"\"\n\n        # Return 1 when currencies match\n        if currency.upper() == to.upper():\n            return self._format_number('1.0')\n\n        # Set base and quote currencies\n        base, quote = currency, to\n        if reverse:\n            base, quote = to, currency\n\n        try:  # Get rate from source\n            rate = self._get_rate(base, quote)\n        except Exception as e:\n            raise ConverterRateError(self.name) from e\n\n        # Convert rate to number\n        rate = self._format_number(rate)\n\n        try:  # Validate rate value\n            assert isinstance(rate, (float, Decimal))\n            assert rate > 0\n        except AssertionError as e:\n            raise ConverterValidationError(self.name, rate) from e\n\n        # Return market rate\n        if reverse:\n            return self._format_number('1.0') / rate\n        return rate", "label": 1}
{"code": "def secure_compare(a, b)\n      fixed_length_secure_compare(::Digest::SHA256.digest(a), ::Digest::SHA256.digest(b)) && a == b\n    end", "label": 4}
{"code": "function(schema, /* optional */ baton) {\n  if (! (this instanceof Valve)) {\n    return new Valve(schema, baton);\n  }\n  this.schema = schema;\n  this.baton = baton;\n}", "label": 3}
{"code": "public boolean removeKey(long key) {\r\n\tint i = indexOfKey(key);\r\n\tif (i<0) return false; // key not contained\r\n\r\n\tthis.state[i]=REMOVED;\r\n\tthis.values[i]=0; // delta\r\n\tthis.distinct--;\r\n\r\n\tif (this.distinct < this.lowWaterMark) {\r\n\t\tint newCapacity = chooseShrinkCapacity(this.distinct,this.minLoadFactor, this.maxLoadFactor);\r\n\t\trehash(newCapacity);\r\n\t}\r\n\t\r\n\treturn true;\t\r\n}", "label": 0}
{"code": "public void load(Reader r, String id) {\r\n    try {\r\n      // could throw an IO exception?\r\n      TreeReader tr = treeReaderFactory().newTreeReader(r);\r\n      int sentIndex = 0;\r\n      for (Tree pt; (pt = tr.readTree()) != null; ) {\r\n        if (pt.label() instanceof HasIndex) { // so we can trace where this tree came from\r\n          HasIndex hi = (HasIndex) pt.label();\r\n          if (id != null) {\r\n            hi.setDocID(id);\r\n          }\r\n          hi.setSentIndex(sentIndex);\r\n        }\r\n        parseTrees.add(pt);\r\n        sentIndex++;\r\n      }\r\n    } catch (IOException e) {\r\n      System.err.println(\"load IO Exception: \" + e);\r\n    }\r\n  }", "label": 0}
{"code": "function (key) {\n                    var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n                    series[key + 'Data'][i] = val;\n                }", "label": 3}
{"code": "public static cachepolicy_cachepolicylabel_binding[] get(nitro_service service, String policyname) throws Exception{\n\t\tcachepolicy_cachepolicylabel_binding obj = new cachepolicy_cachepolicylabel_binding();\n\t\tobj.set_policyname(policyname);\n\t\tcachepolicy_cachepolicylabel_binding response[] = (cachepolicy_cachepolicylabel_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def readSAM(SAMfile,header=False):\n    \"\"\"\n    Reads and parses a sam file.\n\n    :param SAMfile: /path/to/file.sam\n    :param header: logical, if True, reads the header information\n\n    :returns: a pandas dataframe with the respective SAM columns: 'QNAME','FLAG','RNAME','POS','MAPQ','CIGAR','RNEXT','PNEXT','TLEN','SEQ','QUAL' and a list of the headers if header=True\n\n    \"\"\"\n    if header==True:\n        f=open(SAMfile,\"r+\")\n        head=[]\n        for line in f.readlines():\n            if line[0]==\"@\":\n                head.append(line)\n            else:\n                continue\n        f.close()\n\n    sam=pd.read_table(SAMfile,sep=\"this_gives_one_column\",comment=\"@\",header=None)\n    sam=pd.DataFrame(sam[0].str.split(\"\\t\").tolist())\n    acols=[0,1,2,3,4,5,6,7,8,9]\n    sam_=sam[acols]\n    samcols=sam.columns.tolist()\n    bcols=[ s for s in samcols if s not in acols ]\n    sam_[10]=sam[bcols[0]]\n    if len(bcols) > 1:\n        for c in bcols[1:]:\n            sam_[10]=sam_[10].astype(str)\n            sam[c]=sam[c].astype(str)\n            sam_[10]=sam_[10]+\"\\t\"+sam[c]\n\n    sam_.columns=['QNAME','FLAG','RNAME','POS','MAPQ','CIGAR','RNEXT','PNEXT','TLEN','SEQ','QUAL']\n\n    if header==True:\n        return sam_, head\n    else:\n        return sam_", "label": 1}
{"code": "def cast_value(v)\n      return v if v.is_a?(RichText) || v.nil?\n      case type\n      when :date\n        self.style = STYLE_DATE if self.style == 0\n        v\n      when :time\n        self.style = STYLE_DATE if self.style == 0\n        if !v.is_a?(Time) && v.respond_to?(:to_time)\n          v.to_time\n        else\n          v\n        end\n      when :float\n        v.to_f\n      when :integer\n        v.to_i\n      when :boolean\n        v ? 1 : 0\n      when :iso_8601\n        #consumer is responsible for ensuring the iso_8601 format when specifying this type\n        v\n      else\n        v.to_s\n      end\n    end", "label": 4}
{"code": "def file_exists(self, fid):\n        \"\"\"Checks if file with provided fid exists\n\n        Args:\n            **fid**: File identifier <volume_id>,<file_name_hash>\n\n        Returns:\n            True if file exists. False if not.\n        \"\"\"\n        res = self.get_file_size(fid)\n        if res is not None:\n            return True\n        return False", "label": 1}
{"code": "function replaceWithTemplateType(start, end) {\n    var templateToken = {\n      type: \"Template\",\n      value: createTemplateValue(start, end),\n      start: tokens[start].start,\n      end: tokens[end].end,\n      loc: {\n        start: tokens[start].loc.start,\n        end: tokens[end].loc.end\n      }\n    };\n\n    // put new token in place of old tokens\n    tokens.splice(start, end - start + 1, templateToken);\n  }", "label": 3}
{"code": "func startRollingBackRotation(ca services.CertAuthority) error {\n\trotation := ca.GetRotation()\n\n\t// Rollback always sets rotation to manual mode.\n\trotation.Mode = services.RotationModeManual\n\n\tsigningKeys := ca.GetSigningKeys()\n\tcheckingKeys := ca.GetCheckingKeys()\n\tkeyPairs := ca.GetTLSKeyPairs()\n\n\t// Rotation sets the first key to be the new key\n\t// and keep only public keys/certs for the new CA.\n\tsigningKeys = [][]byte{signingKeys[1]}\n\tcheckingKeys = [][]byte{checkingKeys[1]}\n\n\t// Keep the new certificate as trusted\n\t// as during the rollback phase, both types of clients may be present in the cluster.\n\tkeyPairs = []services.TLSKeyPair{keyPairs[1], services.TLSKeyPair{Cert: keyPairs[0].Cert}}\n\trotation.State = services.RotationStateInProgress\n\trotation.Phase = services.RotationPhaseRollback\n\n\tca.SetSigningKeys(signingKeys)\n\tca.SetCheckingKeys(checkingKeys)\n\tca.SetTLSKeyPairs(keyPairs)\n\tca.SetRotation(rotation)\n\treturn nil\n}", "label": 5}
{"code": "func (c *Client) DeleteReverseTunnel(domainName string) error {\n\t// this is to avoid confusing error in case if domain empty for example\n\t// HTTP route will fail producing generic not found error\n\t// instead we catch the error here\n\tif strings.TrimSpace(domainName) == \"\" {\n\t\treturn trace.BadParameter(\"empty domain name\")\n\t}\n\t_, err := c.Delete(c.Endpoint(\"reversetunnels\", domainName))\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "private static function cmpCallback(array &$config, $name, array &$results)\n    {\n        if (!isset($config[$name])) {\n            $config[$name] = function ($v, $k) use (&$results) {\n                $results[$k] = $v;\n            };\n        } else {\n            $currentFn = $config[$name];\n            $config[$name] = function ($v, $k) use (&$results, $currentFn) {\n                $currentFn($v, $k);\n                $results[$k] = $v;\n            };\n        }\n    }", "label": 2}
{"code": "def translate(key = nil, *, throw: false, raise: false, locale: nil, **options) # TODO deprecate :raise\n      locale ||= config.locale\n      raise Disabled.new('t') if locale == false\n      enforce_available_locales!(locale)\n\n      backend = config.backend\n\n      result = catch(:exception) do\n        if key.is_a?(Array)\n          key.map { |k| backend.translate(locale, k, options) }\n        else\n          backend.translate(locale, key, options)\n        end\n      end\n\n      if result.is_a?(MissingTranslation)\n        handle_exception((throw && :throw || raise && :raise), result, locale, key, options)\n      else\n        result\n      end\n    end", "label": 4}
{"code": "public static function generate($userId, $lifetime = 3600)\n    {\n        $token = new static;\n\n        $token->token = str_random(40);\n        $token->user_id = $userId;\n        $token->created_at = Carbon::now();\n        $token->last_activity_at = Carbon::now();\n        $token->lifetime_seconds = $lifetime;\n\n        return $token;\n    }", "label": 2}
{"code": "function(a, b, target){\n\t\t\tif (target == null)\n\t\t\t\ttarget={}\n\t\t\t// Doing it in this order means we can use either a or b as the target, with no conflict\n\t\t\t// Round resulting values to integers; down for xy, up for wh\n\t\t\t// Would be slightly off if negative w, h were allowed\n\t\t\ttarget._h = Math.max(a._y + a._h, b._y + b._h);\n\t\t\ttarget._w = Math.max(a._x + a._w, b._x + b._w);\n\t\t\ttarget._x = ~~Math.min(a._x, b._x);\n\t\t\ttarget._y = ~~Math.min(a._y, b._y);\n\t\t\ttarget._w -= target._x;\n\t\t\ttarget._h -= target._y\n\t\t\ttarget._w = (target._w == ~~target._w) ? target._w : ~~target._w + 1 | 0;\n\t\t\ttarget._h = (target._h == ~~target._h) ? target._h : ~~target._h + 1 | 0;\n\t\t\treturn target\n\t\t}", "label": 3}
{"code": "public function handle($request, Closure $next)\n    {\n        if ($this->cors->isPreflightRequest($request)) {\n            return $this->cors->handlePreflightRequest($request);\n        }\n\n        return $next($request);\n    }", "label": 2}
{"code": "public Set<D> getMatchedDeclaration() {\n        Set<D> bindedSet = new HashSet<D>();\n        for (Map.Entry<ServiceReference<D>, Boolean> e : declarations.entrySet()) {\n            if (e.getValue()) {\n                bindedSet.add(getDeclaration(e.getKey()));\n            }\n        }\n        return bindedSet;\n    }", "label": 0}
{"code": "func (mr *MockMathMockRecorder) Sum(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Sum\", reflect.TypeOf((*MockMath)(nil).Sum), arg0, arg1)\n}", "label": 5}
{"code": "public function setParameters($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\BigQuery\\DataTransfer\\V1\\DataSourceParameter::class);\n        $this->parameters = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function collapseTextChangeRangesAcrossMultipleVersions(changes) {\n        if (changes.length === 0) {\n            return ts.unchangedTextChangeRange;\n        }\n        if (changes.length === 1) {\n            return changes[0];\n        }\n        // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }\n        // as it makes things much easier to reason about.\n        var change0 = changes[0];\n        var oldStartN = change0.span.start;\n        var oldEndN = textSpanEnd(change0.span);\n        var newEndN = oldStartN + change0.newLength;\n        for (var i = 1; i < changes.length; i++) {\n            var nextChange = changes[i];\n            // Consider the following case:\n            // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting\n            // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.\n            // i.e. the span starting at 30 with length 30 is increased to length 40.\n            //\n            //      0         10        20        30        40        50        60        70        80        90        100\n            //      -------------------------------------------------------------------------------------------------------\n            //                |                                                 /\n            //                |                                            /----\n            //  T1            |                                       /----\n            //                |                                  /----\n            //                |                             /----\n            //      -------------------------------------------------------------------------------------------------------\n            //                                     |                            \\\n            //                                     |                               \\\n            //   T2                                |                                 \\\n            //                                     |                                   \\\n            //                                     |                                      \\\n            //      -------------------------------------------------------------------------------------------------------\n            //\n            // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial\n            // it's just the min of the old and new starts.  i.e.:\n            //\n            //      0         10        20        30        40        50        60        70        80        90        100\n            //      ------------------------------------------------------------*------------------------------------------\n            //                |                                                 /\n            //                |                                            /----\n            //  T1            |                                       /----\n            //                |                                  /----\n            //                |                             /----\n            //      ----------------------------------------$-------------------$------------------------------------------\n            //                .                    |                            \\\n            //                .                    |                               \\\n            //   T2           .                    |                                 \\\n            //                .                    |                                   \\\n            //                .                    |                                      \\\n            //      ----------------------------------------------------------------------*--------------------------------\n            //\n            // (Note the dots represent the newly inferred start.\n            // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the\n            // absolute positions at the asterisks, and the relative change between the dollar signs. Basically, we see\n            // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that\n            // means:\n            //\n            //      0         10        20        30        40        50        60        70        80        90        100\n            //      --------------------------------------------------------------------------------*----------------------\n            //                |                                                                     /\n            //                |                                                                /----\n            //  T1            |                                                           /----\n            //                |                                                      /----\n            //                |                                                 /----\n            //      ------------------------------------------------------------$------------------------------------------\n            //                .                    |                            \\\n            //                .                    |                               \\\n            //   T2           .                    |                                 \\\n            //                .                    |                                   \\\n            //                .                    |                                      \\\n            //      ----------------------------------------------------------------------*--------------------------------\n            //\n            // In other words (in this case), we're recognizing that the second edit happened after where the first edit\n            // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started\n            // that's the same as if we started at char 80 instead of 60.\n            //\n            // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rather\n            // than pushing the first edit forward to match the second, we'll push the second edit forward to match the\n            // first.\n            //\n            // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange\n            // semantics: { { start: 10, length: 70 }, newLength: 60 }\n            //\n            // The math then works out as follows.\n            // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the\n            // final result like so:\n            //\n            // {\n            //      oldStart3: Min(oldStart1, oldStart2),\n            //      oldEnd3  : Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),\n            //      newEnd3  : Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))\n            // }\n            var oldStart1 = oldStartN;\n            var oldEnd1 = oldEndN;\n            var newEnd1 = newEndN;\n            var oldStart2 = nextChange.span.start;\n            var oldEnd2 = textSpanEnd(nextChange.span);\n            var newEnd2 = oldStart2 + nextChange.newLength;\n            oldStartN = Math.min(oldStart1, oldStart2);\n            oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));\n            newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));\n        }\n        return createTextChangeRange(createTextSpanFromBounds(oldStartN, oldEndN), /*newLength:*/ newEndN - oldStartN);\n    }", "label": 3}
{"code": "def get_default_config_filename():\n    \"\"\"Returns the configuration filepath.\n\n    If PEYOTL_CONFIG_FILE is in the env that is the preferred choice; otherwise ~/.peyotl/config is preferred.\n    If the preferred file does not exist, then the packaged peyotl/default.conf from the installation of peyotl is\n    used.\n    A RuntimeError is raised if that fails.\n    \"\"\"\n    global _CONFIG_FN\n    if _CONFIG_FN is not None:\n        return _CONFIG_FN\n    with _CONFIG_FN_LOCK:\n        if _CONFIG_FN is not None:\n            return _CONFIG_FN\n        if 'PEYOTL_CONFIG_FILE' in os.environ:\n            cfn = os.path.abspath(os.environ['PEYOTL_CONFIG_FILE'])\n        else:\n            cfn = os.path.expanduser(\"~/.peyotl/config\")\n        if not os.path.isfile(cfn):\n            # noinspection PyProtectedMember\n            if 'PEYOTL_CONFIG_FILE' in os.environ:\n                from peyotl.utility.get_logger import warn_from_util_logger\n                msg = 'Filepath \"{}\" specified via PEYOTL_CONFIG_FILE={} was not found'.format(cfn, os.environ[\n                    'PEYOTL_CONFIG_FILE'])\n                warn_from_util_logger(msg)\n            from pkg_resources import Requirement, resource_filename\n            pr = Requirement.parse('peyotl')\n            cfn = resource_filename(pr, 'peyotl/default.conf')\n        if not os.path.isfile(cfn):\n            raise RuntimeError('The peyotl configuration file cascade failed looking for \"{}\"'.format(cfn))\n        _CONFIG_FN = os.path.abspath(cfn)\n    return _CONFIG_FN", "label": 1}
{"code": "function on (state, eventName, handler) {\n  state.emitter.on(eventName, handler)\n\n  return state.api\n}", "label": 3}
{"code": "def read_header\n      @pos = 0\n\n      # Read first block and check for the header\n      buf = @ios.read(@buffer_size, @output_buffer ||= ''.b)\n\n      # Use cipher specified in header, or global cipher if it has no header\n      iv, key, cipher_name, cipher = nil\n      header                       = Header.new\n      if header.parse!(buf)\n        @header_present = true\n        @compressed     = header.compressed?\n        @version        = header.version\n        cipher          = header.cipher\n        cipher_name     = header.cipher_name || cipher.cipher_name\n        key             = header.key\n        iv              = header.iv\n      else\n        @header_present = false\n        @compressed     = nil\n        cipher          = SymmetricEncryption.cipher(@version)\n        cipher_name     = cipher.cipher_name\n      end\n\n      @stream_cipher = ::OpenSSL::Cipher.new(cipher_name)\n      @stream_cipher.decrypt\n      @stream_cipher.key = key || cipher.send(:key)\n      @stream_cipher.iv  = iv || cipher.iv\n\n      decrypt(buf)\n    end", "label": 4}
{"code": "def remove_index(columns, index_name = nil)\n      columns = [columns].flatten.map(&:to_sym)\n      from_origin = @origin.indices.find { |_, cols| cols.map(&:to_sym) == columns }\n      index_name ||= from_origin[0] unless from_origin.nil?\n      index_name ||= idx_name(@origin.name, columns)\n      ddl('drop index `%s` on `%s`' % [index_name, @name])\n    end", "label": 4}
{"code": "def use(middleware, *args, &blk)\n      stack.push [middleware, args, blk]\n      stack.uniq!\n    end", "label": 4}
{"code": "func createCertificate(principal string, certType uint32, caKey crypto.Signer, key crypto.Signer) (*ssh.Certificate, ssh.Signer, error) {\n\t// Create CA.\n\tcaPublicKey, err := ssh.NewPublicKey(caKey.Public())\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\tcaSigner, err := ssh.NewSignerFromKey(caKey)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\n\t// Create key.\n\tpublicKey, err := ssh.NewPublicKey(key.Public())\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\tkeySigner, err := ssh.NewSignerFromKey(key)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\n\t// Create certificate and signer.\n\tcert := &ssh.Certificate{\n\t\tKeyId:           principal,\n\t\tValidPrincipals: []string{principal},\n\t\tKey:             publicKey,\n\t\tSignatureKey:    caPublicKey,\n\t\tValidAfter:      uint64(time.Now().UTC().Add(-1 * time.Minute).Unix()),\n\t\tValidBefore:     uint64(time.Now().UTC().Add(1 * time.Minute).Unix()),\n\t\tCertType:        certType,\n\t}\n\terr = cert.SignCert(rand.Reader, caSigner)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\tcertSigner, err := ssh.NewCertSigner(cert, keySigner)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\n\treturn cert, certSigner, nil\n}", "label": 5}
{"code": "public static Trajectory getTrajectoryByID(List<? extends Trajectory> t, int id){\n\t\tTrajectory track = null;\n\t\tfor(int i = 0; i < t.size() ; i++){\n\t\t\tif(t.get(i).getID()==id){\n\t\t\t\ttrack = t.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn track;\n\t}", "label": 0}
{"code": "def add_lock(name, klass)\n      raise ArgumentError, \"Lock #{name} already defined, please use another name\" if locks.key?(name.to_sym)\n\n      new_locks = locks.dup.merge(name.to_sym => klass).freeze\n      self.locks = new_locks\n    end", "label": 4}
{"code": "public function render(string $location, string $template = 'platform::partials.mainMenu'): string\n    {\n        $this->checkAccess();\n\n        return $this->findAllChildren($location)\n            ->sortBy('sort')\n            ->map(function ($value) use ($template) {\n                return view($template, $value)->render();\n            })\n            ->implode(' ');\n    }", "label": 2}
{"code": "func AppPath(root string, appName types.ACName) string {\n\treturn filepath.Join(AppsPath(root), appName.String())\n}", "label": 5}
{"code": "function edgeExtent(graph, attribute) {\n  if (!isGraph(graph))\n    throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');\n\n  var attributes = [].concat(attribute);\n\n  var edges = graph.edges(),\n      edge,\n      data,\n      value,\n      key,\n      a,\n      i,\n      l;\n\n  var results = {};\n\n  for (a = 0; a < attributes.length; a++) {\n    key = attributes[a];\n\n    results[key] = [Infinity, -Infinity];\n  }\n\n  for (i = 0, l = edges.length; i < l; i++) {\n    edge = edges[i];\n    data = graph.getEdgeAttributes(edge);\n\n    for (a = 0; a < attributes.length; a++) {\n      key = attributes[a];\n      value = data[key];\n\n      if (value < results[key][0])\n        results[key][0] = value;\n\n      if (value > results[key][1])\n        results[key][1] = value;\n    }\n  }\n\n  return typeof attribute === 'string' ? results[attribute] : results;\n}", "label": 3}
{"code": "public function keyRangeObject()\n    {\n        if (!$this->start || !$this->end) {\n            throw new \\BadMethodCallException('Key Range must supply a start and an end');\n        }\n\n        return [\n            $this->startType => $this->start,\n            $this->endType => $this->end\n        ];\n    }", "label": 2}
{"code": "func (cs callSet) FindMatch(receiver interface{}, method string, args []interface{}) (*Call, error) {\n\tkey := callSetKey{receiver, method}\n\n\t// Search through the expected calls.\n\texpected := cs.expected[key]\n\tvar callsErrors bytes.Buffer\n\tfor _, call := range expected {\n\t\terr := call.matches(args)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(&callsErrors, \"\\n%v\", err)\n\t\t} else {\n\t\t\treturn call, nil\n\t\t}\n\t}\n\n\t// If we haven't found a match then search through the exhausted calls so we\n\t// get useful error messages.\n\texhausted := cs.exhausted[key]\n\tfor _, call := range exhausted {\n\t\tif err := call.matches(args); err != nil {\n\t\t\tfmt.Fprintf(&callsErrors, \"\\n%v\", err)\n\t\t}\n\t}\n\n\tif len(expected)+len(exhausted) == 0 {\n\t\tfmt.Fprintf(&callsErrors, \"there are no expected calls of the method %q for that receiver\", method)\n\t}\n\n\treturn nil, fmt.Errorf(callsErrors.String())\n}", "label": 5}
{"code": "def on_identity_changed(sender, identity):\n    \"\"\"Store groups in session whenever identity changes.\n\n    :param identity: The user identity where information are stored.\n    \"\"\"\n    if isinstance(identity, AnonymousIdentity):\n        return\n\n    client_id = current_app.config['CERN_APP_CREDENTIALS']['consumer_key']\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=client_id,\n    )\n    groups = []\n    if account:\n        remote = find_remote_by_client_id(client_id)\n        resource = get_resource(remote)\n        refresh = current_app.config.get(\n            'OAUTHCLIENT_CERN_REFRESH_TIMEDELTA',\n            OAUTHCLIENT_CERN_REFRESH_TIMEDELTA\n        )\n\n        groups.extend(\n            account_groups_and_extra_data(account, resource,\n                                          refresh_timedelta=refresh)\n        )\n\n    extend_identity(identity, groups)", "label": 1}
{"code": "def _conditions(self, full_path, environ):\n        \"\"\"Return Etag and Last-Modified values defaults to now for both.\"\"\"\n        magic = self._match_magic(full_path)\n        if magic is not None:\n            return magic.conditions(full_path, environ)\n        else:\n            mtime = stat(full_path).st_mtime\n            return str(mtime), rfc822.formatdate(mtime)", "label": 1}
{"code": "func (m *Memory) removeExpired() int {\n\tremoved := 0\n\tnow := m.Clock().Now().UTC()\n\tfor {\n\t\tif len(*m.heap) == 0 {\n\t\t\tbreak\n\t\t}\n\t\titem := m.heap.PeekEl()\n\t\tif now.Before(item.Expires) {\n\t\t\tbreak\n\t\t}\n\t\tm.heap.PopEl()\n\t\tm.tree.Delete(item)\n\t\tm.Debugf(\"Removed expired %v %v item.\", string(item.Key), item.Expires)\n\t\tremoved++\n\t}\n\tif removed > 0 {\n\t\tm.Debugf(\"Removed %v expired items.\", removed)\n\t}\n\treturn removed\n}", "label": 5}
{"code": "def listing_for_language(language)\n      ensure_active_edit!\n\n      begin\n        result = client.get_listing(\n          current_package_name,\n          current_edit.id,\n          language\n        )\n\n        return Listing.new(self, language, result)\n      rescue Google::Apis::ClientError => e\n        return Listing.new(self, language) if e.status_code == 404 # create a new empty listing\n        raise\n      end\n    end", "label": 4}
{"code": "func ExpectAccessDenied(c *check.C, err error) {\n\tc.Assert(trace.IsAccessDenied(err), check.Equals, true, check.Commentf(\"expected AccessDenied, got %T %v at %v\", trace.Unwrap(err), err, string(debug.Stack())))\n}", "label": 5}
{"code": "func parseTimeParam(queryParam string, defaultValue time.Time) (time.Time, error) {\n\tif queryParam != \"\" {\n\t\treqStamp, err := time.Parse(time.RFC3339, queryParam)\n\t\tif err != nil {\n\t\t\treturn time.Time{}, fmt.Errorf(\"timestamp argument cannot be parsed: %s\", err)\n\t\t}\n\t\treturn reqStamp, nil\n\t}\n\treturn defaultValue, nil\n}", "label": 5}
{"code": "public function ListJobs(\\Google\\Cloud\\Talent\\V4beta1\\ListJobsRequest $argument,\n      $metadata = [], $options = []) {\n        return $this->_simpleRequest('/google.cloud.talent.v4beta1.JobService/ListJobs',\n        $argument,\n        ['\\Google\\Cloud\\Talent\\V4beta1\\ListJobsResponse', 'decode'],\n        $metadata, $options);\n    }", "label": 2}
{"code": "private function determineUmbrellaLevel(array $release)\n    {\n        $levels = [];\n        array_walk($release, function ($component) use (&$levels) {\n            $levels[] = $component['level'];\n        });\n\n        $levels = array_unique($levels);\n        rsort($levels);\n\n        // Since we don't use major versions of the umbrella, major versions of\n        // components only bump the umbrella by a minor increment.\n        if ($levels[0] === self::LEVEL_MAJOR) {\n            $levels[0] = self::LEVEL_MINOR;\n        }\n\n        $release[self::DEFAULT_COMPONENT] = [\n            'level' => $levels[0]\n        ];\n\n        return $release;\n    }", "label": 2}
{"code": "def decode(self, id, seq, intf, filter=None, frame=None, inline=False): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Get a capture's decode.\n\n        :param id: Result ID as an int.\n        :param seq: TestResult sequence ID as an int.\n        :param intf: Interface name as string.\n        :param filter: (optional) PCAP filter to apply as string.\n        :param frame: (optional) Frame number to decode.\n        :param inline: (optional) Use inline version of capture file.\n        :return: :class:`captures.Decode <captures.Decode>` object\n        :rtype: captures.Decode\n        \"\"\"\n        schema = DecodeSchema()\n        resp = self.service.get(self._base(id, seq)+str(intf)+'/decode/',\n                                params={'filter': filter, 'frame': frame, 'inline': inline})\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "def underbang_reader(key)\n      ck = convert_key(key)\n      if key?(ck)\n        regular_reader(ck)\n      else\n        self.class.new\n      end\n    end", "label": 4}
{"code": "func isBitcoinAddress(fl FieldLevel) bool {\n\taddress := fl.Field().String()\n\n\tif !btcAddressRegex.MatchString(address) {\n\t\treturn false\n\t}\n\n\talphabet := []byte(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\")\n\n\tdecode := [25]byte{}\n\n\tfor _, n := range []byte(address) {\n\t\td := bytes.IndexByte(alphabet, n)\n\n\t\tfor i := 24; i >= 0; i-- {\n\t\t\td += 58 * int(decode[i])\n\t\t\tdecode[i] = byte(d % 256)\n\t\t\td /= 256\n\t\t}\n\t}\n\n\th := sha256.New()\n\t_, _ = h.Write(decode[:21])\n\td := h.Sum([]byte{})\n\th = sha256.New()\n\t_, _ = h.Write(d)\n\n\tvalidchecksum := [4]byte{}\n\tcomputedchecksum := [4]byte{}\n\n\tcopy(computedchecksum[:], h.Sum(d[:0]))\n\tcopy(validchecksum[:], decode[21:])\n\n\treturn validchecksum == computedchecksum\n}", "label": 5}
{"code": "public static Set<String> readColumnSet(String infile, int field) throws IOException\r\n  {\r\n    BufferedReader br = IOUtils.getBufferedFileReader(infile);\r\n    String line;\r\n    Set<String> set = new HashSet<String>();\r\n    while ((line = br.readLine()) != null) {\r\n      line = line.trim();\r\n      if (line.length() > 0) {\r\n        if (field < 0) {\r\n          set.add(line);\r\n        } else {\r\n          String[] fields = tab.split(line);\r\n          if (field < fields.length) {\r\n            set.add(fields[field]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    br.close();\r\n    return set;\r\n  }", "label": 0}
{"code": "public static File writeStringToTempFile(String contents, String path, String encoding) throws IOException {\r\n\t\tOutputStream writer = null;\r\n\t\tFile tmp = File.createTempFile(path,\".tmp\");\r\n\t\tif (path.endsWith(\".gz\")) {\r\n\t\t\twriter = new GZIPOutputStream(new FileOutputStream(tmp));\r\n\t\t} else {\r\n\t\t\twriter = new BufferedOutputStream(new FileOutputStream(tmp));\r\n\t\t}\r\n\t\twriter.write(contents.getBytes(encoding));\r\n\t\twriter.close();\r\n\t\treturn tmp;\r\n\t}", "label": 0}
{"code": "def _one_iteration(self, F, Ybus, V, Vm, Va, pv, pq, pvpq):\n        \"\"\" Performs one Newton iteration.\n        \"\"\"\n        J = self._build_jacobian(Ybus, V, pv, pq, pvpq)\n\n        # Update step.\n        dx = -1 * spsolve(J, F)\n#        dx = -1 * linalg.lstsq(J.todense(), F)[0]\n\n        # Update voltage vector.\n        npv = len(pv)\n        npq = len(pq)\n        if npv > 0:\n            Va[pv] = Va[pv] + dx[range(npv)]\n        if npq > 0:\n            Va[pq] = Va[pq] + dx[range(npv, npv + npq)]\n            Vm[pq] = Vm[pq] + dx[range(npv + npq, npv + npq + npq)]\n\n        V = Vm * exp(1j * Va)\n        Vm = abs(V) # Avoid wrapped round negative Vm.\n        Va = angle(V)\n\n        return V, Vm, Va", "label": 1}
{"code": "public double areaSquared(HalfEdge hedge0, HalfEdge hedge1) {\n        Point3d p0 = hedge0.tail().pnt;\n        Point3d p1 = hedge0.head().pnt;\n        Point3d p2 = hedge1.head().pnt;\n\n        double dx1 = p1.x - p0.x;\n        double dy1 = p1.y - p0.y;\n        double dz1 = p1.z - p0.z;\n\n        double dx2 = p2.x - p0.x;\n        double dy2 = p2.y - p0.y;\n        double dz2 = p2.z - p0.z;\n\n        double x = dy1 * dz2 - dz1 * dy2;\n        double y = dz1 * dx2 - dx1 * dz2;\n        double z = dx1 * dy2 - dy1 * dx2;\n\n        return x * x + y * y + z * z;\n    }", "label": 0}
{"code": "def decrypt(content_entry, cipher)\n      # Zip::Entry.extract writes a 0-length file when trying\n      # to extract an encrypted stream, so we read the\n      # raw bytes based on the offset and lengths\n      decrypted = ''\n      File.open(@filename, 'rb') do |zipfile|\n        zipfile.seek(\n          content_entry.local_header_offset +\n            content_entry.calculate_local_header_size\n        )\n        total_to_read = content_entry.compressed_size\n\n        block_size = 4096\n        block_size = total_to_read if block_size > total_to_read\n\n        while (buffer = zipfile.read(block_size))\n          decrypted     += cipher.update(buffer)\n          total_to_read -= buffer.length\n\n          break if total_to_read == 0\n\n          block_size = total_to_read if block_size > total_to_read\n        end\n      end\n\n      decrypted + cipher.final\n    end", "label": 4}
{"code": "function assertion(value, schema, message, vars, ssf) {\n\treturn Joi.validate(value, schema, function(err, value) {\n\t\t// fast way\n\t\tif (!err) {\n\t\t\treturn value;\n\t\t}\n\n\t\t// assemble message\n\t\tvar msg = '';\n\n\t\t// process message (if any)\n\t\tvar mtype = typeof message;\n\t\tif (mtype === 'string') {\n\t\t\tif (vars && typeof vars === 'object') {\n\t\t\t\t// mini template\n\t\t\t\tmessage = message.replace(/\\{([\\w]+)\\}/gi, function (match, key) {\n\t\t\t\t\tif (hasOwnProp.call(vars, key)) {\n\t\t\t\t\t\treturn vars[key];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tmsg += message + ': ';\n\t\t}\n\n\t\t// append schema label\n\t\tmsg += getLabel(schema.describe(), err);\n\n\t\t// append some of the errors\n\t\tvar maxDetails = 4;\n\n\t\tmsg += err.details.slice(0, maxDetails).map(function(det) {\n\t\t\tif (/^\\w+\\.\\w/.test(det.path)) {\n\t\t\t\treturn '[' + det.path + '] ' + det.message;\n\t\t\t}\n\t\t\treturn det.message;\n\t\t}).join(', ');\n\n\t\tif (err.details.length > maxDetails) {\n\t\t\tvar hidden = (err.details.length - maxDetails);\n\t\t\tmsg += '... (showing ' + (err.details.length - hidden) + ' of ' + err.details.length + ')';\n\t\t}\n\n\t\t// booya\n\t\tthrow new AssertionError(msg, {\n\t\t\tdetails: err.details,\n\t\t\tvalue: value\n\t\t}, ssf);\n\t});\n}", "label": 3}
{"code": "def from_translation_key(\n            cls,\n            translation_key,\n            translations,\n            overlapping_reads,\n            ref_reads,\n            alt_reads,\n            alt_reads_supporting_protein_sequence,\n            transcripts_overlapping_variant,\n            transcripts_supporting_protein_sequence,\n            gene):\n        \"\"\"\n        Create a ProteinSequence object from a TranslationKey, along with\n        all the extra fields a ProteinSequence requires.\n        \"\"\"\n        return cls(\n            amino_acids=translation_key.amino_acids,\n            variant_aa_interval_start=translation_key.variant_aa_interval_start,\n            variant_aa_interval_end=translation_key.variant_aa_interval_end,\n            ends_with_stop_codon=translation_key.ends_with_stop_codon,\n            frameshift=translation_key.frameshift,\n            translations=translations,\n            overlapping_reads=overlapping_reads,\n            ref_reads=ref_reads,\n            alt_reads=alt_reads,\n            alt_reads_supporting_protein_sequence=(\n                alt_reads_supporting_protein_sequence),\n            transcripts_overlapping_variant=transcripts_overlapping_variant,\n            transcripts_supporting_protein_sequence=(\n                transcripts_supporting_protein_sequence),\n            gene=gene)", "label": 1}
{"code": "function isGlob(candidate) {\n  if (typeof candidate === 'string' && candidate.length > 0) {\n    return true;\n  }\n  if (Array.isArray(candidate) && candidate.length > 0) {\n    return candidate.every(candidateEl => typeof candidateEl === 'string');\n  }\n  return false;\n}", "label": 3}
{"code": "public function getIdentifierColumns(EntityManagerInterface $em) : array\n    {\n        $columns = [];\n\n        foreach ($this->identifier as $idProperty) {\n            $property = $this->getProperty($idProperty);\n\n            if ($property instanceof FieldMetadata) {\n                $columns[$property->getColumnName()] = $property;\n\n                continue;\n            }\n\n            /** @var AssociationMetadata $property */\n\n            // Association defined as Id field\n            $targetClass = $em->getClassMetadata($property->getTargetEntity());\n\n            if (! $property->isOwningSide()) {\n                $property    = $targetClass->getProperty($property->getMappedBy());\n                $targetClass = $em->getClassMetadata($property->getTargetEntity());\n            }\n\n            $joinColumns = $property instanceof ManyToManyAssociationMetadata\n                ? $property->getJoinTable()->getInverseJoinColumns()\n                : $property->getJoinColumns();\n\n            foreach ($joinColumns as $joinColumn) {\n                /** @var JoinColumnMetadata $joinColumn */\n                $columnName           = $joinColumn->getColumnName();\n                $referencedColumnName = $joinColumn->getReferencedColumnName();\n\n                if (! $joinColumn->getType()) {\n                    $joinColumn->setType(PersisterHelper::getTypeOfColumn($referencedColumnName, $targetClass, $em));\n                }\n\n                $columns[$columnName] = $joinColumn;\n            }\n        }\n\n        return $columns;\n    }", "label": 2}
{"code": "public static authenticationvserver_stats[] get(nitro_service service) throws Exception{\n\t\tauthenticationvserver_stats obj = new authenticationvserver_stats();\n\t\tauthenticationvserver_stats[] response = (authenticationvserver_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function addJoinedEntityResult($class, $alias, $parentAlias, $relation)\n    {\n        $this->aliasMap[$alias]       = $class;\n        $this->parentAliasMap[$alias] = $parentAlias;\n        $this->relationMap[$alias]    = $relation;\n\n        return $this;\n    }", "label": 2}
{"code": "function makeRequest(capturedError) {\n      req(app)\n        .get('/bundle.js')\n        .expect(500)\n        .end(function(err, res) {\n          if (err) {\n            done(err);\n          }\n          assert.ok(capturedError, 'expected error in onerror');\n          assert.equal(res.text, capturedError.stack);\n          done();\n        });\n    }", "label": 3}
{"code": "private function getPresignHeaders(array $headers)\n    {\n        $presignHeaders = [];\n        $blacklist = $this->getHeaderBlacklist();\n        foreach ($headers as $name => $value) {\n            $lName = strtolower($name);\n            if (!isset($blacklist[$lName])\n                && $name !== self::AMZ_CONTENT_SHA256_HEADER\n            ) {\n                $presignHeaders[] = $lName;\n            }\n        }\n        return $presignHeaders;\n    }", "label": 2}
{"code": "public static authenticationradiuspolicy_systemglobal_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauthenticationradiuspolicy_systemglobal_binding obj = new authenticationradiuspolicy_systemglobal_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationradiuspolicy_systemglobal_binding response[] = (authenticationradiuspolicy_systemglobal_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def add_or_update_gemfile(update_gemfile_if_needed: false)\n      if gemfile_exists?\n        ensure_gemfile_valid!(update_gemfile_if_needed: update_gemfile_if_needed)\n      else\n        if update_gemfile_if_needed || UI.confirm(\"It is recommended to run fastlane with a Gemfile set up, do you want fastlane to create one for you?\")\n          setup_gemfile!\n        end\n      end\n      return gemfile_path\n    end", "label": 4}
{"code": "def one_shift_greater_than_parent?(node, actual_indent)\n      parent_indent = node_indent(node_indent_parent(node)).length\n      expected_indent = parent_indent + @indent_width\n      expected_indent == actual_indent\n    end", "label": 4}
{"code": "def register(matcher, *aliases):\n    \"\"\" Register a matcher associated to one or more aliases. Each alias\n        given is also normalized.\n    \"\"\"\n    docstr = matcher.__doc__ if matcher.__doc__ is not None else ''\n    helpmatchers[matcher] = docstr.strip()\n\n    for alias in aliases:\n        matchers[alias] = matcher\n        # Map a normalized version of the alias\n        norm = normalize(alias)\n        normalized[norm] = alias\n        # Map a version without snake case\n        norm = norm.replace('_', '')\n        normalized[norm] = alias", "label": 1}
{"code": "func (a *AuthServer) autoRotateCertAuthorities() error {\n\tclusterName, err := a.GetClusterName()\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tfor _, caType := range []services.CertAuthType{services.HostCA, services.UserCA} {\n\t\tca, err := a.Trust.GetCertAuthority(services.CertAuthID{\n\t\t\tType:       caType,\n\t\t\tDomainName: clusterName.GetClusterName(),\n\t\t}, true)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tif err := a.autoRotate(ca); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function selectTab(tab,content) {\n\t//deseleziono tutti i tab\n\t$('#'+tab).parent().children().removeClass('tabButtonSelected');\n\t//seleziono il tab cliccato\n\t$('#'+tab).addClass('tabButtonSelected');\n\t//nascondo tutti i content\n\t$('#'+content).parent().children().fadeOut('fast');\n\t//seleziono il tab cliccato\n\t$('#'+content).delay(200).fadeIn('fast');\n}", "label": 3}
{"code": "public static dnscnamerec[] get(nitro_service service, String aliasname[]) throws Exception{\n\t\tif (aliasname !=null && aliasname.length>0) {\n\t\t\tdnscnamerec response[] = new dnscnamerec[aliasname.length];\n\t\t\tdnscnamerec obj[] = new dnscnamerec[aliasname.length];\n\t\t\tfor (int i=0;i<aliasname.length;i++) {\n\t\t\t\tobj[i] = new dnscnamerec();\n\t\t\t\tobj[i].set_aliasname(aliasname[i]);\n\t\t\t\tresponse[i] = (dnscnamerec) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "function metadata(log, value) {\n    var lines = value.split('\\n');\n    log.commit = lines[0].split(' ')[1];\n    log.author = lines[1].split(':')[1].trim();\n    log.date = lines[2].slice(8);\n    return log\n  }", "label": 3}
{"code": "public function setCompany($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\Company::class);\n        $this->company = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def _validate_states(states, topology):\n    '''Validate states to avoid ignoring states during initialization'''\n    states = states or []\n    if isinstance(states, dict):\n        for x in states:\n            assert x in topology.node\n    else:\n        assert len(states) <= len(topology)\n    return states", "label": 1}
{"code": "public static snmpuser get(nitro_service service, String name) throws Exception{\n\t\tsnmpuser obj = new snmpuser();\n\t\tobj.set_name(name);\n\t\tsnmpuser response = (snmpuser) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (process *TeleportProcess) getAdditionalPrincipals(role teleport.Role) ([]string, []string, error) {\n\tvar principals []string\n\tvar dnsNames []string\n\tif process.Config.Hostname != \"\" {\n\t\tprincipals = append(principals, process.Config.Hostname)\n\t}\n\tvar addrs []utils.NetAddr\n\tswitch role {\n\tcase teleport.RoleProxy:\n\t\taddrs = append(process.Config.Proxy.PublicAddrs, utils.NetAddr{Addr: reversetunnel.RemoteKubeProxy})\n\t\taddrs = append(addrs, process.Config.Proxy.SSHPublicAddrs...)\n\t\taddrs = append(addrs, process.Config.Proxy.TunnelPublicAddrs...)\n\t\taddrs = append(addrs, process.Config.Proxy.Kube.PublicAddrs...)\n\t\t// Automatically add wildcards for every proxy public address for k8s SNI routing\n\t\tif process.Config.Proxy.Kube.Enabled {\n\t\t\tfor _, publicAddr := range utils.JoinAddrSlices(process.Config.Proxy.PublicAddrs, process.Config.Proxy.Kube.PublicAddrs) {\n\t\t\t\thost, err := utils.Host(publicAddr.Addr)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil, trace.Wrap(err)\n\t\t\t\t}\n\t\t\t\tif ip := net.ParseIP(host); ip == nil {\n\t\t\t\t\tdnsNames = append(dnsNames, \"*.\"+host)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase teleport.RoleAuth, teleport.RoleAdmin:\n\t\taddrs = process.Config.Auth.PublicAddrs\n\tcase teleport.RoleNode:\n\t\taddrs = process.Config.SSH.PublicAddrs\n\t\t// If advertise IP is set, add it to the list of principals. Otherwise\n\t\t// add in the default (0.0.0.0) which will be replaced by the Auth Server\n\t\t// when a host certificate is issued.\n\t\tif process.Config.AdvertiseIP != \"\" {\n\t\t\tadvertiseIP, err := utils.ParseAddr(process.Config.AdvertiseIP)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, trace.Wrap(err)\n\t\t\t}\n\t\t\taddrs = append(addrs, *advertiseIP)\n\t\t} else {\n\t\t\taddrs = append(addrs, process.Config.SSH.Addr)\n\t\t}\n\t}\n\tfor _, addr := range addrs {\n\t\thost, err := utils.Host(addr.Addr)\n\t\tif err != nil {\n\t\t\treturn nil, nil, trace.Wrap(err)\n\t\t}\n\t\tprincipals = append(principals, host)\n\t}\n\treturn principals, dnsNames, nil\n}", "label": 5}
{"code": "function fireCallback(callbackName) {\n      var data = [], len = arguments.length - 1;\n      while ( len-- > 0 ) data[ len ] = arguments[ len + 1 ];\n\n      /*\n        Callbacks:\n        beforeCreate (options),\n        beforeOpen (xhr, options),\n        beforeSend (xhr, options),\n        error (xhr, status),\n        complete (xhr, stautus),\n        success (response, status, xhr),\n        statusCode ()\n      */\n      var globalCallbackValue;\n      var optionCallbackValue;\n      if (globals[callbackName]) {\n        globalCallbackValue = globals[callbackName].apply(globals, data);\n      }\n      if (options[callbackName]) {\n        optionCallbackValue = options[callbackName].apply(options, data);\n      }\n      if (typeof globalCallbackValue !== 'boolean') { globalCallbackValue = true; }\n      if (typeof optionCallbackValue !== 'boolean') { optionCallbackValue = true; }\n      return (globalCallbackValue && optionCallbackValue);\n    }", "label": 3}
{"code": "private function validate($path, $mode)\n    {\n        $errors = [];\n\n        if (!$this->getOption('Key')) {\n            $errors[] = 'Cannot open a bucket. You must specify a path in the '\n                . 'form of s3://bucket/key';\n        }\n\n        if (!in_array($mode, ['r', 'w', 'a', 'x'])) {\n            $errors[] = \"Mode not supported: {$mode}. \"\n                . \"Use one 'r', 'w', 'a', or 'x'.\";\n        }\n\n        // When using mode \"x\" validate if the file exists before attempting\n        // to read\n        if ($mode == 'x' &&\n            $this->getClient()->doesObjectExist(\n                $this->getOption('Bucket'),\n                $this->getOption('Key'),\n                $this->getOptions(true)\n            )\n        ) {\n            $errors[] = \"{$path} already exists on Amazon S3\";\n        }\n\n        return $errors;\n    }", "label": 2}
{"code": "def unregister(self, signal):\n        \"\"\"\n        Unregisters an existing signal\n\n        :param signal: Name of the signal\n        \"\"\"\n        if signal in self.signals.keys():\n            del(self.signals[signal])\n            self.__log.debug(\"Signal %s unregisterd\" % signal)\n        else:\n            self.__log.debug(\"Signal %s does not exist and could not be unregistered.\")", "label": 1}
{"code": "def ncx(wobj, indentarray = [])\n      s = @epub.ncx(indentarray)\n      if !s.nil? && !wobj.nil?\n        wobj.puts s\n      end\n    end", "label": 4}
{"code": "private function get($field)\n    {\n        $this->initializeDoctrine();\n\n        $property = $this->cm->getProperty($field);\n\n        if (! $property) {\n            throw new BadMethodCallException(\"no field with name '\" . $field . \"' exists on '\" . $this->cm->getClassName() . \"'\");\n        }\n\n        return $this->{$field};\n    }", "label": 2}
{"code": "func (r *reader) waitAvailable(pos, wanted int64, ctxErr *error) (avail int64) {\n\tr.t.cl.lock()\n\tdefer r.t.cl.unlock()\n\tfor !r.readable(pos) && *ctxErr == nil {\n\t\tr.waitReadable(pos)\n\t}\n\treturn r.available(pos, wanted)\n}", "label": 5}
{"code": "def capability_module(cap_name)\n      @cap_logger.debug(\"Searching for cap: #{cap_name}\")\n      @cap_host_chain.each do |host_name, host|\n        @cap_logger.debug(\"Checking in: #{host_name}\")\n        caps = @cap_caps[host_name]\n\n        if caps && caps.key?(cap_name)\n          @cap_logger.debug(\"Found cap: #{cap_name} in #{host_name}\")\n          return caps[cap_name]\n        end\n      end\n\n      nil\n    end", "label": 4}
{"code": "public function roundUnit($unit, $precision = 1, $function = 'round')\n    {\n        $metaUnits = [\n            // @call roundUnit\n            'millennium' => [static::YEARS_PER_MILLENNIUM, 'year'],\n            // @call roundUnit\n            'century' => [static::YEARS_PER_CENTURY, 'year'],\n            // @call roundUnit\n            'decade' => [static::YEARS_PER_DECADE, 'year'],\n            // @call roundUnit\n            'quarter' => [static::MONTHS_PER_QUARTER, 'month'],\n            // @call roundUnit\n            'millisecond' => [1000, 'microsecond'],\n        ];\n        $normalizedUnit = static::singularUnit($unit);\n        $ranges = array_merge(static::getRangesByUnit(), [\n            // @call roundUnit\n            'microsecond' => [0, 999999],\n        ]);\n        $factor = 1;\n        if (isset($metaUnits[$normalizedUnit])) {\n            [$factor, $normalizedUnit] = $metaUnits[$normalizedUnit];\n        }\n        $precision *= $factor;\n\n        if (!isset($ranges[$normalizedUnit])) {\n            throw new InvalidArgumentException(\"Unknown unit '$unit' to floor\");\n        }\n\n        $found = false;\n        $fraction = 0;\n        $arguments = null;\n        $factor = $this->year < 0 ? -1 : 1;\n        $changes = [];\n\n        foreach ($ranges as $unit => [$minimum, $maximum]) {\n            if ($normalizedUnit === $unit) {\n                $arguments = [$this->$unit, $minimum];\n                $fraction = $precision - floor($precision);\n                $found = true;\n\n                continue;\n            }\n\n            if ($found) {\n                $delta = $maximum + 1 - $minimum;\n                $factor /= $delta;\n                $fraction *= $delta;\n                $arguments[0] += $this->$unit * $factor;\n                $changes[$unit] = round($minimum + ($fraction ? $fraction * call_user_func($function, ($this->$unit - $minimum) / $fraction) : 0));\n                // Cannot use modulo as it lose double precision\n                while ($changes[$unit] >= $delta) {\n                    $changes[$unit] -= $delta;\n                }\n                $fraction -= floor($fraction);\n            }\n        }\n\n        [$value, $minimum] = $arguments;\n        /** @var CarbonInterface $result */\n        $result = $this->$normalizedUnit(floor(call_user_func($function, ($value - $minimum) / $precision) * $precision + $minimum));\n        foreach ($changes as $unit => $value) {\n            $result = $result->$unit($value);\n        }\n\n        return $result;\n    }", "label": 2}
{"code": "public function setDetectionRules($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\CustomInfoType\\DetectionRule::class);\n        $this->detection_rules = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def extract_from_text(text):\n    \"\"\"\n    Extract arXiv IDs from a text.\n\n    :param text: The text to extract arXiv IDs from.\n    :returns: A list of matching arXiv IDs, in canonical form.\n\n    >>> sorted(extract_from_text('1506.06690 1506.06690v1 arXiv:1506.06690 arXiv:1506.06690v1 arxiv:1506.06690 arxiv:1506.06690v1 math.GT/0309136 abcdf bar1506.06690foo mare.GG/0309136'))\n    ['1506.06690', '1506.06690v1', 'math.GT/0309136']\n    \"\"\"\n    # Remove the leading \"arxiv:\".\n    return tools.remove_duplicates([re.sub(\"arxiv:\", \"\", i[0],\n                                           flags=re.IGNORECASE)\n                                    for i in REGEX.findall(text) if i[0] != ''])", "label": 1}
{"code": "private function performCallbackOnCachedPersister(callable $callback)\n    {\n        if (! $this->hasCache) {\n            return;\n        }\n\n        foreach (array_merge($this->entityPersisters, $this->collectionPersisters) as $persister) {\n            if ($persister instanceof CachedPersister) {\n                $callback($persister);\n            }\n        }\n    }", "label": 2}
{"code": "public function hasMany($model, $serializer, $relation = null)\n    {\n        return $this->buildRelationship($model, $serializer, $relation, true);\n    }", "label": 2}
{"code": "def _process_mhci(mhc_file, normal=False):\n    \"\"\"\n    Process the results from running IEDB MHCI binding predictions into a pandas dataframe.\n\n    :param str mhc_file: Output file containing netmhciipan mhci:peptide binding predictions\n    :param bool normal: Is this processing the results of a normal?\n    :return: Results in a tabular format\n    :rtype: pandas.DataFrame\n    \"\"\"\n    results = pandas.DataFrame(columns=['allele', 'pept', 'tumor_pred', 'core'])\n    with open(mhc_file, 'r') as mf:\n        peptides = set()\n        for line in mf:\n            # Skip header lines\n            if not line.startswith('HLA'):\n                continue\n            line = line.strip().split('\\t')\n            allele = line[0]\n            pept = line[5]\n            pred = line[7]\n            if float(pred) > 5.00 and not normal:\n                continue\n            results.loc[len(results)] = [allele, pept, pred, pept]\n    results.drop_duplicates(inplace=True)\n    return results", "label": 1}
{"code": "def parse_n3(row, src='csv'):\n    \"\"\" \n    takes a row from an n3 file and returns the triple\n    NOTE - currently parses a CSV line already split via\n    cyc_extract.py\n    \"\"\"\n    if row.strip() == '':\n        return '',''\n    l_root = 'opencyc'\n    key = ''\n    val = ''\n    if src == 'csv': \n        cols = row.split(',')\n        if len(cols) < 3:\n            #print('PARSE ISSUE : ', row)\n            return '',''\n        key = ''\n        val = ''\n        key = l_root + ':' + cols[1].strip('\"').strip() + ':' + cols[2].strip('\"').strip()\n        try:\n            val = cols[3].strip('\"').strip()\n        except Exception:\n            val = \"Error parsing \" + row\n    elif src == 'n3':\n        pass\n    return key, val", "label": 1}
{"code": "public static String getDefaultJdbcTypeFor(String javaType)\r\n    {\r\n        return _jdbcMappings.containsKey(javaType) ? (String)_jdbcMappings.get(javaType) : JDBC_DEFAULT_TYPE;\r\n    }", "label": 0}
{"code": "function getRoutes(feature) {\n  const targetPath = `src/features/${feature}/route.js`; //utils.mapFeatureFile(feature, 'route.js');\n  if (vio.fileNotExists(targetPath)) return [];\n  const theAst = ast.getAst(targetPath);\n  const arr = [];\n  let rootPath = '';\n  let indexRoute = null;\n\n  traverse(theAst, {\n    ObjectExpression(path) {\n      const node = path.node;\n      const props = node.properties;\n      if (!props.length) return;\n      const obj = {};\n      props.forEach(p => {\n        if (_.has(p, 'key.name') && !p.computed) {\n          obj[p.key.name] = p;\n        }\n      });\n      if (obj.path && obj.component) {\n        // in a route config, if an object expression has both 'path' and 'component' property, then it's a route config\n        arr.push({\n          path: _.get(obj.path, 'value.value'), // only string literal supported\n          component: _.get(obj.component, 'value.name'), // only identifier supported\n          isIndex: !!obj.isIndex && _.get(obj.isIndex, 'value.value'), // suppose to be boolean\n          node: {\n            start: node.start,\n            end: node.end,\n          },\n        });\n      }\n      if (obj.isIndex && obj.component && !indexRoute) {\n        // only find the first index route\n        indexRoute = {\n          component: _.get(obj.component, 'value.name'),\n        };\n      }\n      if (obj.path && obj.childRoutes && !rootPath) {\n        rootPath = _.get(obj.path, 'value.value');\n        if (!rootPath) rootPath = '$none'; // only find the first rootPath\n      }\n    },\n  });\n  const prjRootPath = getRootRoutePath();\n  if (rootPath === '$none') rootPath = prjRootPath;\n  else if (!/^\\//.test(rootPath)) rootPath = prjRootPath + '/' + rootPath;\n  rootPath = rootPath.replace(/\\/+/, '/');\n  arr.forEach(item => {\n    if (!/^\\//.test(item.path)) {\n      item.path = (rootPath + '/' + item.path).replace(/\\/+/, '/');\n    }\n  });\n  if (indexRoute) {\n    indexRoute.path = rootPath;\n    arr.unshift(indexRoute);\n  }\n  return arr;\n}", "label": 3}
{"code": "func TLSDial(ctx context.Context, dial DialWithContextFunc, network, addr string, tlsConfig *tls.Config) (*tls.Conn, error) {\n\tif tlsConfig == nil {\n\t\ttlsConfig = &tls.Config{}\n\t}\n\n\tplainConn, err := dial(ctx, network, addr)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tcolonPos := strings.LastIndex(addr, \":\")\n\tif colonPos == -1 {\n\t\tcolonPos = len(addr)\n\t}\n\thostname := addr[:colonPos]\n\n\t// If no ServerName is set, infer the ServerName\n\t// from the hostname we're connecting to.\n\tif tlsConfig.ServerName == \"\" {\n\t\t// Make a copy to avoid polluting argument or default.\n\t\tc := tlsConfig.Clone()\n\t\tc.ServerName = hostname\n\t\ttlsConfig = c\n\t}\n\n\tconn := tls.Client(plainConn, tlsConfig)\n\terrC := make(chan error, 1)\n\tgo func() {\n\t\terr := conn.Handshake()\n\t\terrC <- err\n\t}()\n\n\tselect {\n\tcase err := <-errC:\n\t\tif err != nil {\n\t\t\tplainConn.Close()\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\tcase <-ctx.Done():\n\t\tplainConn.Close()\n\t\treturn nil, trace.BadParameter(\"tls handshake has been cancelled due to timeout\")\n\t}\n\n\tif tlsConfig.InsecureSkipVerify {\n\t\treturn conn, nil\n\t}\n\n\tif err := conn.VerifyHostname(tlsConfig.ServerName); err != nil {\n\t\tplainConn.Close()\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn conn, nil\n}", "label": 5}
{"code": "func initUploadHandler(auditConfig services.AuditConfig) (events.UploadHandler, error) {\n\tif auditConfig.AuditSessionsURI == \"\" {\n\t\treturn nil, trace.NotFound(\"no upload handler is setup\")\n\t}\n\turi, err := utils.ParseSessionsURI(auditConfig.AuditSessionsURI)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tswitch uri.Scheme {\n\tcase teleport.SchemeS3:\n\t\tregion := auditConfig.Region\n\t\tif uriRegion := uri.Query().Get(teleport.Region); uriRegion != \"\" {\n\t\t\tregion = uriRegion\n\t\t}\n\t\thandler, err := s3sessions.NewHandler(s3sessions.Config{\n\t\t\tBucket: uri.Host,\n\t\t\tRegion: region,\n\t\t\tPath:   uri.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\treturn handler, nil\n\tcase teleport.SchemeFile:\n\t\tif err := os.MkdirAll(uri.Path, teleport.SharedDirMode); err != nil {\n\t\t\treturn nil, trace.ConvertSystemError(err)\n\t\t}\n\t\thandler, err := filesessions.NewHandler(filesessions.Config{\n\t\t\tDirectory: uri.Path,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\treturn handler, nil\n\tdefault:\n\t\treturn nil, trace.BadParameter(\n\t\t\t\"unsupported scheme for audit_sesions_uri: %q, currently supported schemes are %q and %q\",\n\t\t\turi.Scheme, teleport.SchemeS3, teleport.SchemeFile)\n\t}\n}", "label": 5}
{"code": "def run_muse_sump_perchrom(job, muse_output, univ_options, muse_options, chrom):\n    \"\"\"\n    Run MuSE sump on the MuSE call generated vcf.\n\n    :param toil.fileStore.FileID muse_output: vcf generated by MuSE call\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict muse_options: Options specific to MuSE\n    :param str chrom: Chromosome to process\n    :return: fsID for the chromsome vcf\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    work_dir = os.getcwd()\n    input_files = {\n        'MuSE.txt': muse_output,\n        'dbsnp_coding.vcf.gz': muse_options['dbsnp_vcf'],\n        'dbsnp_coding.vcf.gz.tbi.tmp': muse_options['dbsnp_tbi']}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n    tbi = os.path.splitext(input_files['dbsnp_coding.vcf.gz.tbi.tmp'])[0]\n    time.sleep(2)\n    shutil.copy(input_files['dbsnp_coding.vcf.gz.tbi.tmp'], tbi)\n    os.chmod(tbi, 0777)\n    open(tbi, 'a').close()\n    input_files = {key: docker_path(path) for key, path in input_files.items()}\n    output_file = ''.join([work_dir, '/', chrom, '.vcf'])\n\n    parameters = ['sump',\n                  '-I', input_files['MuSE.txt'],\n                  '-O', docker_path(output_file),\n                  '-D', input_files['dbsnp_coding.vcf.gz'],\n                  '-E']\n\n    docker_call(tool='muse', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], tool_version=muse_options['version'])\n    outfile = job.fileStore.writeGlobalFile(output_file)\n    export_results(job, outfile, output_file, univ_options, subfolder='mutations/muse')\n    job.fileStore.logToMaster('Ran MuSE sump on %s:%s successfully'\n                              % (univ_options['patient'], chrom))\n    return outfile", "label": 1}
{"code": "func (f Filter) MatchPropertyList(props []types.DynamicProperty) bool {\n\tfor _, p := range props {\n\t\tif !f.MatchProperty(p) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn len(f) == len(props) // false if a property such as VM \"guest\" is unset\n}", "label": 5}
{"code": "func satisfiesImageFilter(image v1alpha.Image, filter v1alpha.ImageFilter) bool {\n\t// Filter according to the IDs.\n\tif len(filter.Ids) > 0 {\n\t\ts := set.NewString(filter.Ids...)\n\t\tif !s.Has(image.Id) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Filter according to the image full names.\n\tif len(filter.FullNames) > 0 {\n\t\ts := set.NewString(filter.FullNames...)\n\t\tif !s.Has(image.Name) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Filter according to the image name prefixes.\n\tif len(filter.Prefixes) > 0 {\n\t\ts := set.NewString(filter.Prefixes...)\n\t\tif !s.ConditionalHas(isPrefixOf, image.Name) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Filter according to the image base name.\n\tif len(filter.BaseNames) > 0 {\n\t\ts := set.NewString(filter.BaseNames...)\n\t\tif !s.ConditionalHas(isBaseNameOf, image.Name) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Filter according to the image keywords.\n\tif len(filter.Keywords) > 0 {\n\t\ts := set.NewString(filter.Keywords...)\n\t\tif !s.ConditionalHas(isPartOf, image.Name) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Filter according to the imported time.\n\tif filter.ImportedAfter > 0 {\n\t\tif image.ImportTimestamp <= filter.ImportedAfter {\n\t\t\treturn false\n\t\t}\n\t}\n\tif filter.ImportedBefore > 0 {\n\t\tif image.ImportTimestamp >= filter.ImportedBefore {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Filter according to the image labels.\n\tif len(filter.Labels) > 0 {\n\t\tif !containsAllKeyValues(image.Labels, filter.Labels) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Filter according to the annotations.\n\tif len(filter.Annotations) > 0 {\n\t\tif !containsAllKeyValues(image.Annotations, filter.Annotations) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}", "label": 5}
{"code": "public static function env($cacheLimit = self::DEFAULT_CACHE_LIMIT)\n    {\n        return function () use ($cacheLimit) {\n            // Use config from environment variables, if available\n            $enabled = getenv(self::ENV_ENABLED);\n            if ($enabled === false || $enabled === '') {\n                $enabled = getenv(self::ENV_ENABLED_ALT);\n            }\n            if ($enabled !== false && $enabled !== '') {\n                return Promise\\promise_for(\n                    new Configuration($enabled, $cacheLimit)\n                );\n            }\n\n            return self::reject('Could not find environment variable config'\n                . ' in ' . self::ENV_ENABLED);\n        };\n    }", "label": 2}
{"code": "def insert(table, values=(), **kwargs):\r\n    \"\"\"Convenience wrapper for database INSERT.\"\"\"\r\n    values = dict(values, **kwargs).items()\r\n    sql, args = makeSQL(\"INSERT\", table, values=values)\r\n    return execute(sql, args).lastrowid", "label": 1}
{"code": "def update(*args)\n      arguments(args, required: [:card_id])\n      params = arguments.params\n\n      params[\"accept\"] ||= ::Github::Client::Projects::PREVIEW_MEDIA\n\n      patch_request(\"/projects/columns/cards/#{arguments.card_id}\", params)\n    end", "label": 4}
{"code": "def rebuild_page_content(locale)\n      unless page_part && page_part.template\n        raise \"page_part with valid template not available\"\n      end\n      # page_part = self.page_parts.find_by_page_part_key page_part_key\n\n      if page_part.present?\n        l_template = Liquid::Template.parse(page_part.template)\n        new_fragment_html = l_template.render('page_part' => page_part.block_contents[locale][\"blocks\"] )\n        # p \"#{page_part_key} content for #{self.slug} page parsed.\"\n        # save in content model associated with page\n\n        page_fragment_content = find_or_create_content\n        # container.contents.find_or_create_by(page_part_key: page_part_key)\n        content_html_col = \"raw_\" + locale + \"=\"\n        # above is the col used by globalize gem to store localized data\n        # page_fragment_content[content_html_col] = new_fragment_html\n        page_fragment_content.send content_html_col, new_fragment_html\n        page_fragment_content.save!\n\n        # set page_part_key value on join model\n        page_content_join_model = get_join_model\n        # page_fragment_content.page_contents.find_by_page_id self.id\n        page_content_join_model.page_part_key = page_part_key\n        page_content_join_model.save!\n      else\n        new_fragment_html = \"\"\n      end\n\n      new_fragment_html\n    end", "label": 4}
{"code": "func PgAttributeByAttrelidAttname(db XODB, attrelid pgtypes.Oid, attname pgtypes.Name) (*PgAttribute, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, ctid, attrelid, attname, atttypid, attstattarget, attlen, attnum, attndims, attcacheoff, atttypmod, attbyval, attstorage, attalign, attnotnull, atthasdef, attisdropped, attislocal, attinhcount, attcollation, attacl, attoptions, attfdwoptions ` +\n\t\t`FROM pg_catalog.pg_attribute ` +\n\t\t`WHERE attrelid = $1 AND attname = $2`\n\n\t// run query\n\tXOLog(sqlstr, attrelid, attname)\n\tpa := PgAttribute{}\n\n\terr = db.QueryRow(sqlstr, attrelid, attname).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Ctid, &pa.Attrelid, &pa.Attname, &pa.Atttypid, &pa.Attstattarget, &pa.Attlen, &pa.Attnum, &pa.Attndims, &pa.Attcacheoff, &pa.Atttypmod, &pa.Attbyval, &pa.Attstorage, &pa.Attalign, &pa.Attnotnull, &pa.Atthasdef, &pa.Attisdropped, &pa.Attislocal, &pa.Attinhcount, &pa.Attcollation, &pa.Attacl, &pa.Attoptions, &pa.Attfdwoptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pa, nil\n}", "label": 5}
{"code": "public function bufferReadAsync(int $length): \\Generator\n    {\n        return @$this->decrypt->encrypt(yield $this->read_buffer->bufferRead($length));\n    }", "label": 2}
{"code": "def run_star(job, fastqs, univ_options, star_options):\n    \"\"\"\n    Align a pair of fastqs with STAR.\n\n    :param list fastqs: The input fastqs for alignment\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict star_options: Options specific to star\n    :return: Dict containing output genome bam, genome bai, and transcriptome bam\n                 output_files:\n                    |- 'rnaAligned.toTranscriptome.out.bam': fsID\n                    +- 'rnaAligned.out.bam': fsID\n                    +- 'rnaChimeric.out.junction': fsID\n    :rtype: dict\n    \"\"\"\n    assert star_options['type'] in ('star', 'starlong')\n    work_dir = os.getcwd()\n    input_files = {\n        'rna_cutadapt_1.fastq': fastqs[0],\n        'rna_cutadapt_2.fastq': fastqs[1],\n        'star_index.tar.gz': star_options['index']}\n    input_files = get_files_from_filestore(job, input_files, work_dir,\n                                           docker=False)\n    # Handle gzipped file\n    gz = '.gz' if is_gzipfile(input_files['rna_cutadapt_1.fastq']) else ''\n    if gz:\n        for read_file in 'rna_cutadapt_1.fastq', 'rna_cutadapt_2.fastq':\n            os.symlink(read_file, read_file + gz)\n            input_files[read_file + gz] = input_files[read_file] + gz\n    # Untar the index\n    input_files['star_index'] = untargz(input_files['star_index.tar.gz'], work_dir)\n\n    # Check to see if user is using a STAR-Fusion index\n    star_fusion_idx = os.path.join(input_files['star_index'], 'ref_genome.fa.star.idx')\n    if os.path.exists(star_fusion_idx):\n        input_files['star_index'] = star_fusion_idx\n\n    input_files = {key: docker_path(path, work_dir=work_dir) for key, path in input_files.items()}\n\n    # Using recommended STAR-Fusion parameters:\n    # https://github.com/STAR-Fusion/STAR-Fusion/wiki\n    parameters = ['--runThreadN', str(star_options['n']),\n                  '--genomeDir', input_files['star_index'],\n                  '--twopassMode', 'Basic',\n                  '--outReadsUnmapped', 'None',\n                  '--chimSegmentMin', '12',\n                  '--chimJunctionOverhangMin', '12',\n                  '--alignSJDBoverhangMin', '10',\n                  '--alignMatesGapMax', '200000',\n                  '--alignIntronMax', '200000',\n                  '--chimSegmentReadGapMax', 'parameter', '3',\n                  '--alignSJstitchMismatchNmax', '5', '-1', '5', '5',\n                  '--outFileNamePrefix', 'rna',\n                  '--readFilesIn',\n                  input_files['rna_cutadapt_1.fastq' + gz],\n                  input_files['rna_cutadapt_2.fastq' + gz],\n                  '--outSAMattributes', 'NH', 'HI', 'AS', 'NM', 'MD',\n                  '--outSAMtype', 'BAM', 'Unsorted',\n                  '--quantMode', 'TranscriptomeSAM']\n    if gz:\n        parameters.extend(['--readFilesCommand', 'zcat'])\n\n    if star_options['type'] == 'star':\n        docker_call(tool='star', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'], tool_version=star_options['version'])\n    else:\n        docker_call(tool='starlong', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'], tool_version=star_options['version'])\n    output_files = defaultdict()\n    for output_file in ['rnaAligned.toTranscriptome.out.bam',\n                     'rnaAligned.out.bam',\n                     'rnaChimeric.out.junction']:\n        output_files[output_file] = job.fileStore.writeGlobalFile('/'.join([work_dir, output_file]))\n    export_results(job, output_files['rnaAligned.toTranscriptome.out.bam'], 'rna_transcriptome.bam',\n                   univ_options, subfolder='alignments')\n    export_results(job, output_files['rnaChimeric.out.junction'], 'rna_chimeric.junction',\n                   univ_options, subfolder='mutations/fusions')\n    job.fileStore.logToMaster('Ran STAR on %s successfully' % univ_options['patient'])\n    return output_files", "label": 1}
{"code": "@ArgumentsChecked\n\t@Throws(IllegalNullArgumentException.class)\n\tpublic static float checkFloat(@Nonnull final Number number) {\n\t\tCheck.notNull(number, \"number\");\n\t\tif (!isInFloatRange(number)) {\n\t\t\tthrow new IllegalNumberRangeException(number.toString(), FLOAT_MIN, FLOAT_MAX);\n\t\t}\n\n\t\treturn number.floatValue();\n\t}", "label": 0}
{"code": "function grabClassNames (cell) {\n  const classNames = _.pickBy({\n    cell: cell.className,\n    value: cell.inputClassName,\n    label: cell.labelClassName\n  })\n  if (_.size(classNames) > 0) {\n    return classNames\n  }\n}", "label": 3}
{"code": "public static function get_value_from_arg_or_stdin( $args, $index ) {\n\t\tif ( isset( $args[ $index ] ) ) {\n\t\t\t$raw_value = $args[ $index ];\n\t\t} else {\n\t\t\t// We don't use file_get_contents() here because it doesn't handle\n\t\t\t// Ctrl-D properly, when typing in the value interactively.\n\t\t\t$raw_value = '';\n\t\t\twhile ( false !== ( $line = fgets( STDIN ) ) ) {\n\t\t\t\t$raw_value .= $line;\n\t\t\t}\n\t\t}\n\n\t\treturn $raw_value;\n\t}", "label": 2}
{"code": "func applyConfig(ccf *GlobalCLIFlags, cfg *service.Config) error {\n\t// load /etc/teleport.yaml and apply it's values:\n\tfileConf, err := config.ReadConfigFile(ccf.ConfigFile)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t// if configuration is passed as an environment variable,\n\t// try to decode it and override the config file\n\tif ccf.ConfigString != \"\" {\n\t\tfileConf, err = config.ReadFromString(ccf.ConfigString)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\tif err = config.ApplyFileConfig(fileConf, cfg); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t// --debug flag\n\tif ccf.Debug {\n\t\tcfg.Debug = ccf.Debug\n\t\tutils.InitLogger(utils.LoggingForCLI, logrus.DebugLevel)\n\t\tlogrus.Debugf(\"DEBUG logging enabled\")\n\t}\n\n\t// read a host UUID for this node\n\tcfg.HostUUID, err = utils.ReadHostUUID(cfg.DataDir)\n\tif err != nil {\n\t\tutils.FatalError(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def atomic_updates(_use_indexes = false)\n      process_flagged_destroys\n      mods = Modifiers.new\n      generate_atomic_updates(mods, self)\n      _children.each do |child|\n        child.process_flagged_destroys\n        generate_atomic_updates(mods, child)\n      end\n      mods\n    end", "label": 4}
{"code": "void checkRmModelConformance() {\n        final AmVisitor<AmObject, AmConstraintContext> visitor = AmVisitors.preorder(new ConformanceVisitor());\n        ArchetypeWalker.walkConstraints(visitor, archetype, new AmConstraintContext());\n    }", "label": 0}
{"code": "public static base_response update(nitro_service client, spilloverpolicy resource) throws Exception {\n\t\tspilloverpolicy updateresource = new spilloverpolicy();\n\t\tupdateresource.name = resource.name;\n\t\tupdateresource.rule = resource.rule;\n\t\tupdateresource.action = resource.action;\n\t\tupdateresource.comment = resource.comment;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function customStrategy(projectDir, builder, cb)\n{\n  const dest = builder.getTargetDestination(projectDir);\n  shelljs.rm('-rf', dest);\n\n  const copyOptions = { overwrite: true, expand: true, dot: true };\n\n  const onCustomInstallerFilesReady = function (err) {\n    builder.buildFromSource(dest, projectDir);\n    cb();\n  };\n\n  const onInstallerFilesReady = function (err) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    let customInstallerSrc = path.resolve(projectDir, \"src\", \"installer\");\n    customInstallerSrc = fs.realpathSync(customInstallerSrc);\n\n    const customInstallerTarget = path.resolve(dest, \"src\", \"settings\");\n    copy(customInstallerSrc, customInstallerTarget, copyOptions, onCustomInstallerFilesReady);\n  };\n\n  let installerDir = path.resolve(projectDir, \"node_modules\", \"@deskpro\", INSTALLER_PACKAGE_NAME);\n  installerDir = fs.realpathSync(installerDir);\n  copy(installerDir, dest, copyOptions, onInstallerFilesReady);\n}", "label": 3}
{"code": "public static double Bhattacharyya(double[] histogram1, double[] histogram2) {\n        int bins = histogram1.length; // histogram bins\n        double b = 0; // Bhattacharyya's coefficient\n\n        for (int i = 0; i < bins; i++)\n            b += Math.sqrt(histogram1[i]) * Math.sqrt(histogram2[i]);\n\n        // Bhattacharyya distance between the two distributions\n        return Math.sqrt(1.0 - b);\n    }", "label": 0}
{"code": "function getAttribute(path, attrNode, context) {\n    path.forEach((attributeName, i) => {\n        if (!(attrNode.attributes && attrNode.attributes[attributeName])) {\n            if (attrNode._origNodes) {\n                let subAttrNode = null;\n                attrNode._origNodes.forEach((origNode, inheritDepth) => {\n                    if (!origNode || !origNode.attributes || !origNode.attributes[attributeName]) return;\n\n                    let origSubAttrNode = origNode.attributes[attributeName];\n\n                    if (subAttrNode) {\n                        if (subAttrNode.inherit === 'inherit') {\n                            // just add/merge options from sub-resource below\n                        } else if (subAttrNode.inherit === 'replace') {\n                            return; // just ignore options from sub-resource\n                        } else {\n                            let attrPath = context.attrPath.join('.');\n                            throw new ImplementationError(\n                                `Cannot overwrite attribute \"${attributeName}\" in \"${attrPath}\" (maybe use \"inherit\"?)`\n                            );\n                        }\n                    } else {\n                        subAttrNode = {};\n                    }\n\n                    Object.keys(origSubAttrNode).forEach(optionName => {\n                        if (subAttrNode.hasOwnProperty(optionName)) return; // for inherit\n\n                        if (optionName === 'attributes') {\n                            subAttrNode[optionName] = {};\n                        } else if (optionName === 'dataSources') {\n                            // DataSources are handled/cloned later in resolveResourceTree():\n                            subAttrNode[optionName] = origSubAttrNode[optionName];\n                        } else if (typeof origSubAttrNode[optionName] === 'object') {\n                            subAttrNode[optionName] = cloneDeep(origSubAttrNode[optionName]);\n                        } else {\n                            subAttrNode[optionName] = origSubAttrNode[optionName];\n                        }\n                    });\n\n                    // keep the inherit-depth (array length) from parent:\n                    subAttrNode._origNodes = subAttrNode._origNodes || Array(attrNode._origNodes.length);\n                    subAttrNode._origNodes[inheritDepth] = origSubAttrNode;\n\n                    attrNode.attributes[attributeName] = subAttrNode;\n                });\n            }\n\n            if (!(attrNode.attributes && attrNode.attributes[attributeName])) {\n                throw new RequestError(\n                    'Unknown attribute ' + `\"${context.attrPath.concat(path.slice(0, i + 1)).join('.')}\"`\n                );\n            }\n        }\n\n        attrNode = attrNode.attributes[attributeName];\n\n        if (attrNode.resource) {\n            const subContext = Object.assign({}, context);\n            subContext.attrPath = subContext.attrPath.concat(path.slice(0, i + 1));\n            resolveIncludes(attrNode, subContext);\n        }\n    });\n\n    return attrNode;\n}", "label": 3}
{"code": "public function setUnion($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\Admin\\V2\\GcRule_Union::class);\n        $this->writeOneof(4, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "function notifyHandler(data) {\n        const notification = Notification.parse(data);\n        return evalBlacklist(notification)\n            .then(() => {\n                forum.emit('log', `Notification ${notification.id}: ${notification.label} received`);\n    \n                const ids = {\n                    post: notification.postId,\n                    topic: notification.topicId,\n                    user: notification.userId,\n                    pm: -1,\n                    chat: -1\n                };\n                return notification.getText()\n                    .then((postData) => forum.Commands.get(ids,\n                        postData, (content) => forum.Post.reply(notification.topicId, notification.postId, content)))\n                    .then((commands) => {\n                        if (commands.commands.length === 0) {\n                            debug(`Emitting events: 'notification' and 'notification:${notification.type}'`);\n                            forum.emit(`notification:${notification.type}`, notification);\n                            forum.emit('notification', notification);\n                        }\n                        return commands;\n                    })\n                    .then((commands) => commands.execute());\n            }).catch((err) => {\n                if (err === 'Ignoring notification') {\n                //We do not process the notification, but we can continue with life\n                    return Promise.resolve();\n                }\n                throw err;\n            });\n    }", "label": 3}
{"code": "public function getIdForUsername($username, User $actor = null)\n    {\n        $query = User::where('username', 'like', $username);\n\n        return $this->scopeVisibleTo($query, $actor)->value('id');\n    }", "label": 2}
{"code": "public function getCSSValue($css_property_name)\n    {\n        $params = [\n            ':propertyName' => $css_property_name,\n            ':id' => $this->id,\n        ];\n\n        return $this->executor->execute(\n            DriverCommand::GET_ELEMENT_VALUE_OF_CSS_PROPERTY,\n            $params\n        );\n    }", "label": 2}
{"code": "public static java.sql.Date getDate(Object value) {\n        try {\n            return toDate(value);\n        } catch (ParseException pe) {\n            pe.printStackTrace();\n            return null;\n        }\n    }", "label": 0}
{"code": "@ArgumentsChecked\n\t@Throws(IllegalNullArgumentException.class)\n\tpublic static short checkShort(@Nonnull final Number number) {\n\t\tCheck.notNull(number, \"number\");\n\t\tif (!isInShortRange(number)) {\n\t\t\tthrow new IllegalNumberRangeException(number.toString(), SHORT_MIN, SHORT_MAX);\n\t\t}\n\n\t\treturn number.shortValue();\n\t}", "label": 0}
{"code": "function ApiError(type, message, data) {\n        this.name = 'ApiError';\n        this.type = type;\n        this.message = message;\n        this.data = data;\n\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }", "label": 3}
{"code": "public function sendResetLinkEmail()\n    {\n        validator(request()->all(), [\n            'email' => 'required|email',\n        ])->validate();\n\n        if ($author = WinkAuthor::whereEmail(request('email'))->first()) {\n            cache(['password.reset.'.$author->id => $token = Str::random()],\n                now()->addMinutes(30)\n            );\n\n            Mail::to($author->email)->send(new ResetPasswordEmail(\n                encrypt($author->id.'|'.$token)\n            ));\n        }\n\n        return redirect()->route('wink.password.forgot')->with('sent', true);\n    }", "label": 2}
{"code": "function deploy(req, res, next) {\n  var options = req.connectionOptions;\n  var form = req.body;\n  req.user = req.user || {};\n\n  if (req.appformsResultPayload && _.isObject(req.appformsResultPayload.data)) {\n    form = req.appformsResultPayload.data;\n  }\n\n  //Expect A Data Source Data Set To Be Available If Deploying A Form.\n  var params = {\n    userEmail: req.user.email || req.body.updatedBy,\n    expectDataSourceCache: true\n  };\n\n  options = _.extend(options, params);\n\n  logger.debug(\"Middleware: Deploy form: \", {options: options});\n\n  forms.updateOrCreateForm(options, form, formsResultHandlers(constants.resultTypes.forms, req, next));\n}", "label": 3}
{"code": "def abort_transaction\n      check_if_ended!\n      check_if_no_transaction!\n\n      if within_states?(TRANSACTION_COMMITTED_STATE)\n        raise Mongo::Error::InvalidTransactionOperation.new(\n          Mongo::Error::InvalidTransactionOperation.cannot_call_after_msg(\n            :commitTransaction, :abortTransaction))\n      end\n\n      if within_states?(TRANSACTION_ABORTED_STATE)\n        raise Mongo::Error::InvalidTransactionOperation.new(\n          Mongo::Error::InvalidTransactionOperation.cannot_call_twice_msg(:abortTransaction))\n      end\n\n      begin\n        unless starting_transaction?\n          write_with_retry(self, txn_options[:write_concern], true) do |server, txn_num|\n            Operation::Command.new(\n              selector: { abortTransaction: 1 },\n              db_name: 'admin',\n              session: self,\n              txn_num: txn_num\n            ).execute(server)\n          end\n        end\n\n        @state = TRANSACTION_ABORTED_STATE\n      rescue Mongo::Error::InvalidTransactionOperation\n        raise\n      rescue Mongo::Error\n        @state = TRANSACTION_ABORTED_STATE\n      rescue Exception\n        @state = TRANSACTION_ABORTED_STATE\n        raise\n      end\n    end", "label": 4}
{"code": "public function with($property)\n    {\n        if (property_exists($this, $property)) {\n            return $this;\n        }\n        if ($this->_parent) {\n            return $this->_parent->with($property);\n        }\n\n        return false;\n    }", "label": 2}
{"code": "function(saving)\n  {\n    if ( !isObject( saving ) )\n    {\n      return false;\n    }\n\n    for (var prop in saving)\n    {\n      if ( !this.ignoredFields[ prop ] )\n      {\n        return true;\n      }\n    }\n\n    return false;\n  }", "label": 3}
{"code": "public function iam()\n    {\n        if (!$this->iam) {\n            $this->iam = new Iam(\n                new IamInstance($this->connection),\n                $this->name\n            );\n        }\n\n        return $this->iam;\n    }", "label": 2}
{"code": "public function serialize()\n    {\n        return base64_encode(json_encode([\n            'sessionName' => $this->session->name(),\n            'transactionId' => $this->transactionId,\n            'readTimestamp' => $this->readTimestamp->formatAsString()\n        ]));\n    }", "label": 2}
{"code": "protected function getSingleArgumentDefinition(): InputValueDefinitionNode\n    {\n        if (count($this->definitionNode->arguments) !== 1) {\n            throw new DirectiveException(\n                \"The @delete directive requires the field {$this->definitionNode->name->value} to only contain a single argument.\"\n            );\n        }\n\n        return $this->definitionNode->arguments[0];\n    }", "label": 2}
{"code": "function click(d) {\n      if (d.children) {\n        d._children = d.children;\n        d.children = null;\n      } else {\n        d.children = d._children;\n        d._children = null;\n      }\n      update(d);\n    }", "label": 3}
{"code": "public static final String getSelectedValue(ListBox list) {\n\tint index = list.getSelectedIndex();\n\treturn (index >= 0) ? list.getValue(index) : null;\n    }", "label": 0}
{"code": "protected function traverseNode(Node $node) : Node\n    {\n        foreach ($node->getSubNodeNames() as $name) {\n            $subNode =& $node->$name;\n\n            if (\\is_array($subNode)) {\n                $subNode = $this->traverseArray($subNode);\n                if ($this->stopTraversal) {\n                    break;\n                }\n            } elseif ($subNode instanceof Node) {\n                $traverseChildren = true;\n                foreach ($this->visitors as $visitor) {\n                    $return = $visitor->enterNode($subNode, $traverseChildren);\n                    if (null !== $return) {\n                        if ($return instanceof Node) {\n                            $subNode = $return;\n                        } elseif (self::DONT_TRAVERSE_CHILDREN === $return) {\n                            $traverseChildren = false;\n                        } elseif (self::STOP_TRAVERSAL === $return) {\n                            $this->stopTraversal = true;\n                            break 2;\n                        } else {\n                            throw new \\LogicException(\n                                'enterNode() returned invalid value of type ' . gettype($return)\n                            );\n                        }\n                    }\n                }\n\n                if ($traverseChildren) {\n                    $subNode = $this->traverseNode($subNode);\n                    if ($this->stopTraversal) {\n                        break;\n                    }\n                }\n\n                foreach ($this->visitors as $visitor) {\n                    $return = $visitor->leaveNode($subNode);\n                    if (null !== $return) {\n                        if ($return instanceof Node) {\n                            $subNode = $return;\n                        } elseif (self::STOP_TRAVERSAL === $return) {\n                            $this->stopTraversal = true;\n                            break 2;\n                        } elseif (\\is_array($return)) {\n                            throw new \\LogicException(\n                                'leaveNode() may only return an array ' .\n                                'if the parent structure is an array'\n                            );\n                        } else {\n                            throw new \\LogicException(\n                                'leaveNode() returned invalid value of type ' . gettype($return)\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        return $node;\n    }", "label": 2}
{"code": "def pages(catalogs = nil)\n      page_list = []\n      catalogs ||= get_existing_catalogs\n\n      if catalogs.is_a?(Array)\n        catalogs.each { |c| page_list.concat pages(c) unless c.nil? }\n      elsif catalogs.is_a?(Hash)\n        if catalogs[:is_reference_only]\n          if catalogs[:referenced_object]\n            page_list.concat pages(catalogs[:referenced_object])\n          else\n            warn \"couldn't follow reference!!! #{catalogs} not found!\"\n          end\n        else\n          case catalogs[:Type]\n          when :Page\n            page_list << catalogs\n          when :Pages\n            page_list.concat pages(catalogs[:Kids]) unless catalogs[:Kids].nil?\n          when :Catalog\n            page_list.concat pages(catalogs[:Pages]) unless catalogs[:Pages].nil?\n          end\n        end\n      end\n      page_list\n    end", "label": 4}
{"code": "def strict_encode64(key)\n      value = self[key]\n      encoded = if Base64.respond_to?(:strict_encode64)\n                  Base64.strict_encode64(value)\n                else\n                  [value].pack('m0')\n                end\n      self[key] = encoded.delete(\"\\n\\r\")\n    end", "label": 4}
{"code": "public static SPIProvider getInstance()\n   {\n      if (me == null)\n      {\n         final ClassLoader cl = ClassLoaderProvider.getDefaultProvider().getServerIntegrationClassLoader();\n         me = SPIProviderResolver.getInstance(cl).getProvider();\n      }\n      return me;\n   }", "label": 0}
{"code": "public static gslbsite get(nitro_service service, String sitename) throws Exception{\n\t\tgslbsite obj = new gslbsite();\n\t\tobj.set_sitename(sitename);\n\t\tgslbsite response = (gslbsite) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def GTFtoBED(inGTF,name):\n    \"\"\"\n    Transform a GTF dataframe into a bed dataframe\n\n    :param inGTF: GTF dataframe for transformation\n    :param name: field of the GTF data frame to be use for the bed 'name' positon\n\n    returns: a bed dataframe with the corresponding bed fiels: 'chrom','chromStart','chromEnd','name','score','strand'\n    \"\"\"\n\n    bed=inGTF.copy()\n    bed.reset_index(inplace=True, drop=True)\n    if name not in bed.columns.tolist():\n        field=retrieve_GTF_field(name, bed)\n        bed=pd.concat([bed,field],axis=1)\n    bed=bed[['seqname','start','end',name,'score','strand']]\n    bed.columns=['chrom','chromStart','chromEnd','name','score','strand']\n    bed.drop_duplicates(inplace=True)\n    bed.reset_index(inplace=True,drop=True)\n    return bed", "label": 1}
{"code": "def revoke(self):\n        \"\"\"\n        Revokes a lease. All keys attached to the lease will expire\n        and be deleted.\n\n        :returns: Response header.\n        :rtype: instance of :class:`txaioetcd.Header`\n        \"\"\"\n        if self._expired:\n            raise Expired()\n\n        obj = {\n            # ID is the lease ID to revoke. When the ID is revoked, all\n            # associated keys will be deleted.\n            u'ID': self.lease_id,\n        }\n        data = json.dumps(obj).encode('utf8')\n\n        url = u'{}/v3alpha/kv/lease/revoke'.format(self._client._url).encode()\n        response = yield treq.post(url, data, headers=self._client._REQ_HEADERS)\n\n        obj = yield treq.json_content(response)\n\n        header = Header._parse(obj[u'header']) if u'header' in obj else None\n\n        self._expired = True\n\n        returnValue(header)", "label": 1}
{"code": "function (values, model, type) {\n        var deferred = Q.defer();\n        var modelData = {data: model};\n\n        ModelValidator.validate(values, modelData, function (err, data) {\n            deferred.resolve({data: data, err: err, type: type});\n        });\n        return deferred.promise;\n    }", "label": 3}
{"code": "def handle_two_step_failure(ex)\n      if ENV[TWO_FACTOR_ENV_VARIABLE].to_s.length > 0\n        # Password provided, however we already used it\n        UI.error(\"\")\n        UI.error(\"Application specific password you provided using\")\n        UI.error(\"environment variable #{TWO_FACTOR_ENV_VARIABLE}\")\n        UI.error(\"is invalid, please make sure it's correct\")\n        UI.error(\"\")\n        UI.user_error!(\"Invalid application specific password provided\")\n      end\n\n      a = CredentialsManager::AccountManager.new(user: @user,\n                                               prefix: TWO_STEP_HOST_PREFIX,\n                                                 note: \"application-specific\")\n      if a.password(ask_if_missing: false).to_s.length > 0\n        # user already entered one.. delete the old one\n        UI.error(\"Application specific password seems wrong\")\n        UI.error(\"Please make sure to follow the instructions\")\n        a.remove_from_keychain\n      end\n      UI.error(\"\")\n      UI.error(\"Your account has 2 step verification enabled\")\n      UI.error(\"Please go to https://appleid.apple.com/account/manage\")\n      UI.error(\"and generate an application specific password for\")\n      UI.error(\"the iTunes Transporter, which is used to upload builds\")\n      UI.error(\"\")\n      UI.error(\"To set the application specific password on a CI machine using\")\n      UI.error(\"an environment variable, you can set the\")\n      UI.error(\"#{TWO_FACTOR_ENV_VARIABLE} variable\")\n      @password = a.password(ask_if_missing: true) # to ask the user for the missing value\n\n      return true\n    end", "label": 4}
{"code": "private function extractHeaders(\n        $name,\n        Shape $shape,\n        ResponseInterface $response,\n        &$result\n    ) {\n        // Check if the headers are prefixed by a location name\n        $result[$name] = [];\n        $prefix = $shape['locationName'];\n        $prefixLen = strlen($prefix);\n\n        foreach ($response->getHeaders() as $k => $values) {\n            if (!$prefixLen) {\n                $result[$name][$k] = implode(', ', $values);\n            } elseif (stripos($k, $prefix) === 0) {\n                $result[$name][substr($k, $prefixLen)] = implode(', ', $values);\n            }\n        }\n    }", "label": 2}
{"code": "def replace_first(input, string, replacement = ''.freeze)\n      input.to_s.sub(string.to_s, replacement.to_s)\n    end", "label": 4}
{"code": "async function getMcpSettings(accessToken) {\n    let data = await mcpCustomizr.getSettings(accessToken);\n    if (Object.keys(data).length === 0) {\n        return {\n            language: ['en'],\n            regionalSettings: 'en',\n            timezone: 'America/New_York',\n        };\n    }\n    return data;\n}", "label": 3}
{"code": "function(searchterms, excluded, terms, titleterms) {\n    var docnames = this._index.docnames;\n    var filenames = this._index.filenames;\n    var titles = this._index.titles;\n\n    var i, j, file;\n    var fileMap = {};\n    var scoreMap = {};\n    var results = [];\n\n    // perform the search on the required terms\n    for (i = 0; i < searchterms.length; i++) {\n      var word = searchterms[i];\n      var files = [];\n      var _o = [\n        {files: terms[word], score: Scorer.term},\n        {files: titleterms[word], score: Scorer.title}\n      ];\n\n      // no match but word was a required one\n      if ($u.every(_o, function(o){return o.files === undefined;})) {\n        break;\n      }\n      // found search word in contents\n      $u.each(_o, function(o) {\n        var _files = o.files;\n        if (_files === undefined)\n          return\n\n        if (_files.length === undefined)\n          _files = [_files];\n        files = files.concat(_files);\n\n        // set score for the word in each file to Scorer.term\n        for (j = 0; j < _files.length; j++) {\n          file = _files[j];\n          if (!(file in scoreMap))\n            scoreMap[file] = {}\n          scoreMap[file][word] = o.score;\n        }\n      });\n\n      // create the mapping\n      for (j = 0; j < files.length; j++) {\n        file = files[j];\n        if (file in fileMap)\n          fileMap[file].push(word);\n        else\n          fileMap[file] = [word];\n      }\n    }\n\n    // now check if the files don't contain excluded terms\n    for (file in fileMap) {\n      var valid = true;\n\n      // check if all requirements are matched\n      if (fileMap[file].length != searchterms.length)\n          continue;\n\n      // ensure that none of the excluded terms is in the search result\n      for (i = 0; i < excluded.length; i++) {\n        if (terms[excluded[i]] == file ||\n            titleterms[excluded[i]] == file ||\n            $u.contains(terms[excluded[i]] || [], file) ||\n            $u.contains(titleterms[excluded[i]] || [], file)) {\n          valid = false;\n          break;\n        }\n      }\n\n      // if we have still a valid result we can add it to the result list\n      if (valid) {\n        // select one (max) score for the file.\n        // for better ranking, we should calculate ranking by using words statistics like basic tf-idf...\n        var score = $u.max($u.map(fileMap[file], function(w){return scoreMap[file][w]}));\n        results.push([docnames[file], titles[file], '', null, score, filenames[file]]);\n      }\n    }\n    return results;\n  }", "label": 3}
{"code": "private void handleMemoryGetId(SerialMessage incomingMessage) {\n\t\tthis.homeId = ((incomingMessage.getMessagePayloadByte(0)) << 24) | \n\t\t\t\t((incomingMessage.getMessagePayloadByte(1)) << 16) | \n\t\t\t\t((incomingMessage.getMessagePayloadByte(2)) << 8) | \n\t\t\t\t(incomingMessage.getMessagePayloadByte(3));\n\t\tthis.ownNodeId = incomingMessage.getMessagePayloadByte(4);\n\t\tlogger.debug(String.format(\"Got MessageMemoryGetId response. Home id = 0x%08X, Controller Node id = %d\", this.homeId, this.ownNodeId));\n\t}", "label": 0}
{"code": "function renderIssue(message) {\n\treturn issueTemplate({\n\t\tseverity: severityString(message.severity),\n\t\tseverityName: message.severity === 1 ? 'Warning' : 'Error',\n\t\tlineNumber: message.line,\n\t\tcolumn: message.column,\n\t\tmessage: message.message,\n\t\truleId: message.ruleId,\n\t\truleLink: getRuleLink(message.ruleId)\n\t});\n}", "label": 3}
{"code": "def match_tokens(ast_tokens, ast_types):\n        \"\"\"\n        Verify that each token in order does match the expected types.\n\n        The list provided by `get_tokens` does have three more elements\n        at the beginning of the list which should be always the same\n        for a condition (Module and Expr). Those are automatically\n        added first to the final list of expected types so you don't have\n        to specify it yourself each time.\n\n        >>> tokens = Condition.get_tokens('2 == 3')\n        >>> Condition.match_tokens(tokens, [ast.Compare, ast.Num, ast.Eq, ast.Num])\n        True\n\n        Args:\n            ast_entries (list): list of AST tokens parsers previously.\n            ast_types (list): list of expected AST types.\n\n        Returns:\n            bool: when all tokes match the expected types\n        \"\"\"\n        ast_final_types = [ast.Module, ast.Expr] + ast_types\n        return all(isinstance(ast_token, ast_type)\n                   for ast_token, ast_type in zip(ast_tokens, ast_final_types))", "label": 1}
{"code": "private function decToHex($number)\n\t{\n\t\t$hex = [];\n\n\t\tif ($number == 0) {\n\t\t\treturn '00';\n\t\t}\n\n\t\twhile ($number > 0) {\n\t\t\tif ($number == 0) {\n\t\t\t\tarray_push($hex, '0');\n\t\t\t} else {\n\t\t\t\tarray_push($hex, strtoupper(dechex(bcmod($number, '16'))));\n\t\t\t\t$number = bcdiv($number, '16', 0);\n\t\t\t}\n\t\t}\n\n\t\t$hex = array_reverse($hex);\n\t\treturn implode($hex);\n\t}", "label": 2}
{"code": "def build(subject)\n      Kernel.format(HELP_LINK_TEMPLATE, version: Version::STRING, item: name_to_param(subject))\n    end", "label": 4}
{"code": "@SuppressWarnings( { \"unchecked\" })\r\n  public static <K1, K2> TwoDimensionalCounter<K2, K1> reverseIndexOrder(TwoDimensionalCounter<K1, K2> cc) {\r\n    // they typing on the outerMF is violated a bit, but it'll work....\r\n    TwoDimensionalCounter<K2, K1> result = new TwoDimensionalCounter<K2, K1>((MapFactory) cc.outerMF,\r\n        (MapFactory) cc.innerMF);\r\n\r\n    for (K1 key1 : cc.firstKeySet()) {\r\n      ClassicCounter<K2> c = cc.getCounter(key1);\r\n      for (K2 key2 : c.keySet()) {\r\n        double count = c.getCount(key2);\r\n        result.setCount(key2, key1, count);\r\n      }\r\n    }\r\n    return result;\r\n  }", "label": 0}
{"code": "def list(self, id, seq): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Get a list of captures.\n\n        :param id: Result ID as an int.\n        :param seq: TestResult sequence ID as an int.\n        :return: :class:`captures.Capture <captures.Capture>` list\n        \"\"\"\n        schema = CaptureSchema(exclude=('id', 'seq'))\n        resp = self.service.list(self._base(id, seq))\n        return self.service.decode(schema, resp, many=True)", "label": 1}
{"code": "def space(self):\n        \"\"\"Get system disk space usage.\n\n        :return: :class:`system.Space <system.Space>` object\n        :rtype: system.Space\n        \"\"\"\n        schema = SpaceSchema()\n        resp = self.service.get(self.base+'space/')\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "public static base_response update(nitro_service client, snmpalarm resource) throws Exception {\n\t\tsnmpalarm updateresource = new snmpalarm();\n\t\tupdateresource.trapname = resource.trapname;\n\t\tupdateresource.thresholdvalue = resource.thresholdvalue;\n\t\tupdateresource.normalvalue = resource.normalvalue;\n\t\tupdateresource.time = resource.time;\n\t\tupdateresource.state = resource.state;\n\t\tupdateresource.severity = resource.severity;\n\t\tupdateresource.logging = resource.logging;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function appendComments(comments, ul) {\n    $.each(comments, function() {\n      var div = createCommentDiv(this);\n      ul.append($(document.createElement('li')).html(div));\n      appendComments(this.children, div.find('ul.comment-children'));\n      // To avoid stagnating data, don't store the comments children in data.\n      this.children = null;\n      div.data('comment', this);\n    });\n  }", "label": 3}
{"code": "public function basic_publish(\n        $msg,\n        $exchange = '',\n        $routing_key = '',\n        $mandatory = false,\n        $immediate = false,\n        $ticket = null\n    ) {\n        $pkt = new AMQPWriter();\n        $pkt->write($this->pre_publish($exchange, $routing_key, $mandatory, $immediate, $ticket));\n\n        try {\n            $this->connection->send_content(\n                $this->channel_id,\n                60,\n                0,\n                mb_strlen($msg->body, 'ASCII'),\n                $msg->serialize_properties(),\n                $msg->body,\n                $pkt\n            );\n        } catch (AMQPConnectionClosedException $e) {\n            $this->do_close();\n            throw $e;\n        }\n\n        if ($this->next_delivery_tag > 0) {\n            $this->published_messages[$this->next_delivery_tag] = $msg;\n            $this->next_delivery_tag = bcadd($this->next_delivery_tag, '1', 0);\n        }\n    }", "label": 2}
{"code": "public static authenticationnegotiatepolicy_binding get(nitro_service service, String name) throws Exception{\n\t\tauthenticationnegotiatepolicy_binding obj = new authenticationnegotiatepolicy_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationnegotiatepolicy_binding response = (authenticationnegotiatepolicy_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static authenticationradiusaction[] get(nitro_service service) throws Exception{\n\t\tauthenticationradiusaction obj = new authenticationradiusaction();\n\t\tauthenticationradiusaction[] response = (authenticationradiusaction[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def permit(action, keys: nil, except: nil, &block)\n      if block_given?\n        @permitted[action] = block\n      end\n\n      if keys.present?\n        @permitted[action] ||= @auth_keys.dup\n        @permitted[action].concat(keys)\n      end\n\n      if except.present?\n        @permitted[action] ||= @auth_keys.dup\n        @permitted[action] = @permitted[action] - except\n      end\n    end", "label": 4}
{"code": "def merge(other)\n      self.class.new.tap do |result|\n        result.merge!(self)\n        result.merge!(other)\n      end\n    end", "label": 4}
{"code": "func ExpectBadParameter(c *check.C, err error) {\n\tc.Assert(trace.IsBadParameter(err), check.Equals, true, check.Commentf(\"expected BadParameter, got %T %v at %v\", trace.Unwrap(err), err, string(debug.Stack())))\n}", "label": 5}
{"code": "func (a *TestAuthServer) NewRemoteClient(identity TestIdentity, addr net.Addr, pool *x509.CertPool) (*Client, error) {\n\ttlsConfig := utils.TLSConfig(a.CipherSuites)\n\tcert, err := a.NewCertificate(identity)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttlsConfig.Certificates = []tls.Certificate{*cert}\n\ttlsConfig.RootCAs = pool\n\taddrs := []utils.NetAddr{{\n\t\tAddrNetwork: addr.Network(),\n\t\tAddr:        addr.String()}}\n\treturn NewTLSClient(ClientConfig{Addrs: addrs, TLS: tlsConfig})\n}", "label": 5}
{"code": "def lookup_variable(context, variable)\n      lookup = context\n\n      variable.split(\".\").each do |value|\n        lookup = lookup[value]\n      end\n\n      lookup || variable\n    end", "label": 4}
{"code": "function nearestCharAfter(char, str, index) {\n  // Find the nearest char index before given index. skip white space strings\n  // If not found, return -1\n  let i = index + 1;\n  while (i < str.length) {\n    if (str.charAt(i) === char) return i;\n    if (!/\\s/.test(str.charAt(i))) return -1;\n    i += 1;\n  }\n  return -1;\n}", "label": 3}
{"code": "def say(*args)\n      params = arguments(*args).params\n      params[:s] = args.shift unless args.empty?\n      params['raw'] = true\n\n      get_request('/octocat', params)\n    end", "label": 4}
{"code": "func KeepAlive(roundTripper soap.RoundTripper, idleTime time.Duration) soap.RoundTripper {\n\treturn KeepAliveHandler(roundTripper, idleTime, defaultKeepAlive)\n}", "label": 5}
{"code": "def parse_manifest(code, filename)\n      Puppet::Pops::Parser::EvaluatingParser.new.parse_string(code, filename)\n    rescue Puppet::Error => e\n      raise Bolt::PAL::PALError, \"Failed to parse manifest: #{e}\"\n    end", "label": 4}
{"code": "function loadSchemaList(job, uris, callback) {\n\t\turis = uris.filter(function (value) {\n\t\t\treturn !!value;\n\t\t});\n\n\t\tif (uris.length === 0) {\n\t\t\tnextTick(function () {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tvar sweep = function () {\n\t\t\tif (uris.length === 0) {\n\t\t\t\tnextTick(callback);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tforAsync(uris, function (uri, i, callback) {\n\t\t\t\tif (!uri) {\n\t\t\t\t\tout.writeln('> ' + style.error('cannot load') + ' \"' + tweakURI(uri) + '\"');\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t\tout.writeln('> ' + style.accent('load') + ' + ' + tweakURI(uri));\n\n\t\t\t\tloader.load(uri, job.context.options, function (err, schema) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tjob.context.tv4.addSchema(uri, schema);\n\t\t\t\t\turis = job.context.tv4.getMissingUris();\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t}, function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tjob.error = err;\n\t\t\t\t\treturn callback(null);\n\t\t\t\t}\n\t\t\t\t// sweep again\n\t\t\t\tsweep();\n\t\t\t});\n\t\t};\n\t\tsweep();\n\t}", "label": 3}
{"code": "protected function routeRateLimit($route)\n    {\n        list($limit, $expires) = [$route->getRateLimit(), $route->getRateLimitExpiration()];\n\n        if ($limit && $expires) {\n            return sprintf('%s req/s', round($limit / ($expires * 60), 2));\n        }\n    }", "label": 2}
{"code": "public final void info(Object pObject)\r\n\t{\r\n\t\tgetLogger().log(FQCN, Level.INFO, pObject, null);\r\n\t}", "label": 0}
{"code": "public int getSridFromCrs(String crs) {\n\t\tint crsInt;\n\t\tif (crs.indexOf(':') != -1) {\n\t\t\tcrsInt = Integer.parseInt(crs.substring(crs.indexOf(':') + 1));\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tcrsInt = Integer.parseInt(crs);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tcrsInt = 0;\n\t\t\t}\n\t\t}\n\t\treturn crsInt;\n\t}", "label": 0}
{"code": "function processFileResponse(req, res, next) {\n  var fileDetails = req.appformsResultPayload.data;\n  if (fileDetails.stream) {\n    var headers = {};\n    headers[\"Content-Type\"] = fileDetails.type;//Setting the file content type. Mime types are set by the file handler.\n    headers[\"Content-Disposition\"] = \"attachment; filename=\" + fileDetails.name;\n    res.writeHead(200, headers);\n    fileDetails.stream.pipe(res);\n    fileDetails.stream.resume(); //Unpausing the stream as it was paused by the file handler\n  } else {\n    return next('Error getting submitted file - result: ' + JSON.stringify(fileDetails));\n  }\n}", "label": 3}
{"code": "def persist(self, context):\n\t\t\"\"\"Update or insert the session document into the configured collection\"\"\"\n\t\t\n\t\tD = self._Document\n\t\tdocument = context.session[self.name]\n\t\t\n\t\tD.get_collection().replace_one(D.id == document.id, document, True)", "label": 1}
{"code": "public void unregisterComponent(java.awt.Component c)\r\n    {\r\n        java.awt.dnd.DragGestureRecognizer recognizer = \r\n            (java.awt.dnd.DragGestureRecognizer)this.hmDragGestureRecognizers.remove(c);\r\n        if (recognizer != null)\r\n            recognizer.setComponent(null);\r\n    }", "label": 0}
{"code": "def symm_op(g, ax, theta, do_refl):\n    \"\"\" Perform general point symmetry operation on a geometry.\n\n    .. todo:: Complete symm_op docstring\n\n    \"\"\"\n\n    # Imports\n    import numpy as np\n\n    # Depend on lower functions' geometry vector coercion. Just\n    #  do the rotation and, if indicated, the reflection.\n    gx = geom_rotate(g, ax, theta)\n    if do_refl:\n        gx = geom_reflect(gx, ax)\n    ## end if\n\n    # Should be good to go\n    return gx", "label": 1}
{"code": "func StateGet(pdf *Fpdf) (st StateType) {\n\tst.clrDraw.R, st.clrDraw.G, st.clrDraw.B = pdf.GetDrawColor()\n\tst.clrFill.R, st.clrFill.G, st.clrFill.B = pdf.GetFillColor()\n\tst.clrText.R, st.clrText.G, st.clrText.B = pdf.GetTextColor()\n\tst.lineWd = pdf.GetLineWidth()\n\t_, st.fontSize = pdf.GetFontSize()\n\tst.alpha, st.blendStr = pdf.GetAlpha()\n\tst.cellMargin = pdf.GetCellMargin()\n\treturn\n}", "label": 5}
{"code": "public function revise($content, User $actor)\n    {\n        if ($this->content !== $content) {\n            $this->content = $content;\n\n            $this->edited_at = Carbon::now();\n            $this->edited_user_id = $actor->id;\n\n            $this->raise(new Revised($this));\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "public static int daysDiff(Date earlierDate, Date laterDate) {\n        if (earlierDate == null || laterDate == null) {\n            return 0;\n        }\n\n        return (int) ((laterDate.getTime() / DAY_MILLIS) - (earlierDate.getTime() / DAY_MILLIS));\n    }", "label": 0}
{"code": "function getKey(context) {\n        if (context.getModelKey) {\n            return context.getModelKey();\n        }\n        return context.props.name || context.props.key || context.props.ref;\n    }", "label": 3}
{"code": "function () {\n            var axis = this.axis,\n              value = this.value,\n              categories = axis.categories,\n              dateTimeLabelFormat = this.dateTimeLabelFormat,\n              numericSymbols = defaultOptions.lang.numericSymbols,\n              i = numericSymbols && numericSymbols.length,\n              multi,\n              ret,\n              formatOption = axis.options.labels.format,\n\n            // make sure the same symbol is added for all labels on a linear axis\n              numericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n            if (formatOption) {\n                ret = format(formatOption, this);\n\n            } else if (categories) {\n                ret = value;\n\n            } else if (dateTimeLabelFormat) { // datetime axis\n                ret = dateFormat(dateTimeLabelFormat, value);\n\n            } else if (i && numericSymbolDetector >= 1000) {\n                // Decide whether we should add a numeric symbol like k (thousands) or M (millions).\n                // If we are to enable this in tooltip or other places as well, we can move this\n                // logic to the numberFormatter and enable it by a parameter.\n                while (i-- && ret === UNDEFINED) {\n                    multi = Math.pow(1000, i + 1);\n                    if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {\n                        ret = numberFormat(value / multi, -1) + numericSymbols[i];\n                    }\n                }\n            }\n\n            if (ret === UNDEFINED) {\n                if (mathAbs(value) >= 10000) { // add thousands separators\n                    ret = numberFormat(value, 0);\n\n                } else { // small numbers\n                    ret = numberFormat(value, -1, UNDEFINED, ''); // #2466\n                }\n            }\n\n            return ret;\n        }", "label": 3}
{"code": "public static base_responses unset(nitro_service client, String ipaddress[], String args[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (ipaddress != null && ipaddress.length > 0) {\n\t\t\tnsrpcnode unsetresources[] = new nsrpcnode[ipaddress.length];\n\t\t\tfor (int i=0;i<ipaddress.length;i++){\n\t\t\t\tunsetresources[i] = new nsrpcnode();\n\t\t\t\tunsetresources[i].ipaddress = ipaddress[i];\n\t\t\t}\n\t\t\tresult = unset_bulk_request(client, unsetresources,args);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public function queueBroadcast(GraphQLSubscription $subscription, string $fieldName, $root): void\n    {\n        $this->eventsDispatcher->dispatch(\n            new BroadcastSubscriptionEvent($subscription, $fieldName, $root)\n        );\n    }", "label": 2}
{"code": "public function setDeleteFromRow($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\V2\\Mutation_DeleteFromRow::class);\n        $this->writeOneof(4, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public static function contextName($project, $session, $context)\n    {\n        return self::getContextNameTemplate()->render([\n            'project' => $project,\n            'session' => $session,\n            'context' => $context,\n        ]);\n    }", "label": 2}
{"code": "public void setIndirectionHandlerClass(Class indirectionHandlerClass)\r\n    {\r\n        if(indirectionHandlerClass == null)\r\n        {\r\n            //throw new MetadataException(\"No IndirectionHandlerClass specified.\");\r\n            /**\r\n             * andrew.clute\r\n             * Allow the default IndirectionHandler for the given ProxyFactory implementation\r\n             * when the parameter is not given\r\n             */\r\n            indirectionHandlerClass = getDefaultIndirectionHandlerClass();\r\n        }\r\n        if(indirectionHandlerClass.isInterface()\r\n                || Modifier.isAbstract(indirectionHandlerClass.getModifiers())\r\n                || !getIndirectionHandlerBaseClass().isAssignableFrom(indirectionHandlerClass))\r\n        {\r\n            throw new MetadataException(\"Illegal class \"\r\n                    + indirectionHandlerClass.getName()\r\n                    + \" specified for IndirectionHandlerClass. Must be a concrete subclass of \"\r\n                    + getIndirectionHandlerBaseClass().getName());\r\n        }\r\n        _indirectionHandlerClass = indirectionHandlerClass;\r\n    }", "label": 0}
{"code": "public function updateJob($projectId, $region, $jobId, $job, $updateMask, array $optionalArgs = [])\n    {\n        $request = new UpdateJobRequest();\n        $request->setProjectId($projectId);\n        $request->setRegion($region);\n        $request->setJobId($jobId);\n        $request->setJob($job);\n        $request->setUpdateMask($updateMask);\n\n        return $this->startCall(\n            'UpdateJob',\n            Job::class,\n            $optionalArgs,\n            $request\n        )->wait();\n    }", "label": 2}
{"code": "def prepare_full_update(model)\n      document = document_for_full_update(model)\n      setup = setup_for_object(model)\n      if boost = setup.document_boost_for(model)\n        document.attrs[:boost] = boost\n      end\n      setup.all_field_factories.each do |field_factory|\n        field_factory.populate_document(document, model)\n      end\n      document\n    end", "label": 4}
{"code": "def perform_decryption(\n      encryption_data,\n      password,\n      content_entry,\n      roo_content_xml_path\n    )\n      # Extract various expected attributes from the manifest that\n      # describe the encryption\n\n      algorithm_node            = encryption_data.xpath('manifest:algorithm').first\n      key_derivation_node       =\n        encryption_data.xpath('manifest:key-derivation').first\n      start_key_generation_node =\n        encryption_data.xpath('manifest:start-key-generation').first\n\n      # If we have all the expected elements, then we can perform\n      # the decryption.\n\n      if !algorithm_node.nil? && !key_derivation_node.nil? &&\n         !start_key_generation_node.nil?\n\n        # The algorithm is a URI describing the algorithm used\n        algorithm           = algorithm_node['manifest:algorithm-name']\n\n        # The initialization vector is base-64 encoded\n        iv                  = Base64.decode64(\n          algorithm_node['manifest:initialisation-vector']\n        )\n        key_derivation_name = key_derivation_node['manifest:key-derivation-name']\n        iteration_count     = key_derivation_node['manifest:iteration-count'].to_i\n        salt                = Base64.decode64(key_derivation_node['manifest:salt'])\n\n        # The key is hashed with an algorithm represented by this URI\n        key_generation_name =\n          start_key_generation_node[\n            'manifest:start-key-generation-name'\n          ]\n\n        hashed_password = password\n\n        if key_generation_name == 'http://www.w3.org/2000/09/xmldsig#sha256'\n\n          hashed_password = Digest::SHA256.digest(password)\n        else\n          fail ArgumentError, \"Unknown key generation algorithm #{key_generation_name}\"\n        end\n\n        cipher = find_cipher(\n          algorithm,\n          key_derivation_name,\n          hashed_password,\n          salt,\n          iteration_count,\n          iv\n        )\n\n        begin\n          decrypted = decrypt(content_entry, cipher)\n\n          # Finally, inflate the decrypted stream and overwrite\n          # content.xml\n          IO.binwrite(\n            roo_content_xml_path,\n            Zlib::Inflate.new(-Zlib::MAX_WBITS).inflate(decrypted)\n          )\n        rescue StandardError => error\n          raise ArgumentError, \"Invalid password or other data error: #{error}\"\n        end\n      else\n        fail ArgumentError, 'manifest.xml missing encryption-data elements'\n      end\n    end", "label": 4}
{"code": "def remove_fee(location_id, item_id, fee_id, opts = {})\n      data, _status_code, _headers = remove_fee_with_http_info(location_id, item_id, fee_id, opts)\n      return data\n    end", "label": 4}
{"code": "public void releaseDbResources()\r\n    {\r\n        Iterator it = m_rsIterators.iterator();\r\n        while (it.hasNext())\r\n        {\r\n            ((OJBIterator) it.next()).releaseDbResources();\r\n        }\r\n    }", "label": 0}
{"code": "def maintained_selection():\n    \"\"\"Maintain selection during context\n\n    Example:\n        >>> with maintained_selection():\n        ...     # Modify selection\n        ...     node.setSelected(on=False, clear_all_selected=True)\n        >>> # Selection restored\n\n    \"\"\"\n\n    previous_selection = hou.selectedNodes()\n    try:\n        yield\n    finally:\n        if previous_selection:\n            for node in previous_selection:\n                node.setSelected(on=True)\n        else:\n            for node in previous_selection:\n                node.setSelected(on=False)", "label": 1}
{"code": "func isCIDR(fl FieldLevel) bool {\n\n\t_, _, err := net.ParseCIDR(fl.Field().String())\n\n\treturn err == nil\n}", "label": 5}
{"code": "def to_hash\n      hash = {}\n      self.class.attribute_map.each_pair do |attr, param|\n        value = self.send(attr)\n        next if value.nil?\n        hash[param] = _to_hash(value)\n      end\n      hash\n    end", "label": 4}
{"code": "def inverse_bool(name, value)\n      b = convert_bool(name, value)\n\n      if b.nil?\n        nil\n      else\n        !b\n      end\n    end", "label": 4}
{"code": "function generateImports (context) {\n  const { files, tree } = getPageData(context)\n\n  store.state.components = tree\n\n  const output = files\n    .slice()\n    .map(file => `import '@/${file}'`)\n    .join('\\n')\n\n  fs.ensureDirSync(path.join(context, '.temp'))\n  fs.writeFileSync(path.join(context, '.temp/html.js'), output)\n}", "label": 3}
{"code": "func (r *LogResponse) AddLog(log *bees.LogMessage) {\n\tr.logs = append(r.logs, log)\n\tr.Logs = append(r.Logs, prepareLogResponse(r.Context, log))\n}", "label": 5}
{"code": "public static ResourceKey key(Class<?> clazz, Enum<?> value) {\n        return new ResourceKey(clazz.getName(), value.name());\n    }", "label": 0}
{"code": "function(args) {\n        base.call(this, args);\n        this.loadedOnceDeferred = new $.Deferred();\n        this.loadedOnce = false;\n        this.loadingCount = 0;\n        // Loading is a convenience flag that is the equivalent of loadingCount > 0\n        this.loading = false;\n      }", "label": 3}
{"code": "public static tmsessionpolicy_binding get(nitro_service service, String name) throws Exception{\n\t\ttmsessionpolicy_binding obj = new tmsessionpolicy_binding();\n\t\tobj.set_name(name);\n\t\ttmsessionpolicy_binding response = (tmsessionpolicy_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func ExpectNotFound(c *check.C, err error) {\n\tc.Assert(trace.IsNotFound(err), check.Equals, true, check.Commentf(\"expected NotFound, got %T %v at %v\", trace.Unwrap(err), err, string(debug.Stack())))\n}", "label": 5}
{"code": "def create_readme_with_long_description():\n    '''Try to convert content of README.md into rst format using pypandoc,\n    write it into README and return it.\n\n    If pypandoc cannot be imported write content of README.md unchanged into\n    README and return it.\n    '''\n    this_dir = os.path.abspath(os.path.dirname(__file__))\n\n    readme_md = os.path.join(this_dir, 'README.md')\n    readme = os.path.join(this_dir, 'README')\n\n    if os.path.exists(readme_md):\n        # this is the case when running `python setup.py sdist`\n        if os.path.exists(readme):\n            os.remove(readme)\n\n        try:\n            import pypandoc\n            long_description = pypandoc.convert(readme_md, 'rst', format='md')\n        except(ImportError):\n            with open(readme_md, encoding='utf-8') as in_:\n                long_description = in_.read()\n\n        with open(readme, 'w') as out:\n            out.write(long_description)\n    else:\n        # this is in case of `pip install fabsetup-x.y.z.tar.gz`\n        with open(readme, encoding='utf-8') as in_:\n            long_description = in_.read()\n\n    return long_description", "label": 1}
{"code": "func (r *Resource) Request(method string, body ...interface{}) *http.Request {\n\trdr := io.MultiReader() // empty body by default\n\tif len(body) != 0 {\n\t\trdr = encode(body[0])\n\t}\n\treq, err := http.NewRequest(method, r.u.String(), rdr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn req\n}", "label": 5}
{"code": "def convertDay(self, day, prefix=\"\", weekday=False):\n        \"\"\"Convert a datetime object representing a day into a human-ready\n        string that can be read, spoken aloud, etc.\n\n        Args:\n            day (datetime.date): A datetime object to be converted into text.\n            prefix (str): An optional argument that prefixes the converted\n                string. For example, if prefix=\"in\", you'd receive \"in two\n                days\", rather than \"two days\", while the method would still\n                return \"tomorrow\" (rather than \"in tomorrow\").\n            weekday (bool): An optional argument that returns \"Monday, Oct. 1\"\n                if True, rather than \"Oct. 1\".\n\n        Returns:\n            A string representation of the input day, ignoring any time-related\n            information.\n        \"\"\"\n        def sameDay(d1, d2):\n            d = d1.day == d2.day\n            m = d1.month == d2.month\n            y = d1.year == d2.year\n            return d and m and y\n\n        tom = self.now + datetime.timedelta(days=1)\n\n        if sameDay(day, self.now):\n            return \"today\"\n        elif sameDay(day, tom):\n            return \"tomorrow\"\n\n        if weekday:\n            dayString = day.strftime(\"%A, %B %d\")\n        else:\n            dayString = day.strftime(\"%B %d\")\n\n        # Ex) Remove '0' from 'August 03'\n        if not int(dayString[-2]):\n            dayString = dayString[:-2] + dayString[-1]\n\n        return prefix + \" \" + dayString", "label": 1}
{"code": "public static gslbvserver_spilloverpolicy_binding[] get(nitro_service service, String name) throws Exception{\n\t\tgslbvserver_spilloverpolicy_binding obj = new gslbvserver_spilloverpolicy_binding();\n\t\tobj.set_name(name);\n\t\tgslbvserver_spilloverpolicy_binding response[] = (gslbvserver_spilloverpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def parallel_check(vec1, vec2):\n    \"\"\"Checks whether two vectors are parallel OR anti-parallel.\n\n    Vectors must be of the same dimension.\n\n    Parameters\n    ----------\n    vec1\n        length-R |npfloat_| --\n        First vector to compare\n\n    vec2\n        length-R |npfloat_| --\n        Second vector to compare\n\n    Returns\n    -------\n    par\n        |bool| --\n        |True| if (anti-)parallel to within\n        :data:`opan.const.PRM.NON_PARALLEL_TOL` degrees.  |False| otherwise.\n\n    \"\"\"\n\n    # Imports\n    from ..const import PRM\n    import numpy as np\n\n    # Initialize False\n    par = False\n\n    # Shape check\n    for n,v in enumerate([vec1, vec2]):\n        if not len(v.shape) == 1:\n            raise ValueError(\"Bad shape for vector #{0}\".format(n))\n        ## end if\n    ## next v,n\n    if not vec1.shape[0] == vec2.shape[0]:\n        raise ValueError(\"Vector length mismatch\")\n    ## end if\n\n    # Check for (anti-)parallel character and return\n    angle = vec_angle(vec1, vec2)\n    if min([abs(angle), abs(angle - 180.)]) < PRM.NON_PARALLEL_TOL:\n        par = True\n    ## end if\n\n    return par", "label": 1}
{"code": "function setNodes(data){\n        payload = data;\n\n        if(kontx.args.deep === true){\n            async.eachSeries(data, loadChild, sendNext);\n        }\n        else {\n            sendNext();\n        }\n    }", "label": 3}
{"code": "public void addDateTimeHelper(int ds, Date date) throws SerializationException, InvalidDataSetException {\r\n\t\tif (date == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tDataSetInfo dsi = dsiFactory.create(ds);\r\n\r\n\t\tSimpleDateFormat df = new SimpleDateFormat(dsi.getSerializer().toString());\r\n\t\tString value = df.format(date);\r\n\t\tbyte[] data = dsi.getSerializer().serialize(value, activeSerializationContext);\r\n\t\tDataSet dataSet = new DefaultDataSet(dsi, data);\r\n\t\tadd(dataSet);\r\n\t}", "label": 0}
{"code": "def col_id=(column_index)\n      column_index = column_index.col if column_index.is_a?(Cell)\n      Axlsx.validate_unsigned_int column_index\n      @col_id = column_index\n    end", "label": 4}
{"code": "public static transformpolicy get(nitro_service service, String name) throws Exception{\n\t\ttransformpolicy obj = new transformpolicy();\n\t\tobj.set_name(name);\n\t\ttransformpolicy response = (transformpolicy) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def fetch_order_book(self) -> OrderBook:\n        \"\"\"Fetch the order book.\"\"\"\n        return self._fetch('order book', self.market.code)(self._order_book)()", "label": 1}
{"code": "public function setConstraints($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\WebRisk\\V1beta1\\ComputeThreatListDiffRequest_Constraints::class);\n        $this->constraints = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function setAuxiliaryTables($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\StatisticalTable::class);\n        $this->auxiliary_tables = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function add_namespace(\n\t\t$root,\n\t\t$base_dir,\n\t\t$prefix = '',\n\t\t$suffix = '.php',\n\t\t$lowercase = false,\n\t\t$underscores = false\n\t) {\n\t\t$this->namespaces[] = array(\n\t\t\t'root'        => $this->normalize_root( (string) $root ),\n\t\t\t'base_dir'    => $this->add_trailing_slash( (string) $base_dir ),\n\t\t\t'prefix'      => (string) $prefix,\n\t\t\t'suffix'      => (string) $suffix,\n\t\t\t'lowercase'   => (bool) $lowercase,\n\t\t\t'underscores' => (bool) $underscores,\n\t\t);\n\n\t\treturn $this;\n\t}", "label": 2}
{"code": "public static base_response update(nitro_service client, snmpoption resource) throws Exception {\n\t\tsnmpoption updateresource = new snmpoption();\n\t\tupdateresource.snmpset = resource.snmpset;\n\t\tupdateresource.snmptraplogging = resource.snmptraplogging;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "public function sendKeys($value)\n    {\n        $local_file = $this->fileDetector->getLocalFile($value);\n        if ($local_file === null) {\n            $params = [\n                'value' => WebDriverKeys::encode($value),\n                ':id' => $this->id,\n            ];\n            $this->executor->execute(DriverCommand::SEND_KEYS_TO_ELEMENT, $params);\n        } else {\n            $remote_path = $this->upload($local_file);\n            $params = [\n                'value' => WebDriverKeys::encode($remote_path),\n                ':id' => $this->id,\n            ];\n            $this->executor->execute(DriverCommand::SEND_KEYS_TO_ELEMENT, $params);\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "func getHomeDir() string {\n\tswitch runtime.GOOS {\n\tcase teleport.LinuxOS:\n\t\treturn os.Getenv(teleport.EnvHome)\n\tcase teleport.DarwinOS:\n\t\treturn os.Getenv(teleport.EnvHome)\n\tcase teleport.WindowsOS:\n\t\treturn os.Getenv(teleport.EnvUserProfile)\n\t}\n\treturn \"\"\n}", "label": 5}
{"code": "private void prepareModel(DescriptorRepository model)\r\n    {\r\n        TreeMap result = new TreeMap();\r\n\r\n        for (Iterator it = model.getDescriptorTable().values().iterator(); it.hasNext();)\r\n        {\r\n            ClassDescriptor classDesc = (ClassDescriptor)it.next();\r\n\r\n            if (classDesc.getFullTableName() == null)\r\n            {\r\n                // not mapped to a database table\r\n                continue;\r\n            }\r\n\r\n            String elementName        = getElementName(classDesc);\r\n            Table  mappedTable        = getTableFor(elementName);\r\n            Map    columnsMap         = getColumnsFor(elementName);\r\n            Map    requiredAttributes = getRequiredAttributes(elementName);\r\n            List   classDescs         = getClassDescriptorsMappingTo(elementName);\r\n\r\n            if (mappedTable == null)\r\n            {\r\n                mappedTable = _schema.findTable(classDesc.getFullTableName());\r\n                if (mappedTable == null)\r\n                {\r\n                    continue;\r\n                }\r\n                columnsMap         = new TreeMap();\r\n                requiredAttributes = new HashMap();\r\n                classDescs         = new ArrayList();\r\n                _elementToTable.put(elementName, mappedTable);\r\n                _elementToClassDescriptors.put(elementName, classDescs);\r\n                _elementToColumnMap.put(elementName, columnsMap);\r\n                _elementToRequiredAttributesMap.put(elementName, requiredAttributes);\r\n            }\r\n            classDescs.add(classDesc);\r\n            extractAttributes(classDesc, mappedTable, columnsMap, requiredAttributes);\r\n        }\r\n        extractIndirectionTables(model, _schema);\r\n    }", "label": 0}
{"code": "function setDefaults ({ headers={}, overrideHeaders=false, ...rest }) {\n  return {\n    ...DEFAULTS,\n    headers: overrideHeaders ? headers : { ...DEFAULT_HEADERS, ...headers },\n    ...rest,\n  }\n}", "label": 3}
{"code": "def get(self, name=None, plugin=None):\n        \"\"\"\n        Returns requested shared objects.\n\n        :param name: Name of a request shared object\n        :type name: str or None\n        :param plugin: Plugin, which has registered the requested shared object\n        :type plugin: GwBasePattern instance or None\n        \"\"\"\n        if plugin is not None:\n            if name is None:\n                shared_objects_list = {}\n                for key in self._shared_objects.keys():\n                    if self._shared_objects[key].plugin == plugin:\n                        shared_objects_list[key] = self._shared_objects[key]\n                return shared_objects_list\n            else:\n                if name in self._shared_objects.keys():\n                    if self._shared_objects[name].plugin == plugin:\n                        return self._shared_objects[name]\n                    else:\n                        return None\n                else:\n                    return None\n        else:\n            if name is None:\n                return self._shared_objects\n            else:\n                if name in self._shared_objects.keys():\n                    return self._shared_objects[name]\n                else:\n                    return None", "label": 1}
{"code": "private function imbReverseUs($num)\n\t{\n\t\t$rev = 0;\n\t\tfor ($i = 0; $i < 16; ++$i) {\n\t\t\t$rev <<= 1;\n\t\t\t$rev |= ($num & 1);\n\t\t\t$num >>= 1;\n\t\t}\n\t\treturn $rev;\n\t}", "label": 2}
{"code": "private License getLicense(final String licenseId) {\n        License result = null;\n        final Set<DbLicense> matchingLicenses = licenseMatcher.getMatchingLicenses(licenseId);\n\n        if (matchingLicenses.isEmpty()) {\n            result = DataModelFactory.createLicense(\"#\" + licenseId + \"# (to be identified)\", NOT_IDENTIFIED_YET, NOT_IDENTIFIED_YET, NOT_IDENTIFIED_YET, NOT_IDENTIFIED_YET);\n            result.setUnknown(true);\n        } else {\n            if (matchingLicenses.size() > 1 && LOG.isWarnEnabled()) {\n                LOG.warn(String.format(\"%s matches multiple licenses %s. \" +\n                                \"Please run the report showing multiple matching on licenses\",\n                        licenseId, matchingLicenses.toString()));\n            }\n            result = mapper.getLicense(matchingLicenses.iterator().next());\n\n        }\n\n        return result;\n    }", "label": 0}
{"code": "public function setView($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Kms\\V1\\CryptoKeyVersion_CryptoKeyVersionView::class);\n        $this->view = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def cachedir\n      if Gem.win_platform?\n        File.join(ENV['LOCALAPPDATA'], 'PDK', 'cache')\n      else\n        File.join(Dir.home, '.pdk', 'cache')\n      end\n    end", "label": 4}
{"code": "private void handleMultiInstanceReportResponse(SerialMessage serialMessage,\r\n\t\t\tint offset) {\r\n\t\tlogger.trace(\"Process Multi-instance Report\");\r\n\t\tint commandClassCode = serialMessage.getMessagePayloadByte(offset);\r\n\t\tint instances = serialMessage.getMessagePayloadByte(offset + 1);\r\n\r\n\t\tif (instances == 0) {\r\n\t\t\tsetInstances(1);\r\n\t\t} else \r\n\t\t{\r\n\t\t\tCommandClass commandClass = CommandClass.getCommandClass(commandClassCode);\r\n\t\t\t\r\n\t\t\tif (commandClass == null) {\r\n\t\t\t\tlogger.error(String.format(\"Unsupported command class 0x%02x\", commandClassCode));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlogger.debug(String.format(\"Node %d Requested Command Class = %s (0x%02x)\", this.getNode().getNodeId(), commandClass.getLabel() , commandClassCode));\r\n\t\t\tZWaveCommandClass zwaveCommandClass = this.getNode().getCommandClass(commandClass);\r\n\t\t\t\r\n\t\t\tif (zwaveCommandClass == null) {\r\n\t\t\t\tlogger.error(String.format(\"Unsupported command class %s (0x%02x)\", commandClass.getLabel(), commandClassCode));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tzwaveCommandClass.setInstances(instances);\r\n\t\t\tlogger.debug(String.format(\"Node %d Instances = %d, number of instances set.\", this.getNode().getNodeId(), instances));\r\n\t\t}\r\n\t\t\r\n\t\tfor (ZWaveCommandClass zwaveCommandClass : this.getNode().getCommandClasses())\r\n\t\t\tif (zwaveCommandClass.getInstances() == 0) // still waiting for an instance report of another command class. \r\n\t\t\t\treturn;\r\n\t\t\r\n\t\t// advance node stage.\r\n\t\tthis.getNode().advanceNodeStage();\r\n\t}", "label": 0}
{"code": "function resolveModulePath(relativeToFile, modulePath) {\n  if (!isLocalModule(modulePath)) {\n    return modulePath;\n  }\n\n  const alias = getModuleResolverAlias();\n  const matched = _.find(_.keys(alias), k => _.startsWith(modulePath, k));\n\n  let res = null;\n  if (matched) {\n    const resolveTo = alias[matched];\n    const relativePath = modulePath.replace(new RegExp(`^${matched}`), '').replace(/^\\//, '');\n    res = paths.map(resolveTo, relativePath);\n    // res = utils.joinPath(utils.getProjectRoot(), resolveTo, relativePath);\n  } else {\n    res = paths.join(path.dirname(relativeToFile), modulePath);\n  }\n\n  let relPath = res.replace(paths.getProjectRoot(), '').replace(/^\\/?/, '');\n  if (vio.dirExists(relPath)) {\n    // if import from a folder, then resolve to index.js\n    relPath = paths.join(relPath, 'index');\n  }\n  return relPath;\n}", "label": 3}
{"code": "private function buildDefaultAsyncHandler()\n    {\n        $isGuzzleHandler = $this->httpHandler instanceof Guzzle6HttpHandler\n            || $this->httpHandler instanceof Guzzle5HttpHandler;\n\n        return $isGuzzleHandler\n            ? [$this->httpHandler, 'async']\n            : [HttpHandlerFactory::build(), 'async'];\n    }", "label": 2}
{"code": "public Rectangle getTextSize(String text, Font font) {\n\t\ttemplate.saveState();\n\t\t// get the font\n\t\tDefaultFontMapper mapper = new DefaultFontMapper();\n\t\tBaseFont bf = mapper.awtToPdf(font);\n\t\ttemplate.setFontAndSize(bf, font.getSize());\n\t\t// calculate text width and height\n\t\tfloat textWidth = template.getEffectiveStringWidth(text, false);\n\t\tfloat ascent = bf.getAscentPoint(text, font.getSize());\n\t\tfloat descent = bf.getDescentPoint(text, font.getSize());\n\t\tfloat textHeight = ascent - descent;\n\t\ttemplate.restoreState();\n\t\treturn new Rectangle(0, 0, textWidth, textHeight);\n\t}", "label": 0}
{"code": "function processZtagOutput(output) {\n  return output.split('\\n').reduce(function(memo, line) {\n    var match, key, value;\n      match = ztagRegex.exec(line);\n      if(match) {\n        key = match[1];\n        value = match[2];\n        memo[key] = value;\n      }\n      return memo;\n  }, {});\n}", "label": 3}
{"code": "public static locationparameter get(nitro_service service) throws Exception{\n\t\tlocationparameter obj = new locationparameter();\n\t\tlocationparameter[] response = (locationparameter[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "public function setText($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\TextInput::class);\n        $this->writeOneof(2, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public function setPersonalUris($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Talent\\V4beta1\\PersonalUri::class);\n        $this->personal_uris = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func MyEnumValues(db models.XODB, schema string, enum string) ([]*models.EnumValue, error) {\n\tvar err error\n\n\t// load enum vals\n\tres, err := models.MyEnumValues(db, schema, enum)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// process enum vals\n\tenumVals := []*models.EnumValue{}\n\tfor i, ev := range strings.Split(res.EnumValues[1:len(res.EnumValues)-1], \"','\") {\n\t\tenumVals = append(enumVals, &models.EnumValue{\n\t\t\tEnumValue:  ev,\n\t\t\tConstValue: i + 1,\n\t\t})\n\t}\n\n\treturn enumVals, nil\n}", "label": 5}
{"code": "function getAttribute(path, attrNode) {\n    path.forEach(attrName => {\n        if (!(attrNode.attributes && attrNode.attributes[attrName])) {\n            throw new ImplementationError(`Result-Builder: Unknown attribute \"${path.join('.')}\"`);\n        }\n        attrNode = attrNode.attributes[attrName];\n    });\n    return attrNode;\n}", "label": 3}
{"code": "public function hasPermission($permission)\n    {\n        if ($this->id == self::ADMINISTRATOR_ID) {\n            return true;\n        }\n\n        return $this->permissions->contains('permission', $permission);\n    }", "label": 2}
{"code": "func (l *LimiterConfig) SetEnv(v string) error {\n\tif err := json.Unmarshal([]byte(v), l); err != nil {\n\t\treturn trace.Wrap(err, \"expected JSON encoded remote certificate\")\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function checkTypeParameter(node) {\n            // Grammar Checking\n            if (node.expression) {\n                grammarErrorOnFirstToken(node.expression, ts.Diagnostics.Type_expected);\n            }\n            checkSourceElement(node.constraint);\n            getConstraintOfTypeParameter(getDeclaredTypeOfTypeParameter(getSymbolOfNode(node)));\n            if (produceDiagnostics) {\n                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);\n            }\n        }", "label": 3}
{"code": "public void deleteOrganization(final String organizationId) {\n        final DbOrganization dbOrganization = getOrganization(organizationId);\n        repositoryHandler.deleteOrganization(dbOrganization.getName());\n        repositoryHandler.removeModulesOrganization(dbOrganization);\n    }", "label": 0}
{"code": "func (c *Client) RoundTrip(ctx context.Context, req, res soap.HasFault) error {\n\treturn c.RoundTripper.RoundTrip(ctx, req, res)\n}", "label": 5}
{"code": "func fileSize(filename string) (size int64, ok bool) {\n\tinfo, err := os.Stat(filename)\n\tok = err == nil\n\tif ok {\n\t\tsize = info.Size()\n\t}\n\treturn\n}", "label": 5}
{"code": "function parseLine(line) {\n        let args, mention, commandText;\n        if (new RegExp(`^@${forum.username}\\\\s\\\\S{3,}(\\\\s|$)`, 'i').test(line)) {\n            args = line.split(/\\s+/);\n            args.shift();\n            commandText = args.shift();\n            mention = true;\n        } else if (/^!\\w\\S{2,}(\\s|$)/.test(line)) {\n            args = line.split(/\\s+/);\n            commandText = args.shift().substring(1);\n            mention = false;\n        }\n        if (commandText) {\n            return {\n                commandText: commandText,\n                command: commandText.toLowerCase(),\n                args: args,\n                line: line,\n                mention: mention\n            };\n        }\n        return null;\n    }", "label": 3}
{"code": "func (c *Manager) GetLibraryItemUpdateSessionFile(ctx context.Context, sessionID string, fileName string) (*UpdateFileInfo, error) {\n\turl := internal.URL(c, internal.LibraryItemUpdateSessionFile).WithID(sessionID).WithAction(\"get\")\n\tspec := struct {\n\t\tName string `json:\"file_name\"`\n\t}{fileName}\n\tvar res UpdateFileInfo\n\treturn &res, c.Do(ctx, url.Request(http.MethodPost, spec), &res)\n}", "label": 5}
{"code": "public function registerSessionHandler(array $config = [])\n    {\n        $handler = SessionHandler::fromClient($this, $config);\n        $handler->register();\n\n        return $handler;\n    }", "label": 2}
{"code": "def register_std(self):\n        ''' Registers all the standard checkers in the given checker.\n\n        If not present already, the standard checkers schema (STD_NAMESPACE) is\n        added to the checker's namespace with an empty prefix.\n        '''\n        self._namespace.register(STD_NAMESPACE, '')\n        for cond in _ALL_CHECKERS:\n            self.register(cond, STD_NAMESPACE, _ALL_CHECKERS[cond])", "label": 1}
{"code": "public function setInterval($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Monitoring\\V3\\TimeInterval::class);\n        $this->interval = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function setLabelDetectionMode($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\VideoIntelligence\\V1\\LabelDetectionMode::class);\n        $this->label_detection_mode = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def slicesum(self, start, stop=None, axis=0):\n        \"\"\"Slices the histogram along axis, then sums over that slice, returning a d-1 dimensional histogram\"\"\"\n        return self.slice(start, stop, axis).sum(axis)", "label": 1}
{"code": "func (p *DatastorePath) FromString(s string) bool {\n\tif s == \"\" {\n\t\treturn false\n\t}\n\n\ts = strings.TrimSpace(s)\n\n\tif !strings.HasPrefix(s, \"[\") {\n\t\treturn false\n\t}\n\n\ts = s[1:]\n\n\tix := strings.Index(s, \"]\")\n\tif ix < 0 {\n\t\treturn false\n\t}\n\n\tp.Datastore = s[:ix]\n\tp.Path = strings.TrimSpace(s[ix+1:])\n\n\treturn true\n}", "label": 5}
{"code": "public function setType($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Vision\\V1\\TextAnnotation_DetectedBreak_BreakType::class);\n        $this->type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function() {\n      this._undelegateUpdateEvents();\n      var updateEvents = this.__parseUpdateEvents();\n      _.each(updateEvents, function(parsedUpdateEvent) {\n        this.listenTo(parsedUpdateEvent.idContainer, parsedUpdateEvent.eventName, this.retrieve);\n      }, this);\n    }", "label": 3}
{"code": "def call(current_options, params)\n      unless HTTP_METHODS.include?(action)\n        raise ArgumentError, \"unknown http method: #{method}\"\n      end\n\n      puts \"EXECUTED: #{action} - #{path} with PARAMS: #{params.request_params}\" if ENV['DEBUG']\n\n      request_options    = params.options\n      connection_options = current_options.merge(request_options)\n      conn               = connection(api, connection_options)\n\n      self.path = Utils::Url.normalize(self.path)\n      if conn.path_prefix != '/' && self.path.index(conn.path_prefix) != 0\n        self.path = (conn.path_prefix + self.path).gsub(/\\/(\\/)*/, '/')\n      end\n\n      response = conn.send(action) do |request|\n        case action.to_sym\n        when *(HTTP_METHODS - METHODS_WITH_BODIES)\n          request.body = params.data if params.key?('data')\n          if params.key?('encoder')\n            request.params.params_encoder(params.encoder)\n          end\n          request.url(self.path, params.request_params)\n        when *METHODS_WITH_BODIES\n          request.url(self.path, connection_options[:query] || {})\n          request.body = params.data unless params.empty?\n        end\n      end\n      ResponseWrapper.new(response, api)\n    end", "label": 4}
{"code": "def c src, options = {}\n      options = {\n        :expand_types => true,\n      }.merge options\n      self.generate src, options\n    end", "label": 4}
{"code": "protected function fieldValue(string $key)\n    {\n        return $this->isBatched()\n            ? Arr::get($this->operations, $this->batchIndex.'.'.$key)\n            : $this->operations[$key] ?? null;\n    }", "label": 2}
{"code": "function isValid(date) {\n  return Object.prototype.toString.call(date) == '[object Date]' && !isNaN(date.getTime());\n}", "label": 3}
{"code": "public static dnssuffix get(nitro_service service, String Dnssuffix) throws Exception{\n\t\tdnssuffix obj = new dnssuffix();\n\t\tobj.set_Dnssuffix(Dnssuffix);\n\t\tdnssuffix response = (dnssuffix) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def append_text(self, txt):\n        \"\"\" adds a line of text to a file \"\"\"\n        with open(self.fullname, \"a\") as myfile:\n            myfile.write(txt)", "label": 1}
{"code": "function(value, delaySort, equals)\n  {\n    var i = this.indexOf( value, equals );\n    var element = this[ i ];\n\n    if ( i !== -1 )\n    {\n      this.removeAt( i, delaySort );\n    }\n\n    return element;\n  }", "label": 3}
{"code": "function responseCallback(response, model, success) {\n        // Add response to a hash that will eventually be returned through the promise\n        responses[model.cid] = {\n            success: success,\n            response: response\n          };\n        // If we have reached the total of number of expected responses, then resolve or reject the promise\n        if (responsesFailed + responsesSucceeded === numberOfSaves) {\n          if (responsesFailed > 0) {\n            // Rollback if any responses have failed\n            if (options.rollback) {\n              _.each(formModel.getTrackedModels(), function(model) {\n                model.set(oldValues[model.cid]);\n                if (responses[model.cid].success) {\n                  model.save();\n                }\n              });\n            }\n            formModel.trigger('save-fail', responses);\n            deferred.reject(responses);\n          } else {\n            formModel.trigger('save-success', responses);\n            deferred.resolve(responses);\n          }\n        }\n      }", "label": 3}
{"code": "def get_raw_data(self, url, *args, **kwargs):\n        \"\"\"Gets data from url as bytes\n\n        Returns content under the provided url as bytes\n        ie. for binary data\n\n        Args:\n            **url**: address of the wanted data\n\n            .. versionadded:: 0.3.2\n                **additional_headers**: (optional) Additional headers\n                to be used with request\n\n        Returns:\n            bytes\n\n        \"\"\"\n        res = self._conn.get(url, headers=self._prepare_headers(**kwargs))\n        if res.status_code == 200:\n            return res.content\n        else:\n            return None", "label": 1}
{"code": "def b(name, identifier={:index => 0}, &block)\n      standard_methods(name, identifier,'b_for', &block)\n      define_method(name) do\n        return platform.b_text_for identifier.clone unless block_given?\n        self.send(\"#{name}_element\").text\n      end\n    end", "label": 4}
{"code": "public static sslvserver_sslciphersuite_binding[] get(nitro_service service, String vservername) throws Exception{\n\t\tsslvserver_sslciphersuite_binding obj = new sslvserver_sslciphersuite_binding();\n\t\tobj.set_vservername(vservername);\n\t\tsslvserver_sslciphersuite_binding response[] = (sslvserver_sslciphersuite_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static snmpalarm[] get(nitro_service service) throws Exception{\n\t\tsnmpalarm obj = new snmpalarm();\n\t\tsnmpalarm[] response = (snmpalarm[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private function createClient($class, $packageName, array $config = [])\n    {\n        if (class_exists($class)) {\n            return new $class($this->resolveConfig($config + $this->config));\n        }\n        throw new \\Exception(sprintf(\n            'The google/cloud-%s package is missing and must be installed.',\n            $packageName\n        ));\n    }", "label": 2}
{"code": "def oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\n\n    The refresh_token can be used to obtain a new access_token after\n    the old one is expired. It is saved in the database for long term use.\n    A refresh_token will be present only if `access_type=offline` is included\n    in the authorization code request.\n\n    :param remote: The remote application.\n    :param resp: The response.\n    :param token_type: The token type. (Default: ``''``)\n    :param extra_data: Extra information. (Default: ``None``)\n    :returns: A :class:`invenio_oauthclient.models.RemoteToken` instance.\n    \"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )", "label": 1}
{"code": "public static lbvserver_binding get(nitro_service service, String name) throws Exception{\n\t\tlbvserver_binding obj = new lbvserver_binding();\n\t\tobj.set_name(name);\n\t\tlbvserver_binding response = (lbvserver_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (f EventFields) AsString() string {\n\treturn fmt.Sprintf(\"%s: login=%s, id=%v, bytes=%v\",\n\t\tf.GetString(EventType),\n\t\tf.GetString(EventLogin),\n\t\tf.GetInt(EventCursor),\n\t\tf.GetInt(SessionPrintEventBytes))\n}", "label": 5}
{"code": "func (t *terminal) setOwner() error {\n\tuid, gid, mode, err := getOwner(t.ctx.Identity.Login, user.Lookup, user.LookupGroup)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\terr = os.Chown(t.tty.Name(), uid, gid)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\terr = os.Chmod(t.tty.Name(), mode)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\tlog.Debugf(\"Set permissions on %v to %v:%v with mode %v.\", t.tty.Name(), uid, gid, mode)\n\n\treturn nil\n}", "label": 5}
{"code": "function isDir(fp, stat) {\n  if (endsWith(fp, '/')) {\n    return true;\n  }\n\n  if (stat === null) {\n    // try to get the directory info if it hasn't been done yet\n    // to ensure directories containing dots are well handle\n    stat = tryStats(fp);\n  }\n\n  if (isObject(stat) && typeof stat.isDirectory === 'function') {\n    return stat.isDirectory();\n  }\n\n  var segs = fp.split('/');\n  var last = segs[segs.length - 1];\n  if (last && last.indexOf('.') !== -1) {\n    return false;\n  }\n  return true;\n}", "label": 3}
{"code": "func reviewKey() (bool, error) {\n\tin := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tstdout.Printf(\"Are you sure you want to trust this key (yes/no)?\")\n\t\tinput, err := in.ReadString('\\n')\n\t\tif err != nil {\n\t\t\treturn false, errwrap.Wrap(errors.New(\"error reading input\"), err)\n\t\t}\n\t\tswitch input {\n\t\tcase \"yes\\n\":\n\t\t\treturn true, nil\n\t\tcase \"no\\n\":\n\t\t\treturn false, nil\n\t\tdefault:\n\t\t\tstdout.Printf(\"Please enter 'yes' or 'no'\")\n\t\t}\n\t}\n}", "label": 5}
{"code": "private Object getParameter(String name, String value) throws ParseException, NumberFormatException {\n\t\tObject result = null;\n\t\tif (name.length() > 0) {\n\n\t\t\tswitch (name.charAt(0)) {\n\t\t\t\tcase 'i':\n\t\t\t\t\tif (null == value || value.length() == 0) {\n\t\t\t\t\t\tvalue = \"0\";\n\t\t\t\t\t}\n\t\t\t\t\tresult = new Integer(value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tif (name.startsWith(\"form\")) {\n\t\t\t\t\t\tresult = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (null == value || value.length() == 0) {\n\t\t\t\t\t\t\tvalue = \"0.0\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = new Double(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tif (null == value || value.length() == 0) {\n\t\t\t\t\t\tresult = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSimpleDateFormat dateParser = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\t\t\t\t\tresult = dateParser.parse(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tif (null == value || value.length() == 0) {\n\t\t\t\t\t\tresult = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSimpleDateFormat timeParser = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\t\t\t\tresult = timeParser.parse(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tresult = \"true\".equalsIgnoreCase(value) ? Boolean.TRUE : Boolean.FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tresult = value;\n\t\t\t}\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tif (result != null) {\n\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t\"parameter \" + name + \" value \" + result + \" class \" + result.getClass().getName());\n\t\t\t\t} else {\n\t\t\t\t\tlog.debug(\"parameter\" + name + \"is null\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "private List<T> computePagedList(List<T> result, HeaderAndBody httpResponse, JSONObject where, Pipe<T> requestingPipe) {\n        ReadFilter previousRead = null;\n        ReadFilter nextRead = null;\n\n        if (PageConfig.MetadataLocations.WEB_LINKING.equals(pageConfig.getMetadataLocation())) {\n            String webLinksRaw = \"\";\n            final String relHeader = \"rel\";\n            final String nextIdentifier = pageConfig.getNextIdentifier();\n            final String prevIdentifier = pageConfig.getPreviousIdentifier();\n            try {\n                webLinksRaw = getWebLinkHeader(httpResponse);\n                if (webLinksRaw == null) { // no paging, return result\n                    return result;\n                }\n                List<WebLink> webLinksParsed = WebLinkParser.parse(webLinksRaw);\n                for (WebLink link : webLinksParsed) {\n                    if (nextIdentifier.equals(link.getParameters().get(relHeader))) {\n                        nextRead = new ReadFilter();\n                        nextRead.setLinkUri(new URI(link.getUri()));\n                    } else if (prevIdentifier.equals(link.getParameters().get(relHeader))) {\n                        previousRead = new ReadFilter();\n                        previousRead.setLinkUri(new URI(link.getUri()));\n                    }\n\n                }\n            } catch (URISyntaxException ex) {\n                Log.e(TAG, webLinksRaw + \" did not contain a valid context URI\", ex);\n                throw new RuntimeException(ex);\n            } catch (ParseException ex) {\n                Log.e(TAG, webLinksRaw + \" could not be parsed as a web link header\", ex);\n                throw new RuntimeException(ex);\n            }\n        } else if (pageConfig.getMetadataLocation().equals(PageConfig.MetadataLocations.HEADERS)) {\n            nextRead = pageConfig.getPageParameterExtractor().getNextFilter(httpResponse, RestAdapter.this.pageConfig);\n            previousRead = pageConfig.getPageParameterExtractor().getPreviousFilter(httpResponse, RestAdapter.this.pageConfig);\n        } else if (pageConfig.getMetadataLocation().equals(PageConfig.MetadataLocations.BODY)) {\n            nextRead = pageConfig.getPageParameterExtractor().getNextFilter(httpResponse, RestAdapter.this.pageConfig);\n            previousRead = pageConfig.getPageParameterExtractor().getPreviousFilter(httpResponse, RestAdapter.this.pageConfig);\n        } else {\n            throw new IllegalStateException(\"Not supported\");\n        }\n        if (nextRead != null) {\n            nextRead.setWhere(where);\n        }\n\n        if (previousRead != null) {\n            previousRead.setWhere(where);\n        }\n\n        return new WrappingPagedList<T>(requestingPipe, result, nextRead, previousRead);\n    }", "label": 0}
{"code": "public static base_response Import(nitro_service client, application resource) throws Exception {\n\t\tapplication Importresource = new application();\n\t\tImportresource.apptemplatefilename = resource.apptemplatefilename;\n\t\tImportresource.appname = resource.appname;\n\t\tImportresource.deploymentfilename = resource.deploymentfilename;\n\t\treturn Importresource.perform_operation(client,\"Import\");\n\t}", "label": 0}
{"code": "public static base_response update(nitro_service client, cachecontentgroup resource) throws Exception {\n\t\tcachecontentgroup updateresource = new cachecontentgroup();\n\t\tupdateresource.name = resource.name;\n\t\tupdateresource.weakposrelexpiry = resource.weakposrelexpiry;\n\t\tupdateresource.heurexpiryparam = resource.heurexpiryparam;\n\t\tupdateresource.relexpiry = resource.relexpiry;\n\t\tupdateresource.relexpirymillisec = resource.relexpirymillisec;\n\t\tupdateresource.absexpiry = resource.absexpiry;\n\t\tupdateresource.absexpirygmt = resource.absexpirygmt;\n\t\tupdateresource.weaknegrelexpiry = resource.weaknegrelexpiry;\n\t\tupdateresource.hitparams = resource.hitparams;\n\t\tupdateresource.invalparams = resource.invalparams;\n\t\tupdateresource.ignoreparamvaluecase = resource.ignoreparamvaluecase;\n\t\tupdateresource.matchcookies = resource.matchcookies;\n\t\tupdateresource.invalrestrictedtohost = resource.invalrestrictedtohost;\n\t\tupdateresource.polleverytime = resource.polleverytime;\n\t\tupdateresource.ignorereloadreq = resource.ignorereloadreq;\n\t\tupdateresource.removecookies = resource.removecookies;\n\t\tupdateresource.prefetch = resource.prefetch;\n\t\tupdateresource.prefetchperiod = resource.prefetchperiod;\n\t\tupdateresource.prefetchperiodmillisec = resource.prefetchperiodmillisec;\n\t\tupdateresource.prefetchmaxpending = resource.prefetchmaxpending;\n\t\tupdateresource.flashcache = resource.flashcache;\n\t\tupdateresource.expireatlastbyte = resource.expireatlastbyte;\n\t\tupdateresource.insertvia = resource.insertvia;\n\t\tupdateresource.insertage = resource.insertage;\n\t\tupdateresource.insertetag = resource.insertetag;\n\t\tupdateresource.cachecontrol = resource.cachecontrol;\n\t\tupdateresource.quickabortsize = resource.quickabortsize;\n\t\tupdateresource.minressize = resource.minressize;\n\t\tupdateresource.maxressize = resource.maxressize;\n\t\tupdateresource.memlimit = resource.memlimit;\n\t\tupdateresource.ignorereqcachinghdrs = resource.ignorereqcachinghdrs;\n\t\tupdateresource.minhits = resource.minhits;\n\t\tupdateresource.alwaysevalpolicies = resource.alwaysevalpolicies;\n\t\tupdateresource.persist = resource.persist;\n\t\tupdateresource.pinned = resource.pinned;\n\t\tupdateresource.lazydnsresolve = resource.lazydnsresolve;\n\t\tupdateresource.hitselector = resource.hitselector;\n\t\tupdateresource.invalselector = resource.invalselector;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "func (d *driver) getCapabilities() (*driverapi.Capability, error) {\n\tvar capResp api.GetCapabilityResponse\n\tif err := d.call(\"GetCapabilities\", nil, &capResp); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := &driverapi.Capability{}\n\tswitch capResp.Scope {\n\tcase \"global\":\n\t\tc.DataScope = datastore.GlobalScope\n\tcase \"local\":\n\t\tc.DataScope = datastore.LocalScope\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"invalid capability: expecting 'local' or 'global', got %s\", capResp.Scope)\n\t}\n\n\tswitch capResp.ConnectivityScope {\n\tcase \"global\":\n\t\tc.ConnectivityScope = datastore.GlobalScope\n\tcase \"local\":\n\t\tc.ConnectivityScope = datastore.LocalScope\n\tcase \"\":\n\t\tc.ConnectivityScope = c.DataScope\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"invalid capability: expecting 'local' or 'global', got %s\", capResp.Scope)\n\t}\n\n\treturn c, nil\n}", "label": 5}
{"code": "def validate_params_match(method, parameters):\n    \"\"\"Validates that the given parameters are exactly the method's declared parameters.\n\n    :param method: The method to be called\n    :type method: function\n    :param parameters: The parameters to use in the call\n    :type parameters: dict[str, object] | list[object]\n    \"\"\"\n    argspec = inspect.getargspec(method)  # pylint: disable=deprecated-method\n    default_length = len(argspec.defaults) if argspec.defaults is not None else 0\n\n    if isinstance(parameters, list):\n        if len(parameters) > len(argspec.args) and argspec.varargs is None:\n            raise InvalidParamsError(\"Too many parameters\")\n\n        remaining_parameters = len(argspec.args) - len(parameters)\n        if remaining_parameters > default_length:\n            raise InvalidParamsError(\"Not enough parameters\")\n\n    elif isinstance(parameters, dict):\n        missing_parameters = [key for key in argspec.args if key not in parameters]\n        default_parameters = set(argspec.args[len(argspec.args) - default_length:])\n        for key in missing_parameters:\n            if key not in default_parameters:\n                raise InvalidParamsError(\"Parameter {} has not been satisfied\".format(key))\n\n        extra_params = [key for key in parameters if key not in argspec.args]\n        if len(extra_params) > 0 and argspec.keywords is None:\n            raise InvalidParamsError(\"Too many parameters\")", "label": 1}
{"code": "func (t *Torrent) readAt(b []byte, off int64) (n int, err error) {\n\tp := &t.pieces[off/t.info.PieceLength]\n\tp.waitNoPendingWrites()\n\treturn p.Storage().ReadAt(b, off-p.Info().Offset())\n}", "label": 5}
{"code": "func (s *RotationSchedule) CheckAndSetDefaults(clock clockwork.Clock) error {\n\tif s.UpdateServers.IsZero() {\n\t\treturn trace.BadParameter(\"phase %q has no time switch scheduled\", RotationPhaseUpdateServers)\n\t}\n\tif s.Standby.IsZero() {\n\t\treturn trace.BadParameter(\"phase %q has no time switch scheduled\", RotationPhaseStandby)\n\t}\n\tif s.Standby.Before(s.UpdateServers) {\n\t\treturn trace.BadParameter(\"phase %q can not be scheduled before %q\", RotationPhaseStandby, RotationPhaseUpdateServers)\n\t}\n\tif s.UpdateServers.Before(clock.Now()) {\n\t\treturn trace.BadParameter(\"phase %q can not be scheduled in the past\", RotationPhaseUpdateServers)\n\t}\n\tif s.Standby.Before(clock.Now()) {\n\t\treturn trace.BadParameter(\"phase %q can not be scheduled in the past\", RotationPhaseStandby)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def clean_lines(commands):\n    \"\"\" Generate strings that are not comments or lines with only whitespace.\n\n    Purpose: This function is a generator that will read in either a\n           | plain text file of strings(IP list, command list, etc), a\n           | comma separated string of strings, or a list of strings. It\n           | will crop out any comments or blank lines, and yield\n           | individual strings.\n           |\n           | Only strings that do not start with a comment '#', or are not\n           | entirely whitespace will be yielded. This allows a file with\n           | comments and blank lines for formatting neatness to be used\n           | without a problem.\n\n    @param commands: This can be either a string that is a file\n                   | location, a comma separated string of strings\n                   | ('x,y,z,1,2,3'), or a python list of strings.\n    @type commands: str or list\n\n    @returns: Yields each command in order\n    @rtype: iterable of str\n    \"\"\"\n    if isinstance(commands, basestring):\n        # if the command argument is a filename, we need to open it.\n        if path.isfile(commands):\n            commands = open(commands, 'rb')\n        # if the command string is a comma separated list, break it up.\n        elif len(commands.split(',')) > 1:\n            commands = commands.split(',')\n        else:  # if a single command, need to just be returned.\n            try:\n                if commands.strip()[0] != \"#\":\n                    yield commands.strip() + '\\n'\n                    return\n            except IndexError:\n                pass\n    elif isinstance(commands, list):\n        pass\n    else:\n        raise TypeError('clean_lines() accepts a \\'str\\' or \\'list\\'')\n    for cmd in commands:\n        # exclude commented lines, and skip blank lines (index error)\n        try:\n            if cmd.strip()[0] != \"#\":\n                yield cmd.strip() + '\\n'\n        except IndexError:\n            pass", "label": 1}
{"code": "def sync(filename, connection=None):\n    \"\"\"Syncs a file\n\n    :param filename: File to check out\n    :type filename: str\n    :param connection: Connection object to use\n    :type connection: :py:class:`Connection`\n    \"\"\"\n    c = connection or connect()\n    rev = c.ls(filename)\n    if rev:\n        rev[0].sync()", "label": 1}
{"code": "def run_fusion_caller(job, star_bam, univ_options, fusion_options):\n    \"\"\"\n    This module will run a fusion caller on DNA bams.  This module will be\n    implemented in the future.\n\n    This module corresponds to node 10 on the tree\n    \"\"\"\n    job.fileStore.logToMaster('Running FUSION on %s' % univ_options['patient'])\n    fusion_file = job.fileStore.getLocalTempFile()\n    output_file = job.fileStore.writeGlobalFile(fusion_file)\n    return output_file", "label": 1}
{"code": "func (m *Memory) CompareAndSwap(ctx context.Context, expected backend.Item, replaceWith backend.Item) (*backend.Lease, error) {\n\tif len(expected.Key) == 0 {\n\t\treturn nil, trace.BadParameter(\"missing parameter Key\")\n\t}\n\tif len(replaceWith.Key) == 0 {\n\t\treturn nil, trace.BadParameter(\"missing parameter Key\")\n\t}\n\tif bytes.Compare(expected.Key, replaceWith.Key) != 0 {\n\t\treturn nil, trace.BadParameter(\"expected and replaceWith keys should match\")\n\t}\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.removeExpired()\n\ti := m.tree.Get(&btreeItem{Item: expected})\n\tif i == nil {\n\t\treturn nil, trace.CompareFailed(\"key %q is not found\", string(expected.Key))\n\t}\n\texistingItem := i.(*btreeItem).Item\n\tif bytes.Compare(existingItem.Value, expected.Value) != 0 {\n\t\treturn nil, trace.CompareFailed(\"current value does not match expected for %v\", string(expected.Key))\n\t}\n\tevent := backend.Event{\n\t\tType: backend.OpPut,\n\t\tItem: replaceWith,\n\t}\n\tm.processEvent(event)\n\tif !m.EventsOff {\n\t\tm.buf.Push(event)\n\t}\n\treturn m.newLease(replaceWith), nil\n}", "label": 5}
{"code": "private function checkReadContext()\n    {\n        if ($this->type === self::TYPE_SINGLE_USE && $this->context === SessionPoolInterface::CONTEXT_READWRITE) {\n            throw new \\BadMethodCallException('Cannot use a single-use read-write transaction for read or execute.');\n        }\n    }", "label": 2}
{"code": "function(options){\n            var cleanOptions = this.parseOptions(options),\n                excludes = _.clone(this.privateFields),\n                includeExludes = [];\n\n            // If any includes are passed in through the options clean up the\n            // default excluded fields. A type can have some excluded fields by\n            // default and if the user overrides this then we need to clean up the query.\n            if(options && options.include){\n                _.each(options.include, function(include){\n                    //If the include matches an existing exclude then remove it from the\n                    //excludes and also from the includes (you can't mix them)\n                    excludes = _.remove(excludes, function(o){\n                        if(o === include){\n                            cleanOptions.include = _.remove(cleanOptions.include, function(i){\n                                return i !== include;\n                            });\n                        }\n\n                        return o !== include;\n                    });\n\n                });\n            }\n\n            includeExludes = _.union(cleanOptions.include,\n                this.parseExclusion(cleanOptions.exclude),\n                this.parseExclusion(excludes)\n            );\n\n            return includeExludes.join(' ');\n        }", "label": 3}
{"code": "public function setStateChange($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\SecurityCenter\\V1\\ListAssetsResponse_ListAssetsResult_StateChange::class);\n        $this->state_change = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def from_file(cls, fname, form=None):\n        \"\"\"\n        Read an orthography profile from a metadata file or a default tab-separated profile file.\n        \"\"\"\n        try:\n            tg = TableGroup.from_file(fname)\n            opfname = None\n        except JSONDecodeError:\n            tg = TableGroup.fromvalue(cls.MD)\n            opfname = fname\n        if len(tg.tables) != 1:\n            raise ValueError('profile description must contain exactly one table')\n        metadata = tg.common_props\n        metadata.update(fname=Path(fname), form=form)\n        return cls(\n            *[{k: None if (k != cls.GRAPHEME_COL and v == cls.NULL) else v for k, v in d.items()}\n              for d in tg.tables[0].iterdicts(fname=opfname)],\n            **metadata)", "label": 1}
{"code": "def play_dca(file)\n      stop_playing(true) if @playing\n\n      @bot.debug \"Reading DCA file #{file}\"\n      input_stream = File.open(file)\n\n      magic = input_stream.read(4)\n      raise ArgumentError, 'Not a DCA1 file! The file might have been corrupted, please recreate it.' unless magic == 'DCA1'\n\n      # Read the metadata header, then read the metadata and discard it as we don't care about it\n      metadata_header = input_stream.read(4).unpack1('l<')\n      input_stream.read(metadata_header)\n\n      # Play the data, without re-encoding it to opus\n      play_internal do\n        begin\n          # Read header\n          header_str = input_stream.read(2)\n\n          unless header_str\n            @bot.debug 'Finished DCA parsing (header is nil)'\n            next :stop\n          end\n\n          header = header_str.unpack1('s<')\n\n          raise 'Negative header in DCA file! Your file is likely corrupted.' if header.negative?\n        rescue EOFError\n          @bot.debug 'Finished DCA parsing (EOFError)'\n          next :stop\n        end\n\n        # Read bytes\n        input_stream.read(header)\n      end\n    end", "label": 4}
{"code": "public static int cudnnGetActivationDescriptor(\n        cudnnActivationDescriptor activationDesc, \n        int[] mode, \n        int[] reluNanOpt, \n        double[] coef)/** ceiling for clipped RELU, alpha for ELU */\n    {\n        return checkResult(cudnnGetActivationDescriptorNative(activationDesc, mode, reluNanOpt, coef));\n    }", "label": 0}
{"code": "def run_phlat(job, fastqs, sample_type, univ_options, phlat_options):\n    \"\"\"\n    This module will run PHLAT on SAMPLE_TYPE fastqs.\n\n    ARGUMENTS -- <ST> depicts the sample type. Substitute with 'tumor_dna',\n                 'normal_dna', or 'tumor_rna'\n    1. fastqs: Dict of list of input WGS/WXS fastqs\n         fastqs\n              +- '<ST>': [<JSid for 1.fastq> , <JSid for 2.fastq>]\n    2. sample_type: string of 'tumor' or 'normal'\n    3. univ_options: Dict of universal arguments used by almost all tools\n         univ_options\n                +- 'dockerhub': <dockerhub to use>\n    4. phlat_options: Dict of parameters specific to phlat\n         phlat_options\n              |- 'index_tar': <JSid for the PHLAT index tarball>\n              +- 'n': <number of threads to allocate>\n\n    RETURN VALUES\n    1. output_file: <JSid for the allele predictions for ST>\n\n    This module corresponds to nodes 5, 6 and 7 on the tree\n    \"\"\"\n    job.fileStore.logToMaster('Running phlat on %s:%s' % (univ_options['patient'], sample_type))\n    work_dir = job.fileStore.getLocalTempDir()\n    fq_extn = '.gz' if fastqs['gzipped'] else ''\n    input_files = {\n        'input_1.fastq' + fq_extn: fastqs[sample_type][0],\n        'input_2.fastq' + fq_extn: fastqs[sample_type][1],\n        'phlat_index.tar.gz': phlat_options['index_tar']}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=True)\n    parameters = ['-1', input_files['input_1.fastq'],\n                  '-2', input_files['input_2.fastq'],\n                  '-index', input_files['phlat_index'],\n                  '-b2url', '/usr/local/bin/bowtie2',\n                  '-tag', sample_type,\n                  '-e', '/home/phlat-1.0',  # Phlat directory home\n                  '-o', '/data',  # Output directory\n                  '-p', str(phlat_options['n'])]  # Number of threads\n    docker_call(tool='phlat', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'])\n    output_file = job.fileStore.writeGlobalFile(''.join([work_dir, '/', sample_type, '_HLA.sum']))\n    return output_file", "label": 1}
{"code": "def compute_offset_to_first_complete_codon(\n        offset_to_first_complete_reference_codon,\n        n_trimmed_from_reference_sequence):\n    \"\"\"\n    Once we've aligned the variant sequence to the ReferenceContext, we need\n    to transfer reading frame from the reference transcripts to the variant\n    sequences.\n\n    Parameters\n    ----------\n    offset_to_first_complete_reference_codon : int\n\n    n_trimmed_from_reference_sequence : int\n\n    Returns an offset into the variant sequence that starts from a complete\n    codon.\n    \"\"\"\n    if n_trimmed_from_reference_sequence <= offset_to_first_complete_reference_codon:\n        return (\n            offset_to_first_complete_reference_codon -\n            n_trimmed_from_reference_sequence)\n    else:\n        n_nucleotides_trimmed_after_first_codon = (\n            n_trimmed_from_reference_sequence -\n            offset_to_first_complete_reference_codon)\n        frame = n_nucleotides_trimmed_after_first_codon % 3\n        return (3 - frame) % 3", "label": 1}
{"code": "public IndexDef getIndex(String name)\r\n    {\r\n        String   realName = (name == null ? \"\" : name);\r\n        IndexDef def      = null;\r\n\r\n        for (Iterator it = getIndices(); it.hasNext();)\r\n        {\r\n            def = (IndexDef)it.next();\r\n            if (def.getName().equals(realName))\r\n            {\r\n                return def;\r\n            }\r\n        }\r\n        return null;\r\n    }", "label": 0}
{"code": "func aciInfoToV1AlphaAPIImage(store *imagestore.Store, aciInfo *imagestore.ACIInfo) (*v1alpha.Image, error) {\n\tmanifest, err := store.GetImageManifestJSON(aciInfo.BlobKey)\n\tif err != nil {\n\t\tstderr.PrintE(\"failed to read the image manifest\", err)\n\t\treturn nil, err\n\t}\n\n\tvar im schema.ImageManifest\n\tif err = json.Unmarshal(manifest, &im); err != nil {\n\t\tstderr.PrintE(\"failed to unmarshal image manifest\", err)\n\t\treturn nil, err\n\t}\n\n\tversion, ok := im.Labels.Get(\"version\")\n\tif !ok {\n\t\tversion = \"latest\"\n\t}\n\n\treturn &v1alpha.Image{\n\t\tBaseFormat: &v1alpha.ImageFormat{\n\t\t\t// Only support appc image now. If it's a docker image, then it\n\t\t\t// will be transformed to appc before storing in the disk store.\n\t\t\tType:    v1alpha.ImageType_IMAGE_TYPE_APPC,\n\t\t\tVersion: schema.AppContainerVersion.String(),\n\t\t},\n\t\tId:              aciInfo.BlobKey,\n\t\tName:            im.Name.String(),\n\t\tVersion:         version,\n\t\tImportTimestamp: aciInfo.ImportTime.Unix(),\n\t\tManifest:        manifest,\n\t\tSize:            aciInfo.Size + aciInfo.TreeStoreSize,\n\t\tAnnotations:     convertAnnotationsToKeyValue(im.Annotations),\n\t\tLabels:          convertLabelsToKeyValue(im.Labels),\n\t}, nil\n}", "label": 5}
{"code": "def compiler_swift_version(user_version)\n      return LATEST_SWIFT_VERSION unless user_version\n\n      LONG_SWIFT_VERSIONS.select do |version|\n        user_version.start_with?(version)\n      end.last || \"#{user_version[0]}.0\"\n    end", "label": 4}
{"code": "public void remove(IConverter converter, Object sourceObject,\n\t\t\tTypeReference<?> destinationType) {\n\t\tconvertedObjects.remove(new ConvertedObjectsKey(converter,\n\t\t\t\tsourceObject, destinationType));\n\t}", "label": 0}
{"code": "func (process *TeleportProcess) printShutdownStatus(ctx context.Context) {\n\tt := time.NewTicker(defaults.HighResReportingPeriod)\n\tdefer t.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase <-t.C:\n\t\t\tlog.Infof(\"Waiting for services: %v to finish.\", process.Supervisor.Services())\n\t\t}\n\t}\n}", "label": 5}
{"code": "function decompressSamples (o, receivedDeltas) {\n  // add the delta to the previous value\n  for (let i = 1; i < 3; i++) {\n    for (let j = 0; j < 4; j++) {\n      o.decompressedSamples[i][j] = o.decompressedSamples[i - 1][j] - receivedDeltas[i - 1][j];\n    }\n  }\n}", "label": 3}
{"code": "def polygon(*points)\n      if points.length.zero?\n        Kernel.raise ArgumentError, 'no points specified'\n      elsif points.length.odd?\n        Kernel.raise ArgumentError, 'odd number of points specified'\n      end\n      primitive 'polygon ' + points.join(',')\n    end", "label": 4}
{"code": "def replace_row(self, line, ndx):\n        \"\"\" \n        replace a grids row at index 'ndx' with 'line' \n        \"\"\"\n        for col in range(len(line)):\n            self.set_tile(ndx, col, line[col])", "label": 1}
{"code": "def remove(*objects, &block)\n      if block\n        types = objects\n        conjunction = Query::Connective::Conjunction.new\n        if types.length == 1\n          conjunction.add_positive_restriction(TypeField.instance, Query::Restriction::EqualTo, types.first)\n        else\n          conjunction.add_positive_restriction(TypeField.instance, Query::Restriction::AnyOf, types)\n        end\n        dsl = DSL::Scope.new(conjunction, setup_for_types(types))\n        Util.instance_eval_or_call(dsl, &block)\n        indexer.remove_by_scope(conjunction)\n      else\n        objects.flatten!\n        @deletes += objects.length\n        objects.each do |object|\n          indexer.remove(object)\n        end\n      end\n    end", "label": 4}
{"code": "function( wrapper, item, klass, attribute ) {\n\n        // If the item is false-y, just return an empty string\n        if ( !item ) return ''\n\n        // If the item is an array, do a join\n        item = $.isArray( item ) ? item.join( '' ) : item\n\n        // Check for the class\n        klass = klass ? ' class=\"' + klass + '\"' : ''\n\n        // Check for any attributes\n        attribute = attribute ? ' ' + attribute : ''\n\n        // Return the wrapped item\n        return '<' + wrapper + klass + attribute + '>' + item + '</' + wrapper + '>'\n    }", "label": 3}
{"code": "func (t *Torrent) maybeCompleteMetadata() error {\n\tif t.haveInfo() {\n\t\t// Nothing to do.\n\t\treturn nil\n\t}\n\tif !t.haveAllMetadataPieces() {\n\t\t// Don't have enough metadata pieces.\n\t\treturn nil\n\t}\n\terr := t.setInfoBytes(t.metadataBytes)\n\tif err != nil {\n\t\tt.invalidateMetadata()\n\t\treturn fmt.Errorf(\"error setting info bytes: %s\", err)\n\t}\n\tif t.cl.config.Debug {\n\t\tt.logger.Printf(\"%s: got metadata from peers\", t)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "func _pidAlive(pid int) bool {\n\th, err := syscall.OpenProcess(processDesiredAccess, false, uint32(pid))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tvar ec uint32\n\tif e := syscall.GetExitCodeProcess(h, &ec); e != nil {\n\t\treturn false\n\t}\n\n\treturn ec == exit_STILL_ACTIVE\n}", "label": 5}
{"code": "def move(path, options = {}, &block)\n      perform_request Net::HTTP::Move, path, options, &block\n    end", "label": 4}
{"code": "function checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}", "label": 3}
{"code": "func GenerateIfaceName(nlh *netlink.Handle, prefix string, len int) (string, error) {\n\tlinkByName := netlink.LinkByName\n\tif nlh != nil {\n\t\tlinkByName = nlh.LinkByName\n\t}\n\tfor i := 0; i < 3; i++ {\n\t\tname, err := GenerateRandomName(prefix, len)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t_, err = linkByName(name)\n\t\tif err != nil {\n\t\t\tif strings.Contains(err.Error(), \"not found\") {\n\t\t\t\treturn name, nil\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn \"\", types.InternalErrorf(\"could not generate interface name\")\n}", "label": 5}
{"code": "def read_loop(set_input_stream_done, is_client: true)\n      return enum_for(:read_loop,\n                      set_input_stream_done,\n                      is_client: is_client) unless block_given?\n      GRPC.logger.debug('bidi-read-loop: starting')\n      begin\n        count = 0\n        # queue the initial read before beginning the loop\n        loop do\n          GRPC.logger.debug(\"bidi-read-loop: #{count}\")\n          count += 1\n          batch_result = read_using_run_batch\n\n          # handle the next message\n          if batch_result.nil? || batch_result.message.nil?\n            GRPC.logger.debug(\"bidi-read-loop: null batch #{batch_result}\")\n\n            if is_client\n              batch_result = @call.run_batch(RECV_STATUS_ON_CLIENT => nil)\n              @call.status = batch_result.status\n              @call.trailing_metadata = @call.status.metadata if @call.status\n              GRPC.logger.debug(\"bidi-read-loop: done status #{@call.status}\")\n              batch_result.check_status\n            end\n\n            GRPC.logger.debug('bidi-read-loop: done reading!')\n            break\n          end\n\n          res = @unmarshal.call(batch_result.message)\n          yield res\n        end\n      rescue StandardError => e\n        GRPC.logger.warn('bidi: read-loop failed')\n        GRPC.logger.warn(e)\n        raise e\n      ensure\n        set_input_stream_done.call\n      end\n      GRPC.logger.debug('bidi-read-loop: finished')\n      # Make sure that the write loop is done before finishing the call.\n      # Note that blocking is ok at this point because we've already received\n      # a status\n      @enq_th.join if is_client\n    end", "label": 4}
{"code": "def spasser(inbox, s=None):\n    \"\"\"\n    Passes inputs with indecies in s. By default passes the whole inbox.\n\n    Arguments:\n\n      - s(sequence) [default: ``None``] The default translates to a range for\n        all inputs of the \"inbox\" i.e. ``range(len(inbox))``\n    \n    \"\"\"\n    seq = (s or range(len(inbox)))\n    return [input_ for i, input_ in enumerate(inbox) if i in seq]", "label": 1}
{"code": "def shutdown!\n      shutdown\n      if term_child\n        if fork_per_job?\n          new_kill_child\n        else\n          # Raise TermException in the same process\n          trap('TERM') do\n            # ignore subsequent terms\n          end\n          raise TermException.new(\"SIGTERM\")\n        end\n      else\n        kill_child\n      end\n    end", "label": 4}
{"code": "def construct_fragments_attributes(hash, record, path)\n      frag_identifiers = []\n      frag_attributes = hash.collect do |frag_header, frag_content|\n        tag, identifier = frag_header.split\n        frag_hash = {\n          identifier: identifier,\n          tag:        tag\n        }\n\n        # tracking fragments that need removing later\n        frag_identifiers << identifier\n\n        # based on tag we need to cram content in proper place and proper format\n        case tag\n        when \"date\", \"datetime\"\n          frag_hash[:datetime] = frag_content\n        when \"checkbox\"\n          frag_hash[:boolean] = frag_content\n        when \"file\", \"files\"\n          files, file_ids_destroy = files_content(record, identifier, path, frag_content)\n          frag_hash[:files]            = files\n          frag_hash[:file_ids_destroy] = file_ids_destroy\n        else\n          frag_hash[:content] = frag_content\n        end\n\n        frag_hash\n      end\n\n      [frag_identifiers, frag_attributes]\n    end", "label": 4}
{"code": "def replace(placeholder, actual)\n      raise 'wrong placeholder' if placeholder != @target\n      @target.heads.delete(ptrs[0]) if @target\n      @target = actual\n      @target.heads << @ptrs[0]\n      @symbols.map! { |s| s == placeholder ? actual : s }\n    end", "label": 4}
{"code": "public function setJobTrigger($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\JobTrigger::class);\n        $this->job_trigger = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func importsOfFile(file *ast.File) (normalImports map[string]string, dotImports []string) {\n\tnormalImports = make(map[string]string)\n\tdotImports = make([]string, 0)\n\tfor _, is := range file.Imports {\n\t\tvar pkgName string\n\t\timportPath := is.Path.Value[1 : len(is.Path.Value)-1] // remove quotes\n\n\t\tif is.Name != nil {\n\t\t\t// Named imports are always certain.\n\t\t\tif is.Name.Name == \"_\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpkgName = is.Name.Name\n\t\t} else {\n\t\t\tpkg, err := build.Import(importPath, \"\", 0)\n\t\t\tif err != nil {\n\t\t\t\t// Fallback to import path suffix. Note that this is uncertain.\n\t\t\t\t_, last := path.Split(importPath)\n\t\t\t\t// If the last path component has dots, the first dot-delimited\n\t\t\t\t// field is used as the name.\n\t\t\t\tpkgName = strings.SplitN(last, \".\", 2)[0]\n\t\t\t} else {\n\t\t\t\tpkgName = pkg.Name\n\t\t\t}\n\t\t}\n\n\t\tif pkgName == \".\" {\n\t\t\tdotImports = append(dotImports, importPath)\n\t\t} else {\n\n\t\t\tif _, ok := normalImports[pkgName]; ok {\n\t\t\t\tlog.Fatalf(\"imported package collision: %q imported twice\", pkgName)\n\t\t\t}\n\t\t\tnormalImports[pkgName] = importPath\n\t\t}\n\t}\n\treturn\n}", "label": 5}
{"code": "def _error_parse(self, interface, face):\n        \"\"\" Parse the extensive xml output of an interface and yield errors.\n\n        Purpose: Takes the xml output of 'show interfaces extensive' for a\n               | given interface and yields the error types that have a\n               | significant number of errors.\n\n        @param interface: The xml output of the 'sh int ext' command for\n                        | the desired interface.\n        @type interface: lxml.etree._Element object\n        @param face: The direction of the errors we're wanting. Either 'input'\n                   | or 'output' is accepted.\n        @type face: str\n\n        @returns: Yields each error that has a significant number\n        @rtype: iterable of strings.\n        \"\"\"\n        try:\n            error_list = interface.xpath(face + '-error-list')[0].getchildren()\n        except IndexError:  # no error list on this interface\n            pass\n        else:\n            for x in range(len(error_list)):\n                if error_list[x].tag == \"carrier-transitions\":\n                    if int(error_list[x].text.strip()) > 50:\n                        yield \" has greater than 50 flaps.\"\n                elif int(error_list[x].text.strip()) > 0:\n                    yield \" has %s of %s.\" % (error_list[x].text.strip(),\n                                              error_list[x].tag.strip())", "label": 1}
{"code": "func (w *Wrapper) DeleteTunnelConnection(clusterName, connName string) error {\n\treturn w.Write.DeleteTunnelConnection(clusterName, connName)\n}", "label": 5}
{"code": "def replace_grid(self, updated_grid):\n        \"\"\"\n        replace all cells in current grid with updated grid\n        \"\"\"\n        for col in range(self.get_grid_width()):\n            for row in range(self.get_grid_height()):\n                if updated_grid[row][col] == EMPTY:\n                    self.set_empty(row, col)\n                else:\n                    self.set_full(row, col)", "label": 1}
{"code": "func (fs *FSLocalKeyStore) GetCertsPEM(proxy string) ([]byte, error) {\n\tdir, err := fs.dirFor(proxy, false)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn ioutil.ReadFile(filepath.Join(dir, fileNameTLSCerts))\n}", "label": 5}
{"code": "def validate_version_range(version_range)\n      SemanticPuppet::VersionRange.parse(version_range)\n    rescue ArgumentError => e\n      raise ArgumentError, _(\"Invalid 'version_range' field in metadata.json: %{err}\") % { err: e }\n    end", "label": 4}
{"code": "def partial_split number\n        cc = ''\n        1.upto(3) do |i|\n          cc << number.slice!(0..0)\n          country = countries[i][cc]\n          return [country, cc, number] if country\n        end\n        # This line is never reached as CCs are in prefix code.\n      end", "label": 4}
{"code": "function (req, res, next) {\n        var ip = IPAddressHelper.getClientIP(req)\n            , route = req.miajs.route\n            , key = ip + route.path + route.method;\n\n        if (_.isEmpty(route.rateLimits)) {\n            next();\n            return;\n        }\n\n        RateLimiter.checkRateLimitsByKey(key, route.rateLimits).then(function (rateLimiterResult) {\n            if (rateLimiterResult.remaining == -1) {\n                _logInfo(\"Rate limit of \" + rateLimiterResult.limit + \"req/\" + rateLimiterResult.timeInterval + \"min requests exceeded \" + route.requestmethod.toUpperCase() + \" \" + route.url + \" for \" + ip);\n                res.header(\"X-Rate-Limit-Limit\", rateLimiterResult.limit);\n                res.header(\"X-Rate-Limit-Remaining\", 0);\n                res.header(\"X-Rate-Limit-Reset\", rateLimiterResult.timeTillReset);\n                next(new MiaError({\n                    status: 429,\n                    err: {\n                        'code': 'RateLimitExceeded',\n                        'msg': Translator('system', 'RateLimitExceeded')\n                    }\n                }));\n            }\n            else {\n                res.header(\"X-Rate-Limit-Limit\", rateLimiterResult.limit);\n                res.header(\"X-Rate-Limit-Remaining\", rateLimiterResult.remaining);\n                res.header(\"X-Rate-Limit-Reset\", rateLimiterResult.timeTillReset);\n                next();\n            }\n        }).catch(function () {\n            next();\n        });\n    }", "label": 3}
{"code": "public function recordGateCheck(?Authenticatable $user, $ability, $result, $arguments)\n    {\n        if (! Telescope::isRecording() || $this->shouldIgnore($ability)) {\n            return;\n        }\n\n        $caller = $this->getCallerFromStackTrace();\n\n        Telescope::recordGate(IncomingEntry::make([\n            'ability' => $ability,\n            'result' => $result ? 'allowed' : 'denied',\n            'arguments' => $this->formatArguments($arguments),\n            'file' => $caller['file'],\n            'line' => $caller['line'],\n        ]));\n\n        return $result;\n    }", "label": 2}
{"code": "function addToCache(filename, obj) {\n\tif(cacheOn)\n\t{\n\t\tvar x = cache[filename];\n\t\tif(!x)\n\t\t\tx = cache[filename] = {};\n\t\tx.mtime = obj.mtime || x.mtime;\n\t\tx.etag = obj.etag || x.etag;\n\t\tx.size = obj.size || x.size;\n\t}\n}", "label": 3}
{"code": "def dist_iter(self, g_nums, ats_1, ats_2, invalid_error=False):\n        \"\"\" Iterator over selected interatomic distances.\n\n        Distances are in Bohrs as with :meth:`dist_single`.\n\n        See `above <toc-generators_>`_ for more information on\n        calling options.\n\n        Parameters\n        ----------\n        g_nums\n            |int| or length-R iterable |int| or |None| --\n            Index/indices of the desired geometry/geometries\n\n        ats_1\n            |int| or iterable |int| or |None| --\n            Index/indices of the first atom(s)\n\n        ats_2\n            |int| or iterable |int| or |None| --\n            Index/indices of the second atom(s)\n\n        invalid_error\n            |bool|, optional --\n            If |False| (the default), |None| values are returned for\n            results corresponding to invalid indices. If |True|,\n            exceptions are raised per normal.\n\n        Yields\n        ------\n        dist\n            |npfloat_| --\n            Interatomic distance in Bohrs between each atom pair of\n            `ats_1` and `ats_2` from the corresponding geometries\n            of `g_nums`.\n\n        Raises\n        ------\n        ~exceptions.IndexError\n            If an invalid (out-of-range) `g_num` or `at_#` is provided.\n\n        ~exceptions.ValueError\n            If all iterable objects are not the same length.\n\n        \"\"\"\n\n        # Imports\n        import numpy as np\n        from .utils import pack_tups\n\n        # Print the function inputs if debug mode is on\n        if _DEBUG:  # pragma: no cover\n            print(\"g_nums = {0}\".format(g_nums))\n            print(\"ats_1 = {0}\".format(ats_1))\n            print(\"ats_2 = {0}\".format(ats_2))\n        ## end if\n\n        # Perform the None substitution\n        arglist = self._none_subst(g_nums, ats_1, ats_2)\n\n        # Expand/pack the tuples from the inputs\n        tups = pack_tups(*arglist)\n\n        # Dump the results if debug mode is on\n        if _DEBUG:  # pragma: no cover\n            print(tups)\n        ## end if\n\n        # Construct the generator using the packed tuples. If 'None' expansion\n        #  was used, return None for any invalid indices instead of raising\n        #  an exception.\n        for tup in tups:\n            yield self._iter_return(tup, self.dist_single, invalid_error)", "label": 1}
{"code": "public function setJob($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\Job::class);\n        $this->job = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def stringify_comment_array comments\n      ctxt = ''\n      num = nil\n      started = false\n      last_line = nil\n      comments.each { |l|\n        # Trim the comment and minimum leading whitespace\n        p = l.text.gsub(/^#+/, '')\n        if num.nil? and !p.strip.empty?\n          num = p.index(/[^ ]/)\n          started = true\n        elsif started and !p.strip.empty?\n          cur = p.index(/[^ ]/)\n          num = cur if cur < num\n        end\n        # Include blank lines between comments\n        ctxt += (\"\\n\" * (l.loc.first_line - last_line - 1)) unless last_line.nil? || l.loc.first_line - last_line <= 0\n        ctxt += \"#{p[num..-1]}\\n\" if started\n        last_line = l.loc.last_line if last_line.nil? || l.loc.last_line > last_line\n      }\n      ctxt\n    end", "label": 4}
{"code": "public static vpnglobal_auditnslogpolicy_binding[] get(nitro_service service) throws Exception{\n\t\tvpnglobal_auditnslogpolicy_binding obj = new vpnglobal_auditnslogpolicy_binding();\n\t\tvpnglobal_auditnslogpolicy_binding response[] = (vpnglobal_auditnslogpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def schema_complete():\n        \"\"\"Schema for data in CollectorUpdate.\"\"\"\n        return Schema({\n            'stage': And(str, len),\n            'timestamp': int,\n            'status': And(str, lambda s: s in ['started', 'succeeded', 'failed']),\n            # optional matrix\n            Optional('matrix', default='default'): And(str, len),\n            # optional information\n            Optional('information', default={}): {\n                Optional(Regex(r'([a-z][_a-z]*)')): object\n            }\n        })", "label": 1}
{"code": "public void init(final MultivaluedMap<String, String> queryParameters) {\n        final String scopeCompileParam = queryParameters.getFirst(ServerAPI.SCOPE_COMPILE_PARAM);\n        if(scopeCompileParam != null){\n            this.scopeComp = Boolean.valueOf(scopeCompileParam);\n        }\n        final String scopeProvidedParam = queryParameters.getFirst(ServerAPI.SCOPE_PROVIDED_PARAM);\n        if(scopeProvidedParam != null){\n            this.scopePro = Boolean.valueOf(scopeProvidedParam);\n        }\n        final String scopeRuntimeParam = queryParameters.getFirst(ServerAPI.SCOPE_RUNTIME_PARAM);\n        if(scopeRuntimeParam != null){\n            this.scopeRun = Boolean.valueOf(scopeRuntimeParam);\n        }\n        final String scopeTestParam = queryParameters.getFirst(ServerAPI.SCOPE_TEST_PARAM);\n        if(scopeTestParam != null){\n            this.scopeTest = Boolean.valueOf(scopeTestParam);\n        }\n    }", "label": 0}
{"code": "public static function get($locale = null)\n    {\n        $locale = $locale ?: 'en';\n\n        if (!isset(static::$singletons[$locale])) {\n            static::$singletons[$locale] = new static($locale ?: 'en');\n        }\n\n        return static::$singletons[$locale];\n    }", "label": 2}
{"code": "public static <E> double min(Counter<E> c) {\r\n    double min = Double.POSITIVE_INFINITY;\r\n    for (double v : c.values()) {\r\n      min = Math.min(min, v);\r\n    }\r\n    return min;\r\n  }", "label": 0}
{"code": "private function generateRangeVariableDeclarationSQL($rangeVariableDeclaration, bool $buildNestedJoins) : string\n    {\n        $class    = $this->em->getClassMetadata($rangeVariableDeclaration->abstractSchemaName);\n        $dqlAlias = $rangeVariableDeclaration->aliasIdentificationVariable;\n\n        if ($rangeVariableDeclaration->isRoot) {\n            $this->rootAliases[] = $dqlAlias;\n        }\n\n        $tableName  = $class->table->getQuotedQualifiedName($this->platform);\n        $tableAlias = $this->getSQLTableAlias($class->getTableName(), $dqlAlias);\n\n        $sql = $this->platform->appendLockHint(\n            $tableName . ' ' . $tableAlias,\n            $this->query->getHint(Query::HINT_LOCK_MODE)\n        );\n\n        if ($class->inheritanceType !== InheritanceType::JOINED) {\n            return $sql;\n        }\n\n        $classTableInheritanceJoins = $this->generateClassTableInheritanceJoins($class, $dqlAlias);\n\n        if (! $buildNestedJoins) {\n            return $sql . $classTableInheritanceJoins;\n        }\n\n        return $classTableInheritanceJoins === '' ? $sql : '(' . $sql . $classTableInheritanceJoins . ')';\n    }", "label": 2}
{"code": "def set_attrs(hash, clobber = true, target = nil)\n      target ||= @attrs\n      if clobber\n        target.merge!(hash)\n        hash\n      else\n        hash.each do |k, v|\n          if v.is_a?(Hash)\n            set_attrs(v, clobber, target[k])\n          else\n            target[k] = v\n          end\n        end\n      end\n    end", "label": 4}
{"code": "public function recordQuery(QueryExecuted $event)\n    {\n        if (! Telescope::isRecording()) {\n            return;\n        }\n\n        $time = $event->time;\n\n        $caller = $this->getCallerFromStackTrace();\n\n        Telescope::recordQuery(IncomingEntry::make([\n            'connection' => $event->connectionName,\n            'bindings' => $this->formatBindings($event),\n            'sql' => $event->sql,\n            'time' => number_format($time, 2),\n            'slow' => isset($this->options['slow']) && $time >= $this->options['slow'],\n            'file' => $caller['file'],\n            'line' => $caller['line'],\n        ])->tags($this->tags($event)));\n    }", "label": 2}
{"code": "public int getIntegerBelief(String name){\n        Object belief = introspector.getBeliefBase(this).get(name);\n        int count = 0;\n        if (belief!=null) {\n            count = (Integer) belief;\n        }\n        return (Integer) count;\n    }", "label": 0}
{"code": "function route (message, cb) {\n    assert(message, 'route requries a valid message')\n    assert(cb && (typeof cb === 'function'), 'route requires a valid callback handler')\n\n    if (message.pattern) {\n      return pattern(message, cb)\n    }\n\n    if (message.response) {\n      return response(message, cb)\n    }\n\n    malformed(message, cb)\n  }", "label": 3}
{"code": "def to_arel_sql(value)\n      case value\n      when Arel::Node, Arel::Nodes::SqlLiteral, nil\n        value\n      when ActiveRecord::Relation\n        Arel.sql(value.spawn.to_sql)\n      else\n        Arel.sql(value.respond_to?(:to_sql) ? value.to_sql : value.to_s)\n      end\n    end", "label": 4}
{"code": "@ArgumentsChecked\n\t@Throws(IllegalNullArgumentException.class)\n\tpublic static int checkLong(@Nonnull final Number number) {\n\t\tCheck.notNull(number, \"number\");\n\t\tif (!isInLongRange(number)) {\n\t\t\tthrow new IllegalNumberRangeException(number.toString(), LONG_MIN, LONG_MAX);\n\t\t}\n\n\t\treturn number.intValue();\n\t}", "label": 0}
{"code": "public function setSegmentLabelAnnotations($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\VideoIntelligence\\V1beta2\\LabelAnnotation::class);\n        $this->segment_label_annotations = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def alpha_hist(freqs, scale, fg, bg)\n      histogram = Image.new(HISTOGRAM_COLS, HISTOGRAM_ROWS) do\n        self.background_color = bg\n        self.border_color = fg\n      end\n\n      gc = Draw.new\n      gc.affine(1, 0, 0, -scale, 0, HISTOGRAM_ROWS)\n      gc.fill('white')\n\n      HISTOGRAM_COLS.times do |x|\n        gc.point(x, freqs[x])\n      end\n\n      gc.draw(histogram)\n      histogram['Label'] = 'Alpha'\n\n      histogram\n    end", "label": 4}
{"code": "def stat(package, graph):\n    \"\"\"Print download statistics for a package.\n\n    \\b\n    Example:\n\n        pypi stat requests\n    \"\"\"\n    client = requests.Session()\n    for name_or_url in package:\n        package = get_package(name_or_url, client)\n        if not package:\n            secho(u'Invalid name or URL: \"{name}\"'.format(name=name_or_url),\n                  fg='red', file=sys.stderr)\n            continue\n        try:\n            version_downloads = package.version_downloads\n        except NotFoundError:\n            secho(u'No versions found for \"{0}\". '\n                  u'Skipping. . .'.format(package.name),\n                  fg='red', file=sys.stderr)\n            continue\n        echo(u\"Fetching statistics for '{url}'. . .\".format(\n            url=package.package_url))\n        min_ver, min_downloads = package.min_version\n        max_ver, max_downloads = package.max_version\n        if min_ver is None or max_ver is None:\n            raise click.ClickException('Package has no releases')\n        avg_downloads = package.average_downloads\n        total = package.downloads\n        echo()\n        header = u'Download statistics for {name}'.format(name=package.name)\n        echo_header(header)\n        if graph:\n            echo()\n            echo('Downloads by version')\n            echo(package.chart())\n        echo()\n        echo(\"Min downloads:   {min_downloads:12,} ({min_ver})\".format(\n            **locals()))\n        echo(\"Max downloads:   {max_downloads:12,} ({max_ver})\".format(\n            **locals()))\n        echo(\"Avg downloads:   {avg_downloads:12,}\".format(**locals()))\n        echo(\"Total downloads: {total:12,}\".format(**locals()))\n        echo()\n        echo_download_summary(package)\n        echo()", "label": 1}
{"code": "public void setFieldConversionClassName(String fieldConversionClassName)\r\n    {\r\n        try\r\n        {\r\n            this.fieldConversion = (FieldConversion) ClassHelper.newInstance(fieldConversionClassName);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new MetadataException(\r\n                    \"Could not instantiate FieldConversion class using default constructor\", e);\r\n        }\r\n    }", "label": 0}
{"code": "function _gpfGenenerateErrorFunction (code, name, message) {\n    var result = _gpfErrorFactory(code, name, message);\n    result.CODE = code;\n    result.NAME = name;\n    result.MESSAGE = message;\n    return result;\n}", "label": 3}
{"code": "public synchronized void addListener(CollectionProxyListener listener)\r\n    {\r\n        if (_listeners == null)\r\n        {\r\n            _listeners = new ArrayList();\r\n        }\r\n        // to avoid multi-add of same listener, do check\r\n        if(!_listeners.contains(listener))\r\n        {\r\n            _listeners.add(listener);\r\n        }\r\n    }", "label": 0}
{"code": "def reference_transcripts_for_variant(\n        variant,\n        transcript_id_whitelist=None,\n        only_coding_changes=True):\n    \"\"\"\n    For a given variant, find all the transcripts which overlap the\n    variant and for which it has a predictable effect on the amino acid\n    sequence of the protein.\n    \"\"\"\n    predicted_effects = predicted_effects_for_variant(\n        variant=variant,\n        transcript_id_whitelist=transcript_id_whitelist,\n        only_coding_changes=only_coding_changes)\n    return [effect.transcript for effect in predicted_effects]", "label": 1}
{"code": "def get_bids(self, n_points=6):\n        \"\"\" Returns quantity and price bids created from the cost function.\n        \"\"\"\n        from pyreto.smart_market import Bid\n\n        qtyprc = self._get_qtyprc(n_points)\n        return [Bid(self, qty, prc) for qty, prc in qtyprc]", "label": 1}
{"code": "public static policyexpression[] get(nitro_service service) throws Exception{\n\t\tpolicyexpression obj = new policyexpression();\n\t\tpolicyexpression[] response = (policyexpression[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function respondToAccessTokenRequest(\n        ServerRequestInterface $request,\n        ResponseTypeInterface $responseType,\n        DateInterval $accessTokenTTL\n    ) {\n        // Validate request\n        $client = $this->validateClient($request);\n        $encryptedAuthCode = $this->getRequestParameter('code', $request, null);\n\n        if ($encryptedAuthCode === null) {\n            throw OAuthServerException::invalidRequest('code');\n        }\n\n        try {\n            $authCodePayload = json_decode($this->decrypt($encryptedAuthCode));\n\n            $this->validateAuthorizationCode($authCodePayload, $client, $request);\n\n            $scopes = $this->scopeRepository->finalizeScopes(\n                $this->validateScopes($authCodePayload->scopes),\n                $this->getIdentifier(),\n                $client,\n                $authCodePayload->user_id\n            );\n        } catch (LogicException $e) {\n            throw OAuthServerException::invalidRequest('code', 'Cannot decrypt the authorization code', $e);\n        }\n\n        // Validate code challenge\n        if ($this->enableCodeExchangeProof === true) {\n            $codeVerifier = $this->getRequestParameter('code_verifier', $request, null);\n\n            if ($codeVerifier === null) {\n                throw OAuthServerException::invalidRequest('code_verifier');\n            }\n\n            // Validate code_verifier according to RFC-7636\n            // @see: https://tools.ietf.org/html/rfc7636#section-4.1\n            if (preg_match('/^[A-Za-z0-9-._~]{43,128}$/', $codeVerifier) !== 1) {\n                throw OAuthServerException::invalidRequest(\n                    'code_verifier',\n                    'Code Verifier must follow the specifications of RFC-7636.'\n                );\n            }\n\n            switch ($authCodePayload->code_challenge_method) {\n                case 'plain':\n                    if (hash_equals($codeVerifier, $authCodePayload->code_challenge) === false) {\n                        throw OAuthServerException::invalidGrant('Failed to verify `code_verifier`.');\n                    }\n\n                    break;\n                case 'S256':\n                    if (\n                        hash_equals(\n                            strtr(rtrim(base64_encode(hash('sha256', $codeVerifier, true)), '='), '+/', '-_'),\n                            $authCodePayload->code_challenge\n                        ) === false\n                    ) {\n                        throw OAuthServerException::invalidGrant('Failed to verify `code_verifier`.');\n                    }\n                    // @codeCoverageIgnoreStart\n                    break;\n                default:\n                    throw OAuthServerException::serverError(\n                        sprintf(\n                            'Unsupported code challenge method `%s`',\n                            $authCodePayload->code_challenge_method\n                        )\n                    );\n                // @codeCoverageIgnoreEnd\n            }\n        }\n\n        // Issue and persist new access token\n        $accessToken = $this->issueAccessToken($accessTokenTTL, $client, $authCodePayload->user_id, $scopes);\n        $this->getEmitter()->emit(new RequestEvent(RequestEvent::ACCESS_TOKEN_ISSUED, $request));\n        $responseType->setAccessToken($accessToken);\n\n        // Issue and persist new refresh token if given\n        $refreshToken = $this->issueRefreshToken($accessToken);\n\n        if ($refreshToken !== null) {\n            $this->getEmitter()->emit(new RequestEvent(RequestEvent::REFRESH_TOKEN_ISSUED, $request));\n            $responseType->setRefreshToken($refreshToken);\n        }\n\n        // Revoke used auth code\n        $this->authCodeRepository->revokeAuthCode($authCodePayload->auth_code_id);\n\n        return $responseType;\n    }", "label": 2}
{"code": "public void forAllTables(String template, Properties attributes) throws XDocletException\r\n    {\r\n        for (Iterator it = _torqueModel.getTables(); it.hasNext(); )\r\n        {\r\n            _curTableDef = (TableDef)it.next();\r\n            generate(template);\r\n        }\r\n        _curTableDef = null;\r\n    }", "label": 0}
{"code": "public function setJobEvent($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\JobEvent::class);\n        $this->writeOneof(5, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "func SliceMatchesRegex(input string, expressions []string) (bool, error) {\n\tfor _, expression := range expressions {\n\t\tif !strings.HasPrefix(expression, \"^\") || !strings.HasSuffix(expression, \"$\") {\n\t\t\t// replace glob-style wildcards with regexp wildcards\n\t\t\t// for plain strings, and quote all characters that could\n\t\t\t// be interpreted in regular expression\n\t\t\texpression = \"^\" + GlobToRegexp(expression) + \"$\"\n\t\t}\n\n\t\texpr, err := regexp.Compile(expression)\n\t\tif err != nil {\n\t\t\treturn false, trace.BadParameter(err.Error())\n\t\t}\n\n\t\t// Since the expression is always surrounded by ^ and $ this is an exact\n\t\t// match for either a a plain string (for example ^hello$) or for a regexp\n\t\t// (for example ^hel*o$).\n\t\tif expr.MatchString(input) {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}", "label": 5}
{"code": "public function cache_clear() {\n\t\t$cache = WP_CLI::get_cache();\n\n\t\tif ( ! $cache->is_enabled() ) {\n\t\t\tWP_CLI::error( 'Cache directory does not exist.' );\n\t\t}\n\n\t\t$cache->clear();\n\n\t\tWP_CLI::success( 'Cache cleared.' );\n\t}", "label": 2}
{"code": "def strip_cdata(text):\n    \"\"\"Removes all CDATA blocks from `text` if it contains them.\n\n    Note:\n        If the function contains escaped XML characters outside of a\n        CDATA block, they will be unescaped.\n\n    Args:\n        A string containing one or more CDATA blocks.\n\n    Returns:\n        An XML unescaped string with CDATA block qualifiers removed.\n\n    \"\"\"\n    if not is_cdata(text):\n        return text\n\n    xml = \"<e>{0}</e>\".format(text)\n    node = etree.fromstring(xml)\n    return node.text", "label": 1}
{"code": "private void checkModifications(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException\r\n    {\r\n        if (CHECKLEVEL_NONE.equals(checkLevel))\r\n        {\r\n            return;\r\n        }\r\n\r\n        HashMap              features = new HashMap();\r\n        FeatureDescriptorDef def;\r\n\r\n        for (Iterator it = classDef.getFields(); it.hasNext();)\r\n        {\r\n            def = (FeatureDescriptorDef)it.next();\r\n            features.put(def.getName(), def);\r\n        }\r\n        for (Iterator it = classDef.getReferences(); it.hasNext();)\r\n        {\r\n            def = (FeatureDescriptorDef)it.next();\r\n            features.put(def.getName(), def);\r\n        }\r\n        for (Iterator it = classDef.getCollections(); it.hasNext();)\r\n        {\r\n            def = (FeatureDescriptorDef)it.next();\r\n            features.put(def.getName(), def);\r\n        }\r\n\r\n        // now checking the modifications\r\n        Properties mods;\r\n        String     modName;\r\n        String     propName;\r\n\r\n        for (Iterator it = classDef.getModificationNames(); it.hasNext();)\r\n        {\r\n            modName = (String)it.next();\r\n            if (!features.containsKey(modName))\r\n            {\r\n                throw new ConstraintException(\"Class \"+classDef.getName()+\" contains a modification for an unknown feature \"+modName);\r\n            }\r\n            def = (FeatureDescriptorDef)features.get(modName);\r\n            if (def.getOriginal() == null)\r\n            {\r\n                throw new ConstraintException(\"Class \"+classDef.getName()+\" contains a modification for a feature \"+modName+\" that is not inherited but defined in the same class\");\r\n            }\r\n            // checking modification\r\n            mods = classDef.getModification(modName);\r\n            for (Iterator propIt = mods.keySet().iterator(); propIt.hasNext();)\r\n            {\r\n                propName = (String)propIt.next();\r\n                if (!PropertyHelper.isPropertyAllowed(def.getClass(), propName))\r\n                {\r\n                    throw new ConstraintException(\"The modification of attribute \"+propName+\" in class \"+classDef.getName()+\" is not applicable to the feature \"+modName);\r\n                }\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "func isEqCrossStructField(fl FieldLevel) bool {\n\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\ttopField, topKind, ok := fl.GetStructFieldOK()\n\tif !ok || topKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn topField.Int() == field.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn topField.Uint() == field.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn topField.Float() == field.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(topField.Len()) == int64(field.Len())\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != topField.Type() {\n\t\t\treturn false\n\t\t}\n\n\t\tif fieldType == timeType {\n\n\t\t\tt := field.Interface().(time.Time)\n\t\t\tfieldTime := topField.Interface().(time.Time)\n\n\t\t\treturn fieldTime.Equal(t)\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn topField.String() == field.String()\n}", "label": 5}
{"code": "def state_push(self):\n        \"Save the state of the output functions, to be restored with state_pop.\"\n        for of in self.output_fns:\n            if hasattr(of,'state_push'):\n                of.state_push()\n        super(PatternGenerator, self).state_push()", "label": 1}
{"code": "function(model)\n  {\n    var exists = this.has( model.$key() );\n    var matches = this.filter( model );\n\n    if ( exists && !matches )\n    {\n      this.remove( model );\n    }\n    if ( !exists && matches )\n    {\n      this.add( model );\n    }\n  }", "label": 3}
{"code": "function enrichMethodNode(methodNode, method) {\n  method.description && (methodNode.description = method.description)\n\n  if (method.tags.route) {\n    let httpPath = method.tags.route\n    let httpMethod = 'GET'\n    const sepPos = httpPath.indexOf(' ')\n\n    if (sepPos !== -1) {\n      httpMethod = httpPath.substr(0, sepPos).toUpperCase()\n      httpPath = httpPath.substr(sepPos + 1)\n\n      if (!isValidHttpMethod(httpMethod)) {\n        throw new Error(`Unsupported HTTP method [${httpMethod}] for ${method.name} method`)\n      }\n    }\n\n    methodNode.method = httpMethod\n    methodNode.path = httpPath\n  }\n\n  return methodNode\n}", "label": 3}
{"code": "protected void writePropertiesToLog(Logger logger, Level level) {\n    writeToLog(logger, level, getMapAsString(this.properties, separator), null);\n\n    if (this.exception != null) {\n      writeToLog(this.logger, Level.ERROR, \"Error:\", this.exception);\n    }\n  }", "label": 0}
{"code": "function openDatabase(options) {\n    var db;\n    var sqlitePlugin = 'sqlitePlugin';\n    if (global[sqlitePlugin]) {\n        // device implementation\n        options = _.clone(options);\n        if (!options.key) {\n            if (options.security) {\n                options.key = options.security;\n                delete options.security;\n            }\n            else if (options.credentials) {\n                options.key = cipher.hashJsonSync(options.credentials, 'sha256').toString('hex');\n                delete options.credentials;\n            }\n        }\n        if (!options.location) {\n            options.location = 2;\n        }\n        db = global[sqlitePlugin].openDatabase(options);\n    }\n    else if (global['openDatabase']) {\n        // native implementation\n        db = global['openDatabase'](options.name, options.version || '', options.description || '', options.size || 1024 * 1024);\n    }\n    else if (process && !process['browser']) {\n        // node.js implementation\n        var websql = void 0;\n        try {\n            websql = require('websql');\n        }\n        catch (error) {\n            diag.debug.warn(error);\n        }\n        if (websql) {\n            db = websql(options.name, options.version || '', options.description || '', options.size || 1024 * 1024);\n        }\n    }\n    if (!db) {\n        // when this is reached no supported implementation is present\n        throw new Error('WebSQL implementation is not available');\n    }\n    return db;\n}", "label": 3}
{"code": "public static sslciphersuite[] get(nitro_service service, options option) throws Exception{\n\t\tsslciphersuite obj = new sslciphersuite();\n\t\tsslciphersuite[] response = (sslciphersuite[])obj.get_resources(service,option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def process_remove_action(processors, action, argument):\n    \"\"\"Process action removals.\"\"\"\n    for processor in processors:\n        processor(action, argument)\n    db.session.commit()", "label": 1}
{"code": "public static appfwprofile_xmlwsiurl_binding[] get(nitro_service service, String name) throws Exception{\n\t\tappfwprofile_xmlwsiurl_binding obj = new appfwprofile_xmlwsiurl_binding();\n\t\tobj.set_name(name);\n\t\tappfwprofile_xmlwsiurl_binding response[] = (appfwprofile_xmlwsiurl_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def resolve\n      if !refs.nil? and refs.select { |ref| File.file? ref }.any?\n        paths = refs.select { |ref| File.file? ref }.map { |path| File.expand_path(path) }\n      elsif refs and refs.kind_of? Array\n        paths, gems = GemsResolver.new(refs).call\n      else\n        paths = Dir.glob(File.join(\".\", \"lib/**/*.rb\")).map { |path| File.expand_path(path) }\n      end\n\n      { paths: paths, gems: gems || [] }\n    end", "label": 4}
{"code": "func NewGRPCServer(cfg APIConfig) http.Handler {\n\tauthServer := &GRPCServer{\n\t\tAPIConfig: cfg,\n\t\tEntry: logrus.WithFields(logrus.Fields{\n\t\t\ttrace.Component: teleport.Component(teleport.ComponentAuth, teleport.ComponentGRPC),\n\t\t}),\n\t\thttpHandler: NewAPIServer(&cfg),\n\t\tgrpcHandler: grpc.NewServer(),\n\t}\n\tproto.RegisterAuthServiceServer(authServer.grpcHandler, authServer)\n\treturn authServer\n}", "label": 5}
{"code": "public static function handle(CommunicationException $exception)\n    {\n        if ($exception->shouldResetConnection()) {\n            $connection = $exception->getConnection();\n\n            if ($connection->isConnected()) {\n                $connection->disconnect();\n            }\n        }\n\n        throw $exception;\n    }", "label": 2}
{"code": "function (obj, other) {\n    var notIn = {};\n    for (var key in obj) {\n        if (other[key] === undefined) {\n            notIn[key] = true;\n        }\n    }\n    return _.keys(notIn);\n}", "label": 3}
{"code": "def _const_pf_constraints(self, gn, base_mva):\n        \"\"\" Returns a linear constraint enforcing constant power factor for\n        dispatchable loads.\n\n        The power factor is derived from the original value of Pmin and either\n        Qmin (for inductive loads) or Qmax (for capacitive loads). If both Qmin\n        and Qmax are zero, this implies a unity power factor without the need\n        for an additional constraint.\n        \"\"\"\n        ivl = array([i for i, g in enumerate(gn)\n                     if g.is_load and (g.q_min != 0.0 or g.q_max != 0.0)])\n        vl = [gn[i] for i in ivl]\n        nvl = len(vl)\n\n        ng = len(gn)\n        Pg = array([g.p for g in vl]) / base_mva\n        Qg = array([g.q for g in vl]) / base_mva\n        Pmin = array([g.p_min for g in vl]) / base_mva\n        Qmin = array([g.q_min for g in vl]) / base_mva\n        Qmax = array([g.q_max for g in vl]) / base_mva\n\n        # At least one of the Q limits must be zero (corresponding to Pmax==0).\n        for g in vl:\n            if g.qmin != 0.0 and g.q_max != 0.0:\n                logger.error(\"Either Qmin or Qmax must be equal to zero for \"\n                \"each dispatchable load.\")\n\n        # Initial values of PG and QG must be consistent with specified power\n        # factor. This is to prevent a user from unknowingly using a case file\n        # which would have defined a different power factor constraint under a\n        # previous version which used PG and QG to define the power factor.\n        Qlim = (Qmin == 0.0) * Qmax + (Qmax == 0.0) * Qmin\n        if any( abs(Qg - Pg * Qlim / Pmin) > 1e-6 ):\n            logger.error(\"For a dispatchable load, PG and QG must be \"\n                         \"consistent with the power factor defined by \"\n                         \"PMIN and the Q limits.\")\n\n        # Make Avl, lvl, uvl, for lvl <= Avl * r_[Pg, Qg] <= uvl\n        if nvl > 0:\n            xx = Pmin\n            yy = Qlim\n            pftheta = arctan2(yy, xx)\n            pc = sin(pftheta)\n            qc = -cos(pftheta)\n            ii = array([range(nvl), range(nvl)])\n            jj = r_[ivl, ivl + ng]\n            Avl = csr_matrix(r_[pc, qc], (ii, jj), (nvl, 2 * ng))\n            lvl = zeros(nvl)\n            uvl = lvl\n        else:\n            Avl = zeros((0, 2 * ng))\n            lvl = array([])\n            uvl = array([])\n\n        return LinearConstraint(\"vl\", Avl, lvl, uvl, [\"Pg\", \"Qg\"])", "label": 1}
{"code": "public ProxyAuthentication getProxyAuthentication() {\n\t\t// convert authentication to layerAuthentication so we only use one\n\t\t// TODO Remove when removing deprecated authentication field.\n\t\tif (layerAuthentication == null && authentication != null) {\n\t\t\tlayerAuthentication = new LayerAuthentication();\n\t\t\tlayerAuthentication.setAuthenticationMethod(LayerAuthenticationMethod.valueOf(authentication\n\t\t\t\t\t.getAuthenticationMethod().name()));\n\t\t\tlayerAuthentication.setPassword(authentication.getPassword());\n\t\t\tlayerAuthentication.setPasswordKey(authentication.getPasswordKey());\n\t\t\tlayerAuthentication.setRealm(authentication.getRealm());\n\t\t\tlayerAuthentication.setUser(authentication.getUser());\n\t\t\tlayerAuthentication.setUserKey(authentication.getUserKey());\n\t\t}\n\t\t// TODO Remove when removing deprecated authentication field.\n\t\treturn layerAuthentication;\n\t}", "label": 0}
{"code": "public function storeSubscriber(Subscriber $subscriber, string $topic): void\n    {\n        $topicKey = self::TOPIC_KEY.\".{$topic}\";\n        $subscriberKey = self::SUBSCRIBER_KEY.\".{$subscriber->channel}\";\n\n        $topic = $this->cache->has($topicKey)\n            ? json_decode($this->cache->get($topicKey), true)\n            : [];\n\n        $topic[] = $subscriber->channel;\n\n        $this->cache->forever($topicKey, json_encode($topic));\n        $this->cache->forever($subscriberKey, $subscriber);\n    }", "label": 2}
{"code": "public static double Exp(double x, int nTerms) {\r\n        if (nTerms < 2) return 1 + x;\r\n        if (nTerms == 2) {\r\n            return 1 + x + (x * x) / 2;\r\n        } else {\r\n\r\n            double mult = x * x;\r\n            double fact = 2;\r\n            double result = 1 + x + mult / fact;\r\n            for (int i = 3; i <= nTerms; i++) {\r\n                mult *= x;\r\n                fact *= i;\r\n                result += mult / fact;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }", "label": 0}
{"code": "func delVlanLink(linkName string) error {\n\tif strings.Contains(linkName, \".\") {\n\t\t_, _, err := parseVlan(linkName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// delete the vlan subinterface\n\t\tvlanLink, err := ns.NlHandle().LinkByName(linkName)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to find interface %s on the Docker host : %v\", linkName, err)\n\t\t}\n\t\t// verify a parent interface isn't being deleted\n\t\tif vlanLink.Attrs().ParentIndex == 0 {\n\t\t\treturn fmt.Errorf(\"interface %s does not appear to be a slave device: %v\", linkName, err)\n\t\t}\n\t\t// delete the macvlan slave device\n\t\tif err := ns.NlHandle().LinkDel(vlanLink); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to delete  %s link: %v\", linkName, err)\n\t\t}\n\t\tlogrus.Debugf(\"Deleted a vlan tagged netlink subinterface: %s\", linkName)\n\t}\n\t// if the subinterface doesn't parse to iface.vlan_id leave the interface in\n\t// place since it could be a user specified name not created by the driver.\n\treturn nil\n}", "label": 5}
{"code": "function groups_to_docsets(groups, docset) {\n  var results = [{\n    \"tagname\": \"class\",\n    \"type\": docset[\"type\"],\n    \"comment\": groups[\"class\"],\n    \"code\": docset[\"code\"],\n    \"linenr\": docset[\"linenr\"]\n  }];\n\n  _.each(groups[\"cfg\"], function(cfg) {\n    results.push({\n      \"tagname\": \"cfg\",\n      \"type\": docset[\"type\"],\n      \"comment\": cfg,\n      \"code\": {},\n      \"linenr\": docset[\"linenr\"]\n    });\n  });\n\n  if (groups[\"Constructor\"].length > 0) {\n    // Remember that a constructor is already found and ignore if a\n    // constructor is detected from code.\n    var constructor_found = true\n\n    results.push({\n      \"tagname\": \"method\",\n      \"type\": docset[\"type\"],\n      \"comment\": groups[\"Constructor\"],\n      \"code\": {},\n      \"linenr\": docset[\"linenr\"]\n    });\n  }\n  \n  return results;\n}", "label": 3}
{"code": "func (c *Manager) DeleteLibrary(ctx context.Context, library *Library) error {\n\turl := internal.URL(c, internal.LocalLibraryPath).WithID(library.ID)\n\treturn c.Do(ctx, url.Request(http.MethodDelete), nil)\n}", "label": 5}
{"code": "function _gpfXmlCheckDefinableNamespacePrefixName(name) {\n        _gpfXmlCheckValidNamespacePrefixName(name);\n        _gpfXmlCheckNoXmlns(name);\n        if (name === \"xml\") {\n            gpf.Error.invalidXmlUseOfPrefixXml();\n        }\n    }", "label": 3}
{"code": "async function registerAccount(options) {\n    options = options || {};\n    const atlasClient = options.atlasClient || await AtlasClient.factory();\n    const name = options.name || defaultName;\n    const registrationId = libsignal.keyhelper.generateRegistrationId();\n    const password = generatePassword();\n    const signalingKey = generateSignalingKey();\n    const response = await atlasClient.fetch('/v1/provision/account', {\n        method: 'PUT',\n        json: {\n            signalingKey: signalingKey.toString('base64'),\n            supportsSms: false,\n            fetchesMessages: true,\n            registrationId,\n            name,\n            password\n        }\n    });\n    const addr = response.userId;\n    const username = `${addr}.${response.deviceId}`;\n    const identity = libsignal.keyhelper.generateIdentityKeyPair();\n    await storage.clearSessionStore();\n    await storage.removeOurIdentity();\n    await storage.removeIdentity(addr);\n    await storage.saveIdentity(addr, identity.pubKey);\n    await storage.saveOurIdentity(identity);\n    await storage.putState('addr', addr);\n    await storage.putState('serverUrl', response.serverUrl);\n    await storage.putState('deviceId', response.deviceId);\n    await storage.putState('name', name);\n    await storage.putState('username', username);\n    await storage.putState('password', password);\n    await storage.putState('registrationId', registrationId);\n    await storage.putState('signalingKey', signalingKey);\n    const sc = new SignalClient(username, password, response.serverUrl);\n    await sc.registerKeys(await sc.generateKeys());\n}", "label": 3}
{"code": "function getPhotoUrl(data) {\n    return FLICK_PHOTO_URL_TEMPLATE\n        .replace('{farm-id}', data.farm)\n        .replace('{server-id}', data.server)\n        .replace('{id}', data.id)\n        .replace('{secret}', data.secret)\n        .replace('{size}', 'm');\n}", "label": 3}
{"code": "def sharing?(permission_template:)\n        wf = workflow(permission_template: permission_template)\n        return false unless wf\n        wf.allows_access_grant?\n      end", "label": 4}
{"code": "def _is_sudoer(what_for=''):\n    '''Return True if current user is a sudoer, else False.\n\n    Should be called non-eager if sudo is wanted only.\n    '''\n    if env.get('nosudo', None) is None:\n        if what_for:\n            print(yellow(what_for))\n        with quiet():\n            # possible outputs:\n            #  en: \"Sorry, user winhost-tester may not run sudo on <hostname>\"\n            #  en: \"sudo: a password is required\"     (=> is sudoer)\n            #  de: \"sudo: Ein Passwort ist notwendig\" (=> is sudoer)\n            output = run('sudo -nv', capture=True)\n            env.nosudo = not (output.startswith('sudo: ') or output == '')\n        if env.nosudo:\n            print('Cannot execute sudo-commands')\n    return not env.nosudo", "label": 1}
{"code": "function findDataSources(connections, dataSources, cb) {\n  //Just Want The Data Source IDs.\n  logger.debug(\"findDataSources\", {dataSources: dataSources});\n  var dataSourceIDsToUpdate = _.map(dataSources, function(dataSourceUpdateData) {\n    return dataSourceUpdateData.error ? null : dataSourceUpdateData._id;\n  });\n\n  dataSourceIDsToUpdate = _.compact(dataSourceIDsToUpdate);\n\n  //No Valid Data Sources To Update. No Need To Search For Data Sources\n  if (dataSourceIDsToUpdate.length === 0) {\n    return cb(undefined, dataSourceIDsToUpdate);\n  }\n\n  var query = {\n\n  };\n\n  //Searching By ID. Just one mongo call to get them all. More Efficient\n  query[CONSTANTS.DATA_SOURCE_ID] = {\n    \"$in\": dataSourceIDsToUpdate\n  };\n\n  lookUpDataSources(connections, {\n    query: query\n  }, function(err, foundDataSources) {\n    if (err) {\n      logger.error(\"Error Finding Data Sources \", {error: err});\n      return cb(buildErrorResponse({\n        error: err,\n        userDetail: \"Unexpected Error When Searching For A Data Source\",\n        code: ERROR_CODES.FH_FORMS_UNEXPECTED_ERROR\n      }));\n    }\n\n    //Map Found Data Source Documents\n    var dsWithDocuments = _.map(dataSources, function(validDataSource) {\n      var matchingDocument = _.find(foundDataSources, function(dataSourceDocument) {\n        return _.isEqual(dataSourceDocument._id.toString(), validDataSource._id.toString());\n      });\n\n      //If the document is found, assign it to the object, if not, set an error\n      if (matchingDocument) {\n        validDataSource.document = matchingDocument;\n      } else {\n        validDataSource.error = buildErrorResponse({\n          error: new Error(\"Data Source Not Found\"),\n          userDetail: \"Data Source Not Found\",\n          code: ERROR_CODES.FH_FORMS_NOT_FOUND\n        });\n      }\n\n      return validDataSource;\n    });\n\n    var validInvalidDataSources = updateValidAndInvalidDataSources(dsWithDocuments, []);\n\n    logger.debug(\"findDataSources\", {validInvalidDataSources: validInvalidDataSources});\n\n    cb(undefined, validInvalidDataSources.valid, validInvalidDataSources.invalid);\n  });\n}", "label": 3}
{"code": "func (process *TeleportProcess) addConnector(connector *Connector) {\n\tprocess.Lock()\n\tdefer process.Unlock()\n\n\tprocess.connectors[connector.ClientIdentity.ID.Role] = connector\n}", "label": 5}
{"code": "func (a *AuthServer) GetRemoteClusters(opts ...services.MarshalOption) ([]services.RemoteCluster, error) {\n\t// To make sure remote cluster exists - to protect against random\n\t// clusterName requests (e.g. when clusterName is set to local cluster name)\n\tremoteClusters, err := a.Presence.GetRemoteClusters(opts...)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tfor i := range remoteClusters {\n\t\tif err := a.updateRemoteClusterStatus(remoteClusters[i]); err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t}\n\treturn remoteClusters, nil\n}", "label": 5}
{"code": "public static appfwjsoncontenttype get(nitro_service service, String jsoncontenttypevalue) throws Exception{\n\t\tappfwjsoncontenttype obj = new appfwjsoncontenttype();\n\t\tobj.set_jsoncontenttypevalue(jsoncontenttypevalue);\n\t\tappfwjsoncontenttype response = (appfwjsoncontenttype) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (t *Table) AddRow(row []string) {\n\tlimit := min(len(row), len(t.columns))\n\tfor i := 0; i < limit; i++ {\n\t\tcellWidth := len(row[i])\n\t\tt.columns[i].width = max(cellWidth, t.columns[i].width)\n\t}\n\tt.rows = append(t.rows, row[:limit])\n}", "label": 5}
{"code": "def find_column(t):\n    \"\"\"Get cursor position, based on previous newline\"\"\"\n    pos = t.lexer.lexpos\n    data = t.lexer.lexdata\n    last_cr = data.rfind('\\n', 0, pos)\n    if last_cr < 0:\n        last_cr = -1\n    column = pos - last_cr\n    return column", "label": 1}
{"code": "protected function populateRoutes(RouteCollection $routes)\n    {\n        $factory = $this->app->make(RouteHandlerFactory::class);\n\n        $callback = include __DIR__.'/routes.php';\n        $callback($routes, $factory);\n\n        $this->app->make('events')->fire(\n            new ConfigureForumRoutes($routes, $factory)\n        );\n\n        $defaultRoute = $this->app->make('flarum.settings')->get('default_route');\n\n        if (isset($routes->getRouteData()[0]['GET'][$defaultRoute])) {\n            $toDefaultController = $routes->getRouteData()[0]['GET'][$defaultRoute];\n        } else {\n            $toDefaultController = $factory->toForum(Content\\Index::class);\n        }\n\n        $routes->get(\n            '/',\n            'default',\n            $toDefaultController\n        );\n    }", "label": 2}
{"code": "def register(self, name, method, method_signature=None):\n        \"\"\"Registers a method with a given name and signature.\n\n        :param name: The name used to register the method\n        :type name: str\n        :param method: The method to register\n        :type method: function\n        :param method_signature: The method signature for the given function\n        :type method_signature: MethodSignature | None\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        if inspect.ismethod(method):\n            raise Exception(\"typedjsonrpc does not support making class methods into endpoints\")\n        self._name_to_method_info[name] = MethodInfo(name, method, method_signature)", "label": 1}
{"code": "def append_record_to_messages(op, meta, header, record, msgs)\n      case op\n      when UPDATE_OP, UPSERT_OP\n        if meta.has_key?(ID_FIELD)\n          header[UPDATE_OP] = meta\n          msgs << @dump_proc.call(header) << BODY_DELIMITER\n          msgs << @dump_proc.call(update_body(record, op)) << BODY_DELIMITER\n          return true\n        end\n      when CREATE_OP\n        if meta.has_key?(ID_FIELD)\n          header[CREATE_OP] = meta\n          msgs << @dump_proc.call(header) << BODY_DELIMITER\n          msgs << @dump_proc.call(record) << BODY_DELIMITER\n          return true\n        end\n      when INDEX_OP\n        header[INDEX_OP] = meta\n        msgs << @dump_proc.call(header) << BODY_DELIMITER\n        msgs << @dump_proc.call(record) << BODY_DELIMITER\n        return true\n      end\n      return false\n    end", "label": 4}
{"code": "def delete(*args)\n      raise_authentication_error unless authenticated?\n      params = arguments(args, required: [:client_id]).params\n\n      if arguments.client_id\n        if access_token = (params.delete('access_token') || args[1])\n          delete_request(\"/applications/#{arguments.client_id}/tokens/#{access_token}\", params)\n        else\n          # Revokes all tokens\n          delete_request(\"/applications/#{arguments.client_id}/tokens\", params)\n        end\n      else\n        raise raise_app_authentication_error\n      end\n    end", "label": 4}
{"code": "function validateParams(dataSource, cb) {\n  var dataSourceValidator = validate(dataSource);\n  //The data source parameter should have an ID property.\n  dataSourceValidator.has(CONSTANTS.DATA_SOURCE_ID, function(err) {\n    if (err) {\n      return cb(buildErrorResponse({error: new Error(\"An ID Parameter Is Required To Update A Data Source\"), code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS}));\n    }\n\n    //Data Source Cache Should Not Be Updated With This Function\n    dataSourceValidator.hasno(CONSTANTS.DATA_SOURCE_DATA, CONSTANTS.DATA_SOURCE_CACHE, function() {\n      if (err) {\n        return cb(buildErrorResponse({error: new Error(\"Updating A Data Source Should Not Include Cache Data\"), code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS}));\n      }\n\n      cb(undefined, dataSource);\n    });\n  });\n}", "label": 3}
{"code": "public static String checkRequiredProperties(Properties props,\r\n                                               String ... requiredProps) {\r\n    for (String required : requiredProps) {\r\n      if (props.getProperty(required) == null) {\r\n        return required;\r\n      }\r\n    }\r\n    return null;\r\n  }", "label": 0}
{"code": "function(win, elems) {\n\t\t\t\tvar mode = svgCanvas.getMode();\n\t\t\t\tif (mode === 'select') {\n\t\t\t\t\tsetSelectMode();\n\t\t\t\t}\n\t\t\t\tvar is_node = (mode == \"pathedit\");\n\t\t\t\t// if elems[1] is present, then we have more than one element\n\t\t\t\tselectedElement = (elems.length === 1 || elems[1] == null ? elems[0] : null);\n\t\t\t\tmultiselected = (elems.length >= 2 && elems[1] != null);\n\t\t\t\tif (selectedElement != null) {\n\t\t\t\t\t// unless we're already in always set the mode of the editor to select because\n\t\t\t\t\t// upon creation of a text element the editor is switched into\n\t\t\t\t\t// select mode and this event fires - we need our UI to be in sync\n\n\t\t\t\t\tif (!is_node) {\n\t\t\t\t\t\tupdateToolbar();\n\t\t\t\t\t}\n\t\t\t\t} // if (elem != null)\n\n\t\t\t\t// Deal with pathedit mode\n\t\t\t\ttogglePathEditMode(is_node, elems);\n\t\t\t\tupdateContextPanel();\n\t\t\t\tsvgCanvas.runExtensions('selectedChanged', {\n\t\t\t\t\telems: elems,\n\t\t\t\t\tselectedElement: selectedElement,\n\t\t\t\t\tmultiselected: multiselected\n\t\t\t\t});\n\t\t\t}", "label": 3}
{"code": "function (err, data) {\n\t\tif (err) {\n\t\t\tLOG.warn(err.toString());\n\t\t}\n\t\telse {\n\t\t\tfor (var server in data.accounts) {\n\t\t\t\tLOG.warn('local server: ' + server);\n\n\t\t\t\tvar user_list = data.accounts[server];\n\t\t\t\tfor (var uid in user_list) {\n\t\t\t\t\tvar token = user_list[uid];\n\t\t\t\t\tLOG.warn('local uid: ' + uid + ' token: ' + token);\n\t\t\t\t\tl_send_remote_login(server, uid, token);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "label": 3}
{"code": "def add_field(name: nil, value: nil, inline: nil)\n      self << EmbedField.new(name: name, value: value, inline: inline)\n    end", "label": 4}
{"code": "def apks_version_codes\n      ensure_active_edit!\n\n      result = call_google_api { client.list_apks(current_package_name, current_edit.id) }\n\n      return Array(result.apks).map(&:version_code)\n    end", "label": 4}
{"code": "func (c *Manager) ListTags(ctx context.Context) ([]string, error) {\n\turl := internal.URL(c, internal.TagPath)\n\tvar res []string\n\treturn res, c.Do(ctx, url.Request(http.MethodGet), &res)\n}", "label": 5}
{"code": "def server(id)\n      id = id.resolve_id\n      return @servers[id] if @servers[id]\n\n      LOGGER.out(\"Resolving server #{id}\")\n      begin\n        response = API::Server.resolve(token, id)\n      rescue Discordrb::Errors::NoPermission\n        return nil\n      end\n      server = Server.new(JSON.parse(response), self)\n      @servers[id] = server\n    end", "label": 4}
{"code": "private String buildAliasKey(String aPath, List hintClasses)\r\n    {\r\n        if (hintClasses == null || hintClasses.isEmpty())\r\n        {\r\n            return aPath;\r\n        }\r\n        \r\n        StringBuffer buf = new StringBuffer(aPath);\r\n        for (Iterator iter = hintClasses.iterator(); iter.hasNext();)\r\n        {\r\n            Class hint = (Class) iter.next();\r\n            buf.append(\" \");\r\n            buf.append(hint.getName());\r\n        }\r\n        return buf.toString();\r\n    }", "label": 0}
{"code": "public function topics(array $options = [])\n    {\n        $resultLimit = $this->pluck('resultLimit', $options, false);\n\n        return new ItemIterator(\n            new PageIterator(\n                function (array $topic) {\n                    return $this->topicFactory($topic['name'], $topic);\n                },\n                [$this->connection, 'listTopics'],\n                $options + ['project' => $this->formatName('project', $this->projectId)],\n                [\n                    'itemsKey' => 'topics',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "func NewSyncBuffer() *SyncBuffer {\n\treader, writer := io.Pipe()\n\tbuf := &bytes.Buffer{}\n\tgo func() {\n\t\tio.Copy(buf, reader)\n\t}()\n\treturn &SyncBuffer{\n\t\treader: reader,\n\t\twriter: writer,\n\t\tbuf:    buf,\n\t}\n}", "label": 5}
{"code": "public function setVersionView($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Kms\\V1\\CryptoKeyVersion_CryptoKeyVersionView::class);\n        $this->version_view = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def dependencies(self, tkn: str) -> Set[str]:\n        \"\"\"Return all the items that tkn depends on as a set\n\n        :param tkn:\n        :return:\n        \"\"\"\n        return set(self.dependency_list(tkn))", "label": 1}
{"code": "public static String ptb2Text(String ptbText) {\r\n    StringBuilder sb = new StringBuilder(ptbText.length()); // probably an overestimate\r\n    PTB2TextLexer lexer = new PTB2TextLexer(new StringReader(ptbText));\r\n    try {\r\n      for (String token; (token = lexer.next()) != null; ) {\r\n        sb.append(token);\r\n      }\r\n    } catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n    return sb.toString();\r\n  }", "label": 0}
{"code": "def [](loader_name)\n    loader = @loaders_by_name[loader_name]\n    if loader.nil?\n      # Unable to find the module private loader. Try resolving the module\n      loader = private_loader_for_module(loader_name[0..-9]) if loader_name.end_with?(' private')\n      raise Puppet::ParseError, _(\"Unable to find loader named '%{loader_name}'\") % { loader_name: loader_name } if loader.nil?\n    end\n    loader\n  end", "label": 4}
{"code": "def load_addon(username, package_name, _globals):\n    '''Load an fabsetup addon given by 'package_name' and hook it in the\n    base task namespace 'username'.\n\n    Args:\n        username(str)\n        package_name(str)\n        _globals(dict): the globals() namespace of the fabric script.\n\n    Return: None\n    '''\n    addon_module = get_or_create_module_r(username)\n    package_module = __import__(package_name)\n    add_tasks_r(addon_module, package_module, package_name)\n    _globals.update({username: addon_module})\n    del package_module\n    del addon_module", "label": 1}
{"code": "function getUIDCallback (err, uid) {\n\t\tif (err) {\n\t\t\treturn onDone('UID_ERROR');\n\t\t}\n\t\tvar ip = (extra) ? extra.conn.host : \"server\";\n\t\t// NOTE: by default a user is a normal user, user 'groups' can later be customized\n\t\tvar reg = {\n\t\t\tuid: \t\tuid,\n\t\t\taccount:\targs.account,\n\t\t\tpassword:\tl_encryptPass(args.password),\n\t\t\temail:\t\targs.email,\n\t\t\t// verify:\t\t{email_verify: false, phone_verify: false},\n\t\t\ttokens: \t{reset: '', pass: {}},\n\t\t\tenc_type:\tl_enc_type,\n\t\t\tcontrol:\t{groups: args.groups || [], permissions: []},\n\t\t\tdata: \t\targs.data || {},\n\t\t\tlogin: \t\t{IP: ip, count: 1}\n\t\t};\n\n\t\t// special handling (by default 'admin' account is special and will be part of the 'admin' group by default\n\t\tif (!args.authWP && reg.account === 'admin') {\n\t\t\treg.control.groups.push('admin');\n\t\t}\n\n\t\tLOG.warn('creating new account [' + args.account + ']...', l_name);\n\t\tl_accounts.add(reg, function (err) {\n\t\t\tif (err) {\n\t\t\t\treturn onDone('DB_ERROR', err);\n\t\t\t}\n\t\t\t// register success\n\t\t\tLOG.warn('account register success', l_name);\n\t\t\tonDone(null);\n\t\t});\n\t}", "label": 3}
{"code": "function processWebRequest(routeInfo, callbacks) {\n    var appName = routeInfo.appName;\n    var serverOnly = !!routeInfo.query.server;\n    var page = injector.loadModule('app/' + appName + '/pages/' + routeInfo.name + '.page');\n\n    // get the callbacks\n    var serverPreprocessing = callbacks.serverPreprocessing || function () { return false; };\n    var appAddToModel = callbacks.addToModel || function () {};\n    var pageCacheService = callbacks.pageCacheService || defaultPageCache;\n    var initialModel, cacheKey;\n\n    return getInitialModel(routeInfo, page)\n        .then(function (model) {\n            initialModel = model || {};\n\n            // if the server pre-processing returns true, then return without doing anything\n            // this is because the pre-processor sent a reply to the user already\n            if (serverPreprocessing(routeInfo, page, model)) {\n                return true;\n            }\n\n            //TODO: may be weird edge cases with this. need to test more to ensure performance and uniqueness\n            // but note that we have an hour default timeout for the redis cache just in case\n            // and we have the redis LRU config set up so the least recently used will get pushed out\n            cacheKey = utensils.checksum(routeInfo.lang + '||' + routeInfo.appName + '||' +\n                routeInfo.url + '||' + JSON.stringify(model));\n\n            return pageCacheService.get({ key: cacheKey });\n        })\n        .then(function (cachedPage) {\n            if (cachedPage === true) { return null; }\n            if (cachedPage && !serverOnly) { return cachedPage; }\n\n            // allow the app level to modify the model before rendering\n            appAddToModel(initialModel, routeInfo);\n\n            // finally use the client side plugin to do the rendering\n            return clientPlugin.renderPage(routeInfo, page, initialModel, inlineCssCache[appName + '||' + routeInfo.name]);\n        })\n        .then(function (renderedPage) {\n            if (!serverOnly && renderedPage) {\n                pageCacheService.set({ key: cacheKey, value: renderedPage });\n            }\n\n            return renderedPage;\n        });\n}", "label": 3}
{"code": "public function mutation(\n        $operation,\n        $input,\n        $type,\n        $baseVersion = null\n    ) {\n        // If the given element is an EntityInterface, it will use that baseVersion.\n        if ($input instanceof EntityInterface) {\n            $baseVersion = $input->baseVersion();\n            $data = $this->entityMapper->objectToRequest($input);\n\n            if (!$input->key()) {\n                throw new \\InvalidArgumentException('Base entities must provide a datastore key.');\n            }\n        } elseif ($input instanceof Key) {\n            $data = $input->keyObject();\n        } else {\n            throw new \\InvalidArgumentException(sprintf(\n                'Input must be a Key or Entity, %s given',\n                get_class($input)\n            ));\n        }\n\n        return array_filter([\n            $operation => $data,\n            'baseVersion' => $baseVersion\n        ]);\n    }", "label": 2}
{"code": "public static aaagroup_authorizationpolicy_binding[] get(nitro_service service, String groupname) throws Exception{\n\t\taaagroup_authorizationpolicy_binding obj = new aaagroup_authorizationpolicy_binding();\n\t\tobj.set_groupname(groupname);\n\t\taaagroup_authorizationpolicy_binding response[] = (aaagroup_authorizationpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static String truncate(int n, int smallestDigit, int biggestDigit) {\r\n    int numDigits = biggestDigit - smallestDigit + 1;\r\n    char[] result = new char[numDigits];\r\n    for (int j = 1; j < smallestDigit; j++) {\r\n      n = n / 10;\r\n    }\r\n    for (int j = numDigits - 1; j >= 0; j--) {\r\n      result[j] = Character.forDigit(n % 10, 10);\r\n      n = n / 10;\r\n    }\r\n    return new String(result);\r\n  }", "label": 0}
{"code": "def price_range\n      prices = variants.collect(&:price).collect(&:to_f)\n      format =  \"%0.2f\"\n      if prices.min != prices.max\n        \"#{format % prices.min} - #{format % prices.max}\"\n      else\n        format % prices.min\n      end\n    end", "label": 4}
{"code": "public function registerJob($identifier, $callback)\n    {\n        if (array_key_exists($identifier, $this->identifierToId)) {\n            $idNum = $this->identifierToId[$identifier];\n        } else {\n            $idNum = count($this->identifierToId) + 1;\n            $this->idToIdentifier[$idNum] = $identifier;\n        }\n        $this->jobs[$identifier] = call_user_func(\n            $callback,\n            $idNum\n        );\n        $this->identifierToId[$identifier] = $idNum;\n    }", "label": 2}
{"code": "def find_many(trello_class, path, params = {})\n      response = get(path, params)\n      trello_class.parse_many response do |data|\n        data.client = self\n      end\n    end", "label": 4}
{"code": "private function setLroProperties(\n        LongRunningConnectionInterface $lroConnection,\n        array $lroCallables,\n        $resource = null\n    ) {\n        $this->lroConnection = $lroConnection;\n        $this->lroCallables = $lroCallables;\n        $this->lroResource = $resource;\n    }", "label": 2}
{"code": "function getAssignmentReducedType(declaredType, assignedType) {\n            if (declaredType !== assignedType) {\n                var reducedType = filterType(declaredType, function (t) { return typeMaybeAssignableTo(assignedType, t); });\n                if (reducedType !== neverType) {\n                    return reducedType;\n                }\n            }\n            return declaredType;\n        }", "label": 3}
{"code": "def make_logger(self, level=\"INFO\"):\n        \"\"\"\n        Convenience function which creates a logger for the module.\n\n        INPUTS:\n        level   (default=\"INFO\"):   Minimum log level for logged/streamed messages.\n\n        OUTPUTS:\n        logger                      Logger for the function. NOTE: Must be bound to variable named logger.\n        \"\"\"\n        level = getattr(logging, level.upper())\n\n        logger = logging.getLogger(__name__)\n        logger.setLevel(logging.DEBUG)\n\n        fh = logging.FileHandler('PyMORESANE.log', mode='w')\n        fh.setLevel(level)\n\n        ch = logging.StreamHandler()\n        ch.setLevel(level)\n\n        formatter = logging.Formatter('%(asctime)s [%(levelname)s]: %(''message)s', datefmt='[%m/%d/%Y] [%I:%M:%S]')\n        fh.setFormatter(formatter)\n        ch.setFormatter(formatter)\n\n        logger.addHandler(fh)\n        logger.addHandler(ch)\n\n        return logger", "label": 1}
{"code": "function(context, childPkg){\n\t\tvar curAddress = childPkg.origFileUrl;\n\t\tvar parentAddress = utils.path.parentNodeModuleAddress(childPkg.origFileUrl);\n\t\twhile(parentAddress) {\n\t\t\tvar packageAddress = parentAddress+\"/\"+childPkg.name+\"/package.json\";\n\t\t\tvar parentPkg =\tcontext.paths[packageAddress];\n\t\t\tif(parentPkg && SemVer.valid(parentPkg.version)) {\n\t\t\t\tif(SemVer.satisfies(parentPkg.version, childPkg.version)) {\n\t\t\t\t\treturn parentPkg.fileUrl;\n\t\t\t\t} else {\n\t\t\t\t\treturn curAddress;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentAddress = utils.path.parentNodeModuleAddress(packageAddress);\n\t\t\tcurAddress = packageAddress;\n\t\t}\n\t\treturn curAddress;\n\t}", "label": 3}
{"code": "public function recordFailedJob(JobFailed $event)\n    {\n        if (! Telescope::isRecording()) {\n            return;\n        }\n\n        $uuid = $event->job->payload()['telescope_uuid'] ?? null;\n\n        if (! $uuid) {\n            return;\n        }\n\n        Telescope::recordUpdate(EntryUpdate::make(\n            $uuid, EntryType::JOB, [\n                'status' => 'failed',\n                'exception' => [\n                    'message' => $event->exception->getMessage(),\n                    'trace' => $event->exception->getTrace(),\n                    'line' => $event->exception->getLine(),\n                    'line_preview' => ExceptionContext::get($event->exception),\n                ],\n            ]\n        )->addTags(['failed']));\n    }", "label": 2}
{"code": "public static policydataset_value_binding[] get(nitro_service service, String name) throws Exception{\n\t\tpolicydataset_value_binding obj = new policydataset_value_binding();\n\t\tobj.set_name(name);\n\t\tpolicydataset_value_binding response[] = (policydataset_value_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function readStanza()\n    {\n        $buff = '';\n\n        if ($this->isConnected()) {\n            $header = @socket_read($this->socket, 3); //read stanza header\n           // if($header !== false && strlen($header) > 1){\n\n            if ($header === false) {\n                $this->eventManager()->fire('onClose',\n                    [\n                        $this->phoneNumber,\n                        'Socket EOF',\n                    ]\n                );\n            }\n            if (strlen($header) == 0) {\n                //no data received\n                return;\n            }\n            if (strlen($header) != 3) {\n                throw new ConnectionException('Failed to read stanza header');\n            }\n            $treeLength = (ord($header[0]) & 0x0F) << 16;\n            $treeLength |= ord($header[1]) << 8;\n            $treeLength |= ord($header[2]) << 0;\n\n            //read full length\n            $buff = socket_read($this->socket, $treeLength);\n            //$trlen = $treeLength;\n            $len = strlen($buff);\n            //$prev = 0;\n            while (strlen($buff) < $treeLength) {\n                $toRead = $treeLength - strlen($buff);\n                $buff .= socket_read($this->socket, $toRead);\n                if ($len == strlen($buff)) {\n                    //no new data read, fuck it\n                    break;\n                }\n                $len = strlen($buff);\n            }\n\n            if (strlen($buff) != $treeLength) {\n                throw new ConnectionException('Tree length did not match received length (buff = '.strlen($buff).\" & treeLength = $treeLength)\");\n            }\n            $buff = $header.$buff;\n        }\n\n        return $buff;\n    }", "label": 2}
{"code": "function initContainer(opts) {\n    var apps, appDir;\n\n    container = opts.container;\n\n    // if batch, preload that dir\n    container === 'batch' ?\n        opts.preload.push('batch') :\n        opts.preload.push('middleware');\n\n    if (container === 'webserver') {\n        appDir = path.join(opts.rootDir, '/app');\n        apps = fs.readdirSync(appDir);\n        _.each(apps, function (app) {\n            opts.preload = opts.preload.concat([\n                'app/' + app + '/filters',\n                'app/' + app + '/utils'\n            ]);\n        });\n    }\n\n    init(opts);\n}", "label": 3}
{"code": "private static function coalesceReplacements(array $diff)\n    {\n        $newDiff = [];\n        $c = \\count($diff);\n        for ($i = 0; $i < $c; $i++) {\n            $diffType = $diff[$i]->type;\n            if ($diffType !== DiffElem::TYPE_REMOVE) {\n                $newDiff[] = $diff[$i];\n                continue;\n            }\n\n            $j = $i;\n            while ($j < $c && $diff[$j]->type === DiffElem::TYPE_REMOVE) {\n                $j++;\n            }\n\n            $k = $j;\n            while ($k < $c && $diff[$k]->type === DiffElem::TYPE_ADD) {\n                $k++;\n            }\n\n            if ($j - $i === $k - $j) {\n                $len = $j - $i;\n                for ($n = 0; $n < $len; $n++) {\n                    $newDiff[] = new DiffElem(\n                        DiffElem::TYPE_REPLACE,\n                        $diff[$i + $n]->old,\n                        $diff[$j + $n]->new\n                    );\n                }\n            } else {\n                for (; $i < $k; $i++) {\n                    $newDiff[] = $diff[$i];\n                }\n            }\n\n            /** @psalm-suppress LoopInvalidation */\n            $i = $k - 1;\n        }\n        return $newDiff;\n    }", "label": 2}
{"code": "def clean(rate_limit_time = nil)\n      rate_limit_time ||= Time.now\n\n      @bucket.delete_if do |_, limit_hash|\n        # Time limit has not run out\n        return false if @time_span && rate_limit_time < (limit_hash[:set_time] + @time_span)\n\n        # Delay has not run out\n        return false if @delay && rate_limit_time < (limit_hash[:last_time] + @delay)\n\n        true\n      end\n    end", "label": 4}
{"code": "def get_default_for(prop, value):\n    \"\"\" Ensures complex property types have the correct default values \"\"\"\n\n    prop = prop.strip('_')     # Handle alternate props (leading underscores)\n    val = reduce_value(value)  # Filtering of value happens here\n\n    if prop in _COMPLEX_LISTS:\n        return wrap_value(val)\n    elif prop in _COMPLEX_STRUCTS:\n        return val or {}\n    else:\n        return u'' if val is None else val", "label": 1}
{"code": "func (p *Pod) ExclusiveLockManifest() error {\n\tif p.manifestLock != nil {\n\t\treturn p.manifestLock.ExclusiveLock() // This is idempotent\n\t}\n\n\tl, err := lock.ExclusiveLock(common.PodManifestLockPath(p.Path()), lock.RegFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.manifestLock = l\n\treturn nil\n}", "label": 5}
{"code": "function convert(files) {\n    var converted = []\n    files.forEach(function(file) {\n      // We need originals as the destinations may not yet exist\n      file = file.orig\n      var dest = file.dest\n\n      // Use destination for source if no source is available\n      if (!file.src.length) {\n        converted.push({\n          src: dest,\n          dest: dest\n        })\n        return\n      }\n\n      file.src.forEach(function(source) {\n        converted.push({\n          src: source,\n          dest: dest\n        })\n      })\n    })\n    return converted\n  }", "label": 3}
{"code": "function (expectedClass) {\n            _gpfAssertAttributeClassOnly(expectedClass);\n            var result = new _gpfA.Array();\n            result._array = this._array.filter(function (attribute) {\n                return attribute instanceof expectedClass;\n            });\n            return result;\n        }", "label": 3}
{"code": "def _api_action(url, req, data=None):\n    \"\"\"Take action based on what kind of request is needed.\"\"\"\n    requisite_headers = {'Accept': 'application/json',\n                         'Content-Type': 'application/json'}\n    auth = (user, token)\n\n    if req == \"GET\":\n        response = requests.get(url, headers=requisite_headers, auth=auth)\n    elif req == \"PUT\":\n        response = requests.put(url, headers=requisite_headers, auth=auth,\n                                data=data)\n    elif req == \"POST\":\n        response = requests.post(url, headers=requisite_headers, auth=auth,\n                                 data=data)\n    elif req == \"DELETE\":\n        response = requests.delete(url, headers=requisite_headers, auth=auth)\n\n    return response.status_code, response.text", "label": 1}
{"code": "public static gslbservice_dnsview_binding[] get(nitro_service service, String servicename) throws Exception{\n\t\tgslbservice_dnsview_binding obj = new gslbservice_dnsview_binding();\n\t\tobj.set_servicename(servicename);\n\t\tgslbservice_dnsview_binding response[] = (gslbservice_dnsview_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function findMatch(filters, listener){\n        var handlers = [],\n            isMatch = true;\n\n        if( !_.isUndefined(listener.filters.nodes) && listener.filters.nodes.length > 0 ) {\n            isMatch = !_.isUndefined( _.find( listener.filters.nodes , function(node) {\n                return (node === filters.node || node === '*');\n            } ) );\n        }\n\n        if ( isMatch && !_.isUndefined(listener.filters.types) && listener.filters.types.length > 0 ) {\n            isMatch = !_.isUndefined( _.find( listener.filters.types , function(type) {\n                return (type === filters.type || type === '*');\n            } ) );\n        }\n\n        if( isMatch && !_.isUndefined(listener.filters.contentids) && listener.filters.contentids.length > 0 ) {\n            isMatch = !_.isUndefined( _.find( listener.filters.contentids , function(contentid) {\n                return (contentid === filters.contentid || contentid === '*');\n            } ) );\n        }\n\n        if( isMatch && !_.isUndefined(listener.filters.system) && listener.filters.system.length > 0 ) {\n            isMatch = !_.isUndefined( _.find( listener.filters.system , function(val) {\n                return (val === filters.system || val === '*');\n            } ) );\n        }\n\n        // If we still have a match return handlers attached to the listener\n        if( isMatch ) {\n            handlers = listener.handlers;\n        }\n\n        return handlers;\n    }", "label": 3}
{"code": "def data_attributes(admin_set)\n        # Get permission template associated with this AdminSet (if any)\n        permission_template = PermissionTemplate.find_by(source_id: admin_set.id)\n\n        # Only add data attributes if permission template exists\n        return {} unless permission_template\n        attributes_for(permission_template: permission_template)\n      end", "label": 4}
{"code": "def emit(self, name, *args, **kwargs):\n        \"\"\"Dispatches an event to any subscribed listeners\n\n        Note:\n            If a listener returns :obj:`False`, the event will stop dispatching to\n            other listeners. Any other return value is ignored.\n\n        Args:\n            name (str): The name of the :class:`Event` to dispatch\n            *args (Optional): Positional arguments to be sent to listeners\n            **kwargs (Optional): Keyword arguments to be sent to listeners\n        \"\"\"\n        e = self.__property_events.get(name)\n        if e is None:\n            e = self.__events[name]\n        return e(*args, **kwargs)", "label": 1}
{"code": "public function setSkillsUsed($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Talent\\V4beta1\\Skill::class);\n        $this->skills_used = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public static cacheselector get(nitro_service service, String selectorname) throws Exception{\n\t\tcacheselector obj = new cacheselector();\n\t\tobj.set_selectorname(selectorname);\n\t\tcacheselector response = (cacheselector) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def find_next(start, stop, i2hits):\n    \"\"\"\n    which protein has the best hit, the one to the 'right' or to the 'left?'\n    \"\"\"\n    if start not in i2hits and stop in i2hits:\n        index = stop\n    elif stop not in i2hits and start in i2hits:\n        index = start\n    elif start not in i2hits and stop not in i2hits:\n        index = choice([start, stop])\n        i2hits[index] = [[False]]\n    else:\n        A, B = i2hits[start][0], i2hits[stop][0]\n        if B[10] <= A[10]:\n            index = stop\n        else:\n            index = start\n    if index == start:\n        nstart = start - 1\n        nstop = stop\n    else:\n        nstop = stop + 1\n        nstart = start\n    match = i2hits[index][0]\n    rp = match[-1]\n    return index, nstart, nstop, rp, match", "label": 1}
{"code": "function _copy(val) {\n    const type = $type(val);\n\n    if (type == 'object') {\n        val = _extend({}, val, true);\n    } else if (type == 'array') {\n        val = val.slice(0);\n    }\n\n    return val;\n}", "label": 3}
{"code": "func ReadHostUUID(dataDir string) (string, error) {\n\tout, err := ReadPath(filepath.Join(dataDir, HostUUIDFile))\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn strings.TrimSpace(string(out)), nil\n}", "label": 5}
{"code": "func Extract(r io.Reader, dir string) error {\n\ttarball := tar.NewReader(r)\n\n\tfor {\n\t\theader, err := tarball.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\n\t\tif err := extractFile(tarball, header, dir); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "private void handleSerialAPIGetCapabilitiesResponse(SerialMessage incomingMessage) {\n\t\tlogger.trace(\"Handle Message Serial API Get Capabilities\");\n\n\t\tthis.serialAPIVersion = String.format(\"%d.%d\", incomingMessage.getMessagePayloadByte(0), incomingMessage.getMessagePayloadByte(1));\n\t\tthis.manufactureId = ((incomingMessage.getMessagePayloadByte(2)) << 8) | (incomingMessage.getMessagePayloadByte(3));\n\t\tthis.deviceType = ((incomingMessage.getMessagePayloadByte(4)) << 8) | (incomingMessage.getMessagePayloadByte(5));\n\t\tthis.deviceId = (((incomingMessage.getMessagePayloadByte(6)) << 8) | (incomingMessage.getMessagePayloadByte(7)));\n\t\t\n\t\tlogger.debug(String.format(\"API Version = %s\", this.getSerialAPIVersion()));\n\t\tlogger.debug(String.format(\"Manufacture ID = 0x%x\", this.getManufactureId()));\n\t\tlogger.debug(String.format(\"Device Type = 0x%x\", this.getDeviceType()));\n\t\tlogger.debug(String.format(\"Device ID = 0x%x\", this.getDeviceId()));\n\t\t\n\t\t// Ready to get information on Serial API\t\t\n\t\tthis.enqueue(new SerialMessage(SerialMessage.SerialMessageClass.SerialApiGetInitData, SerialMessage.SerialMessageType.Request, SerialMessage.SerialMessageClass.SerialApiGetInitData, SerialMessage.SerialMessagePriority.High));\n\t}", "label": 0}
{"code": "public static aaapreauthenticationpolicy_binding get(nitro_service service, String name) throws Exception{\n\t\taaapreauthenticationpolicy_binding obj = new aaapreauthenticationpolicy_binding();\n\t\tobj.set_name(name);\n\t\taaapreauthenticationpolicy_binding response = (aaapreauthenticationpolicy_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function(comparator, startingValue)\n  {\n    var cmp = createComparator( comparator || this.comparator, false );\n    var min = startingValue;\n\n    for (var i = 0; i < this.length; i++)\n    {\n      if ( cmp( min, this[i] ) > 0 )\n      {\n        min = this[i];\n      }\n    }\n\n    return min;\n  }", "label": 3}
{"code": "public static linkset get(nitro_service service, String id) throws Exception{\n\t\tlinkset obj = new linkset();\n\t\tobj.set_id(id);\n\t\tlinkset response = (linkset) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function generateQuery(searchParams, cb) {\n  if (searchParams.query ) {\n    searchSubmissions.queryBuilder(searchParams.query, cb);\n  } else {\n    return cb(undefined, buildQuery(searchParams));\n  }\n}", "label": 3}
{"code": "public TransactionImpl getCurrentTransaction()\r\n    {\r\n        TransactionImpl tx = tx_table.get(Thread.currentThread());\r\n        if(tx == null)\r\n        {\r\n            throw new TransactionNotInProgressException(\"Calling method needed transaction, but no transaction found for current thread :-(\");\r\n        }\r\n        return tx;\r\n    }", "label": 0}
{"code": "public static base_response delete(nitro_service client, String fieldname) throws Exception {\n\t\tappfwconfidfield deleteresource = new appfwconfidfield();\n\t\tdeleteresource.fieldname = fieldname;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "public function setInspectTemplate($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\InspectTemplate::class);\n        $this->inspect_template = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def statuses(*args)\n      arguments(args, required: [:user, :repo, :id])\n      params = arguments.params\n      params['accept'] ||= PREVIEW_MEDIA\n\n      statuses = get_request(\"repos/#{arguments.user}/#{arguments.repo}/deployments/#{arguments.id}/statuses\", params)\n      return statuses unless block_given?\n      statuses.each { |status| yield status }\n    end", "label": 4}
{"code": "def itermonthdays(cls, year, month):\n        \"\"\"Similar to itermonthdates but returns day number instead of NepDate object\n        \"\"\"\n        for day in NepCal.itermonthdates(year, month):\n            if day.month == month:\n                yield day.day\n            else:\n                yield 0", "label": 1}
{"code": "@Override\n\tpublic List<String> contentTypes() {\n\t\tList<String> contentTypes = null;\n\t\tfinal HttpServletRequest request = getHttpRequest();\n\n\t\tif (favorParameterOverAcceptHeader) {\n\t\t\tcontentTypes = getFavoredParameterValueAsList(request);\n\t\t} else {\n\t\t\tcontentTypes = getAcceptHeaderValues(request);\n\t\t}\n\n\t\tif (isEmpty(contentTypes)) {\n\t\t\tlogger.debug(\"Setting content types to default: {}.\", DEFAULT_SUPPORTED_CONTENT_TYPES);\n\n\t\t\tcontentTypes = DEFAULT_SUPPORTED_CONTENT_TYPES;\n\t\t}\n\n\t\treturn unmodifiableList(contentTypes);\n\t}", "label": 0}
{"code": "func GetKubeClient(configPath string) (client *kubernetes.Clientset, config *rest.Config, err error) {\n\t// if path to kubeconfig was provided, init config from it\n\tif configPath != \"\" {\n\t\tconfig, err = clientcmd.BuildConfigFromFlags(\"\", configPath)\n\t\tif err != nil {\n\t\t\treturn nil, nil, trace.Wrap(err)\n\t\t}\n\t} else {\n\t\t// otherwise attempt to init as if connecting from cluster\n\t\tconfig, err = rest.InClusterConfig()\n\t\tif err != nil {\n\t\t\treturn nil, nil, trace.Wrap(err)\n\t\t}\n\t}\n\n\tclient, err = kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\treturn client, config, nil\n}", "label": 5}
{"code": "function pauseStreams (streams, options) {\n  if (!Array.isArray(streams)) {\n    // Backwards-compat with old-style streams\n    if (!streams._readableState && streams.pipe) streams = streams.pipe(PassThrough(options))\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\n      throw new Error('Only readable stream can be merged.')\n    }\n    streams.pause()\n  } else {\n    for (let i = 0, len = streams.length; i < len; i++) streams[i] = pauseStreams(streams[i], options)\n  }\n  return streams\n}", "label": 3}
{"code": "def change_password(self, id, new, old=None, change_token=True): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Change a user's password.\n\n        :param id: User ID as an int.\n        :param new: New password as string.\n        :param old: (optional) Old password as string (required if performing action as non-admin).\n        :param change_token: (optional) If bool `True`, also generate a new API token for user.\n        :return: :class:`users.User <users.User>` object\n        :rtype: users.User\n        \"\"\"\n        schema = UserSchema(exclude=('password', 'password_confirm'))\n        resp = self.service.post(self.base+str(id)+'/password/',\n                                  params={'change_token': change_token},\n                                  json={'old': old, 'new': new, 'new_confirm': new})\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "private BytesRef computeMaximumFilteredPayload(String value, BytesRef payload,\n      String filter) {\n    // do magic with filter\n    if (value != null) {\n      if (payload != null) {\n        Float payloadFloat = PayloadHelper.decodeFloat(payload.bytes,\n            payload.offset);\n        Float valueFloat = Float.parseFloat(value);\n        return new BytesRef(\n            PayloadHelper.encodeFloat(Math.max(payloadFloat, valueFloat)));\n      } else {\n        return new BytesRef(PayloadHelper.encodeFloat(Float.parseFloat(value)));\n      }\n    } else {\n      return payload;\n    }\n  }", "label": 0}
{"code": "def dSbr_dV(Yf, Yt, V, buses, branches):\n    \"\"\" Computes the branch power flow vector and the partial derivative of\n        branch power flow w.r.t voltage.\n    \"\"\"\n    nl = len(branches)\n    nb = len(V)\n\n    f = matrix([l.from_bus._i for l in branches])\n    t = matrix([l.to_bus._i for l in branches])\n\n    # Compute currents.\n    If = Yf * V\n    It = Yt * V\n\n    Vnorm = div(V, abs(V))\n\n    diagVf = spdiag(V[f])\n    diagIf = spdiag(If)\n    diagVt = spdiag(V[t])\n    diagIt = spdiag(It)\n    diagV = spdiag(V)\n    diagVnorm = spdiag(Vnorm)\n\n    ibr = range(nl)\n    size = (nl, nb)\n    # Partial derivative of S w.r.t voltage phase angle.\n    dSf_dVa = 1j * (conj(diagIf) *\n        spmatrix(V[f], ibr, f, size) - diagVf * conj(Yf * diagV))\n\n    dSt_dVa = 1j * (conj(diagIt) *\n        spmatrix(V[t], ibr, t, size) - diagVt * conj(Yt * diagV))\n\n    # Partial derivative of S w.r.t. voltage amplitude.\n    dSf_dVm = diagVf * conj(Yf * diagVnorm) + conj(diagIf) * \\\n        spmatrix(Vnorm[f], ibr, f, size)\n\n    dSt_dVm = diagVt * conj(Yt * diagVnorm) + conj(diagIt) * \\\n        spmatrix(Vnorm[t], ibr, t, size)\n\n    # Compute power flow vectors.\n    Sf = mul(V[f], conj(If))\n    St = mul(V[t], conj(It))\n\n    return dSf_dVa, dSf_dVm, dSt_dVa, dSt_dVm, Sf, St", "label": 1}
{"code": "private BytesRef computePayloadFromMappingPayload(MtasParserObject object,\n      List<Map<String, String>> mappingPayloads,\n      Map<String, List<MtasParserObject>> currentList)\n      throws MtasParserException {\n    BytesRef payload = null;\n    for (Map<String, String> mappingPayload : mappingPayloads) {\n      if (mappingPayload.get(MAPPING_VALUE_SOURCE)\n          .equals(MtasParserMapping.SOURCE_STRING)) {\n        if (mappingPayload.get(MAPPING_VALUE_TYPE)\n            .equals(MtasParserMapping.PARSER_TYPE_STRING)\n            && mappingPayload.get(MAPPING_VALUE_TEXT) != null) {\n          BytesRef subpayload = computeMaximumFilteredPayload(\n              mappingPayload.get(MAPPING_VALUE_TEXT), payload, null);\n          payload = (subpayload != null) ? subpayload : payload;\n        }\n        // from objects\n      } else {\n        MtasParserObject[] checkObjects = computeObjectFromMappingValue(object,\n            mappingPayload, currentList);\n        // do checks and updates\n        if (checkObjects != null) {\n          // payload from attribute\n          if (mappingPayload.get(\"type\")\n              .equals(MtasParserMapping.PARSER_TYPE_ATTRIBUTE)) {\n            BytesRef subpayload = computeMaximumFilteredPayload(\n                checkObjects[0].getAttribute(mappingPayload.get(\"name\")),\n                payload, mappingPayload.get(MAPPING_VALUE_FILTER));\n            payload = (subpayload != null) ? subpayload : payload;\n            // payload from text\n          } else if (mappingPayload.get(\"type\")\n              .equals(MtasParserMapping.PARSER_TYPE_TEXT)) {\n            BytesRef subpayload = computeMaximumFilteredPayload(\n                object.getText(), payload,\n                mappingPayload.get(MAPPING_VALUE_FILTER));\n            payload = (subpayload != null) ? subpayload : payload;\n          }\n        }\n      }\n    }\n    return payload;\n  }", "label": 0}
{"code": "public function transaction(array $options = [])\n    {\n        $transaction = $this->operation->beginTransaction([\n            // if empty, force request to encode as {} rather than [].\n            'readWrite' => $this->pluck('transactionOptions', $options, false) ?: (object) []\n        ], $options);\n\n        return new Transaction(\n            $this->operation,\n            $this->projectId,\n            $transaction\n        );\n    }", "label": 2}
{"code": "def user_as_string=(user)\n      # reset both either way\n      self.user_as_model = self.username = nil\n      user.is_a?(::ActiveRecord::Base) ?\n        self.user_as_model = user :\n        self.username = user\n    end", "label": 4}
{"code": "def unescape_form(str)\n      str = str.dup\n      binary_encode(str)\n      str.gsub!(/\\+/, ' ')\n      str.gsub(ESCAPED) { $1.hex.chr }\n    end", "label": 4}
{"code": "function handleError(error) {\n\tconsole.log(`${options.entry} failed.`);\n\tconsole.trace(error);\n\n\tsetTimeout(() => {\n\t\tthrow error;\n\t});\n}", "label": 3}
{"code": "func (args Arguments) Assert(t TestingT, objects ...interface{}) bool {\n\tif h, ok := t.(tHelper); ok {\n\t\th.Helper()\n\t}\n\n\t// get the differences\n\tdiff, diffCount := args.Diff(objects)\n\n\tif diffCount == 0 {\n\t\treturn true\n\t}\n\n\t// there are differences... report them...\n\tt.Logf(diff)\n\tt.Errorf(\"%sArguments do not match.\", assert.CallerInfo())\n\n\treturn false\n\n}", "label": 5}
{"code": "func run(program string) (*model.Package, error) {\n\tf, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilename := f.Name()\n\tdefer os.Remove(filename)\n\tif err := f.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Run the program.\n\tcmd := exec.Command(program, \"-output\", filename)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tf, err = os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Process output.\n\tvar pkg model.Package\n\tif err := gob.NewDecoder(f).Decode(&pkg); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := f.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pkg, nil\n}", "label": 5}
{"code": "function (projectDir)\n  {\n    \"use strict\";\n    const packageJson = readPackageJson(projectDir);\n    const extracted = extractVendors(packageJson);\n\n    return extracted.filter(function (packageName) { return startsWith(packageName, '@deskpro/'); });\n  }", "label": 3}
{"code": "def unsubscribe\n      response = Rdkafka::Bindings.rd_kafka_unsubscribe(@native_kafka)\n      if response != 0\n        raise Rdkafka::RdkafkaError.new(response)\n      end\n    end", "label": 4}
{"code": "public function attachCallback($channel, $callback)\n    {\n        $callbackName = $this->getPrefixKeys().$channel;\n\n        $this->assertCallback($callback);\n        $this->callbacks[$callbackName] = $callback;\n        $this->pubsub->subscribe($channel);\n    }", "label": 2}
{"code": "function(obj, id) {\n            if (!obj) {\n                return;\n            }\n\n            if (typeof obj == 'function') {\n                obj.prototype.__moduleId__ = id;\n                return;\n            }\n\n            if (typeof obj == 'string') {\n                return;\n            }\n\n            obj.__moduleId__ = id;\n        }", "label": 3}
{"code": "function handleUrlSwagger(profile, profileKey) {\n    console.log(chalk`{green [${profileKey}]} Input swagger URL : {cyan ${profile.url}}`);\n    const options = {\n        rejectUnauthorized: false\n    };\n    needle.get(profile.url, options, (err, resp, body) => {\n        if (err) {\n            console.log(chalk`{red Cannot read swagger URL '{bold ${profile.url}}'.}`);\n            console.log(chalk.red(err));\n        } else {\n            handleSwagger(body, profile, profileKey);\n        }\n    });\n}", "label": 3}
{"code": "def launch(self, resource):\n        \"\"\"Launch a new job.\n\n        :param resource: :class:`jobs.Job <jobs.Job>` object\n        :return: :class:`jobs.Job <jobs.Job>` object\n        :rtype: jobs.Job\n        \"\"\"\n        schema = JobSchema(exclude=('id', 'status', 'package_name', 'config_name', 'device_name', 'result_id', 'user_id', 'created', 'updated', 'automatic'))\n        json = self.service.encode(schema, resource)\n\n        schema = JobSchema()\n        resp = self.service.create(self.base, json)\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "public function setPrefixes($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->prefixes = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (process *TeleportProcess) Shutdown(ctx context.Context) {\n\tlocalCtx := process.StartShutdown(ctx)\n\t// wait until parent context closes\n\tselect {\n\tcase <-localCtx.Done():\n\t\tprocess.Debugf(\"Process completed.\")\n\t}\n}", "label": 5}
{"code": "def events_list(self):\n        \"\"\" Returns the events today \"\"\"\n        evt = []\n        evt.extend(events.NEPALI_EVENTS[self.month, self.day])\n        evt.extend(events.ENGLISH_EVENTS[self.en_date.month, self.en_date.day])\n        return evt", "label": 1}
{"code": "func (process *TeleportProcess) closeImportedDescriptors(prefix string) error {\n\tprocess.Lock()\n\tdefer process.Unlock()\n\n\tvar errors []error\n\tfor i := range process.importedDescriptors {\n\t\td := process.importedDescriptors[i]\n\t\tif strings.HasPrefix(d.Type, prefix) {\n\t\t\tprocess.Infof(\"Closing imported but unused descriptor %v %v.\", d.Type, d.Address)\n\t\t\terrors = append(errors, d.File.Close())\n\t\t}\n\t}\n\treturn trace.NewAggregate(errors...)\n}", "label": 5}
{"code": "func (m *DatastoreFileManager) MoveFile(ctx context.Context, src string, dst string) error {\n\tsrcp := m.Path(src)\n\tdstp := m.Path(dst)\n\n\ttask, err := m.FileManager.MoveDatastoreFile(ctx, srcp.String(), m.Datacenter, dstp.String(), m.DatacenterTarget, m.Force)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn m.wait(ctx, task)\n}", "label": 5}
{"code": "function parseDelimitedList(kind, parseElement, considerSemicolonAsDelimiter) {\n            var saveParsingContext = parsingContext;\n            parsingContext |= 1 << kind;\n            var result = [];\n            result.pos = getNodePos();\n            var commaStart = -1; // Meaning the previous token was not a comma\n            while (true) {\n                if (isListElement(kind, /*inErrorRecovery*/ false)) {\n                    result.push(parseListElement(kind, parseElement));\n                    commaStart = scanner.getTokenPos();\n                    if (parseOptional(24 /* CommaToken */)) {\n                        continue;\n                    }\n                    commaStart = -1; // Back to the state where the last token was not a comma\n                    if (isListTerminator(kind)) {\n                        break;\n                    }\n                    // We didn't get a comma, and the list wasn't terminated, explicitly parse\n                    // out a comma so we give a good error message.\n                    parseExpected(24 /* CommaToken */);\n                    // If the token was a semicolon, and the caller allows that, then skip it and\n                    // continue.  This ensures we get back on track and don't result in tons of\n                    // parse errors.  For example, this can happen when people do things like use\n                    // a semicolon to delimit object literal members.   Note: we'll have already\n                    // reported an error when we called parseExpected above.\n                    if (considerSemicolonAsDelimiter && token() === 23 /* SemicolonToken */ && !scanner.hasPrecedingLineBreak()) {\n                        nextToken();\n                    }\n                    continue;\n                }\n                if (isListTerminator(kind)) {\n                    break;\n                }\n                if (abortParsingListOrMoveToNextToken(kind)) {\n                    break;\n                }\n            }\n            // Recording the trailing comma is deliberately done after the previous\n            // loop, and not just if we see a list terminator. This is because the list\n            // may have ended incorrectly, but it is still important to know if there\n            // was a trailing comma.\n            // Check if the last token was a comma.\n            if (commaStart >= 0) {\n                // Always preserve a trailing comma by marking it on the NodeArray\n                result.hasTrailingComma = true;\n            }\n            result.end = getNodeEnd();\n            parsingContext = saveParsingContext;\n            return result;\n        }", "label": 3}
{"code": "private function find_wp_root() {\n\t\tif ( ! empty( $this->config['path'] ) ) {\n\t\t\t$path = $this->config['path'];\n\t\t\tif ( ! Utils\\is_path_absolute( $path ) ) {\n\t\t\t\t$path = getcwd() . '/' . $path;\n\t\t\t}\n\n\t\t\treturn $path;\n\t\t}\n\n\t\tif ( $this->cmd_starts_with( array( 'core', 'download' ) ) ) {\n\t\t\treturn getcwd();\n\t\t}\n\n\t\t$dir = getcwd();\n\n\t\twhile ( is_readable( $dir ) ) {\n\t\t\tif ( file_exists( \"$dir/wp-load.php\" ) ) {\n\t\t\t\treturn $dir;\n\t\t\t}\n\n\t\t\tif ( file_exists( \"$dir/index.php\" ) ) {\n\t\t\t\t$path = self::extract_subdir_path( \"$dir/index.php\" );\n\t\t\t\tif ( ! empty( $path ) ) {\n\t\t\t\t\treturn $path;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$parent_dir = dirname( $dir );\n\t\t\tif ( empty( $parent_dir ) || $parent_dir === $dir ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$dir = $parent_dir;\n\t\t}\n\t}", "label": 2}
{"code": "def delete_by_pattern(pattern, count: DEFAULT_COUNT)\n      result, elapsed = timed do\n        digests = all(pattern: pattern, count: count)\n        batch_delete(digests)\n        digests.size\n      end\n\n      log_info(\"#{__method__}(#{pattern}, count: #{count}) completed in #{elapsed}ms\")\n\n      result\n    end", "label": 4}
{"code": "public void setLabels(Collection<LabelType> labels) {\r\n    this.labels.clear();\r\n    if (labels != null) {\r\n      this.labels.addAll(labels);\r\n    }\r\n  }", "label": 0}
{"code": "def as_json(*args)\n      document = { COLLECTION => collection, ID => id }\n      document.merge!(DATABASE => database) if database\n      document\n    end", "label": 4}
{"code": "func (s *Server) ReadV3(p *Packet) (interface{}, error) {\n\treq := new(RequestReadV3)\n\terr := UnmarshalBinary(p.Payload, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession, err := s.getSession(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.mu.Lock()\n\tfile, ok := session.files[req.Handle]\n\tsession.mu.Unlock()\n\n\tif !ok {\n\t\treturn nil, &Status{Code: StatusInvalidHandle}\n\t}\n\n\tbuf := make([]byte, req.RequiredSize)\n\n\t// Use ReadFull as Read() of an archive io.Pipe may return much smaller chunks,\n\t// such as when we've read a tar header.\n\tn, err := io.ReadFull(file, buf)\n\tif err != nil && n == 0 {\n\t\tif err != io.EOF {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tres := &ReplyReadV3{\n\t\tActualSize: uint32(n),\n\t\tPayload:    buf[:n],\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "protected function whereBeforeSequence($query, EntryQueryOptions $options)\n    {\n        $query->when($options->beforeSequence, function ($query, $beforeSequence) {\n            return $query->where('sequence', '<', $beforeSequence);\n        });\n\n        return $this;\n    }", "label": 2}
{"code": "public void setBooleanAttribute(String name, Boolean value) {\n\t\tensureValue();\n\t\tAttribute attribute = new BooleanAttribute(value);\n\t\tattribute.setEditable(isEditable(name));\n\t\tgetValue().getAllAttributes().put(name, attribute);\n\t}", "label": 0}
{"code": "function getBodyItems (privateKey, currentDate, uid, items) {\n  return {\n    Hlavicka: getHeaderItems(uid, currentDate, items.prvniZaslani, items.overeni),\n    Data: getDataItems(items),\n    KontrolniKody: getFooterItems(privateKey, items)\n  }\n}", "label": 3}
{"code": "def drag_and_drop_by(right_by, down_by)\n      element_call(:wait_for_present) do\n        driver.action\n              .drag_and_drop_by(@element, right_by, down_by)\n              .perform\n      end\n    end", "label": 4}
{"code": "def collect_lints(file, linter_selector, config)\n      begin\n        document = HamlLint::Document.new(File.read(file), file: file, config: config)\n      rescue HamlLint::Exceptions::ParseError => e\n        return [HamlLint::Lint.new(HamlLint::Linter::Syntax.new(config), file,\n                                   e.line, e.to_s, :error)]\n      end\n\n      linter_selector.linters_for_file(file).map do |linter|\n        linter.run(document)\n      end.flatten\n    end", "label": 4}
{"code": "function buildPrefix(depth, bottom) {\n  if (!shouldIndent) {\n    return ''\n  }\n  let prefix = bottom ? BOX_BOTTOM_LEFT : BOX_INTERSECTION\n  let spacing = []\n  let spaceIndex = 0\n  while(spaceIndex < depth) {\n    spacing[spaceIndex] = depths[spaceIndex] && !printJSX ? BOX_VERTICAL : EMPTY\n    spaceIndex++\n  }\n  return printJSX ? spacing.join('') : spacing.join('') + prefix\n}", "label": 3}
{"code": "function(dom_node) {\n\t\t\t\t\t\t\tvar index = get_template_instance_index(getFirstDOMChild(dom_node)),\n\t\t\t\t\t\t\t\tinstance = index >= 0 ? template_instances[index] : false;\n\n\t\t\t\t\t\t\tif(instance) {\n\t\t\t\t\t\t\t\tdelete template_instances[index];\n\t\t\t\t\t\t\t\tinstance.destroy();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}", "label": 3}
{"code": "public void retrieveReference(Object pInstance, String pAttributeName) throws PersistenceBrokerException\n    {\n        if (logger.isDebugEnabled())\n        {\n        \tlogger.debug(\"Retrieving reference named [\"+pAttributeName+\"] on object of type [\"+\n        \t            pInstance.getClass().getName()+\"]\");\n        }\n        ClassDescriptor cld = getClassDescriptor(pInstance.getClass());\n        CollectionDescriptor cod = cld.getCollectionDescriptorByName(pAttributeName);\n        getInternalCache().enableMaterializationCache();\n        // to avoid problems with circular references, locally cache the current object instance\n        Identity oid = serviceIdentity().buildIdentity(pInstance);\n        boolean needLocalRemove = false;\n        if(getInternalCache().doLocalLookup(oid) == null)\n        {\n            getInternalCache().doInternalCache(oid, pInstance, MaterializationCache.TYPE_TEMP);\n            needLocalRemove = true;\n        }\n        try\n        {\n            if (cod != null)\n            {\n                referencesBroker.retrieveCollection(pInstance, cld, cod, true);\n            }\n            else\n            {\n                ObjectReferenceDescriptor ord = cld.getObjectReferenceDescriptorByName(pAttributeName);\n                if (ord != null)\n                {\n                    referencesBroker.retrieveReference(pInstance, cld, ord, true);\n                }\n                else\n                {\n                    throw new PersistenceBrokerException(\"did not find attribute \" + pAttributeName +\n                            \" for class \" + pInstance.getClass().getName());\n                }\n            }\n            // do locally remove the object to avoid problems with object state detection (insert/update),\n            // because objects found in the cache detected as 'old' means 'update'\n            if(needLocalRemove) getInternalCache().doLocalRemove(oid);\n            getInternalCache().disableMaterializationCache();\n        }\n        catch(RuntimeException e)\n        {\n            getInternalCache().doLocalClear();\n            throw e;\n        }\n    }", "label": 0}
{"code": "public static Status from(Set<ServiceReference> serviceReferencesBound, Set<ServiceReference> serviceReferencesHandled) {\n        if (serviceReferencesBound == null && serviceReferencesHandled == null) {\n            throw new IllegalArgumentException(\"Cannot create a status with serviceReferencesBound == null\" +\n                    \"and serviceReferencesHandled == null\");\n        } else if (serviceReferencesBound == null) {\n            throw new IllegalArgumentException(\"Cannot create a status with serviceReferencesBound == null\");\n        } else if (serviceReferencesHandled == null) {\n            throw new IllegalArgumentException(\"Cannot create a status with serviceReferencesHandled == null\");\n        }\n        return new Status(serviceReferencesBound, serviceReferencesHandled);\n    }", "label": 0}
{"code": "def merge_vcfs(vcf_file, merged_mut_file):\n    \"\"\"\n    This module will accept the vcf files for mutect and radia read into memory in a dict object\n    VCF_FILE and will merge the calls.  Merged calls are printed to MERGED_MUT_FILE.\n\n    VCF_FILE is a dict with\n    key : mutation caller (mutect or radia)\n    value : dict with\n            key: (chrom, pos, ref, alt)\n            value: vcf line in list form (split by tab)\n    \"\"\"\n    mutect_keys = set(vcf_file['mutect'].keys())\n    radia_keys = set(vcf_file['radia'].keys())\n    common_keys = radia_keys.intersection(mutect_keys)\n    # Open as append since the header is already written\n    with open(merged_mut_file, 'a') as outfile:\n        for mutation in common_keys:\n            print('\\t'.join(vcf_file['radia'][mutation]), file=outfile)\n    return None", "label": 1}
{"code": "function(keyName, increment) {\n    if (!increment) { increment = 1; }\n    set(this, keyName, (get(this, keyName) || 0)+increment);\n    return get(this, keyName);\n  }", "label": 3}
{"code": "protected function showDebugger(array $output)\n    {\n        $output['queries'] = $this->connection->getQueryLog();\n        $output['input']   = $this->request->all();\n\n        return $output;\n    }", "label": 2}
{"code": "public function setAppProfiles($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Bigtable\\Admin\\V2\\AppProfile::class);\n        $this->app_profiles = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def read_attribute_before_type_cast(name)\n      attr = name.to_s\n      if attributes_before_type_cast.key?(attr)\n        attributes_before_type_cast[attr]\n      else\n        read_raw_attribute(attr)\n      end\n    end", "label": 4}
{"code": "public function getConfigGeneratorClassPath($class, $directoryPath = false)\n    {\n        switch ($class) {\n            case ('models' === $class):\n                $path = config('repository.generator.paths.models', 'Entities');\n                break;\n            case ('repositories' === $class):\n                $path = config('repository.generator.paths.repositories', 'Repositories');\n                break;\n            case ('interfaces' === $class):\n                $path = config('repository.generator.paths.interfaces', 'Repositories');\n                break;\n            case ('presenters' === $class):\n                $path = config('repository.generator.paths.presenters', 'Presenters');\n                break;\n            case ('transformers' === $class):\n                $path = config('repository.generator.paths.transformers', 'Transformers');\n                break;\n            case ('validators' === $class):\n                $path = config('repository.generator.paths.validators', 'Validators');\n                break;\n            case ('controllers' === $class):\n                $path = config('repository.generator.paths.controllers', 'Http\\Controllers');\n                break;\n            case ('provider' === $class):\n                $path = config('repository.generator.paths.provider', 'RepositoryServiceProvider');\n                break;\n            case ('criteria' === $class):\n                $path = config('repository.generator.paths.criteria', 'Criteria');\n                break;\n            default:\n                $path = '';\n        }\n\n        if ($directoryPath) {\n            $path = str_replace('\\\\', '/', $path);\n        } else {\n            $path = str_replace('/', '\\\\', $path);\n        }\n\n\n        return $path;\n    }", "label": 2}
{"code": "public static int Hamming(String first, String second) {\n\n        if (first.length() != second.length())\n            throw new IllegalArgumentException(\"The size of string must be the same.\");\n\n        int diff = 0;\n        for (int i = 0; i < first.length(); i++)\n            if (first.charAt(i) != second.charAt(i))\n                diff++;\n        return diff;\n    }", "label": 0}
{"code": "def remote_read\n      ops = { RECV_MESSAGE => nil }\n      ops[RECV_INITIAL_METADATA] = nil unless @metadata_received\n      batch_result = @call.run_batch(ops)\n      unless @metadata_received\n        @call.metadata = batch_result.metadata\n        @metadata_received = true\n      end\n      get_message_from_batch_result(batch_result)\n    end", "label": 4}
{"code": "def push_pv(self, tokens):\n        \"\"\" Creates and Generator object, populates it with data, finds its Bus\n        and adds it.\n        \"\"\"\n        logger.debug(\"Pushing PV data: %s\" % tokens)\n\n        bus = self.case.buses[tokens[\"bus_no\"]-1]\n\n        g = Generator(bus)\n        g.p = tokens[\"p\"]\n        g.q_max = tokens[\"q_max\"]\n        g.q_min = tokens[\"q_min\"]\n        # Optional parameter\n#        if tokens.has_key(\"status\"):\n#        g.online = tokens[\"status\"]\n\n        self.case.generators.append(g)", "label": 1}
{"code": "public static base_response add(nitro_service client, gslbsite resource) throws Exception {\n\t\tgslbsite addresource = new gslbsite();\n\t\taddresource.sitename = resource.sitename;\n\t\taddresource.sitetype = resource.sitetype;\n\t\taddresource.siteipaddress = resource.siteipaddress;\n\t\taddresource.publicip = resource.publicip;\n\t\taddresource.metricexchange = resource.metricexchange;\n\t\taddresource.nwmetricexchange = resource.nwmetricexchange;\n\t\taddresource.sessionexchange = resource.sessionexchange;\n\t\taddresource.triggermonitor = resource.triggermonitor;\n\t\taddresource.parentsite = resource.parentsite;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def request(verb, path, opts = {}, &block)\n      configure_authentication!(opts)\n      @client.request(verb, path, opts, &block)\n    end", "label": 4}
{"code": "function columnAdjustAdd($type, $k, $xadj, $yadj, $a, $b, $c = 0, $d = 0, $e = 0, $f = 0)\n\t{\n\t\tif ($type === 'Td') {  // xpos,ypos\n\n\t\t\t$a += ($xadj * $k);\n\t\t\t$b -= ($yadj * $k);\n\n\t\t\treturn 'BT ' . sprintf('%.3F %.3F', $a, $b) . ' Td';\n\n\t\t} elseif ($type === 're') {  // xpos,ypos,width,height\n\n\t\t\t$a += ($xadj * $k);\n\t\t\t$b -= ($yadj * $k);\n\n\t\t\treturn sprintf('%.3F %.3F %.3F %.3F', $a, $b, $c, $d) . ' re';\n\n\t\t} elseif ($type === 'l') {  // xpos,ypos,x2pos,y2pos\n\n\t\t\t$a += ($xadj * $k);\n\t\t\t$b -= ($yadj * $k);\n\n\t\t\treturn sprintf('%.3F %.3F l', $a, $b);\n\n\t\t} elseif ($type === 'img') {  // width,height,xpos,ypos\n\n\t\t\t$c += ($xadj * $k);\n\t\t\t$d -= ($yadj * $k);\n\n\t\t\treturn sprintf('q %.3F 0 0 %.3F %.3F %.3F', $a, $b, $c, $d) . ' cm /' . $e;\n\n\t\t} elseif ($type === 'draw') {  // xpos,ypos\n\n\t\t\t$a += ($xadj * $k);\n\t\t\t$b -= ($yadj * $k);\n\n\t\t\treturn sprintf('%.3F %.3F m', $a, $b);\n\n\t\t} elseif ($type === 'bezier') {  // xpos,ypos,x2pos,y2pos,x3pos,y3pos\n\n\t\t\t$a += ($xadj * $k);\n\t\t\t$b -= ($yadj * $k);\n\t\t\t$c += ($xadj * $k);\n\t\t\t$d -= ($yadj * $k);\n\t\t\t$e += ($xadj * $k);\n\t\t\t$f -= ($yadj * $k);\n\n\t\t\treturn sprintf('%.3F %.3F %.3F %.3F %.3F %.3F', $a, $b, $c, $d, $e, $f) . ' c';\n\t\t}\n\t}", "label": 2}
{"code": "def run_car_t_validity_assessment(job, rsem_files, univ_options, reports_options):\n    \"\"\"\n    A wrapper for assess_car_t_validity.\n\n    :param dict rsem_files: Results from running rsem\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict reports_options: Options specific to reporting modules\n    :return: The results of running assess_car_t_validity\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    return job.addChildJobFn(assess_car_t_validity, rsem_files['rsem.genes.results'],\n                             univ_options, reports_options).rv()", "label": 1}
{"code": "function setupConn(connectCfg, options) {\n    var conn = amqp.createConnection(connectCfg, options);\n    conn.on('ready', function() {\n      debug('received ready event from node-amqp');\n      var eventName = 'connection';\n      //Ready event will be emitted when re-connected.\n      //To keep backward compatible, only emit 'connection' event for the first time\n      if (_connection) {\n        eventName = 'reconnect';\n      }\n      _connection = conn;\n      _connection._isClosed = false;\n      self.emit('ready');\n      // wrapped in 'nextTick' for unit test friendliness\n      process.nextTick(function() {\n        debug('going to emit ' + eventName);\n        self.emit(eventName);\n      });\n\n      autoSubscribe();\n      publishCachedMessages();\n      _rpcReplyQ = null;\n      _rpcReplyQName = null;\n      _rpcSubscribed = false;\n      if (_.size(_rpcCallbacks) > 0) {\n        debug('found ' + _.size(_rpcCallbacks) + ' callbacks left after reconnect');\n        //still have callbacks that are waiting for response.However, since we have reconnected, they won't receive the messages\n        _.each(_rpcCallbacks, function(cb) {\n          return cb('connection_error');\n        });\n      }\n      _rpcCallbacks = {};\n    });\n    conn.on('error', function(err) {\n      self.emit('error', err);\n    });\n    conn.on('close', function() {\n      if (_connection) {\n        _connection._isClosed = true;\n      }\n    });\n  }", "label": 3}
{"code": "public static Chart getMSDLineWithActiveTransportModelChart(Trajectory t, int lagMin,\n\t\t\tint lagMax, double timelag, double diffusionCoefficient, double velocity) {\n\n\t\tdouble[] xData = new double[lagMax - lagMin + 1];\n\t\tdouble[] yData = new double[lagMax - lagMin + 1];\n\t\tdouble[] modelData = new double[lagMax - lagMin + 1];\n\t\tMeanSquaredDisplacmentFeature msdeval = new MeanSquaredDisplacmentFeature(\n\t\t\t\tt, lagMin);\n\t\tmsdeval.setTrajectory(t);\n\t\tmsdeval.setTimelag(lagMin);\n\t\tfor (int i = lagMin; i < lagMax + 1; i++) {\n\t\t\tmsdeval.setTimelag(i);\n\t\t\tdouble msdhelp = msdeval.evaluate()[0];\n\t\t\txData[i - lagMin] = i;\n\t\t\tyData[i - lagMin] = msdhelp;\n\t\t\tmodelData[i - lagMin] = Math.pow(velocity*(i*timelag), 2) + 4*diffusionCoefficient*(i*timelag);//4 * D * Math.pow(i * timelag, a);\n\t\t}\n\n\t\t// Create Chart\n\t\tChart chart = QuickChart.getChart(\"MSD Line\", \"LAG\", \"MSD\", \"MSD\",\n\t\t\t\txData, yData);\n\t\tchart.addSeries(\"y=4*D*t + (v*t)^2\", xData, modelData);\n\n\t\t// Show it\n\t\t//new SwingWrapper(chart).displayChart();\n\t\treturn chart;\n\t}", "label": 0}
{"code": "public function isSameUnit($unit, $date = null)\n    {\n        $units = [\n            // @call isSameUnit\n            'year' => 'Y',\n            // @call isSameUnit\n            'week' => 'o-W',\n            // @call isSameUnit\n            'day' => 'Y-m-d',\n            // @call isSameUnit\n            'hour' => 'Y-m-d H',\n            // @call isSameUnit\n            'minute' => 'Y-m-d H:i',\n            // @call isSameUnit\n            'second' => 'Y-m-d H:i:s',\n            // @call isSameUnit\n            'micro' => 'Y-m-d H:i:s.u',\n            // @call isSameUnit\n            'microsecond' => 'Y-m-d H:i:s.u',\n        ];\n\n        if (!isset($units[$unit])) {\n            if (isset($this->$unit)) {\n                $date = $date ? static::instance($date) : static::now($this->tz);\n\n                static::expectDateTime($date);\n\n                return $this->$unit === $date->$unit;\n            }\n\n            if ($this->localStrictModeEnabled ?? static::isStrictModeEnabled()) {\n                throw new InvalidArgumentException(\"Bad comparison unit: '$unit'\");\n            }\n\n            return false;\n        }\n\n        return $this->isSameAs($units[$unit], $date);\n    }", "label": 2}
{"code": "public boolean classifyDocumentStdin(DocumentReaderAndWriter<IN> readerWriter)\r\n    throws IOException\r\n  {\r\n    BufferedReader is = new BufferedReader(new InputStreamReader(System.in, flags.inputEncoding));\r\n    String line;\r\n    String text = \"\";\r\n    String eol = \"\\n\";\r\n    String sentence = \"<s>\";\r\n    int blankLines = 0;\r\n    while ((line = is.readLine()) != null) {\r\n      if (line.trim().equals(\"\")) {\r\n    \t  ++blankLines;\r\n    \t  if (blankLines > 3) {\r\n    \t\t  return false;\r\n    \t  } else if (blankLines > 2) {\r\n\t\t\t  ObjectBank<List<IN>> documents = makeObjectBankFromString(text, readerWriter);\r\n\t    \t  classifyAndWriteAnswers(documents, readerWriter);\r\n    \t\t  text = \"\";\r\n    \t  } else {\r\n    \t\t  text += sentence + eol;\r\n    \t  }\r\n      } else {\r\n    \t  text += line + eol;\r\n    \t  blankLines = 0;\r\n      }\r\n    }\r\n    // Classify last document before input stream end\r\n    if (text.trim() != \"\") {\r\n      ObjectBank<List<IN>> documents = makeObjectBankFromString(text, readerWriter);\r\n  \t  classifyAndWriteAnswers(documents, readerWriter);\r\n    }\r\n    return (line == null); // reached eol\r\n  }", "label": 0}
{"code": "def add(after_hook = nil, &block)\n      if block_given?\n        @after_hooks << block\n      elsif after_hook.respond_to? :call\n        @after_hooks << after_hook\n      else\n        raise ArgumentError, 'expected block or object responding to #call'\n      end\n    end", "label": 4}
{"code": "function (chord) {\n  var noteRegex = '[A-Ga-g][#b]{0,2}';\n  var root = chord.match(new RegExp('^' + noteRegex))[0];\n  var bass = null;\n  var symbol;\n\n  root = note.create(root);\n\n  // Strip note, strip spaces, strip bass\n  symbol = chord.replace(/[\\s]/g, '')\n                .replace(new RegExp('^' + noteRegex), '')\n                .replace(new RegExp('/' + noteRegex + '$'), '');\n\n  bass = chord.match(new RegExp('/' + noteRegex + '$'));\n  if (bass) bass = note.create(bass[0].slice(1));\n\n  return { root: root, symbol: symbol, bass: bass };\n}", "label": 3}
{"code": "public void removeMapping(K key, V value) {\r\n    if (treatCollectionsAsImmutable) {\r\n      Collection<V> c = map.get(key);\r\n      if (c != null) {\r\n        Collection<V> newC = cf.newCollection();\r\n        newC.addAll(c);\r\n        newC.remove(value);\r\n        map.put(key, newC);\r\n      }\r\n\r\n    } else {\r\n      Collection<V> c = get(key);\r\n      c.remove(value);\r\n    }\r\n  }", "label": 0}
{"code": "public Object getRealSubject() throws PersistenceBrokerException\r\n\t{\r\n\t\tif (_realSubject == null)\r\n\t\t{\r\n\t\t\tbeforeMaterialization();\r\n\t\t\t_realSubject = materializeSubject();\r\n\t\t\tafterMaterialization();\r\n\t\t}\r\n\t\treturn _realSubject;\r\n\t}", "label": 0}
{"code": "function ensureTrailingDirectorySeparator(path) {\n        if (path.charAt(path.length - 1) !== ts.directorySeparator) {\n            return path + ts.directorySeparator;\n        }\n        return path;\n    }", "label": 3}
{"code": "public static base_responses add(nitro_service client, clusterinstance resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tclusterinstance addresources[] = new clusterinstance[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new clusterinstance();\n\t\t\t\taddresources[i].clid = resources[i].clid;\n\t\t\t\taddresources[i].deadinterval = resources[i].deadinterval;\n\t\t\t\taddresources[i].hellointerval = resources[i].hellointerval;\n\t\t\t\taddresources[i].preemption = resources[i].preemption;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def checkup_git_repos_legacy(repos, base_dir='~/repos',\n                             verbose=False, prefix='', postfix=''):\n    '''Checkout or update git repos.\n\n    repos must be a list of dicts each with an url and optional with a name\n    value.\n    '''\n    run(flo('mkdir -p {base_dir}'))\n    for repo in repos:\n        cur_base_dir = repo.get('base_dir', base_dir)\n        checkup_git_repo_legacy(url=repo['url'], name=repo.get('name', None),\n                                base_dir=cur_base_dir, verbose=verbose,\n                                prefix=prefix, postfix=postfix)", "label": 1}
{"code": "public function setSurpriseLikelihood($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Vision\\V1\\Likelihood::class);\n        $this->surprise_likelihood = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function getOutput()\n    {\n        if (!$this->output) {\n            if ($output = $this['output']) {\n                $this->output = $this->shapeFor($output);\n            } else {\n                $this->output = new StructureShape([], $this->shapeMap);\n            }\n        }\n\n        return $this->output;\n    }", "label": 2}
{"code": "private function searchByPost()\n    {\n        return static function (callable $handler) {\n            return function (\n                CommandInterface $c,\n                RequestInterface $r = null\n            ) use ($handler) {\n                if ($c->getName() !== 'Search') {\n                    return $handler($c, $r);\n                }\n                return $handler($c, self::convertGetToPost($r));\n            };\n        };\n    }", "label": 2}
{"code": "def process_webhooks(webhooks)\n      webhooks.each do |element|\n        webhook = Webhook.new(element, @bot)\n        @webhooks[webhook.id] = webhook\n      end\n    end", "label": 4}
{"code": "func ConfigLocalScopeDefaultNetworks(defaultAddressPool []*NetworkToSplit) error {\n\tif defaultAddressPool == nil {\n\t\treturn nil\n\t}\n\treturn configDefaultNetworks(defaultAddressPool, &PredefinedLocalScopeDefaultNetworks)\n}", "label": 5}
{"code": "public function setEntityTypes($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dialogflow\\V2\\EntityType::class);\n        $this->entity_types = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public static appfwjsoncontenttype[] get(nitro_service service, String jsoncontenttypevalue[]) throws Exception{\n\t\tif (jsoncontenttypevalue !=null && jsoncontenttypevalue.length>0) {\n\t\t\tappfwjsoncontenttype response[] = new appfwjsoncontenttype[jsoncontenttypevalue.length];\n\t\t\tappfwjsoncontenttype obj[] = new appfwjsoncontenttype[jsoncontenttypevalue.length];\n\t\t\tfor (int i=0;i<jsoncontenttypevalue.length;i++) {\n\t\t\t\tobj[i] = new appfwjsoncontenttype();\n\t\t\t\tobj[i].set_jsoncontenttypevalue(jsoncontenttypevalue[i]);\n\t\t\t\tresponse[i] = (appfwjsoncontenttype) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "def host=(new_host)\n      if new_host && !new_host.respond_to?(:to_str)\n        raise TypeError, \"Can't convert #{new_host.class} into String.\"\n      end\n      @host = new_host ? new_host.to_str : nil\n\n      # Reset dependent values\n      remove_instance_variable(:@authority) if defined?(@authority)\n      remove_instance_variable(:@normalized_host) if defined?(@normalized_host)\n      remove_composite_values\n\n      # Ensure we haven't created an invalid URI\n      validate()\n    end", "label": 4}
{"code": "private static function classify_token( $token ) {\n\t\t$param = array();\n\n\t\tlist( $param['optional'], $token )  = self::is_optional( $token );\n\t\tlist( $param['repeating'], $token ) = self::is_repeating( $token );\n\n\t\t$p_name  = '([a-z-_0-9]+)';\n\t\t$p_value = '([a-zA-Z-_|,0-9]+)';\n\n\t\tif ( '--<field>=<value>' === $token ) {\n\t\t\t$param['type'] = 'generic';\n\t\t} elseif ( preg_match( \"/^<($p_value)>$/\", $token, $matches ) ) {\n\t\t\t$param['type'] = 'positional';\n\t\t\t$param['name'] = $matches[1];\n\t\t} elseif ( preg_match( \"/^--(?:\\\\[no-\\\\])?$p_name/\", $token, $matches ) ) {\n\t\t\t$param['name'] = $matches[1];\n\n\t\t\t$value = substr( $token, strlen( $matches[0] ) );\n\n\t\t\t// substr returns false <= PHP 5.6, and '' PHP 7+\n\t\t\tif ( false === $value || '' === $value ) {\n\t\t\t\t$param['type'] = 'flag';\n\t\t\t} else {\n\t\t\t\t$param['type'] = 'assoc';\n\n\t\t\t\tlist( $param['value']['optional'], $value ) = self::is_optional( $value );\n\n\t\t\t\tif ( preg_match( \"/^=<$p_value>$/\", $value, $matches ) ) {\n\t\t\t\t\t$param['value']['name'] = $matches[1];\n\t\t\t\t} else {\n\t\t\t\t\t$param = array(\n\t\t\t\t\t\t'type' => 'unknown',\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$param['type'] = 'unknown';\n\t\t}\n\n\t\treturn $param;\n\t}", "label": 2}
{"code": "def RdatasetsBM(database,host=rbiomart_host):\n    \"\"\"\n    Lists BioMart datasets through a RPY2 connection.\n\n    :param database: a database listed in RdatabasesBM()\n    :param host: address of the host server, default='www.ensembl.org'\n\n    :returns: nothing\n\n    \"\"\"\n    biomaRt = importr(\"biomaRt\")\n    ensemblMart=biomaRt.useMart(database, host=host)\n    print(biomaRt.listDatasets(ensemblMart))", "label": 1}
{"code": "public function distinctOn($property)\n    {\n        if (!is_array($property)) {\n            $property = [$property];\n        }\n\n        foreach ($property as $prop) {\n            $this->query['distinctOn'][] = $this->propertyName($prop);\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "function checksum(str) {\n    crcTbl = crcTbl || makeCRCTable();\n\n    /* jslint bitwise: true */\n    var crc = 0 ^ (-1);\n\n    for (var i = 0; i < str.length; i++) {\n        crc = (crc >>> 8) ^ crcTbl[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n\n    return (crc ^ (-1)) >>> 0;\n}", "label": 3}
{"code": "func New(params legacy.Params) (*BoltBackend, error) {\n\t// look at 'path' parameter, if it's missing use 'data_dir' (default):\n\tpath := params.GetString(\"path\")\n\tif len(path) == 0 {\n\t\tpath = params.GetString(teleport.DataDirParameterName)\n\t}\n\t// still nothing? return an error:\n\tif path == \"\" {\n\t\treturn nil, trace.BadParameter(\"BoltDB backend: 'path' is not set\")\n\t}\n\tif !utils.IsDir(path) {\n\t\treturn nil, trace.BadParameter(\"%v is not a valid directory\", path)\n\t}\n\tpath, err := filepath.Abs(filepath.Join(path, keysBoltFile))\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tdb, err := bolt.Open(path, openFileMode, &bolt.Options{Timeout: openTimeout})\n\tif err != nil {\n\t\tif err == bolt.ErrTimeout {\n\t\t\treturn nil, trace.Errorf(\"Local storage is locked. Another instance is running? (%v)\", path)\n\t\t}\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\t// Wrap the backend in a input sanitizer and return it.\n\treturn &BoltBackend{\n\t\tlocks: make(map[string]time.Time),\n\t\tclock: clockwork.NewRealClock(),\n\t\tdb:    db,\n\t}, nil\n}", "label": 5}
{"code": "static JDOClass getJDOClass(Class c)\r\n\t{\r\n\t\tJDOClass rc = null;\r\n\t\ttry\r\n\t\t{\r\n\t\t\tJavaModelFactory javaModelFactory = RuntimeJavaModelFactory.getInstance();\r\n\t\t\tJavaModel javaModel = javaModelFactory.getJavaModel(c.getClassLoader());\r\n\t\t\tJDOModel m = JDOModelFactoryImpl.getInstance().getJDOModel(javaModel);\r\n\t\t\trc = m.getJDOClass(c.getName());\r\n\t\t}\r\n\t\tcatch (RuntimeException ex)\r\n\t\t{\r\n\t\t\tthrow new JDOFatalInternalException(\"Not a JDO class: \" + c.getName()); \r\n\t\t}\r\n\t\treturn rc;\r\n\t}", "label": 0}
{"code": "function getChalkColors(defaultConfig, overrideConfig) {\r\n\tvar effectiveConfig = Object.assign({}, defaultConfig, overrideConfig);\r\n\r\n\t// make the effectiveConfig understandable to chalk\r\n\t// and return it\r\n\treturn buildChalkFunction(effectiveConfig);\r\n}", "label": 3}
{"code": "func getAllDepTypes() []string {\n\tdepTypes := make([]string, 0, len(cmds))\n\tfor depType := range cmds {\n\t\tdepTypes = append(depTypes, depType)\n\t}\n\tsort.Strings(depTypes)\n\treturn depTypes\n}", "label": 5}
{"code": "def discharge(ctx, id, caveat, key, checker, locator):\n    ''' Creates a macaroon to discharge a third party caveat.\n\n    The given parameters specify the caveat and how it should be checked.\n    The condition implicit in the caveat is checked for validity using checker.\n    If it is valid, a new macaroon is returned which discharges the caveat.\n    The macaroon is created with a version derived from the version that was\n    used to encode the id.\n\n    :param id: (bytes) holds the id to give to the discharge macaroon.\n    If Caveat is empty, then the id also holds the encrypted third party\n    caveat.\n    :param caveat: (bytes) holds the encrypted third party caveat.\n    If this is None, id will be used.\n    :param key: holds the key to use to decrypt the third party caveat\n    information and to encrypt any additional third party caveats returned by\n    the caveat checker.\n    :param checker: used to check the third party caveat, and may also return\n    further caveats to be added to the discharge macaroon.\n    :param locator: used to information on third parties referred to by third\n    party caveats returned by the Checker.\n    '''\n    caveat_id_prefix = []\n    if caveat is None:\n        # The caveat information is encoded in the id itself.\n        caveat = id\n    else:\n        # We've been given an explicit id, so when extra third party\n        # caveats are added, use that id as the prefix\n        # for any more ids.\n        caveat_id_prefix = id\n    cav_info = decode_caveat(key, caveat)\n    cav_info = ThirdPartyCaveatInfo(\n        condition=cav_info.condition,\n        first_party_public_key=cav_info.first_party_public_key,\n        third_party_key_pair=cav_info.third_party_key_pair,\n        root_key=cav_info.root_key,\n        caveat=cav_info.caveat,\n        version=cav_info.version,\n        id=id,\n        namespace=cav_info.namespace\n    )\n    # Note that we don't check the error - we allow the\n    # third party checker to see even caveats that we can't\n    # understand.\n    try:\n        cond, arg = checkers.parse_caveat(cav_info.condition)\n    except ValueError as exc:\n        raise VerificationError(exc.args[0])\n\n    if cond == checkers.COND_NEED_DECLARED:\n        cav_info = cav_info._replace(condition=arg)\n        caveats = _check_need_declared(ctx, cav_info, checker)\n    else:\n        caveats = checker.check_third_party_caveat(ctx, cav_info)\n\n    # Note that the discharge macaroon does not need to\n    # be stored persistently. Indeed, it would be a problem if\n    # we did, because then the macaroon could potentially be used\n    # for normal authorization with the third party.\n    m = Macaroon(\n        cav_info.root_key,\n        id,\n        '',\n        cav_info.version,\n        cav_info.namespace,\n    )\n    m._caveat_id_prefix = caveat_id_prefix\n    if caveats is not None:\n        for cav in caveats:\n            m.add_caveat(cav, key, locator)\n    return m", "label": 1}
{"code": "public static dnspolicy_dnsglobal_binding[] get(nitro_service service, String name) throws Exception{\n\t\tdnspolicy_dnsglobal_binding obj = new dnspolicy_dnsglobal_binding();\n\t\tobj.set_name(name);\n\t\tdnspolicy_dnsglobal_binding response[] = (dnspolicy_dnsglobal_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def _subscribed(self):\n        \"\"\"\n        Called when the subscription was\n        accepted successfully.\n        \"\"\"\n        self.logger.debug('Subscription confirmed.')\n        self.state = 'subscribed'\n        for message in self.message_queue:\n            self.send(message)", "label": 1}
{"code": "protected function recalculateTotal(): void\n    {\n        $this->total = $this->unitsTotal + $this->adjustmentsTotal;\n\n        if ($this->total < 0) {\n            $this->total = 0;\n        }\n\n        if (null !== $this->order) {\n            $this->order->recalculateItemsTotal();\n        }\n    }", "label": 2}
{"code": "func getAvailableFromCurrent(head *sequence, start, curr, end uint64) (uint64, uint64, error) {\n\tvar bytePos, bitPos uint64\n\tvar err error\n\tif curr != 0 && curr > start {\n\t\tbytePos, bitPos, err = getFirstAvailable(head, curr)\n\t\tret := posToOrdinal(bytePos, bitPos)\n\t\tif end < ret || err != nil {\n\t\t\tgoto begin\n\t\t}\n\t\treturn bytePos, bitPos, nil\n\t}\n\nbegin:\n\tbytePos, bitPos, err = getFirstAvailable(head, start)\n\tret := posToOrdinal(bytePos, bitPos)\n\tif end < ret || err != nil {\n\t\treturn invalidPos, invalidPos, ErrNoBitAvailable\n\t}\n\treturn bytePos, bitPos, nil\n}", "label": 5}
{"code": "public function toggleOptions($options, $state = null)\n    {\n        if ($state === null) {\n            $state = ($this->options & $options) !== $options;\n        }\n\n        return $this->setOptions(\n            $state ?\n            $this->options | $options :\n            $this->options & ~$options\n        );\n    }", "label": 2}
{"code": "def get_process_token():\n\t\"\"\"\n\tGet the current process token\n\t\"\"\"\n\ttoken = wintypes.HANDLE()\n\tres = process.OpenProcessToken(\n\t\tprocess.GetCurrentProcess(), process.TOKEN_ALL_ACCESS, token)\n\tif not res > 0:\n\t\traise RuntimeError(\"Couldn't get process token\")\n\treturn token", "label": 1}
{"code": "def attach(attachable)\n      if record.persisted? && !record.changed?\n        record.update(name => attachable)\n      else\n        record.public_send(\"#{name}=\", attachable)\n      end\n    end", "label": 4}
{"code": "def mr(items, targets, **kwargs):\n    \"\"\"Max-Rest\n\n    Complexity O(n^2)\n    \"\"\"\n    bins = [(target, []) for target in targets]\n    skip = []\n\n    for item in items:\n        capacities = [target - sum(content) for target, content in bins]\n        weighted = weight(capacities, **kwargs)\n\n        (target, content), capacity, _ = max(zip(bins, capacities, weighted),\n                                             key=operator.itemgetter(2))\n        if item <= capacity:\n            content.append(item)\n        else:\n            skip.append(item)\n    return bins, skip", "label": 1}
{"code": "public static long count(nitro_service service, String sitename) throws Exception{\n\t\tgslbsite_gslbservice_binding obj = new gslbsite_gslbservice_binding();\n\t\tobj.set_sitename(sitename);\n\t\toptions option = new options();\n\t\toption.set_count(true);\n\t\tgslbsite_gslbservice_binding response[] = (gslbsite_gslbservice_binding[]) obj.get_resources(service,option);\n\t\tif (response != null) {\n\t\t\treturn response[0].__count;\n\t\t}\n\t\treturn 0;\n\t}", "label": 0}
{"code": "func matchRegexp(rx interface{}, str interface{}) bool {\n\n\tvar r *regexp.Regexp\n\tif rr, ok := rx.(*regexp.Regexp); ok {\n\t\tr = rr\n\t} else {\n\t\tr = regexp.MustCompile(fmt.Sprint(rx))\n\t}\n\n\treturn (r.FindStringIndex(fmt.Sprint(str)) != nil)\n\n}", "label": 5}
{"code": "async function getPreferredMcpRegionalSettings(accessToken) {\n    const mcpSettings = await mcpCustomizr.getSettings(accessToken);\n    return mcpSettings.regionalSettings;\n}", "label": 3}
{"code": "public function setDeviceConfigs($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Iot\\V1\\DeviceConfig::class);\n        $this->device_configs = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def gen_top_index(collection, title, template, filename)\n      template = TemplatePage.new(RDoc::Page::FR_INDEX_BODY, template)\n      res = []\n      collection.sort.each do |f|\n        if f.document_self\n          res << { \"classlist\" => CGI.escapeHTML(\"#{MODULE_DIR}/fr_#{f.index_name}.html\"), \"module\" => CGI.escapeHTML(\"#{CLASS_DIR}/#{f.index_name}.html\"),\"name\" => CGI.escapeHTML(f.index_name) }\n        end\n      end\n\n      values = {\n        \"entries\"    => res,\n        'list_title' => CGI.escapeHTML(title),\n        'index_url'  => main_url,\n        'charset'    => @options.charset,\n        'style_url'  => style_url('', @options.css),\n      }\n\n      Puppet::FileSystem.open(filename, nil, \"w:UTF-8\") do |f|\n        template.write_html_on(f, values)\n      end\n    end", "label": 4}
{"code": "def attachment_title(attachment)\n      attachment.title.is_a?(Hash) ? translated_attribute(attachment.title) : attachment.title\n    end", "label": 4}
{"code": "function show(id) {\n    $('#ao' + id).hide();\n    $('#ah' + id).show();\n    var context = $.extend({id: id}, opts);\n    var popup = $(renderTemplate(popupTemplate, context)).hide();\n    popup.find('textarea[name=\"proposal\"]').hide();\n    popup.find('a.by' + by).addClass('sel');\n    var form = popup.find('#cf' + id);\n    form.submit(function(event) {\n      event.preventDefault();\n      addComment(form);\n    });\n    $('#s' + id).after(popup);\n    popup.slideDown('fast', function() {\n      getComments(id);\n    });\n  }", "label": 3}
{"code": "public function setTopics($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\PubSub\\V1\\Topic::class);\n        $this->topics = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "protected function prepareForReturn(CarbonInterface $date)\n    {\n        $date = call_user_func([$this->dateClass, 'make'], $date);\n\n        if ($this->timezone) {\n            $date = $date->setTimezone($this->timezone);\n        }\n\n        return $date;\n    }", "label": 2}
{"code": "public function transform_item_values_to_json( $item ) {\n\t\tforeach ( $this->args['fields'] as $field ) {\n\t\t\t$true_field = $this->find_item_key( $item, $field );\n\t\t\t$value      = is_object( $item ) ? $item->$true_field : $item[ $true_field ];\n\t\t\tif ( is_array( $value ) || is_object( $value ) ) {\n\t\t\t\tif ( is_object( $item ) ) {\n\t\t\t\t\t$item->$true_field = json_encode( $value );\n\t\t\t\t} elseif ( is_array( $item ) ) {\n\t\t\t\t\t$item[ $true_field ] = json_encode( $value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $item;\n\t}", "label": 2}
{"code": "def _get_request_messages(self, request):\n        \"\"\"Parses the request as a json message.\n\n        :param request: a werkzeug request with json data\n        :type request: werkzeug.wrappers.Request\n        :return: The parsed json object\n        :rtype: dict[str, object]\n        \"\"\"\n        data = request.get_data(as_text=True)\n        try:\n            msg = self.json_decoder.decode(data)\n        except Exception:\n            raise ParseError(\"Could not parse request data '{}'\".format(data))\n        if isinstance(msg, list):\n            return msg\n        else:\n            return [msg]", "label": 1}
{"code": "func CryptoRandomHex(len int) (string, error) {\n\trandomBytes := make([]byte, len)\n\tif _, err := rand.Reader.Read(randomBytes); err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn hex.EncodeToString(randomBytes), nil\n}", "label": 5}
{"code": "public function setPages($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::INT32);\n        $this->pages = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "private function convertFilterProps(array $filter)\n    {\n        if (isset($filter['propertyFilter'])) {\n            $operator = $filter['propertyFilter']['op'];\n\n            $constName = PropertyFilterOperator::class . '::' . $operator;\n            if (!defined($constName)) {\n                throw new \\InvalidArgumentException('Invalid operator.');\n            }\n\n            $filter['propertyFilter']['op'] = constant($constName);\n        }\n\n        if (isset($filter['compositeFilter'])) {\n            $filter['compositeFilter']['op'] = CompositeFilterOperator::PBAND;\n\n            foreach ($filter['compositeFilter']['filters'] as &$nested) {\n                $nested = $this->convertFilterProps($nested);\n            }\n        }\n\n        return $filter;\n    }", "label": 2}
{"code": "private void checkSequenceName(FieldDescriptorDef fieldDef, String checkLevel) throws ConstraintException\r\n    {\r\n        if (CHECKLEVEL_NONE.equals(checkLevel))\r\n        {\r\n            return;\r\n        }\r\n\r\n        String autoIncr = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_AUTOINCREMENT);\r\n        String seqName  = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_SEQUENCE_NAME);\r\n\r\n        if ((seqName != null) && (seqName.length() > 0))\r\n        {\r\n            if (!\"ojb\".equals(autoIncr) && !\"database\".equals(autoIncr))\r\n            {\r\n                throw new ConstraintException(\"The field \"+fieldDef.getName()+\" in class \"+fieldDef.getOwner().getName()+\" has sequence-name set though it's autoincrement value is not set to 'ojb'\");\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "private PreparedStatement prepareBatchStatement(String sql)\r\n    {\r\n        String sqlCmd = sql.substring(0, 7);\r\n\r\n        if (sqlCmd.equals(\"UPDATE \") || sqlCmd.equals(\"DELETE \") || (_useBatchInserts && sqlCmd.equals(\"INSERT \")))\r\n        {\r\n            PreparedStatement stmt = (PreparedStatement) _statements.get(sql);\r\n            if (stmt == null)\r\n            {\r\n                // [olegnitz] for JDK 1.2 we need to list both PreparedStatement and Statement\r\n                // interfaces, otherwise proxy.jar works incorrectly\r\n                stmt = (PreparedStatement) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{\r\n                        PreparedStatement.class, Statement.class, BatchPreparedStatement.class},\r\n                        new PreparedStatementInvocationHandler(this, sql, m_jcd));\r\n                _statements.put(sql, stmt);\r\n            }\r\n            return stmt;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }", "label": 0}
{"code": "def run(engine, config)\n      @lints = []\n      @config = config\n      @engine = engine\n      @comment_processor = ControlCommentProcessor.new(self)\n      visit(engine.tree)\n      @lints = @comment_processor.filter_lints(@lints)\n    end", "label": 4}
{"code": "def load(self, fname):\n        \"\"\" loads a ASCII text file grid to self  \"\"\"\n        \n        # get height and width of grid from file\n        self.grid_width = 4\n        self.grid_height = 4\n        \n        # re-read the file and load it\n        self.grid = [[0 for dummy_l in range(self.grid_width)] for dummy_l in range(self.grid_height)]\n        with open(fname, 'r') as f:\n            for row_num, row in enumerate(f):\n                if row.strip('\\n') == '':\n                    break\n                for col_num, col in enumerate(row.strip('\\n')):   \n                    self.set_tile(row_num, col_num, col)", "label": 1}
{"code": "public static int cudnnLRNCrossChannelForward(\n        cudnnHandle handle, \n        cudnnLRNDescriptor normDesc, \n        int lrnMode, \n        Pointer alpha, \n        cudnnTensorDescriptor xDesc, \n        Pointer x, \n        Pointer beta, \n        cudnnTensorDescriptor yDesc, \n        Pointer y)\n    {\n        return checkResult(cudnnLRNCrossChannelForwardNative(handle, normDesc, lrnMode, alpha, xDesc, x, beta, yDesc, y));\n    }", "label": 0}
{"code": "func (m *MockIndex) Ptr(arg0 *int) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Ptr\", arg0)\n}", "label": 5}
{"code": "def single_line_rule_set?(rule)\n      rule.children.all? { |child| child.line == rule.source_range.end_pos.line }\n    end", "label": 4}
{"code": "public function setSingleClusterRouting($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\Admin\\V2\\AppProfile_SingleClusterRouting::class);\n        $this->writeOneof(6, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "function putItAllTogether(serviceInfo, resource, adapter) {\n        var me = this;\n        var debug = this.injector.debug;\n\n        // loop through the methods\n        _.each(resource.methods[serviceInfo.adapterName], function (method) {\n            if (!adapter[method]) {\n                return;\n            }\n\n            // we are going to monkey patch the target method on the adapter, so save the original method\n            var origMethod = adapter[method].bind(adapter);\n            var eventNameBase = {\n                resource: serviceInfo.resourceName,\n                adapter: serviceInfo.adapterName,\n                method: method\n            };\n\n            // create the new service function\n            adapter[method] = function (req) {\n                req = req || {};\n\n                // clean out request\n                _.each(req, function (value, name) {\n                    if (value && value === 'undefined') {\n                        delete req[name];\n                    }\n                });\n\n                // add event for data before anything happens (used only for debugging)\n                if (debug) { me.emitEvent(req, eventNameBase, { type: 'service', timing: 'before' }); }\n\n                // first validate the request\n                return me.validateRequestParams(req, resource, method, serviceInfo.adapterName)\n                    .then(function () {\n\n                        // add event before calling the original method (used only for debugging)\n                        if (debug) { me.emitEvent(req, eventNameBase, { type: 'service', timing: 'before' }); }\n\n                        // call the original target method on the adapter\n                        return origMethod(req);\n                    })\n                    .then(function (res) {\n\n                        // emit event after origin method called; this is what most\n                        // reactors key off of (can be disabled with noemit flag)\n                        if (!req.noemit && !req.multi && method !== 'find') {\n                            var payload = {\n                                caller: req.caller,\n                                inputId: req._id,\n                                targetId: req.targetId,\n                                inputData: req.data,\n                                data: res\n                            };\n                            me.emitEvent(payload, eventNameBase, null);\n                        }\n\n                        // return the response that will go back to the calling client\n                        return res;\n                    });\n            };\n        });\n\n        // so essentially the service is the adapter with each method bulked up with some extra stuff\n        return adapter;\n    }", "label": 3}
{"code": "def status(value = nil)\n      response.status = Rack::Utils.status_code(value) if value\n      response.status\n    end", "label": 4}
{"code": "def parse(self, file_name):\n        \"\"\"\n        Parse entire file and return relevant object.\n\n        :param file_name: File path\n        :type file_name: str\n        :return: Parsed object\n        \"\"\"\n        self.object = self.parsed_class()\n        with open(file_name, encoding='utf-8') as f:\n            self.parse_str(f.read())\n        return self.object", "label": 1}
{"code": "def respond_with(*resources, &block)\n      if self.class.mimes_for_respond_to.empty?\n        raise \"In order to use respond_with, first you need to declare the \" \\\n          \"formats your controller responds to in the class level.\"\n      end\n\n      mimes = collect_mimes_from_class_level\n      collector = ActionController::MimeResponds::Collector.new(mimes, request.variant)\n      block.call(collector) if block_given?\n\n      if format = collector.negotiate_format(request)\n        _process_format(format)\n        options = resources.size == 1 ? {} : resources.extract_options!\n        options = options.clone\n        options[:default_response] = collector.response\n        (options.delete(:responder) || self.class.responder).call(self, resources, options)\n      else\n        raise ActionController::UnknownFormat\n      end\n    end", "label": 4}
{"code": "func newSessionCache(proxyClient auth.ClientI, servers []utils.NetAddr, cipherSuites []uint16) (*sessionCache, error) {\n\tclusterName, err := proxyClient.GetClusterName()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tm, err := ttlmap.New(1024, ttlmap.CallOnExpire(closeContext))\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tcache := &sessionCache{\n\t\tclusterName:  clusterName.GetClusterName(),\n\t\tproxyClient:  proxyClient,\n\t\tcontexts:     m,\n\t\tauthServers:  servers,\n\t\tcloser:       utils.NewCloseBroadcaster(),\n\t\tcipherSuites: cipherSuites,\n\t}\n\t// periodically close expired and unused sessions\n\tgo cache.expireSessions()\n\treturn cache, nil\n}", "label": 5}
{"code": "public static appfwsignatures get(nitro_service service) throws Exception{\n\t\tappfwsignatures obj = new appfwsignatures();\n\t\tappfwsignatures[] response = (appfwsignatures[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "function trace() {\n    var _console5;\n\n    if (LatticeLogs.failFast(LatticeLogs.TRACE)) return;\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    (_console5 = console).trace.apply(_console5, (0, _toConsumableArray2.default)(args.map(LatticeLogs.argMapper)));\n  }", "label": 3}
{"code": "function mergeInner(base, mixin, mergeArrays) {\n    if (base === null || typeof base !== 'object' || Array.isArray(base)) {\n        throw new Error('base must be object');\n    }\n    if (mixin === null || typeof mixin !== 'object' || Array.isArray(mixin)) {\n        throw new Error('mixin must be object');\n    }\n    Object.keys(mixin).forEach((name) => {\n        mergeHelper(base, mixin, name, mergeArrays);\n    });\n}", "label": 3}
{"code": "def stringify_params(conditions)\n      return conditions unless conditions.is_a?(Hash)\n      conditions.each do |k, v|\n        conditions[k] = v.to_s if param_requires_string_conversion?(v)\n      end\n    end", "label": 4}
{"code": "public function databases(array $options = [])\n    {\n        $resultLimit = $this->pluck('resultLimit', $options, false);\n        return new ItemIterator(\n            new PageIterator(\n                function (array $database) {\n                    return $this->database($database['name']);\n                },\n                [$this->connection, 'listDatabases'],\n                $options + ['instance' => $this->name],\n                [\n                    'itemsKey' => 'databases',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "public static dnsnsecrec[] get(nitro_service service, String hostname[]) throws Exception{\n\t\tif (hostname !=null && hostname.length>0) {\n\t\t\tdnsnsecrec response[] = new dnsnsecrec[hostname.length];\n\t\t\tdnsnsecrec obj[] = new dnsnsecrec[hostname.length];\n\t\t\tfor (int i=0;i<hostname.length;i++) {\n\t\t\t\tobj[i] = new dnsnsecrec();\n\t\t\t\tobj[i].set_hostname(hostname[i]);\n\t\t\t\tresponse[i] = (dnsnsecrec) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "def _decode_caveat_v1(key, caveat):\n    '''Decode a base64 encoded JSON id.\n\n    @param key the nacl private key to decode.\n    @param caveat a base64 encoded JSON string.\n    '''\n\n    data = base64.b64decode(caveat).decode('utf-8')\n    wrapper = json.loads(data)\n    tp_public_key = nacl.public.PublicKey(\n        base64.b64decode(wrapper['ThirdPartyPublicKey']))\n    if key.public_key.key != tp_public_key:\n        raise Exception('public key mismatch')  # TODO\n\n    if wrapper.get('FirstPartyPublicKey', None) is None:\n        raise Exception('target service public key not specified')\n\n    # The encrypted string is base64 encoded in the JSON representation.\n    secret = base64.b64decode(wrapper.get('Id'))\n    nonce = base64.b64decode(wrapper.get('Nonce'))\n\n    fp_public_key = nacl.public.PublicKey(base64.b64decode(\n        wrapper.get('FirstPartyPublicKey')))\n\n    box = nacl.public.Box(key.key, fp_public_key)\n    c = box.decrypt(secret, nonce)\n    record = json.loads(c.decode('utf-8'))\n    fp_key = nacl.public.PublicKey(\n        base64.b64decode(wrapper.get('FirstPartyPublicKey')))\n    return ThirdPartyCaveatInfo(\n        condition=record.get('Condition'),\n        first_party_public_key=PublicKey(fp_key),\n        third_party_key_pair=key,\n        root_key=base64.b64decode(record.get('RootKey')),\n        caveat=caveat,\n        id=None,\n        version=VERSION_1,\n        namespace=legacy_namespace()\n    )", "label": 1}
{"code": "function isPathChild(pathA, pathB) {\n  const relPath = relative(normalizePath(pathA), normalizePath(pathB));\n  return relPath === '..';\n}", "label": 3}
{"code": "function addRelationshipToModelMeta(modelName, property, meta) {\n    if (!exports.relationshipsByModel[modelName]) {\n        exports.relationshipsByModel[modelName] = {};\n    }\n    // TODO: investigate why we need to genericize to model (from <T>)\n    exports.relationshipsByModel[modelName][property] = meta;\n}", "label": 3}
{"code": "def _prepare_headers(self, additional_headers=None, **kwargs):\n        \"\"\"Prepare headers for http communication.\n\n        Return dict of header to be used in requests.\n\n        Args:\n            .. versionadded:: 0.3.2\n                **additional_headers**: (optional) Additional headers\n                to be used with request\n\n        Returns:\n            Headers dict. Key and values are string\n\n        \"\"\"\n        user_agent = \"pyseaweed/{version}\".format(version=__version__)\n        headers = {\"User-Agent\": user_agent}\n        if additional_headers is not None:\n            headers.update(additional_headers)\n        return headers", "label": 1}
{"code": "function replacePath (path, keys) {\n  var index = 0;\n\n  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {\n    if (escaped) {\n      return escaped;\n    }\n\n    if (escape) {\n      return '\\\\' + escape;\n    }\n\n    var repeat   = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n\n    keys.push({\n      name:      key || index++,\n      delimiter: prefix || '/',\n      optional:  optional,\n      repeat:    repeat\n    });\n\n    prefix = prefix ? ('\\\\' + prefix) : '';\n    capture = escapeGroup(capture || group || '[^' + (prefix || '\\\\/') + ']+?');\n\n    if (repeat) {\n      capture = capture + '(?:' + prefix + capture + ')*';\n    }\n\n    if (optional) {\n      return '(?:' + prefix + '(' + capture + '))?';\n    }\n\n    // Basic parameter support.\n    return prefix + '(' + capture + ')';\n  }\n\n  return path.replace(PATH_REGEXP, replace);\n}", "label": 3}
{"code": "def from_args(cls, **kwargs):\n        \"\"\"\n        Generates one or more VSGSuite instances from command line arguments.\n\n        :param kwargs:  List of additional keyworded arguments to be passed into the VSGSuite defined in the :meth:`~VSGSuite.make_parser` method.\n        \"\"\"\n        # Create a VSGSuite for each filename on the command line.\n        if kwargs.get('suite_commands', None) == 'generate':\n            filenames = kwargs.pop('configuration_filenames', [])\n            return [cls.from_file(f) for f in filenames]\n\n        # Create a VSGSuit from the target directory and override commands\n        if kwargs.get('suite_commands', None) == 'auto':\n            type = kwargs.get('suite_type', None)\n            return [cls.from_directory('', type, **kwargs)]\n\n        # Create nothing.\n        return []", "label": 1}
{"code": "def installer_for_type(type)\n      case type\n        when TemplateDeclarationType::LOCAL_TEMPLATE\n          return Generamba::LocalInstaller.new\n        when TemplateDeclarationType::REMOTE_TEMPLATE\n          return Generamba::RemoteInstaller.new\n        when TemplateDeclarationType::CATALOG_TEMPLATE\n          return Generamba::CatalogInstaller.new\n        else\n          return nil\n      end\n    end", "label": 4}
{"code": "func PgQueryStrip(query []string, queryComments []string) {\n\tfor i, l := range query {\n\t\tpos := pgQueryStripRE.FindStringIndex(l)\n\t\tif pos != nil {\n\t\t\tquery[i] = l[:pos[0]] + l[pos[1]:]\n\t\t\tqueryComments[i+1] = l[pos[0]:pos[1]]\n\t\t} else {\n\t\t\tqueryComments[i+1] = \"\"\n\t\t}\n\t}\n}", "label": 5}
{"code": "public function setInputConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\AutoMl\\V1beta1\\InputConfig::class);\n        $this->writeOneof(6, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def start_monitoring\n      publish_sdam_event(\n        Monitoring::SERVER_OPENING,\n        Monitoring::Event::ServerOpening.new(address, cluster.topology)\n      )\n      if options[:monitoring_io] != false\n        monitor.run!\n        ObjectSpace.define_finalizer(self, self.class.finalize(monitor))\n      end\n    end", "label": 4}
{"code": "def cms_fragment_render(identifier, page = @cms_page)\n      node = page.fragment_nodes.detect { |n| n.identifier == identifier.to_s }\n      return \"\" unless node\n      node.renderable = true\n      render inline: page.render([node])\n    end", "label": 4}
{"code": "public function delete( $args, $assoc_args ) {\n\n\t\tlist( $alias ) = $args;\n\n\t\t$config = ( ! empty( $assoc_args['config'] ) ? $assoc_args['config'] : '' );\n\n\t\tlist( $config_path, $aliases ) = $this->get_aliases_data( $config, $alias );\n\n\t\t$this->validate_config_file( $config_path );\n\n\t\tif ( empty( $aliases[ $alias ] ) ) {\n\t\t\tWP_CLI::error( \"No alias found with key '{$alias}'.\" );\n\t\t}\n\n\t\tunset( $aliases[ $alias ] );\n\t\t$this->process_aliases( $aliases, $alias, $config_path, 'Deleted' );\n\n\t}", "label": 2}
{"code": "public static base_response add(nitro_service client, cmpaction resource) throws Exception {\n\t\tcmpaction addresource = new cmpaction();\n\t\taddresource.name = resource.name;\n\t\taddresource.cmptype = resource.cmptype;\n\t\taddresource.deltatype = resource.deltatype;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "function getArguments(node) {\n    if (node && node.arguments && node.arguments.length > 0) {\n        return node.arguments;\n    }\n    return [];\n}", "label": 3}
{"code": "def detailed_transition_graph\n      @dtgraph ||= each_with_object(Graph::Labeled.new(size)) do |s, graph|\n        s.gotos.each do |tok, goto|\n          path = if tok.terminal?\n            [tok]\n          else\n            actions_to_reach_reduce(s.ident, tok)\n          end\n          graph.add_vector(s.ident, goto.to_state.ident, path)\n        end\n      end.tap { |graph| graph.start = 0 }.freeze\n    end", "label": 4}
{"code": "function getBindPointForSamplerType(gl, type) {\n    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;        // eslint-disable-line\n    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;  // eslint-disable-line\n    return undefined;\n  }", "label": 3}
{"code": "public function setScheduling($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dataproc\\V1\\JobScheduling::class);\n        $this->scheduling = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def export_results(job, fsid, file_name, univ_options, subfolder=None):\n    \"\"\"\n    Write out a file to a given location. The location can be either a directory on the local\n    machine, or a folder with a bucket on AWS.\n\n    :param str fsid: The file store id for the file to be exported\n    :param str file_name: The name of the file that neeeds to be exported (path to file is also\n           acceptable)\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param str subfolder: A sub folder within the main folder where this data should go\n    :return: None\n    \"\"\"\n    job.fileStore.logToMaster('Exporting %s to output location' % fsid)\n    file_name = os.path.basename(file_name)\n    try:\n        assert univ_options['output_folder'], 'Need a path to a folder to write out files'\n        assert univ_options['storage_location'], 'Need to know where the files need to go. ' + \\\n                                                 'Local or AWS/Azure, etc.'\n    except AssertionError as err:\n        # This isn't a game killer.  Continue the pipeline without erroring out but do inform the\n        # user about it.\n        print('ERROR:', err.message, file=sys.stderr)\n        return\n    if univ_options['output_folder'] == 'NA':\n        output_folder = ''\n    else:\n        output_folder = univ_options['output_folder']\n    output_folder = os.path.join(output_folder, univ_options['patient'])\n    output_folder = os.path.join(output_folder, subfolder) if subfolder else output_folder\n    if univ_options['storage_location'] == 'local':\n        # Handle Local\n        try:\n            # Create the directory if required\n            os.makedirs(output_folder, 0755)\n        except OSError as err:\n            if err.errno != errno.EEXIST:\n                raise\n        output_url = 'file://' + os.path.join(output_folder, file_name)\n    elif univ_options['storage_location'].startswith('aws'):\n        # Handle AWS\n        bucket_name = univ_options['storage_location'].split(':')[-1]\n        output_url = os.path.join('S3://', bucket_name, output_folder.strip('/'), file_name)\n    # Can't do Azure or google yet.\n    else:\n        # TODO: Azure support\n        print(\"Currently doesn't support anything but Local and aws.\")\n        return\n    job.fileStore.exportFile(fsid, output_url)", "label": 1}
{"code": "public static base_responses add(nitro_service client, dnssrvrec resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tdnssrvrec addresources[] = new dnssrvrec[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new dnssrvrec();\n\t\t\t\taddresources[i].domain = resources[i].domain;\n\t\t\t\taddresources[i].target = resources[i].target;\n\t\t\t\taddresources[i].priority = resources[i].priority;\n\t\t\t\taddresources[i].weight = resources[i].weight;\n\t\t\t\taddresources[i].port = resources[i].port;\n\t\t\t\taddresources[i].ttl = resources[i].ttl;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def save_to_disk\n      FileUtils.mkdir_p(File.dirname(answer_file_path))\n\n      write_file(answer_file_path, JSON.pretty_generate(answers))\n    rescue SystemCallError, IOError => e\n      raise PDK::CLI::FatalError, _(\"Unable to write '%{file}': %{msg}\") % {\n        file: answer_file_path,\n        msg:  e.message,\n      }\n    end", "label": 4}
{"code": "func (v *ViewPort) Reset() {\n\tv.limx = 0\n\tv.limy = 0\n\tv.viewx = 0\n\tv.viewy = 0\n}", "label": 5}
{"code": "public DbModule getModule(final String moduleId) {\n        final DbModule dbModule = repositoryHandler.getModule(moduleId);\n\n        if (dbModule == null) {\n            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)\n                    .entity(\"Module \" + moduleId + \" does not exist.\").build());\n        }\n\n        return dbModule;\n    }", "label": 0}
{"code": "def store_current_location\n      return if (devise_controller? && params[:redirect_url].blank?) || !request.format.html?\n\n      value = params[:redirect_url] || request.url\n      store_location_for(:user, value)\n    end", "label": 4}
{"code": "public static function ini(\n        $profile = null,\n        $filename = null,\n        $cacheLimit = self::DEFAULT_CACHE_LIMIT\n    ) {\n        $filename = $filename ?: (self::getHomeDir() . '/.aws/config');\n        $profile = $profile ?: (getenv(self::ENV_PROFILE) ?: 'default');\n\n        return function () use ($profile, $filename, $cacheLimit) {\n            if (!is_readable($filename)) {\n                return self::reject(\"Cannot read configuration from $filename\");\n            }\n            $data = \\Aws\\parse_ini_file($filename, true);\n            if ($data === false) {\n                return self::reject(\"Invalid config file: $filename\");\n            }\n            if (!isset($data[$profile])) {\n                return self::reject(\"'$profile' not found in config file\");\n            }\n            if (!isset($data[$profile]['endpoint_discovery_enabled'])) {\n                return self::reject(\"Required endpoint discovery config values \n                    not present in INI profile '{$profile}' ({$filename})\");\n            }\n\n            return Promise\\promise_for(\n                new Configuration(\n                    $data[$profile]['endpoint_discovery_enabled'],\n                    $cacheLimit\n                )\n            );\n        };\n    }", "label": 2}
{"code": "public ValueContainer[] getCurrentLockingValues(Object o) throws PersistenceBrokerException\r\n    {\r\n        FieldDescriptor[] fields = getLockingFields();\r\n        ValueContainer[] result = new ValueContainer[fields.length];\r\n        for (int i = 0; i < result.length; i++)\r\n        {\r\n            result[i] = new ValueContainer(fields[i].getPersistentField().get(o), fields[i].getJdbcType());\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "public static nshttpparam get(nitro_service service) throws Exception{\n\t\tnshttpparam obj = new nshttpparam();\n\t\tnshttpparam[] response = (nshttpparam[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "protected function findControllerPropertyOptions($name)\n    {\n        $properties = [];\n\n        foreach ($this->getControllerInstance()->{'get'.ucfirst($name)}() as $property) {\n            if (isset($property['options']) && ! $this->optionsApplyToControllerMethod($property['options'])) {\n                continue;\n            }\n\n            unset($property['options']);\n\n            $properties = array_merge_recursive($properties, $property);\n        }\n\n        return $properties;\n    }", "label": 2}
{"code": "public List<FailedEventInvocation> getFailedInvocations() {\n        synchronized (this.mutex) {\n            if (this.failedEvents == null) {\n                return Collections.emptyList();\n            }\n            return Collections.unmodifiableList(this.failedEvents);\n        }\n    }", "label": 0}
{"code": "function (unnormalizedPath) {\n        var path = _gpfPathNormalize(unnormalizedPath);\n        return new Promise(function (resolve) {\n            _gpfNodeFs.exists(path, resolve);\n        })\n            .then(function (exists) {\n                if (exists) {\n                    return _gpfFsNodeFsCallWithPath(\"stat\", path)\n                        .then(function (stats) {\n                            return {\n                                fileName: _gpfNodePath.basename(path),\n                                filePath: _gpfPathNormalize(_gpfNodePath.resolve(path)),\n                                size: stats.size,\n                                createdDateTime: stats.ctime,\n                                modifiedDateTime: stats.mtime,\n                                type: _gpfFsNodeGetType(stats)\n                            };\n                        });\n                }\n                return {\n                    type: _GPF_FS_TYPES.NOT_FOUND\n                };\n            });\n\n    }", "label": 3}
{"code": "def render(self, form=None, **kwargs):\n        \"\"\"\n        Returns a ``HttpResponse`` containing a all needed context data.\n        \"\"\"\n        form = form or self.get_form()\n        context = self.get_context_data(form, **kwargs)\n        return self.render_to_response(context)", "label": 1}
{"code": "func (s *APIServer) upsertReverseTunnel(auth ClientI, w http.ResponseWriter, r *http.Request, p httprouter.Params, version string) (interface{}, error) {\n\tvar req upsertReverseTunnelRawReq\n\tif err := httplib.ReadJSON(r, &req); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttun, err := services.GetReverseTunnelMarshaler().UnmarshalReverseTunnel(req.ReverseTunnel)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tif req.TTL != 0 {\n\t\ttun.SetTTL(s, req.TTL)\n\t}\n\tif err := auth.UpsertReverseTunnel(tun); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn message(\"ok\"), nil\n}", "label": 5}
{"code": "def status(self):\n        \"\"\"\n        Get the container's current status from Docker.\n\n        If the container does not exist (before creation and after removal),\n        the status is ``None``.\n        \"\"\"\n        if not self.created:\n            return None\n        self.inner().reload()\n        return self.inner().status", "label": 1}
{"code": "async function generateFonts (options = {}) {\n  if (!options.fontName) throw new TypeError('Missing fontName argument');\n  if (!options.icons || !Array.isArray(options.icons) || !options.icons.length) { throw new TypeError('Invalid or empty icons argument'); }\n  // Store created tasks to match dependencies.\n  let genTasks = {};\n\n  /**\n   * First, creates tasks for dependent font types.\n   * Then creates task for specified font type and chains it to dependencies promises.\n   * If some task already exists, it reuses it.\n   */\n  const makeGenTask = type => {\n    // If already defined return.\n    if (genTasks[type]) return genTasks[type];\n\n    // Get generator function.\n    const gen = generators[type];\n    // Create dependent functions\n    const depsTasks = (gen.deps || []).map(depType => makeGenTask(depType));\n    const task = Promise.all(depsTasks).then(results =>\n      gen.fn(options, results)\n    );\n\n    genTasks[type] = task;\n    return task;\n  };\n\n  // Make a gen task for each type.\n  const types = ['svg', 'ttf', 'woff', 'woff2'];\n  const tasks = types.map(type => {\n    return makeGenTask(type);\n  });\n\n  const results = await Promise.all(tasks);\n  return zipObject(types, results);\n}", "label": 3}
{"code": "public function getCreateSchemaSql(array $classes)\n    {\n        $schema = $this->getSchemaFromMetadata($classes);\n\n        return $schema->toSql($this->platform);\n    }", "label": 2}
{"code": "def write(self, file):\n        \"\"\" Writes market experiment data to file in ReStructuredText format.\n        \"\"\"\n        # Write environment state data.\n        file.write(\"State\\n\")\n        file.write( (\"-\" * 5) + \"\\n\")\n        self.writeDataTable(file, type=\"state\")\n\n        # Write action data.\n        file.write(\"Action\\n\")\n        file.write( (\"-\" * 6) + \"\\n\")\n        self.writeDataTable(file, type=\"action\")\n\n        # Write reward data.\n        file.write(\"Reward\\n\")\n        file.write( (\"-\" * 6) + \"\\n\")\n        self.writeDataTable(file, type=\"reward\")", "label": 1}
{"code": "def write(pylist, parallel=True):\n        \"\"\"\n        Utility method to spawn a VSGWriter for each element in a collection.\n\n        :param list pylist:   A list of VSG objects (PrProjects, VSGSolutions, etc)\n        :param bool parallel: Flag to enable asynchronous writing.\n        \"\"\"\n        threads = [VSGWriter(o) for o in pylist]\n        if parallel:\n            for t in threads:\n                t.start()\n            for t in threads:\n                t.join()\n        else:\n            for t in threads:\n                t.run()", "label": 1}
{"code": "def write_generator_data(self, file, padding=\"    \"):\n        \"\"\" Write generator data in Graphviz DOT language.\n        \"\"\"\n        attrs = ['%s=\"%s\"' % (k, v) for k, v in self.gen_attr.iteritems()]\n        attr_str = \", \".join(attrs)\n\n        edge_attrs = ['%s=\"%s\"' % (k,v) for k,v in {}.iteritems()]\n        edge_attr_str = \", \".join(edge_attrs)\n\n        for g in self.case.generators:\n            # Generator node.\n            file.write(\"%s%s [%s];\\n\" % (padding, g.name, attr_str))\n\n            # Edge connecting generator and bus.\n            file.write(\"%s%s -> %s [%s];\\n\" % \\\n                       (padding, g.name, g.bus.name, edge_attr_str))", "label": 1}
{"code": "protected function discoverFromSlave(NodeConnectionInterface $connection, FactoryInterface $connectionFactory)\n    {\n        $response = $connection->executeCommand(RawCommand::create('INFO', 'REPLICATION'));\n        $replication = $this->handleInfoResponse($response);\n\n        if ($replication['role'] !== 'slave') {\n            throw new ClientException(\"Role mismatch (expected slave, got master) [$connection]\");\n        }\n\n        $masterConnection = $connectionFactory->create(array(\n            'host' => $replication['master_host'],\n            'port' => $replication['master_port'],\n            'alias' => 'master',\n        ));\n\n        $this->add($masterConnection);\n\n        $this->discoverFromMaster($masterConnection, $connectionFactory);\n    }", "label": 2}
{"code": "def load!(path)\n      return unless defined?(Dotenv::Parser)\n\n      contents = ::File.open(path, \"rb:bom|utf-8\", &:read)\n      parsed   = Dotenv::Parser.call(contents)\n\n      parsed.each do |k, v|\n        next if @env.has_key?(k)\n\n        @env[k] = v\n      end\n      nil\n    end", "label": 4}
{"code": "function isCandidate(modulePath) {\n        modulePath = modulePath || '';\n        var len = modulePath.length;\n        return modulePath.indexOf('/') < 0 && len > 7 &&\n            modulePath.substring(modulePath.length - 7) === 'Service';\n    }", "label": 3}
{"code": "func (f *Fpdf) GetAutoPageBreak() (auto bool, margin float64) {\n\tauto = f.autoPageBreak\n\tmargin = f.bMargin\n\treturn\n}", "label": 5}
{"code": "func (suite *Suite) Require() *require.Assertions {\n\tif suite.require == nil {\n\t\tsuite.require = require.New(suite.T())\n\t}\n\treturn suite.require\n}", "label": 5}
{"code": "function getOptions(merge) {\n\tvar options = {\n\t\troot: null,\n\t\tschemas: {},\n\t\tadd: [],\n\t\tformats: {},\n\t\tfresh: false,\n\t\tmulti: false,\n\t\ttimeout: 5000,\n\t\tcheckRecursive: false,\n\t\tbanUnknownProperties: false,\n\t\tlanguages: {},\n\t\tlanguage: null\n\t};\n\treturn copyProps(options, merge);\n}", "label": 3}
{"code": "def _d2f(self, x):\n        \"\"\" Evaluates the cost Hessian.\n        \"\"\"\n        d2f_dPg2 = lil_matrix((self._ng, 1)) # w.r.t p.u. Pg\n        d2f_dQg2 = lil_matrix((self._ng, 1)) # w.r.t p.u. Qg]\n\n        for i in self._ipol:\n            p_cost = list(self._gn[i].p_cost)\n            d2f_dPg2[i, 0] = polyval(polyder(p_cost, 2),\n                self._Pg.v0[i] * self._base_mva) * self._base_mva**2\n#            for i in ipol:\n#                d2f_dQg2[i] = polyval(polyder(list(gn[i].p_cost), 2),\n#                                      Qg.v0[i] * base_mva) * base_mva**2\n\n        i = r_[range(self._Pg.i1, self._Pg.iN + 1),\n               range(self._Qg.i1, self._Qg.iN + 1)]\n\n        d2f = csr_matrix((vstack([d2f_dPg2, d2f_dQg2]).toarray().flatten(),\n                          (i, i)), shape=(self._nxyz, self._nxyz))\n        return d2f", "label": 1}
{"code": "def run(self):\n        \"\"\" Clears a set of bids and offers.\n        \"\"\"\n        # Compute cleared offer/bid quantities from total dispatched quantity.\n        self._clearQuantities()\n\n        # Compute shift values to add to lam to get desired pricing.\n#        lao, fro, lab, frb = self._first_rejected_last_accepted()\n\n        # Clear offer/bid prices according to auction type.\n        self._clearPrices()\n#        self._clear_prices(lao, fro, lab, frb)\n\n        # Clip cleared prices according to guarantees and limits.\n        self._clipPrices()\n\n        self._logClearances()\n\n        return self.offers, self.bids", "label": 1}
{"code": "def process_email(ctx, param, value):\n    \"\"\"Return an user if it exists.\"\"\"\n    user = User.query.filter(User.email == value).first()\n    if not user:\n        raise click.BadParameter('User with email \\'%s\\' not found.', value)\n    return user", "label": 1}
{"code": "def field_names(options)\n      names = (as_attributes.keys + attribute_names).uniq.sort\n\n      only = Array.wrap(options[:only]).map(&:to_s)\n      except = Array.wrap(options[:except]).map(&:to_s)\n      except |= ['_type'] unless Mongoid.include_type_for_serialization\n\n      if !only.empty?\n        names &= only\n      elsif !except.empty?\n        names -= except\n      end\n      names\n    end", "label": 4}
{"code": "def process_action(ctx, param, value):\n    \"\"\"Return an action if exists.\"\"\"\n    actions = current_app.extensions['invenio-access'].actions\n    if value not in actions:\n        raise click.BadParameter('Action \"%s\" is not registered.', value)\n    return actions[value]", "label": 1}
{"code": "public static long count(nitro_service service, String monitorname) throws Exception{\n\t\tlbmonitor_metric_binding obj = new lbmonitor_metric_binding();\n\t\tobj.set_monitorname(monitorname);\n\t\toptions option = new options();\n\t\toption.set_count(true);\n\t\tlbmonitor_metric_binding response[] = (lbmonitor_metric_binding[]) obj.get_resources(service,option);\n\t\tif (response != null) {\n\t\t\treturn response[0].__count;\n\t\t}\n\t\treturn 0;\n\t}", "label": 0}
{"code": "function (name) {\n  var octave = null;\n\n  name = prepareNoteName(name);\n\n  // Extract octave number if given\n  if (/\\d$/.test(name)) {\n    octave = parseInt(name.slice(-1));\n    name = name.slice(0, -1);\n  } \n\n  // Throw an error for an invalid note name\n  if (!(/^[A-Ga-g](bb|##|[b#n])?$/).test(name)) {\n    throw new Error('Invalid note name:  ' + name);\n  }\n\n  return {\n    letter: name[0].toUpperCase(),\n    acc: name.slice(1) || 'n',\n    octave: octave\n  };\n}", "label": 3}
{"code": "function mergeConfig(loaderConfig) {\n  var defaultConfig = {\n    // Web3\n    provider: 'http://localhost:8545',\n\n    // For deployment\n    from: web3.eth.accounts[0],\n    gasLimit: web3.eth.getBlock(web3.eth.defaultBlock).gasLimit,\n\n    // Specify contract constructor parameters, if any.\n    // constructorParams: {\n    //   ContractOne: [ 'param1_value', 'param2_value' ]\n    // }\n    constructorParams: {},\n\n    // To use deployed contracts instead of redeploying, include contract addresses in config\n    // deployedContracts: {\n    //   ContractOne: '0x...........',\n    //   ContractTwo: '0x...........',\n    // }\n    deployedContracts: {}\n  };\n\n  var mergedConfig = loaderConfig;\n  for (var key in defaultConfig) {\n    if (!mergedConfig.hasOwnProperty(key)) {\n      mergedConfig[key] = defaultConfig[key];\n    }\n  }\n  return mergedConfig;\n}", "label": 3}
{"code": "function spaces(arg1, arg2) {\n    var l, builder = [];\n    if(arg1.constructor === Number) {\n        l = arg1;\n    } else {\n        if(arg1.length == arg2) return arg1;\n        l = arg2 - arg1.length;\n        builder.push(arg1);\n    }\n    while(l-- > 0) builder.push(' ');\n    return builder.join('');\n}", "label": 3}
{"code": "func (l VirtualDeviceList) InsertImg(device *types.VirtualFloppy, img string) *types.VirtualFloppy {\n\tdevice.Backing = &types.VirtualFloppyImageBackingInfo{\n\t\tVirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{\n\t\t\tFileName: img,\n\t\t},\n\t}\n\n\treturn device\n}", "label": 5}
{"code": "def setup_system(self, system, name_from_system='', **kwargs):\n        \"\"\"\n            Set system attribute and do some initialization. Used by System.\n        \"\"\"\n\n        if not self.system:\n            self.system = system\n        name, traits = self._passed_arguments\n        new_name = self.system.get_unique_name(self, name, name_from_system)\n        if not self in self.system.reverse:\n            self.name = new_name\n        self.logger = self.system.logger.getChild('%s.%s' % (self.__class__.__name__, self.name))\n        self.logger.setLevel(self.log_level)\n        if name is None and 'name' in traits:  # Only __setstate__ sets name to None. Default is ''.\n            del traits['name']\n\n        for cname in self.callables:\n            if cname in traits:\n                c = self._postponed_callables[cname] = traits.pop(cname)\n                c.setup_callable_system(self.system)\n            getattr(self, cname).setup_callable_system(self.system)\n\n        if not self.traits_inited():\n            super().__init__(**traits)\n        self.name_changed_event = True\n        self.setup()", "label": 1}
{"code": "def new(attributes = nil, &block)\n      block = _deprecated_scope_block(\"new\", &block)\n      scoping { klass.new(attributes, &block) }\n    end", "label": 4}
{"code": "func MsTables(db XODB, schema string, relkind string) ([]*Table, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`xtype AS type, ` +\n\t\t`name AS table_name ` +\n\t\t`FROM sysobjects ` +\n\t\t`WHERE SCHEMA_NAME(uid) = $1 AND xtype = $2`\n\n\t// run query\n\tXOLog(sqlstr, schema, relkind)\n\tq, err := db.Query(sqlstr, schema, relkind)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer q.Close()\n\n\t// load results\n\tres := []*Table{}\n\tfor q.Next() {\n\t\tt := Table{}\n\n\t\t// scan\n\t\terr = q.Scan(&t.Type, &t.TableName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres = append(res, &t)\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "def authorized(remote_app=None):\n    \"\"\"Authorized handler callback.\"\"\"\n    if remote_app not in current_oauthclient.handlers:\n        return abort(404)\n\n    state_token = request.args.get('state')\n\n    # Verify state parameter\n    try:\n        assert state_token\n        # Checks authenticity and integrity of state and decodes the value.\n        state = serializer.loads(state_token)\n        # Verify that state is for this session, app and that next parameter\n        # have not been modified.\n        assert state['sid'] == _create_identifier()\n        assert state['app'] == remote_app\n        # Store next URL\n        set_session_next_url(remote_app, state['next'])\n    except (AssertionError, BadData):\n        if current_app.config.get('OAUTHCLIENT_STATE_ENABLED', True) or (\n           not(current_app.debug or current_app.testing)):\n            abort(403)\n\n    try:\n        handler = current_oauthclient.handlers[remote_app]()\n    except OAuthException as e:\n        if e.type == 'invalid_response':\n            abort(500)\n        else:\n            raise\n\n    return handler", "label": 1}
{"code": "def build_hash_tree(tree_scope)\n      tree = ActiveSupport::OrderedHash.new\n      id_to_hash = {}\n\n      tree_scope.each do |ea|\n        h = id_to_hash[ea.id] = ActiveSupport::OrderedHash.new\n        (id_to_hash[ea._ct_parent_id] || tree)[ea] = h\n      end\n      tree\n    end", "label": 4}
{"code": "def write_out(input):\n    \"\"\" Callback function to write the output from the script.\n\n    @param input: A tuple containing two things:\n                | 1. None or Tuple of file mode and destination filepath\n                | 2. The output of the jaide command that will be either\n                |    written to sys.stdout or to a file, depending on the\n                |    first index in the tuple.\n                |\n                | If the first index of the tuple *is not* another tuple,\n                | the output will be written to sys.stdout. If the first\n                | index *is* a tuple, that tuple is further broken down\n                | into the mode ('single' for single file or 'multiple'\n                | for one file for each IP), and the destination filepath.\n    @type input: tuple\n\n    @returns: None\n    \"\"\"\n    # peel off the to_file metadata from the output.\n    to_file, output = input\n    if to_file != \"quiet\":\n        try:\n            # split the to_file metadata into it's separate parts.\n            mode, dest_file = to_file\n        except TypeError:\n            # just dump the output if we had an internal problem with getting\n            # the metadata.\n            click.echo(output)\n        else:\n            ip = output.split('device: ')[1].split('\\n')[0].strip()\n            if mode in ['m', 'multiple']:\n                # put the IP in front of the filename if we're writing each\n                # device to its own file.\n                dest_file = path.join(path.split(dest_file)[0], ip + \"_\" +\n                                      path.split(dest_file)[1])\n            try:\n                out_file = open(dest_file, 'a+b')\n            except IOError as e:\n                print(color(\"Could not open output file '%s' for writing. \"\n                            \"Output would have been:\\n%s\" %\n                            (dest_file, output), 'red'))\n                print(color('Here is the error for opening the output file:' +\n                            str(e), 'red'))\n            else:\n                click.echo(output, nl=False, file=out_file)\n                print(color('%s output appended to: %s' % (ip, dest_file)))\n                out_file.close()", "label": 1}
{"code": "public void add(IConverter converter, Object sourceObject,\n\t\t\tTypeReference<?> destinationType, Object convertedObject) {\n\t\tconvertedObjects.put(new ConvertedObjectsKey(converter, sourceObject,\n\t\t\t\tdestinationType), convertedObject);\n\t}", "label": 0}
{"code": "public static base_response unset(nitro_service client, nsdiameter resource, String[] args) throws Exception{\n\t\tnsdiameter unsetresource = new nsdiameter();\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "function getIntervalRunner (context, actions) {\n    return function itervalRunner () {\n        var i = 0;\n        var len = actions.length;\n        var actionData = null;\n\n        for (; i < len; i += 1) {\n            actionData = actions[i];\n            context.executeAction(actionData.action, actionData.params);\n        }\n    };\n}", "label": 3}
{"code": "func InOrder(calls ...*Call) {\n\tfor i := 1; i < len(calls); i++ {\n\t\tcalls[i].After(calls[i-1])\n\t}\n}", "label": 5}
{"code": "def prepend_path(path)\n      self.config = hash_reassoc(config, :paths) do |paths|\n        path = File.expand_path(path, config[:root]).freeze\n        paths.unshift(path)\n      end\n    end", "label": 4}
{"code": "public function setGender($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Language\\V1beta2\\PartOfSpeech_Gender::class);\n        $this->gender = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "private function validateDefaultTypes($type, $value): bool\n    {\n        switch ($type) {\n            case 'string':\n                return is_string($value);\n            case 'boolean':\n                return is_bool($value);\n            case 'integer':\n                return is_int($value);\n            case 'number':\n                return is_numeric($value);\n            case 'object':\n                return is_object($value);\n            case 'array':\n                return $this->validateArrayType($value);\n            case 'scheme':\n                return in_array($value, ['http', 'https', 'ws', 'wss'], true);\n            default:\n                throw new Exception('Invalid type \"' . $type . '\"');\n        }\n    }", "label": 2}
{"code": "def helpers\n      @helpers ||= begin\n        helpers = Module.new\n        all = ActionController::Base.all_helpers_from_path(helpers_paths)\n        ActionController::Base.modules_for_helpers(all).each do |mod|\n          helpers.include(mod)\n        end\n        helpers\n      end\n    end", "label": 4}
{"code": "private function getValueType(array $value)\n    {\n        $keys = array_keys($value);\n        $types = array_values(array_filter($keys, function ($key) {\n            return strpos($key, 'Value') !== false;\n        }));\n\n        if (!empty($types)) {\n            return $types[0];\n        }\n\n        throw new \\RuntimeException('Invalid entity property value given');\n    }", "label": 2}
{"code": "func (this *summaryMetricsSource) cloneLabels(labels map[string]string) map[string]string {\n\tclone := make(map[string]string, len(labels))\n\tfor k, v := range labels {\n\t\tclone[k] = v\n\t}\n\treturn clone\n}", "label": 5}
{"code": "public static base_response Import(nitro_service client, appfwsignatures resource) throws Exception {\n\t\tappfwsignatures Importresource = new appfwsignatures();\n\t\tImportresource.src = resource.src;\n\t\tImportresource.name = resource.name;\n\t\tImportresource.xslt = resource.xslt;\n\t\tImportresource.comment = resource.comment;\n\t\tImportresource.overwrite = resource.overwrite;\n\t\tImportresource.merge = resource.merge;\n\t\tImportresource.sha1 = resource.sha1;\n\t\treturn Importresource.perform_operation(client,\"Import\");\n\t}", "label": 0}
{"code": "public function setOpenUriAction($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\Intent_Message_BasicCard_Button_OpenUriAction::class);\n        $this->open_uri_action = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function build(string $schema): DocumentAST\n    {\n        $document = DocumentAST::fromSource($schema);\n\n        // Node manipulators may be defined on type extensions\n        $document = $this->applyNodeManipulators($document);\n        // After they have been applied, we can safely merge them\n        $document = $this->mergeTypeExtensions($document);\n\n        $document = $this->applyFieldManipulators($document);\n        $document = $this->applyArgManipulators($document);\n\n        $document = $this->addPaginationInfoTypes($document);\n\n        $document = $this->addOrderByTypes($document);\n\n        return $this->addNodeSupport($document);\n    }", "label": 2}
{"code": "function tryRequire(filePath) {\n  let resolvedPath = req.resolve(filePath);\n\n  if (resolvedPath) {\n    return req(resolvedPath);\n  }\n\n  return undefined;\n}", "label": 3}
{"code": "def process_token(self, tok):\n        \"\"\"count comments and non-empty lines that contain code\"\"\"\n        if(tok[0].__str__() in ('Token.Comment.Multiline', 'Token.Comment',\n                'Token.Literal.String.Doc')):\n            self.comments += tok[1].count('\\n')+1\n        elif(tok[0].__str__() in ('Token.Comment.Single')):\n            self.comments += 1\n        elif(self.contains_code and tok[0].__str__().startswith('Token.Text')\n                and tok[1].count(u'\\n')):\n            # start new line\n            self.contains_code = False\n            self.sloc += 1\n        # for c style includes\n        elif(tok[0].__str__() == 'Token.Comment.Preproc' and\n                tok[1].count(u'\\n')):\n            # start new line\n            self.contains_code = False\n            self.sloc += 1\n        elif(tok[0][0] in token_types):\n            self.contains_code = True", "label": 1}
{"code": "def historical_rates(self, date, symbols=None):\n        \"\"\"\n        Get historical rates for any day since `date`.\n\n        :param date: a date\n        :type date: date or str\n        :param symbols: currency symbols to request specific exchange rates.\n        :type symbols: list or tuple\n        :return: the historical rates for any day since `date`.\n        :rtype: dict\n        :raises FixerioException: if any error making a request.\n        \"\"\"\n        try:\n            if isinstance(date, datetime.date):\n                # Convert date to ISO 8601 format.\n                date = date.isoformat()\n\n            symbols = symbols or self.symbols\n            payload = self._create_payload(symbols)\n\n            url = BASE_URL + date\n\n            response = requests.get(url, params=payload)\n\n            response.raise_for_status()\n\n            return response.json()\n        except requests.exceptions.RequestException as ex:\n            raise FixerioException(str(ex))", "label": 1}
{"code": "def split_linear_constraints(A, l, u):\n    \"\"\" Returns the linear equality and inequality constraints.\n    \"\"\"\n    ieq = []\n    igt = []\n    ilt = []\n    ibx = []\n    for i in range(len(l)):\n        if abs(u[i] - l[i]) <= EPS:\n            ieq.append(i)\n        elif (u[i] > 1e10) and (l[i] > -1e10):\n            igt.append(i)\n        elif (l[i] <= -1e10) and (u[i] < 1e10):\n            ilt.append(i)\n        elif (abs(u[i] - l[i]) > EPS) and (u[i] < 1e10) and (l[i] > -1e10):\n            ibx.append(i)\n        else:\n            raise ValueError\n\n    Ae = A[ieq, :]\n    Ai = sparse([A[ilt, :], -A[igt, :], A[ibx, :], -A[ibx, :]])\n    be = u[ieq, :]\n    bi = matrix([u[ilt], -l[igt], u[ibx], -l[ibx]])\n\n    return Ae, be, Ai, bi", "label": 1}
{"code": "def looking_for_pub(self):\n        '''Look for a pub that accepts me and my friends'''\n        if self['pub'] != None:\n            return self.sober_in_pub\n        self.debug('I am looking for a pub')\n        group = list(self.get_neighboring_agents())\n        for pub in self.env.available_pubs():\n            self.debug('We\\'re trying to get into {}: total: {}'.format(pub, len(group)))\n            if self.env.enter(pub, self, *group):\n                self.info('We\\'re all {} getting in {}!'.format(len(group), pub))\n                return self.sober_in_pub", "label": 1}
{"code": "def machine_names_and_options\n      {}.tap do |r|\n        @config.vm.defined_vms.each do |name, subvm|\n          r[name] = subvm.options || {}\n        end\n      end\n    end", "label": 4}
{"code": "public function setUpdate($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Container\\V1\\MasterAuth::class);\n        $this->update = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def params(self):\n        \"\"\"The parameters for this method in a JSON-compatible format\n\n        :rtype: list[dict[str, str]]\n        \"\"\"\n        return [{\"name\": p_name, \"type\": p_type.__name__}\n                for (p_name, p_type) in self.signature.parameter_types]", "label": 1}
{"code": "public static function get_config( $key = null ) {\n\t\tif ( null === $key ) {\n\t\t\treturn self::get_runner()->config;\n\t\t}\n\n\t\tif ( ! isset( self::get_runner()->config[ $key ] ) ) {\n\t\t\tself::warning( \"Unknown config option '$key'.\" );\n\t\t\treturn null;\n\t\t}\n\n\t\treturn self::get_runner()->config[ $key ];\n\t}", "label": 2}
{"code": "function(req, params) {\n    if(!params) {\n      params = URL.parse(req.url, true).query;\n    }\n    var cconfig = this.config.client;\n    var next = params.next || cconfig.default_redirection_url;\n    var url = cconfig.base_url + next;\n    return url;\n  }", "label": 3}
{"code": "def filter_geometry(queryset, **filters):\n    \"\"\"Helper function for spatial lookups filters.\n\n    Provide spatial lookup types as keywords without underscores instead of the\n    usual \"geometryfield__lookuptype\" format.\n    \"\"\"\n    fieldname = geo_field(queryset).name\n    query = {'%s__%s' % (fieldname, k): v for k, v in filters.items()}\n    return queryset.filter(**query)", "label": 1}
{"code": "function (obj, tag) {\n        tag = _.isArray(tag) ? tag.join(',') : tag;\n        tag = !_.isEmpty(tag) ? tag.toLowerCase() : 'default';\n\n        obj.trace = function (message, data) {\n            _logEvent(\"trace\", message, tag, data);\n        };\n\n        obj.debug = function (message, data) {\n            _logEvent(\"debug\", message, tag, data);\n        };\n\n        obj.info = function (message, data) {\n            _logEvent(\"info\", message, tag, data);\n        };\n\n        obj.warn = function (message, data) {\n            _logEvent(\"warn\", message, tag, data);\n        };\n\n        obj.error = function (message, data) {\n            _logEvent(\"error\", message, tag, data);\n        };\n\n        obj.fatal = function (message, data) {\n            _logEvent(\"fatal\", message, tag, data);\n        };\n\n        return obj;\n    }", "label": 3}
{"code": "public Query customizeQuery(Object anObject, PersistenceBroker aBroker, CollectionDescriptor aCod, QueryByCriteria aQuery)\r\n    {\r\n        return aQuery;\r\n    }", "label": 0}
{"code": "def execute_script(script, *args)\n      args.map! do |e|\n        e.is_a?(Element) ? e.wait_until(&:exists?).wd : e\n      end\n\n      wrap_elements_in(self, @driver.execute_script(script, *args))\n    end", "label": 4}
{"code": "def add_chart(chart_type, options={})\n      chart = worksheet_drawing.add_chart(chart_type, options)\n      yield chart if block_given?\n      chart\n    end", "label": 4}
{"code": "public static base_responses delete(nitro_service client, String fieldname[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (fieldname != null && fieldname.length > 0) {\n\t\t\tappfwconfidfield deleteresources[] = new appfwconfidfield[fieldname.length];\n\t\t\tfor (int i=0;i<fieldname.length;i++){\n\t\t\t\tdeleteresources[i] = new appfwconfidfield();\n\t\t\t\tdeleteresources[i].fieldname = fieldname[i];\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "protected function addColumns($data, $row)\n    {\n        foreach ($this->appendColumns as $key => $value) {\n            $value['content'] = Helper::compileContent($value['content'], $data, $row);\n            $data             = Helper::includeInArray($value, $data);\n        }\n\n        return $data;\n    }", "label": 2}
{"code": "func parseDuration(s string) (time.Duration, error) {\n\tif s == \"\" {\n\t\treturn time.Duration(-1), nil\n\t}\n\n\tb, err := strconv.ParseBool(s)\n\n\tswitch {\n\tcase err != nil:\n\t\treturn time.ParseDuration(s)\n\tcase b:\n\t\treturn time.Duration(-1), nil\n\t}\n\n\treturn time.Duration(0), nil\n}", "label": 5}
{"code": "public function setChain($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\V2\\RowFilter_Chain::class);\n        $this->writeOneof(1, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public function apply(AbstractSearch $search, $query)\n    {\n        $query = $this->applyGambits($search, $query);\n\n        if ($query) {\n            $this->applyFulltext($search, $query);\n        }\n    }", "label": 2}
{"code": "def changed_action(mapper, connection, target):\n    \"\"\"Remove the action from cache when an item is updated.\"\"\"\n    action_history = get_history(target, 'action')\n    argument_history = get_history(target, 'argument')\n    owner_history = get_history(\n        target,\n        'user' if isinstance(target, ActionUsers) else\n        'role' if isinstance(target, ActionRoles) else 'role_name')\n\n    if action_history.has_changes() or argument_history.has_changes() \\\n       or owner_history.has_changes():\n        current_access.delete_action_cache(\n            get_action_cache_key(target.action, target.argument))\n        current_access.delete_action_cache(\n            get_action_cache_key(\n                action_history.deleted[0] if action_history.deleted\n                else target.action,\n                argument_history.deleted[0] if argument_history.deleted\n                else target.argument)\n        )", "label": 1}
{"code": "def perform_job(*args)\n      @task_logger.info('Creating job')\n\n      job = @job_class.new(*args)\n      Config.current_job = job\n\n      job.task_id = @task_id\n      job.task_checkpoint # cancelled in the queue?\n\n      run_checkpointing\n\n      @task_logger.info(\"Performing task: #{@task.inspect}\")\n\n      @task.timestamp = Time.now\n      @task.started_at = Time.now\n      @task.checkpoint_time = Time.now\n      @task.save\n\n      result = job.perform\n\n      @task_logger.info('Done')\n      finish_task(:done, result)\n\n    rescue Bosh::Director::TaskCancelled => e\n      log_exception(e)\n      @task_logger.info(\"Task #{@task.id} cancelled\")\n      finish_task(:cancelled, 'task cancelled')\n    rescue Exception => e\n      log_exception(e)\n      @task_logger.error(\"#{e}\\n#{e.backtrace.join(\"\\n\")}\")\n      finish_task(:error, e)\n    end", "label": 4}
{"code": "func (m *Mock) AssertNumberOfCalls(t TestingT, methodName string, expectedCalls int) bool {\n\tif h, ok := t.(tHelper); ok {\n\t\th.Helper()\n\t}\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\tvar actualCalls int\n\tfor _, call := range m.calls() {\n\t\tif call.Method == methodName {\n\t\t\tactualCalls++\n\t\t}\n\t}\n\treturn assert.Equal(t, expectedCalls, actualCalls, fmt.Sprintf(\"Expected number of calls (%d) does not match the actual number of calls (%d).\", expectedCalls, actualCalls))\n}", "label": 5}
{"code": "def calc_coverage(ref, start, end, length, nucs):\n    \"\"\"\n    calculate coverage for positions in range start -> end\n    \"\"\"\n    ref = ref[start - 1:end]\n    bases = 0\n    for pos in ref:\n        for base, count in list(pos.items()):\n            if base in nucs:\n                bases += count\n    return float(bases)/float(length)", "label": 1}
{"code": "public function setAudioEncoding($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Dialogflow\\V2\\OutputAudioEncoding::class);\n        $this->audio_encoding = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function setPages($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\Page::class);\n        $this->pages = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public static function fromArray(array $data)\n    {\n        $models = collect($data)->map(function ($value) {\n            if ($value instanceof Model) {\n                return [$value];\n            } elseif ($value instanceof EloquentCollection) {\n                return $value->flatten();\n            }\n        })->collapse()->filter();\n\n        return $models->map(function ($model) {\n            return FormatModel::given($model);\n        })->all();\n    }", "label": 2}
{"code": "public void addFile(File file) {\n        String name = \"file\";\n        files.put(normalizeDuplicateName(name), file);\n    }", "label": 0}
{"code": "def _process_value(self, value, type):\n        \"\"\"\n        Process a value that will be sent to backend\n\n        :param value: the value to return\n\n        :param type: hint for what sort of value this is\n        :type type: str\n\n        \"\"\"\n\n        if not isinstance(value, six.string_types + (list,)):\n            value = json.dumps(value)\n        return value", "label": 1}
{"code": "function transformToString(xform) {\n\tvar m = xform.matrix,\n\t\ttext = '';\n\tswitch(xform.type) {\n\t\tcase 1: // MATRIX\n\t\t\ttext = 'matrix(' + [m.a, m.b, m.c, m.d, m.e, m.f].join(',') + ')';\n\t\t\tbreak;\n\t\tcase 2: // TRANSLATE\n\t\t\ttext = 'translate(' + m.e + ',' + m.f + ')';\n\t\t\tbreak;\n\t\tcase 3: // SCALE\n\t\t\tif (m.a == m.d) {text = 'scale(' + m.a + ')';}\n\t\t\telse {text = 'scale(' + m.a + ',' + m.d + ')';}\n\t\t\tbreak;\n\t\tcase 4: // ROTATE\n\t\t\tvar cx = 0, cy = 0;\n\t\t\t// this prevents divide by zero\n\t\t\tif (xform.angle != 0) {\n\t\t\t\tvar K = 1 - m.a;\n\t\t\t\tcy = ( K * m.f + m.b*m.e ) / ( K*K + m.b*m.b );\n\t\t\t\tcx = ( m.e - m.b * cy ) / K;\n\t\t\t}\n\t\t\ttext = 'rotate(' + xform.angle + ' ' + cx + ',' + cy + ')';\n\t\t\tbreak;\n\t}\n\treturn text;\n}", "label": 3}
{"code": "public static base_response unset(nitro_service client, snmpmanager resource, String[] args) throws Exception{\n\t\tsnmpmanager unsetresource = new snmpmanager();\n\t\tunsetresource.ipaddress = resource.ipaddress;\n\t\tunsetresource.netmask = resource.netmask;\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "public static Object newInstance(Class target, Class type, Object arg) throws InstantiationException,\r\n                                                                                  IllegalAccessException,\r\n                                                                                  IllegalArgumentException,\r\n                                                                                  InvocationTargetException,\r\n                                                                                  NoSuchMethodException,\r\n                                                                                  SecurityException\r\n    {\r\n        return newInstance(target, new Class[]{ type }, new Object[]{ arg });\r\n    }", "label": 0}
{"code": "function contains(file, pattern, options) {\n  options = _.sanitize(options, {encoding: 'utf-8'});\n  if (!exists(file)) return false;\n  const text = read(file, options);\n  if (_.isRegExp(pattern)) {\n    return !!text.match(pattern);\n  } else {\n    return (text.search(_escapeRegExp(pattern)) !== -1);\n  }\n}", "label": 3}
{"code": "function _path(loc) {\n\tloc = loc || location;\n\treturn loc.pathname + loc.search + loc.hash;\n}", "label": 3}
{"code": "def described_as(self, description, *args):\n        \"\"\" Specify a custom message for the matcher \"\"\"\n        if len(args):\n            description = description.format(*args)\n        self.description = description\n        return self", "label": 1}
{"code": "function extendCell (cell, cellDefinitions) {\n  cell = _.clone(cell)\n  while (cell.extends) {\n    const extendedCell = cellDefinitions[cell.extends]\n    if (!_.isObject(extendedCell)) {\n      throw new Error(`'${cell.extends}' is not a valid model definition`)\n    }\n    delete cell.extends\n    cell = _.defaults(cell, extendedCell)\n  }\n  return cell\n}", "label": 3}
{"code": "def get_action_cache_key(name, argument):\n    \"\"\"Get an action cache key string.\"\"\"\n    tokens = [str(name)]\n    if argument:\n        tokens.append(str(argument))\n    return '::'.join(tokens)", "label": 1}
{"code": "func (c *Counter) SetFreq(prevCount Counter, period time.Duration) {\n\tif period == 0 {\n\t\treturn\n\t}\n\tfreq := float64(c.Count-prevCount.Count) / float64(period/time.Second)\n\tc.Freq = &freq\n}", "label": 5}
{"code": "def move(self):\n        \"\"\"Move directory from working directory to output directory.\"\"\"\n        if not os.path.isdir(self.outdir):\n            os.makedirs(self.outdir)\n        shutil.move(self.tmpdir, os.path.join(self.outdir, self.name))", "label": 1}
{"code": "public static dnsaaaarec[] get(nitro_service service) throws Exception{\n\t\tdnsaaaarec obj = new dnsaaaarec();\n\t\tdnsaaaarec[] response = (dnsaaaarec[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (filter *TemplateFilter) Passes(data interface{}, value interface{}) bool {\n\tswitch v := value.(type) {\n\tcase string:\n\t\tvar res bytes.Buffer\n\n\t\tif strings.Index(v, \"{{test\") >= 0 {\n\t\t\tv = strings.Replace(v, \"{{test\", \"{{if\", -1)\n\t\t\tv += \"true{{end}}\"\n\t\t}\n\n\t\ttmpl, err := template.New(\"_\" + v).Funcs(templatehelper.FuncMap).Parse(v)\n\t\tif err == nil {\n\t\t\terr = tmpl.Execute(&res, data)\n\t\t}\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\treturn strings.TrimSpace(res.String()) == \"true\"\n\t}\n\n\treturn false\n}", "label": 5}
{"code": "func ComparePDFs(rdr1, rdr2 io.Reader, printDiff bool) (err error) {\n\tvar b1, b2 *bytes.Buffer\n\t_, err = b1.ReadFrom(rdr1)\n\tif err == nil {\n\t\t_, err = b2.ReadFrom(rdr2)\n\t\tif err == nil {\n\t\t\terr = CompareBytes(b1.Bytes(), b2.Bytes(), printDiff)\n\t\t}\n\t}\n\treturn\n}", "label": 5}
{"code": "func IsIsolatorSupported(isolator string) (bool, error) {\n\tisUnified, err := IsCgroupUnified(\"/\")\n\tif err != nil {\n\t\treturn false, errwrap.Wrap(errors.New(\"error determining cgroup version\"), err)\n\t}\n\n\tif isUnified {\n\t\tcontrollers, err := v2.GetEnabledControllers()\n\t\tif err != nil {\n\t\t\treturn false, errwrap.Wrap(errors.New(\"error determining enabled controllers\"), err)\n\t\t}\n\t\tfor _, c := range controllers {\n\t\t\tif c == isolator {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t\treturn false, nil\n\t}\n\treturn v1.IsControllerMounted(isolator)\n}", "label": 5}
{"code": "function _loadEntityAttribute(attribute) {\n    expect(_methods).to.not.have.ownProperty(\n      attribute.name,\n      'failed to load entity attribute \"' + attribute.name + '\" because ' +\n      'there is a method with same name in the current Entity and it cannot ' +\n      'be overloaded'\n    );\n\n    if (_Entity.General) {\n      expect(_Entity.General.attributes).to.not.have.ownProperty(\n        attribute.name,\n        'failed to load entity attribute \"' + attribute.name + '\" because ' +\n        'there is an attribute with same name in a parent of current Entity ' +\n        'and it cannot be overriden'\n      );\n\n      expect(_Entity.General.methods).to.not.respondTo(\n        attribute.name,\n        'failed to load entity attribute \"' + attribute.name + '\" because ' +\n        'there is a method with same name in a parent of current Entity ' +\n        'and it cannot be overriden'\n      );\n    }\n\n    var entitySpecializations = _Entity.specializations;\n    for (var specialization in entitySpecializations) {\n      expect(entitySpecializations[specialization].specification.attributes)\n        .to.not.have.ownProperty(\n        attribute.name,\n        'failed to load entity attribute \"' + attribute.name + '\" because ' +\n        'there is an attribute with same name in a child of current Entity'\n      );\n\n      expect(entitySpecializations[specialization].specification.methods)\n        .to.not.have.ownProperty(\n        attribute.name,\n        'failed to load entity attribute \"' + attribute.name + '\" because ' +\n        'there is a method with same name in a child of current Entity'\n      );\n    }\n\n    _Entity.adapter.loadEntityAttribute(_Entity, attribute);\n  }", "label": 3}
{"code": "func (config *configuration) fromOptions(labels map[string]string) error {\n\tfor label, value := range labels {\n\t\tswitch label {\n\t\tcase parentOpt:\n\t\t\t// parse driver option '-o parent'\n\t\t\tconfig.Parent = value\n\t\tcase driverModeOpt:\n\t\t\t// parse driver option '-o ipvlan_mode'\n\t\t\tconfig.IpvlanMode = value\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "public void beforeCompletion()\r\n    {\r\n        // avoid redundant calls\r\n        if(beforeCompletionCall) return;\r\n\r\n        log.info(\"Method beforeCompletion was called\");\r\n        int status = Status.STATUS_UNKNOWN;\r\n        try\r\n        {\r\n            JTATxManager mgr = (JTATxManager) getImplementation().getTxManager();\r\n            status = mgr.getJTATransaction().getStatus();\r\n            // ensure proper work, check all possible status\r\n            // normally only check for 'STATUS_MARKED_ROLLBACK' is necessary\r\n            if(status == Status.STATUS_MARKED_ROLLBACK\r\n                    || status == Status.STATUS_ROLLEDBACK\r\n                    || status == Status.STATUS_ROLLING_BACK\r\n                    || status == Status.STATUS_UNKNOWN\r\n                    || status == Status.STATUS_NO_TRANSACTION)\r\n            {\r\n                log.error(\"Synchronization#beforeCompletion: Can't prepare for commit, because tx status was \"\r\n                        + TxUtil.getStatusString(status) + \". Do internal cleanup only.\");\r\n            }\r\n            else\r\n            {\r\n                if(log.isDebugEnabled())\r\n                {\r\n                    log.debug(\"Synchronization#beforeCompletion: Prepare for commit\");\r\n                }\r\n                // write objects to database\r\n                prepareCommit();\r\n            }\r\n        }\r\n        catch(Exception e)\r\n        {\r\n            log.error(\"Synchronization#beforeCompletion: Error while prepare for commit\", e);\r\n            if(e instanceof LockNotGrantedException)\r\n            {\r\n                throw (LockNotGrantedException) e;\r\n            }\r\n            else if(e instanceof TransactionAbortedException)\r\n            {\r\n                throw (TransactionAbortedException) e;\r\n            }\r\n            else if(e instanceof ODMGRuntimeException)\r\n            {\r\n                throw (ODMGRuntimeException) e;\r\n            }\r\n            else\r\n            { \r\n                throw new ODMGRuntimeException(\"Method beforeCompletion() fails, status of JTA-tx was \"\r\n                        + TxUtil.getStatusString(status) + \", message: \" + e.getMessage());\r\n            }\r\n\r\n        }\r\n        finally\r\n        {\r\n            beforeCompletionCall = true;\r\n            setInExternTransaction(false);\r\n            internalCleanup();\r\n        }\r\n    }", "label": 0}
{"code": "public function setSelect($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\V1beta1\\StructuredQuery_Projection::class);\n        $this->select = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def use_one_cell_anchor\n      return if @anchor.is_a?(OneCellAnchor)\n      new_anchor = OneCellAnchor.new(@anchor.drawing, :start_at => [@anchor.from.col, @anchor.from.row])\n      swap_anchor(new_anchor)\n    end", "label": 4}
{"code": "def with_environment(env)\n      old_env = {}\n      env.each do |var, value|\n        old_env[var] = ENV[var.to_s]\n        ENV[var.to_s] = value\n      end\n\n      yield\n    ensure\n      old_env.each { |var, value| ENV[var.to_s] = value }\n    end", "label": 4}
{"code": "def run_mhc_gene_assessment(job, rsem_files, rna_haplotype, univ_options, reports_options):\n    \"\"\"\n    A wrapper for assess_mhc_genes.\n\n    :param dict rsem_files: Results from running rsem\n    :param str rna_haplotype: The job store id for the rna haplotype file\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict reports_options: Options specific to reporting modules\n    :return: The results of running assess_mhc_genes\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    return job.addChildJobFn(assess_mhc_genes, rsem_files['rsem.genes.results'], rna_haplotype,\n                             univ_options, reports_options).rv()", "label": 1}
{"code": "public function basic_nack($delivery_tag, $multiple = false, $requeue = false)\n    {\n        list($class_id, $method_id, $args) = $this->protocolWriter->basicNack($delivery_tag, $multiple, $requeue);\n        $this->send_method_frame(array($class_id, $method_id), $args);\n    }", "label": 2}
{"code": "func Load(r io.Reader) (*MetaInfo, error) {\n\tvar mi MetaInfo\n\td := bencode.NewDecoder(r)\n\terr := d.Decode(&mi)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &mi, nil\n}", "label": 5}
{"code": "func queryLimit(query url.Values, name string, def int) (int, error) {\n\tstr := query.Get(name)\n\tif str == \"\" {\n\t\treturn def, nil\n\t}\n\tlimit, err := strconv.Atoi(str)\n\tif err != nil {\n\t\treturn 0, trace.BadParameter(\"failed to parse %v as limit: %v\", name, str)\n\t}\n\treturn limit, nil\n}", "label": 5}
{"code": "public function setSsmlGender($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Dialogflow\\V2\\SsmlVoiceGender::class);\n        $this->ssml_gender = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func pidWait(pid int) error {\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\tif !pidAlive(pid) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, onlinkipv6prefix resource) throws Exception {\n\t\tonlinkipv6prefix addresource = new onlinkipv6prefix();\n\t\taddresource.ipv6prefix = resource.ipv6prefix;\n\t\taddresource.onlinkprefix = resource.onlinkprefix;\n\t\taddresource.autonomusprefix = resource.autonomusprefix;\n\t\taddresource.depricateprefix = resource.depricateprefix;\n\t\taddresource.decrementprefixlifetimes = resource.decrementprefixlifetimes;\n\t\taddresource.prefixvalidelifetime = resource.prefixvalidelifetime;\n\t\taddresource.prefixpreferredlifetime = resource.prefixpreferredlifetime;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "func NewSimpleStyledText() *SimpleStyledText {\n\tss := &SimpleStyledText{}\n\t// Create map and establish default styles.\n\tss.styles = make(map[rune]tcell.Style)\n\tss.styles['N'] = tcell.StyleDefault\n\tss.styles['S'] = tcell.StyleDefault.Reverse(true)\n\tss.styles['U'] = tcell.StyleDefault.Underline(true)\n\tss.styles['B'] = tcell.StyleDefault.Bold(true)\n\treturn ss\n}", "label": 5}
{"code": "public void updateSequenceElement(int[] sequence, int pos, int oldVal) {\r\n    if(models != null){\r\n      for(int i = 0; i < models.length; i++)\r\n        models[i].updateSequenceElement(sequence, pos, oldVal);\r\n      return; \r\n    }\r\n    model1.updateSequenceElement(sequence, pos, 0);\r\n    model2.updateSequenceElement(sequence, pos, 0);\r\n  }", "label": 0}
{"code": "def check_multiline_sequence(node, sequence, index)\n      return unless sequence.members.size > 1\n      return unless sequence.members[2..-1].any? { |member| member == \"\\n\" }\n\n      add_lint(node.line + index, MESSAGE)\n    end", "label": 4}
{"code": "function _gpfWebTagFlattenChildren (array, callback) {\n    array.forEach(function (item) {\n        if (_gpfIsArray(item)) {\n            _gpfWebTagFlattenChildren(item, callback);\n        } else {\n            callback(item);\n        }\n    });\n}", "label": 3}
{"code": "func (m *DatastoreFileManager) Copy(ctx context.Context, src string, dst string) error {\n\tsrcp := m.Path(src)\n\tdstp := m.Path(dst)\n\n\tf := m.FileManager.CopyDatastoreFile\n\n\tif srcp.IsVMDK() {\n\t\t// types.VirtualDiskSpec=nil as it is not implemented by vCenter\n\t\tf = func(ctx context.Context, src string, srcDC *Datacenter, dst string, dstDC *Datacenter, force bool) (*Task, error) {\n\t\t\treturn m.VirtualDiskManager.CopyVirtualDisk(ctx, src, srcDC, dst, dstDC, nil, force)\n\t\t}\n\t}\n\n\ttask, err := f(ctx, srcp.String(), m.Datacenter, dstp.String(), m.DatacenterTarget, m.Force)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn m.wait(ctx, task)\n}", "label": 5}
{"code": "function CountFunction(win) {\n  var self = this, n;\n  self.name = \"count\";\n  self.type = \"simple\";\n  self.init = function() { n = 0; };\n  self.accumulate = function(ignored) { n += 1; };\n  self.compensate = function(ignored) { n -= 1; };\n  self.emit = function()  { return n; };\n  self.make = function(win) { return new CountFunction(win); };\n}", "label": 3}
{"code": "def cleanup_strings(strings, strip: true)\n      strings = Array(strings).flatten.map! { |s| cleanup_string(s, strip: strip) }\n      strings.reject!(&:blank?)\n      strings\n    end", "label": 4}
{"code": "func PgReplicationOriginByRoident(db XODB, roident pgtypes.Oid) (*PgReplicationOrigin, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, ctid, roident, roname ` +\n\t\t`FROM pg_catalog.pg_replication_origin ` +\n\t\t`WHERE roident = $1`\n\n\t// run query\n\tXOLog(sqlstr, roident)\n\tpro := PgReplicationOrigin{}\n\n\terr = db.QueryRow(sqlstr, roident).Scan(&pro.Tableoid, &pro.Cmax, &pro.Xmax, &pro.Cmin, &pro.Xmin, &pro.Ctid, &pro.Roident, &pro.Roname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pro, nil\n}", "label": 5}
{"code": "def at_time_validate(ctx, param, value):\n    \"\"\" Callback validating the at_time commit option.\n\n    Purpose: Validates the `at time` option for the commit command. Only the\n           | the following two formats are supported: 'hh:mm[:ss]' or\n           | 'yyyy-mm-dd hh:mm[:ss]' (seconds are optional).\n\n    @param ctx: The click context paramter, for receiving the object dictionary\n              | being manipulated by other previous functions. Needed by any\n              | function with the @click.pass_context decorator. Callback\n              | functions such as this one receive this automatically.\n    @type ctx: click.Context\n    @param param: param is passed into a validation callback function by click.\n                | We do not use it.\n    @type param: None\n    @param value: The value that the user supplied for the at_time option.\n    @type value: str\n\n    @returns: The value that the user supplied, if it passed validation.\n            | Otherwise, raises click.BadParameter\n    @rtype: str\n    \"\"\"\n    # if they are doing commit_at, ensure the input is formatted correctly.\n    if value is not None:\n        if (re.search(r'([0-2]\\d)(:[0-5]\\d){1,2}', value) is None and\n            re.search(r'\\d{4}-[01]\\d-[0-3]\\d [0-2]\\d:[0-5]\\d(:[0-5]\\d)?',\n                      value) is None):\n            raise click.BadParameter(\"A commit at time must be in one of the \"\n                                     \"two formats: 'hh:mm[:ss]' or \"\n                                     \"'yyyy-mm-dd hh:mm[:ss]' (seconds are \"\n                                     \"optional).\")\n    ctx.obj['at_time'] = value\n    return value", "label": 1}
{"code": "protected function setHttpOptions(): self\n    {\n        if ($this->config->has('http') && is_array($this->config->get('http'))) {\n            $this->config->forget('http.base_uri');\n            $this->httpOptions = $this->config->get('http');\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "func (v *ViewPort) ValidateViewX() {\n\tif v.viewx >= v.limx-v.width {\n\t\tv.viewx = (v.limx - v.width)\n\t}\n\tif v.viewx < 0 {\n\t\tv.viewx = 0\n\t}\n}", "label": 5}
{"code": "public static String getContent(String stringUrl) throws IOException {\n    InputStream stream = getContentStream(stringUrl);\n    return MyStreamUtils.readContent(stream);\n  }", "label": 0}
{"code": "func NewLoggingMounter(m Mounter, um Unmounter, logf func(string, ...interface{})) MountUnmounter {\n\treturn &loggingMounter{m, um, logf}\n}", "label": 5}
{"code": "def acquire_discharge(self, cav, payload):\n        ''' Request a discharge macaroon from the caveat location\n        as an HTTP URL.\n        @param cav Third party {pymacaroons.Caveat} to be discharged.\n        @param payload External caveat data {bytes}.\n        @return The acquired macaroon {macaroonbakery.Macaroon}\n        '''\n        resp = self._acquire_discharge_with_token(cav, payload, None)\n        # TODO Fabrice what is the other http response possible ??\n        if resp.status_code == 200:\n            return bakery.Macaroon.from_dict(resp.json().get('Macaroon'))\n        cause = Error.from_dict(resp.json())\n        if cause.code != ERR_INTERACTION_REQUIRED:\n            raise DischargeError(cause.message)\n        if cause.info is None:\n            raise DischargeError(\n                'interaction-required response with no info: {}'.format(\n                    resp.json())\n            )\n        loc = cav.location\n        if not loc.endswith('/'):\n            loc = loc + '/'\n        token, m = self._interact(loc, cause, payload)\n        if m is not None:\n            # We've acquired the macaroon directly via legacy interaction.\n            return m\n        # Try to acquire the discharge again, but this time with\n        # the token acquired by the interaction method.\n        resp = self._acquire_discharge_with_token(cav, payload, token)\n        if resp.status_code == 200:\n            return bakery.Macaroon.from_dict(resp.json().get('Macaroon'))\n        else:\n            raise DischargeError(\n                'discharge failed with code {}'.format(resp.status_code))", "label": 1}
{"code": "public static base_response clear(nitro_service client) throws Exception {\n\t\tgslbldnsentries clearresource = new gslbldnsentries();\n\t\treturn clearresource.perform_operation(client,\"clear\");\n\t}", "label": 0}
{"code": "def list(*args)\n      params = arguments(args) do\n        assert_values VALID_ISSUE_PARAM_VALUES\n      end.params\n\n      response = if (org = params.delete('org'))\n        get_request(\"/orgs/#{org}/issues\", params)\n\n      elsif (user_name = params.delete('user')) &&\n            (repo_name = params.delete('repo'))\n\n        list_repo user_name, repo_name\n      elsif args.include? :user\n        get_request(\"/user/issues\", params)\n      else\n        get_request(\"/issues\", params)\n      end\n      return response unless block_given?\n      response.each { |el| yield el }\n    end", "label": 4}
{"code": "public int min() {\r\n    int min = Integer.MAX_VALUE;\r\n    for (E key : map.keySet()) {\r\n      min = Math.min(min, getIntCount(key));\r\n    }\r\n    return min;\r\n  }", "label": 0}
{"code": "def collection(parent = nil)\n      parent ? parent.collection.with(client_options) : client[collection_name.to_sym]\n    end", "label": 4}
{"code": "private function getHeaderBlacklist()\n    {\n        return [\n            'cache-control'         => true,\n            'content-type'          => true,\n            'content-length'        => true,\n            'expect'                => true,\n            'max-forwards'          => true,\n            'pragma'                => true,\n            'range'                 => true,\n            'te'                    => true,\n            'if-match'              => true,\n            'if-none-match'         => true,\n            'if-modified-since'     => true,\n            'if-unmodified-since'   => true,\n            'if-range'              => true,\n            'accept'                => true,\n            'authorization'         => true,\n            'proxy-authorization'   => true,\n            'from'                  => true,\n            'referer'               => true,\n            'user-agent'            => true,\n            'x-amzn-trace-id'       => true,\n            'aws-sdk-invocation-id' => true,\n            'aws-sdk-retry'         => true,\n        ];\n    }", "label": 2}
{"code": "func (r Record) WriteTo(w io.Writer) (int64, error) {\n\tn, err := fmt.Fprintf(w, \"%s\\t%s\\n\", r.IP, r.Hosts)\n\treturn int64(n), err\n}", "label": 5}
{"code": "public static base_responses add(nitro_service client, dnsaddrec resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tdnsaddrec addresources[] = new dnsaddrec[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new dnsaddrec();\n\t\t\t\taddresources[i].hostname = resources[i].hostname;\n\t\t\t\taddresources[i].ipaddress = resources[i].ipaddress;\n\t\t\t\taddresources[i].ttl = resources[i].ttl;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "protected function formatListeners($eventName)\n    {\n        return collect(app('events')->getListeners($eventName))\n            ->map(function ($listener) {\n                $listener = (new ReflectionFunction($listener))\n                        ->getStaticVariables()['listener'];\n\n                if (is_string($listener)) {\n                    return Str::contains($listener, '@') ? $listener : $listener.'@handle';\n                } elseif (is_array($listener)) {\n                    return get_class($listener[0]).'@'.$listener[1];\n                }\n\n                return $this->formatClosureListener($listener);\n            })->reject(function ($listener) {\n                return Str::contains($listener, 'Laravel\\\\Telescope');\n            })->map(function ($listener) {\n                if (Str::contains($listener, '@')) {\n                    $queued = in_array(ShouldQueue::class, class_implements(explode('@', $listener)[0]));\n                }\n\n                return [\n                    'name' => $listener,\n                    'queued' => $queued ?? false,\n                ];\n            })->values()->toArray();\n    }", "label": 2}
{"code": "def save_to_file_object(self, fd, format=None, **kwargs):\n        \"\"\" Save the object to a given file like object in the given format.\n        \"\"\"\n        format = 'pickle' if format is None else format\n        save = getattr(self, \"save_%s\" % format, None)\n        if save is None:\n            raise ValueError(\"Unknown format '%s'.\" % format)\n        save(fd, **kwargs)", "label": 1}
{"code": "func PgEnumByEnumtypidEnumsortorder(db XODB, enumtypid pgtypes.Oid, enumsortorder float32) (*PgEnum, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, enumtypid, enumsortorder, enumlabel ` +\n\t\t`FROM pg_catalog.pg_enum ` +\n\t\t`WHERE enumtypid = $1 AND enumsortorder = $2`\n\n\t// run query\n\tXOLog(sqlstr, enumtypid, enumsortorder)\n\tpe := PgEnum{}\n\n\terr = db.QueryRow(sqlstr, enumtypid, enumsortorder).Scan(&pe.Tableoid, &pe.Cmax, &pe.Xmax, &pe.Cmin, &pe.Xmin, &pe.Oid, &pe.Ctid, &pe.Enumtypid, &pe.Enumsortorder, &pe.Enumlabel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pe, nil\n}", "label": 5}
{"code": "public function times($factor)\n    {\n        if ($factor < 0) {\n            $this->invert = $this->invert ? 0 : 1;\n            $factor = -$factor;\n        }\n\n        $this->years = (int) round($this->years * $factor);\n        $this->months = (int) round($this->months * $factor);\n        $this->dayz = (int) round($this->dayz * $factor);\n        $this->hours = (int) round($this->hours * $factor);\n        $this->minutes = (int) round($this->minutes * $factor);\n        $this->seconds = (int) round($this->seconds * $factor);\n        $this->microseconds = (int) round($this->microseconds * $factor);\n\n        return $this;\n    }", "label": 2}
{"code": "private function validateResetRow(CellChunk $chunk)\n    {\n        $this->isError(\n            $chunk->getResetRow() &&\n            (\n                $chunk->getRowKey() ||\n                $chunk->getQualifier() ||\n                $chunk->getValue() ||\n                $chunk->getTimestampMicros() > 0\n            ),\n            'A reset should have no data.'\n        );\n    }", "label": 2}
{"code": "function (remote, driver) {\n      return function webdriverCommand() {\n        var deferred = Q.defer();\n        // the request meta data\n        var params = Driver.generateParamset(remote.params, arguments);\n        var body = Driver.generateBody({}, remote.onRequest, this, params);\n        var options = Driver.generateRequestOptions(this.opts.host, this.opts.port, this.opts.path, Driver.parseUrl(remote.url, this.options), remote.method, body, this.opts.auth);\n\n        // generate the request, wait for response & fire the request\n        var req = new http.ClientRequest(options);\n        req.on('response', driver._onResponse.bind(this, driver, remote, options, deferred));\n        req.end(body);\n\n        return deferred.promise;\n      };\n    }", "label": 3}
{"code": "def received(*args)\n      arguments(args, required: [:user])\n      params = arguments.params\n\n      public_events = if params['public']\n        params.delete('public')\n        '/public'\n      end\n\n      response = get_request(\"/users/#{arguments.user}/received_events#{public_events}\", params)\n      return response unless block_given?\n      response.each { |el| yield el }\n    end", "label": 4}
{"code": "private Properties parseFile(File file) throws InvalidDeclarationFileException {\n        Properties properties = new Properties();\n        InputStream is = null;\n        try {\n            is = new FileInputStream(file);\n            properties.load(is);\n        } catch (Exception e) {\n            throw new InvalidDeclarationFileException(String.format(\"Error reading declaration file %s\", file.getAbsoluteFile()), e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    LOG.error(\"IOException thrown while trying to close the declaration file.\", e);\n                }\n            }\n        }\n\n        if (!properties.containsKey(Constants.ID)) {\n            throw new InvalidDeclarationFileException(String.format(\"File %s is not a correct declaration, needs to contains an id property\", file.getAbsoluteFile()));\n        }\n        return properties;\n    }", "label": 0}
{"code": "def render(self, template, filename, context={}, filters={}):\n        \"\"\"\n        Renders a Jinja2 template to text.\n        \"\"\"\n        filename = os.path.normpath(filename)\n        path, file = os.path.split(filename)\n        try:\n            os.makedirs(path)\n        except OSError as exception:\n            if exception.errno != errno.EEXIST:\n                raise\n\n        path, file = os.path.split(template)\n        loader = jinja2.FileSystemLoader(path)\n        env = jinja2.Environment(loader=loader, trim_blocks=True, lstrip_blocks=True)\n        env.filters.update(filters)\n        template = env.get_template(file)\n        text = template.render(context)\n        with open(filename, 'wt') as f:\n            f.write(text)", "label": 1}
{"code": "def gem_name_taken?(name)\n      require 'open-uri'\n      require 'json'\n      url = \"https://rubygems.org/api/v1/gems/#{name}.json\"\n      response = JSON.parse(open(url).read)\n      return !!response['version']\n    rescue\n      false\n    end", "label": 4}
{"code": "func (ts *Store) GetID(key string) (string, error) {\n\thash, err := types.NewHash(key)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\timages, err := acirenderer.CreateDepListFromImageID(*hash, ts.store)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar keys []string\n\tfor _, image := range images {\n\t\tkeys = append(keys, image.Key)\n\t}\n\timagesString := strings.Join(keys, \",\")\n\th := sha512.New()\n\th.Write([]byte(imagesString))\n\treturn \"deps-\" + hashToKey(h), nil\n}", "label": 5}
{"code": "public void reportSqlError(String message, java.sql.SQLException sqlEx)\r\n    {\r\n        StringBuffer strBufMessages = new StringBuffer();\r\n        java.sql.SQLException currentSqlEx = sqlEx;\r\n        do\r\n        {\r\n            strBufMessages.append(\"\\n\" + sqlEx.getErrorCode() + \":\" + sqlEx.getMessage());\r\n            currentSqlEx = currentSqlEx.getNextException();\r\n        } while (currentSqlEx != null);        \r\n        System.err.println(message + strBufMessages.toString());\r\n        sqlEx.printStackTrace();\r\n    }", "label": 0}
{"code": "public function getTemporaryUrl(DateTimeInterface $expiration, array $options = []): string\n    {\n        return $this\n            ->filesystemManager\n            ->disk($this->media->disk)\n            ->temporaryUrl($this->getPath(), $expiration, $options);\n    }", "label": 2}
{"code": "def get_cache_path(filename):\n\t\"\"\" get file path \"\"\"\n\tcwd = os.path.dirname(os.path.realpath(__file__))\n\treturn os.path.join(cwd, filename)", "label": 1}
{"code": "function getAdapter(serviceInfo, resource, moduleStack) {\n        var adapterName = serviceInfo.adapterName;\n\n        // if adapter name is 'service' and there is a default, switch to the default\n        if (adapterName === 'service' && resource.adapters[this.injector.container]) {\n            adapterName = serviceInfo.adapterName = resource.adapters[this.injector.container];\n            serviceInfo.adapterImpl = this.injector.adapterMap[adapterName];\n            serviceInfo.serviceName = utils.getCamelCase(serviceInfo.resourceName + '.' +\n                serviceInfo.adapterName + '.service');\n        }\n\n        // if that doesn't work, we will assume the adapter is in the current codebase, so go get it\n        var overridePath = '/resources/' + serviceInfo.resourceName + '/' + serviceInfo.resourceName + '.' +\n            (adapterName === 'service' ? adapterName : adapterName + '.service');\n        var adapterPath = '/adapters/' + adapterName + '/' +\n            serviceInfo.adapterImpl + '.' + adapterName + '.adapter';\n\n        // if override exists, use that one, else use the lower level adapter\n        var Adapter =\n            this.loadIfExists(overridePath, moduleStack, null) ||\n            this.injector.adapters[serviceInfo.adapterImpl] ||\n            this.loadIfExists(adapterPath, moduleStack, null);\n\n        // if still no adapter found, then there is an issue\n        if (!Adapter) {\n            throw new Error('ServiceFactory could not find adapter ' + adapterName +\n            ' paths ' + overridePath + ' and ' + adapterPath);\n        }\n\n        return new Adapter(resource);\n    }", "label": 3}
{"code": "def remove_group_users(user_ids)\n      raise 'Attempted to remove a user from a non-group channel!' unless group?\n\n      user_ids = [user_ids] unless user_ids.is_a? Array\n      user_ids.each do |user_id|\n        API::Channel.remove_group_user(@bot.token, @id, user_id.resolve_id)\n      end\n      self\n    end", "label": 4}
{"code": "function url(httpRequest, httpResponse) {\n        var response = new Response(httpResponse);\n\n        grasshopper.googleAuthUrl()\n            .then(function(url) {\n                response.writeSuccess(url);\n            })\n            .fail(function(message) {\n                var err = {\n                    code : 400,\n                    message : message\n                };\n\n                response.writeError(err);\n            })\n            .done();\n    }", "label": 3}
{"code": "private void fillQueue(QueueItem item, Integer minStartPosition,\n      Integer maxStartPosition, Integer minEndPosition) throws IOException {\n    int newStartPosition;\n    int newEndPosition;\n    Integer firstRetrievedPosition = null;\n    // remove everything below minStartPosition\n    if ((minStartPosition != null) && (item.lowestPosition != null)\n        && (item.lowestPosition < minStartPosition)) {\n      item.del((minStartPosition - 1));\n    }\n    // fill queue\n    while (!item.noMorePositions) {\n      boolean doNotCollectAnotherPosition;\n      doNotCollectAnotherPosition = item.filledPosition\n          && (minStartPosition == null) && (maxStartPosition == null);\n      doNotCollectAnotherPosition |= item.filledPosition\n          && (maxStartPosition != null) && (item.lastRetrievedPosition != null)\n          && (maxStartPosition < item.lastRetrievedPosition);\n      if (doNotCollectAnotherPosition) {\n        return;\n      } else {\n        // collect another full position\n        firstRetrievedPosition = null;\n        while (!item.noMorePositions) {\n          newStartPosition = item.sequenceSpans.spans.nextStartPosition();\n          if (newStartPosition == NO_MORE_POSITIONS) {\n            if (!item.queue.isEmpty()) {\n              item.filledPosition = true;\n              item.lastFilledPosition = item.lastRetrievedPosition;\n            }\n            item.noMorePositions = true;\n            return;\n          } else if ((minStartPosition != null)\n              && (newStartPosition < minStartPosition)) {\n            // do nothing\n          } else {\n            newEndPosition = item.sequenceSpans.spans.endPosition();\n            if ((minEndPosition == null) || (newEndPosition >= minEndPosition\n                - ignoreItem.getMinStartPosition(docId, newEndPosition))) {\n              item.add(newStartPosition, newEndPosition);\n              if (firstRetrievedPosition == null) {\n                firstRetrievedPosition = newStartPosition;\n              } else if (!firstRetrievedPosition.equals(newStartPosition)) {\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }", "label": 0}
{"code": "public static systemuser get(nitro_service service, String username) throws Exception{\n\t\tsystemuser obj = new systemuser();\n\t\tobj.set_username(username);\n\t\tsystemuser response = (systemuser) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function get($url, array $urlParameters = [], array $headers = [], $asJSON = false)\n    {\n        $request = $this->prepareRequest($url, $urlParameters, $headers);\n\n        return $this->executeRequest($request);\n    }", "label": 2}
{"code": "def krai_to_raw(self, amount):\n        \"\"\"\n        Multiply an krai amount by the krai ratio.\n\n        :param amount: Amount in krai to convert to raw\n        :type amount: int\n\n        :raises: :py:exc:`nano.rpc.RPCException`\n\n        >>> rpc.krai_to_raw(amount=1)\n        1000000000000000000000000000\n\n        \"\"\"\n\n        amount = self._process_value(amount, 'int')\n\n        payload = {\"amount\": amount}\n\n        resp = self.call('krai_to_raw', payload)\n\n        return int(resp['amount'])", "label": 1}
{"code": "public static base_response unset(nitro_service client, bridgetable resource, String[] args) throws Exception{\n\t\tbridgetable unsetresource = new bridgetable();\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "def blob_at(revision, path)\n      tree = Rugged::Commit.lookup(self, revision).tree\n      begin\n        blob_data = tree.path(path)\n      rescue Rugged::TreeError\n        return nil\n      end\n      blob = Rugged::Blob.lookup(self, blob_data[:oid])\n      (blob.type == :blob) ? blob : nil\n    end", "label": 4}
{"code": "public function setEnd($type, array $end)\n    {\n        if (!in_array($type, array_keys($this->definition))) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Invalid KeyRange type. Allowed values are %s',\n                implode(', ', array_keys($this->definition))\n            ));\n        }\n\n        $rangeKey = $this->fromDefinition($type, 'end');\n\n        $this->endType = $rangeKey;\n        $this->end = $end;\n    }", "label": 2}
{"code": "protected function validateClient(ServerRequestInterface $request)\n    {\n        list($basicAuthUser, $basicAuthPassword) = $this->getBasicAuthCredentials($request);\n\n        $clientId = $this->getRequestParameter('client_id', $request, $basicAuthUser);\n        if ($clientId === null) {\n            throw OAuthServerException::invalidRequest('client_id');\n        }\n\n        // If the client is confidential require the client secret\n        $clientSecret = $this->getRequestParameter('client_secret', $request, $basicAuthPassword);\n\n        $client = $this->clientRepository->getClientEntity(\n            $clientId,\n            $this->getIdentifier(),\n            $clientSecret,\n            true\n        );\n\n        if ($client instanceof ClientEntityInterface === false) {\n            $this->getEmitter()->emit(new RequestEvent(RequestEvent::CLIENT_AUTHENTICATION_FAILED, $request));\n            throw OAuthServerException::invalidClient();\n        }\n\n        $redirectUri = $this->getRequestParameter('redirect_uri', $request, null);\n\n        if ($redirectUri !== null) {\n            $this->validateRedirectUri($redirectUri, $client, $request);\n        }\n\n        return $client;\n    }", "label": 2}
{"code": "def define(procedure = nil, &block)\n      config = Config.new(null: null)\n      config.instance_exec(&(procedure || block))\n      config.mixin.include Mixin::Root\n      config.mixin\n    end", "label": 4}
{"code": "def flush\n      return @transport.flush unless @write\n\n      out = [@wbuf.length].pack('N')\n      # Array#pack should return a BINARY encoded String, so it shouldn't be necessary to force encoding\n      out << @wbuf\n      @transport.write(out)\n      @transport.flush\n      @wbuf = Bytes.empty_byte_buffer\n    end", "label": 4}
{"code": "func SliceContainsStr(slice []string, value string) bool {\n\tfor i := range slice {\n\t\tif slice[i] == value {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "label": 5}
{"code": "def infer_declared(ms, namespace=None):\n    '''Retrieves any declared information from the given macaroons and returns\n    it as a key-value map.\n    Information is declared with a first party caveat as created by\n    declared_caveat.\n\n    If there are two caveats that declare the same key with different values,\n    the information is omitted from the map. When the caveats are later\n    checked, this will cause the check to fail.\n    namespace is the Namespace used to retrieve the prefix associated to the\n    uri, if None it will use the STD_NAMESPACE only.\n    '''\n    conditions = []\n    for m in ms:\n        for cav in m.caveats:\n            if cav.location is None or cav.location == '':\n                conditions.append(cav.caveat_id_bytes.decode('utf-8'))\n    return infer_declared_from_conditions(conditions, namespace)", "label": 1}
{"code": "def title_min_height\n      @title_min_height ||= begin\n        height = fetch_config['title_min_height'] || 0\n        if height.kind_of?(String) && height.end_with?('%')\n          height = ([image.width, image.height].min * height.to_f * 0.01).ceil\n        end\n        height\n      end\n    end", "label": 4}
{"code": "protected function diffTimeInNanoseconds($start, $end): int\n    {\n        if ($this->platformSupportsNanoseconds()) {\n            return $end - $start;\n        }\n\n        // Difference is in seconds (with microsecond precision)\n        // * 1000 to get to milliseconds\n        // * 1000 to get to microseconds\n        // * 1000 to get to nanoseconds\n        return (int) (($end - $start) * 1000 * 1000 * 1000);\n    }", "label": 2}
{"code": "public @Nullable String build() {\n    StringBuilder queryString = new StringBuilder();\n\n    for (NameValuePair param : params) {\n      if (queryString.length() > 0) {\n        queryString.append(PARAM_SEPARATOR);\n      }\n      queryString.append(Escape.urlEncode(param.getName()));\n      queryString.append(VALUE_SEPARATOR);\n      queryString.append(Escape.urlEncode(param.getValue()));\n    }\n\n    if (queryString.length() > 0) {\n      return queryString.toString();\n    }\n    else {\n      return null;\n    }\n  }", "label": 0}
{"code": "def reload\n      old_id = @id\n      @id = nil\n\n      if @data_dir\n        # Read the id file from the data directory if it exists as the\n        # ID for the pre-existing physical representation of this machine.\n        id_file = @data_dir.join(\"id\")\n        id_content = id_file.read.strip if id_file.file?\n        if !id_content.to_s.empty?\n          @id = id_content\n        end\n      end\n\n      if @id != old_id && @provider\n        # It changed, notify the provider\n        @provider.machine_id_changed\n      end\n\n      @id\n    end", "label": 4}
{"code": "public function setFrames($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\VideoIntelligence\\V1beta2\\ExplicitContentFrame::class);\n        $this->frames = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (i *TeleInstance) Start() error {\n\t// Build a list of expected events to wait for before unblocking based off\n\t// the configuration passed in.\n\texpectedEvents := []string{}\n\tif i.Config.Auth.Enabled {\n\t\texpectedEvents = append(expectedEvents, service.AuthTLSReady)\n\t}\n\tif i.Config.Proxy.Enabled {\n\t\texpectedEvents = append(expectedEvents, service.ProxyReverseTunnelReady)\n\t\texpectedEvents = append(expectedEvents, service.ProxySSHReady)\n\t\texpectedEvents = append(expectedEvents, service.ProxyAgentPoolReady)\n\t\tif !i.Config.Proxy.DisableWebService {\n\t\t\texpectedEvents = append(expectedEvents, service.ProxyWebServerReady)\n\t\t}\n\t}\n\tif i.Config.SSH.Enabled {\n\t\texpectedEvents = append(expectedEvents, service.NodeSSHReady)\n\t}\n\n\t// Start the process and block until the expected events have arrived.\n\treceivedEvents, err := startAndWait(i.Process, expectedEvents)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\t// Extract and set reversetunnel.Server and reversetunnel.AgentPool upon\n\t// receipt of a ProxyReverseTunnelReady and ProxyAgentPoolReady respectively.\n\tfor _, re := range receivedEvents {\n\t\tswitch re.Name {\n\t\tcase service.ProxyReverseTunnelReady:\n\t\t\tts, ok := re.Payload.(reversetunnel.Server)\n\t\t\tif ok {\n\t\t\t\ti.Tunnel = ts\n\t\t\t}\n\t\tcase service.ProxyAgentPoolReady:\n\t\t\tap, ok := re.Payload.(*reversetunnel.AgentPool)\n\t\t\tif ok {\n\t\t\t\ti.Pool = ap\n\t\t\t}\n\t\t}\n\t}\n\n\tlog.Debugf(\"Teleport instance %v started: %v/%v events received.\",\n\t\ti.Secrets.SiteName, len(receivedEvents), len(expectedEvents))\n\treturn nil\n}", "label": 5}
{"code": "def edit\n      # if a user is not found, return nil\n      @resource = resource_class.with_reset_password_token(resource_params[:reset_password_token])\n\n      if @resource && @resource.reset_password_period_valid?\n        client_id, token = @resource.create_token\n\n        # ensure that user is confirmed\n        @resource.skip_confirmation! if confirmable_enabled? && !@resource.confirmed_at\n\n        # allow user to change password once without current_password\n        @resource.allow_password_change = true if recoverable_enabled?\n\n        @resource.save!\n\n        yield @resource if block_given?\n\n        redirect_header_options = { reset_password: true }\n        redirect_headers = build_redirect_headers(token,\n                                                  client_id,\n                                                  redirect_header_options)\n        redirect_to(@resource.build_auth_url(@redirect_url,\n                                             redirect_headers))\n      else\n        render_edit_error\n      end\n    end", "label": 4}
{"code": "function InternalObjectFactory(injector) {\n    this.injector = injector;\n    this.internalObjects = {\n        resources: true,\n        reactors: true,\n        adapters: true,\n        appConfigs: true,\n        eventBus: eventBus,\n        chainPromises: utils.chainPromises\n    };\n}", "label": 3}
{"code": "private function flattenKeySet(KeySet $keySet)\n    {\n        $keys = $keySet->keySetObject();\n\n        if (!empty($keys['ranges'])) {\n            foreach ($keys['ranges'] as $index => $range) {\n                foreach ($range as $type => $rangeKeys) {\n                    $range[$type] = $this->mapper->encodeValuesAsSimpleType($rangeKeys);\n                }\n\n                $keys['ranges'][$index] = $range;\n            }\n        }\n\n        if (!empty($keys['keys'])) {\n            $keys['keys'] = $this->mapper->encodeValuesAsSimpleType($keys['keys'], true);\n        }\n\n        return $this->arrayFilterRemoveNull($keys);\n    }", "label": 2}
{"code": "func pieceFirstFileIndex(pieceOffset int64, files []*File) int {\n\tfor i, f := range files {\n\t\tif f.offset+f.length > pieceOffset {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn 0\n}", "label": 5}
{"code": "def discover(timeout=DISCOVERY_TIMEOUT):\n    \"\"\" Discover devices on the local network.\n\n    :param timeout: Optional timeout in seconds.\n    :returns: Set of discovered host addresses.\n    \"\"\"\n    hosts = {}\n    payload = MAGIC + DISCOVERY\n    for _ in range(RETRIES):\n        _SOCKET.sendto(bytearray(payload), ('255.255.255.255', PORT))\n        start = time.time()\n        while time.time() < start + timeout:\n            for host, data in _BUFFER.copy().items():\n                if not _is_discovery_response(data):\n                    continue\n                if host not in hosts:\n                    _LOGGER.debug(\"Discovered device at %s\", host)\n                    entry = {}\n                    entry['mac'] = data[7:13]\n                    entry['imac'] = data[19:25]\n                    entry['next'] = 0\n                    entry['st'] = int(data[-1])\n                    entry['time'] = _device_time(data[37:41])\n                    entry['serverTime'] = int(time.time())\n                    hosts[host] = entry\n    return hosts", "label": 1}
{"code": "public static dnszone_domain_binding[] get(nitro_service service, String zonename) throws Exception{\n\t\tdnszone_domain_binding obj = new dnszone_domain_binding();\n\t\tobj.set_zonename(zonename);\n\t\tdnszone_domain_binding response[] = (dnszone_domain_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function mapStateToProps(state) {\n    return {\n        clicker: state.clicker,\n        repoUser: state.repoUser,\n        repositories: state.repositories,\n        errors: state.errors\n    };\n}", "label": 3}
{"code": "public function split()\n    {\n        $result = new stdClass();\n        $result->merged = $this->merged();\n        $result->unmerged = new Analysis();\n        foreach ($this->annotations as $annotation) {\n            if ($result->merged->annotations->contains($annotation) === false) {\n                $result->unmerged->annotations->attach($annotation, $this->annotations[$annotation]);\n            }\n        }\n\n        return $result;\n    }", "label": 2}
{"code": "def extract_embedded_attributes(attributes)\n      atomic_position.split(\".\").inject(attributes) do |attrs, part|\n        attrs = attrs[part =~ /\\d/ ? part.to_i : part]\n        attrs\n      end\n    end", "label": 4}
{"code": "public function commit(array $options = [])\n    {\n        $options['transaction'] = $this->transactionId;\n\n        return $this->operation->commit($this->mutations, $options);\n    }", "label": 2}
{"code": "def commit_data(sha)\n      sha = sha.to_s\n      cdata = command_lines('cat-file', ['commit', sha])\n      process_commit_data(cdata, sha, 0)\n    end", "label": 4}
{"code": "func (r *reader) available(off, max int64) (ret int64) {\n\toff += r.offset\n\tfor max > 0 {\n\t\treq, ok := r.t.offsetRequest(off)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif !r.t.haveChunk(req) {\n\t\t\tbreak\n\t\t}\n\t\tlen1 := int64(req.Length) - (off - r.t.requestOffset(req))\n\t\tmax -= len1\n\t\tret += len1\n\t\toff += len1\n\t}\n\t// Ensure that ret hasn't exceeded our original max.\n\tif max < 0 {\n\t\tret += max\n\t}\n\treturn\n}", "label": 5}
{"code": "public static <K> Map<K, Integer> rankMapOnIntegerValue(Map<K, Integer> inputMap) {\n    Map<K, Integer> newMap = new TreeMap<K, Integer>(new IntegerValueComparator(inputMap));\n    newMap.putAll(inputMap);\n\n    Map<K, Integer> linkedMap = new LinkedHashMap<K, Integer>(newMap);\n    return linkedMap;\n  }", "label": 0}
{"code": "function convertPropertyNamesAndValues (context, pkg, map, root, waiting) {\n\tif(!map) {\n\t\treturn map;\n\t}\n\tvar clone = {}, val, name;\n\tfor(var property in map ) {\n\t\tval = map[property];\n\t\tname = convertName(context, pkg, map, root, property, waiting); \n\t\tval = typeof val === \"object\"\n\t\t\t? convertPropertyNamesAndValues(context, pkg, val, root, waiting)\n\t\t\t: convertName(context, pkg, map, root, val, waiting);\n\t\tif(typeof name !== 'undefined' && typeof val !== 'undefined') {\n\t\t\tclone[name] = val;\n\t\t}\n\t}\n\treturn clone;\n}", "label": 3}
{"code": "public static function extract_assoc( $arguments ) {\n\t\t$positional_args = array();\n\t\t$assoc_args      = array();\n\t\t$global_assoc    = array();\n\t\t$local_assoc     = array();\n\n\t\tforeach ( $arguments as $arg ) {\n\t\t\t$positional_arg = null;\n\t\t\t$assoc_arg      = null;\n\n\t\t\tif ( preg_match( '|^--no-([^=]+)$|', $arg, $matches ) ) {\n\t\t\t\t$assoc_arg = array( $matches[1], false );\n\t\t\t} elseif ( preg_match( '|^--([^=]+)$|', $arg, $matches ) ) {\n\t\t\t\t$assoc_arg = array( $matches[1], true );\n\t\t\t} elseif ( preg_match( '|^--([^=]+)=(.*)|s', $arg, $matches ) ) {\n\t\t\t\t$assoc_arg = array( $matches[1], $matches[2] );\n\t\t\t} else {\n\t\t\t\t$positional = $arg;\n\t\t\t}\n\n\t\t\tif ( ! is_null( $assoc_arg ) ) {\n\t\t\t\t$assoc_args[] = $assoc_arg;\n\t\t\t\tif ( count( $positional_args ) ) {\n\t\t\t\t\t$local_assoc[] = $assoc_arg;\n\t\t\t\t} else {\n\t\t\t\t\t$global_assoc[] = $assoc_arg;\n\t\t\t\t}\n\t\t\t} elseif ( ! is_null( $positional ) ) {\n\t\t\t\t$positional_args[] = $positional;\n\t\t\t}\n\t\t}\n\n\t\treturn array( $positional_args, $assoc_args, $global_assoc, $local_assoc );\n\t}", "label": 2}
{"code": "public function setIamPolicy($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\SecurityCenter\\V1\\Asset_IamPolicy::class);\n        $this->iam_policy = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function equals(self $point)\n    {\n        return $this->x === $point->getX() &&\n        $this->y === $point->getY();\n    }", "label": 2}
{"code": "func SetSessionServer(sessionServer rsession.Service) ServerOption {\n\treturn func(s *Server) error {\n\t\ts.sessionServer = sessionServer\n\t\treturn nil\n\t}\n}", "label": 5}
{"code": "@Override\n    protected void onLoad() {\n\tsuper.onLoad();\n\n\t// these styles need to be the same for the box and shadow so\n\t// that we can measure properly\n\tmatchStyles(\"display\");\n\tmatchStyles(\"fontSize\");\n\tmatchStyles(\"fontFamily\");\n\tmatchStyles(\"fontWeight\");\n\tmatchStyles(\"lineHeight\");\n\tmatchStyles(\"paddingTop\");\n\tmatchStyles(\"paddingRight\");\n\tmatchStyles(\"paddingBottom\");\n\tmatchStyles(\"paddingLeft\");\n\n\tadjustSize();\n    }", "label": 0}
{"code": "def get_time_now(self):\n        \"\"\"Returns a time stamp\"\"\"\n        import datetime\n        import getpass\n        username = getpass.getuser()\n        # this is not working on some systems: os.environ[\"USERNAME\"]\n        timenow = str(datetime.datetime.now())\n        timenow = timenow.split('.')[0]\n        msg = '<div class=\"date\">Created on ' + timenow\n        msg += \" by \" + username +'</div>'\n        return msg", "label": 1}
{"code": "def reference_for_path(absolute_path)\n      absolute_pathname = Pathname.new(absolute_path)\n\n      unless absolute_pathname.absolute?\n        raise ArgumentError, \"Paths must be absolute #{absolute_path}\"\n      end\n\n      objects.find do |child|\n        child.isa == 'PBXFileReference' && child.real_path == absolute_pathname\n      end\n    end", "label": 4}
{"code": "def upgrade_home_path_v1_1\n      if !ENV[\"VAGRANT_UPGRADE_SILENT_1_5\"]\n        @ui.ask(I18n.t(\"vagrant.upgrading_home_path_v1_5\"))\n      end\n\n      collection = BoxCollection.new(\n        @home_path.join(\"boxes\"), temp_dir_root: tmp_path)\n      collection.upgrade_v1_1_v1_5\n    end", "label": 4}
{"code": "def parse_files(self):\n        \"\"\"\n        Find the files and parse them.\n\n        Returns:\n            list: list of dictionaries (one for each parsed line).\n        \"\"\"\n        log_re = self.log_format_regex\n        log_lines = []\n        for log_file in self.matching_files():\n            with open(log_file) as f:\n                matches = re.finditer(log_re, f.read())\n                for match in matches:\n                    log_lines.append(match.groupdict())\n        return log_lines", "label": 1}
{"code": "func NewServer() *Server {\n\tif f := flag.Lookup(\"toolbox.trace\"); f != nil {\n\t\tTrace, _ = strconv.ParseBool(f.Value.String())\n\t}\n\n\ts := &Server{\n\t\tsessions: make(map[uint64]*session),\n\t\tschemes:  make(map[string]FileHandler),\n\t\tchmod:    os.Chmod,\n\t\tchown:    os.Chown,\n\t}\n\n\ts.handlers = map[int32]func(*Packet) (interface{}, error){\n\t\tOpCreateSessionV4:  s.CreateSessionV4,\n\t\tOpDestroySessionV4: s.DestroySessionV4,\n\t\tOpGetattrV2:        s.GetattrV2,\n\t\tOpSetattrV2:        s.SetattrV2,\n\t\tOpOpen:             s.Open,\n\t\tOpClose:            s.Close,\n\t\tOpOpenV3:           s.OpenV3,\n\t\tOpReadV3:           s.ReadV3,\n\t\tOpWriteV3:          s.WriteV3,\n\t}\n\n\tfor op := range s.handlers {\n\t\ts.Capabilities = append(s.Capabilities, Capability{Op: op, Flags: 0x1})\n\t}\n\n\treturn s\n}", "label": 5}
{"code": "public function activate()\n    {\n        if ($this->is_email_confirmed !== true) {\n            $this->is_email_confirmed = true;\n\n            $this->raise(new Activated($this));\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "def feel_for_enclosing_parens(node) # rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity\n      range = node.source_range\n      original_source = source_from_range(range)\n      left_offset = -1\n      right_offset = 0\n\n      if original_source[-1] != ')'\n        right_offset += 1 while character_at(range.end_pos, right_offset) =~ /\\s/\n\n        return original_source if character_at(range.end_pos, right_offset) != ')'\n      end\n\n      # At this point, we know that we're wrapped on the right by a ')'.\n      # Are we wrapped on the left by a '('?\n      left_offset -= 1 while character_at(range.start_pos, left_offset) =~ /\\s/\n      return original_source if character_at(range.start_pos, left_offset) != '('\n\n      # At this point, we know we're wrapped on both sides by parens. However,\n      # those parens may be part of a parent function call. We don't care about\n      # such parens. This depends on whether the preceding character is part of\n      # a function name.\n      return original_source if character_at(range.start_pos, left_offset - 1).match?(/[A-Za-z0-9_]/)\n\n      range.start_pos.offset += left_offset\n      range.end_pos.offset += right_offset\n      source_from_range(range)\n    end", "label": 4}
{"code": "def register_page(name, options = {}, &block)\n      ns = options.fetch(:namespace) { default_namespace }\n      namespace(ns).register_page name, options, &block\n    end", "label": 4}
{"code": "public void postModule(final Module module, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {\n        final Client client = getClient(user, password);\n        final WebResource resource = client.resource(serverURL).path(RequestUtils.moduleResourcePath());\n        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class, module);\n\n        client.destroy();\n        if(ClientResponse.Status.CREATED.getStatusCode() != response.getStatus()){\n            final String message = \"Failed to POST module\";\n            if(LOG.isErrorEnabled()) {\n                LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, message, response.getStatus()));\n            }\n            throw new GrapesCommunicationException(message, response.getStatus());\n        }\n    }", "label": 0}
{"code": "public Map<String, ClientWidgetInfo> securityClone(Map<String, ClientWidgetInfo> widgetInfo) {\n\t\tMap<String, ClientWidgetInfo> res = new HashMap<String, ClientWidgetInfo>();\n\t\tfor (Map.Entry<String, ClientWidgetInfo> entry : widgetInfo.entrySet()) {\n\t\t\tClientWidgetInfo value = entry.getValue();\n\t\t\tif (!(value instanceof ServerSideOnlyInfo)) {\n\t\t\t\tres.put(entry.getKey(), value);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}", "label": 0}
{"code": "def ot_find_studies(arg_dict, exact=True, verbose=False, oti_wrapper=None):\n    \"\"\"Uses a peyotl wrapper around an Open Tree web service to get a list of studies\n    including values `value` for a given property to be searched on `porperty`.\n\n    The oti_wrapper can be None (in which case the default wrapper from peyotl.sugar will be used.\n    All other arguments correspond to the arguments of the web-service call.\n    \"\"\"\n    if oti_wrapper is None:\n        from peyotl.sugar import oti\n        oti_wrapper = oti\n    return oti_wrapper.find_studies(arg_dict,\n                                    exact=exact,\n                                    verbose=verbose,\n                                    wrap_response=True)", "label": 1}
{"code": "def validate(self, **kwargs):\n        \"\"\"\n        Validates a data file\n\n        :param file_path: path to file to be loaded.\n        :param data: pre loaded YAML object (optional).\n        :return: Bool to indicate the validity of the file.\n        \"\"\"\n\n        default_data_schema = json.load(open(self.default_schema_file, 'r'))\n\n        # even though we are using the yaml package to load,\n        # it supports JSON and YAML\n        data = kwargs.pop(\"data\", None)\n        file_path = kwargs.pop(\"file_path\", None)\n\n        if file_path is None:\n            raise LookupError(\"file_path argument must be supplied\")\n\n        if data is None:\n\n            try:\n                data = yaml.load(open(file_path, 'r'), Loader=Loader)\n            except Exception as e:\n                self.add_validation_message(ValidationMessage(file=file_path, message=\n                'There was a problem parsing the file.\\n' + e.__str__()))\n                return False\n\n        try:\n\n            if 'type' in data:\n                custom_schema = self.load_custom_schema(data['type'])\n                json_validate(data, custom_schema)\n            else:\n                json_validate(data, default_data_schema)\n\n        except ValidationError as ve:\n\n            self.add_validation_message(\n                ValidationMessage(file=file_path,\n                                    message=ve.message + ' in ' + str(ve.instance)))\n\n        if self.has_errors(file_path):\n            return False\n        else:\n            return True", "label": 1}
{"code": "func (p *PAM) codeToError(returnValue C.int) error {\n\t// Error strings are not allocated on the heap, so memory does not need\n\t// released.\n\terr := C._pam_strerror(pamHandle, p.pamh, returnValue)\n\tif err != nil {\n\t\treturn trace.BadParameter(C.GoString(err))\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public static authenticationvserver_authenticationnegotiatepolicy_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauthenticationvserver_authenticationnegotiatepolicy_binding obj = new authenticationvserver_authenticationnegotiatepolicy_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationvserver_authenticationnegotiatepolicy_binding response[] = (authenticationvserver_authenticationnegotiatepolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "protected function githubToken($userToken)\n    {\n        $token = $userToken ?: getenv(self::TOKEN_ENV);\n\n        if (!$token) {\n            throw new \\RuntimeException(sprintf(\n                'Could not find GitHub auth token. Please set the environment ' .\n                'variable `%s` or pass token as console argument.',\n                self::TOKEN_ENV\n            ));\n        }\n\n        return $token;\n    }", "label": 2}
{"code": "func (i *Handle) doCmdWithoutAttr(cmd uint8) ([][]byte, error) {\n\treq := newIPVSRequest(cmd)\n\treq.Seq = atomic.AddUint32(&i.seq, 1)\n\treturn execute(i.sock, req, 0)\n}", "label": 5}
{"code": "def infer_declared_from_conditions(conds, namespace=None):\n    ''' like infer_declared except that it is passed a set of first party\n    caveat conditions as a list of string rather than a set of macaroons.\n    '''\n    conflicts = []\n    # If we can't resolve that standard namespace, then we'll look for\n    # just bare \"declared\" caveats which will work OK for legacy\n    # macaroons with no namespace.\n    if namespace is None:\n        namespace = Namespace()\n    prefix = namespace.resolve(STD_NAMESPACE)\n    if prefix is None:\n        prefix = ''\n    declared_cond = prefix + COND_DECLARED\n\n    info = {}\n    for cond in conds:\n        try:\n            name, rest = parse_caveat(cond)\n        except ValueError:\n            name, rest = '', ''\n        if name != declared_cond:\n            continue\n        parts = rest.split(' ', 1)\n        if len(parts) != 2:\n            continue\n        key, val = parts[0], parts[1]\n        old_val = info.get(key)\n        if old_val is not None and old_val != val:\n            conflicts.append(key)\n            continue\n        info[key] = val\n    for key in set(conflicts):\n        del info[key]\n    return info", "label": 1}
{"code": "public static cmppolicylabel_stats[] get(nitro_service service) throws Exception{\n\t\tcmppolicylabel_stats obj = new cmppolicylabel_stats();\n\t\tcmppolicylabel_stats[] response = (cmppolicylabel_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static int[] Argsort(final float[] array, final boolean ascending) {\n        Integer[] indexes = new Integer[array.length];\n        for (int i = 0; i < indexes.length; i++) {\n            indexes[i] = i;\n        }\n        Arrays.sort(indexes, new Comparator<Integer>() {\n            @Override\n            public int compare(final Integer i1, final Integer i2) {\n                return (ascending ? 1 : -1) * Float.compare(array[i1], array[i2]);\n            }\n        });\n        return asArray(indexes);\n    }", "label": 0}
{"code": "function cacheSubmissionFile(params, fileToStreamTo, cb) {\n  //If the files are remote, use the mbaas client\n  logger.debug(\"cacheFiles: cacheSubmissionFile submission\", {params: params, fileToStreamTo: fileToStreamTo});\n  if (params.options.filesAreRemote) {\n    return downloadFileFromMbaas(params, fileToStreamTo, cb);\n  }\n\n  //File is in the local database, load it there\n  getSubmissionFile(params.connections, params.options, {\n    _id: params.fileId\n  }, function(err, fileDetails) {\n    if (err) {\n      logger.error(\"cacheFiles: cacheSubmissionFile getSubmissionFile\", {error: err});\n      return cb(err);\n    }\n\n    fileDetails.stream.on('error', function(err) {\n      logger.error(\"cacheFiles: cacheSubmissionFile Error Streaming File With Id: \" + params.fileId);\n      return cb(err);\n    });\n\n    fileDetails.stream.on('end', function() {\n      logger.debug(\"cacheFiles: cacheSubmissionFile Stream Complete For File With Id: \" + params.fileId);\n      return cb(undefined, fileDetails);\n    });\n\n    //Streaming The File\n    fileDetails.stream.pipe(fileToStreamTo);\n    fileDetails.stream.resume();\n  });\n}", "label": 3}
{"code": "public function reload(array $options = [])\n    {\n        return $this->info = $this->connection->getObject(\n            $this->formatEncryptionHeaders(\n                $options\n                + $this->encryptionData\n                + array_filter($this->identity)\n            )\n        );\n    }", "label": 2}
{"code": "public static void printResults(Counter<String> entityTP, Counter<String> entityFP,\r\n                           Counter<String> entityFN) {\r\n    Set<String> entities = new TreeSet<String>();\r\n    entities.addAll(entityTP.keySet());\r\n    entities.addAll(entityFP.keySet());\r\n    entities.addAll(entityFN.keySet());\r\n    boolean printedHeader = false;\r\n    for (String entity : entities) {\r\n      double tp = entityTP.getCount(entity);\r\n      double fp = entityFP.getCount(entity);\r\n      double fn = entityFN.getCount(entity);\r\n      printedHeader = printPRLine(entity, tp, fp, fn, printedHeader);\r\n    }\r\n    double tp = entityTP.totalCount();\r\n    double fp = entityFP.totalCount();\r\n    double fn = entityFN.totalCount();\r\n    printedHeader = printPRLine(\"Totals\", tp, fp, fn, printedHeader);\r\n  }", "label": 0}
{"code": "@ArgumentsChecked\n\t@Throws(IllegalNullArgumentException.class)\n\tpublic static byte checkByte(@Nonnull final Number number) {\n\t\tCheck.notNull(number, \"number\");\n\t\tif (!isInByteRange(number)) {\n\t\t\tthrow new IllegalNumberRangeException(number.toString(), BYTE_MIN, BYTE_MAX);\n\t\t}\n\n\t\treturn number.byteValue();\n\t}", "label": 0}
{"code": "func (c *SessionContext) Close() error {\n\tclosers := c.TransferClosers()\n\tfor _, closer := range closers {\n\t\tc.Debugf(\"Closing %v.\", closer)\n\t\tcloser.Close()\n\t}\n\tif c.clt != nil {\n\t\treturn trace.Wrap(c.clt.Close())\n\t}\n\treturn nil\n}", "label": 5}
{"code": "func (cfg *Config) RoleConfig() RoleConfig {\n\treturn RoleConfig{\n\t\tDataDir:     cfg.DataDir,\n\t\tHostUUID:    cfg.HostUUID,\n\t\tHostName:    cfg.Hostname,\n\t\tAuthServers: cfg.AuthServers,\n\t\tAuth:        cfg.Auth,\n\t\tConsole:     cfg.Console,\n\t}\n}", "label": 5}
{"code": "def get_cantera_mole_fraction(self, species_conversion=None):\n        \"\"\"Get the mole fractions in a string format suitable for input to Cantera.\n\n        Arguments:\n            species_conversion (`dict`, optional): Mapping of species identifier to a\n                species name. This argument should be supplied when the name of the\n                species in the ChemKED YAML file does not match the name of the same\n                species in a chemical kinetic mechanism. The species identifier (the key\n                of the mapping) can be the name, InChI, or SMILES provided in the ChemKED\n                file, while the value associated with a key should be the desired name in\n                the Cantera format output string.\n\n        Returns:\n            `str`: String of mole fractions in the ``SPEC:AMT, SPEC:AMT`` format\n\n        Raises:\n            `ValueError`: If the composition type is ``'mass fraction'``, the conversion cannot\n                be done because no molecular weight information is known\n\n        Examples:\n            >>> dp = DataPoint(properties)\n            >>> dp.get_cantera_mole_fraction()\n            'H2:4.4400e-03, O2:5.5600e-03, Ar:9.9000e-01'\n            >>> species_conversion = {'H2': 'h2', 'O2': 'o2'}\n            >>> dp.get_cantera_mole_fraction(species_conversion)\n            'h2:4.4400e-03, o2:5.5600e-03, Ar:9.9000e-01'\n            >>> species_conversion = {'1S/H2/h1H': 'h2', '1S/O2/c1-2': 'o2'}\n            >>> dp.get_cantera_mole_fraction(species_conversion)\n            'h2:4.4400e-03, o2:5.5600e-03, Ar:9.9000e-01'\n        \"\"\"\n        if self.composition_type == 'mass fraction':\n            raise ValueError('Cannot get mole fractions from the given composition.\\n'\n                             '{}'.format(self.composition))\n        else:\n            return self.get_cantera_composition_string(species_conversion)", "label": 1}
{"code": "public static function ini($profile = null, $filename = null)\n    {\n        $filename = $filename ?: (self::getHomeDir() . '/.aws/credentials');\n        $profile = $profile ?: (getenv(self::ENV_PROFILE) ?: 'default');\n\n        return function () use ($profile, $filename) {\n            if (!is_readable($filename)) {\n                return self::reject(\"Cannot read credentials from $filename\");\n            }\n            $data = \\Aws\\parse_ini_file($filename, true, INI_SCANNER_RAW);\n            if ($data === false) {\n                return self::reject(\"Invalid credentials file: $filename\");\n            }\n            if (!isset($data[$profile])) {\n                return self::reject(\"'$profile' not found in credentials file\");\n            }\n            if (!isset($data[$profile]['aws_access_key_id'])\n                || !isset($data[$profile]['aws_secret_access_key'])\n            ) {\n                return self::reject(\"No credentials present in INI profile \"\n                    . \"'$profile' ($filename)\");\n            }\n\n            if (empty($data[$profile]['aws_session_token'])) {\n                $data[$profile]['aws_session_token']\n                    = isset($data[$profile]['aws_security_token'])\n                        ? $data[$profile]['aws_security_token']\n                        : null;\n            }\n\n            return Promise\\promise_for(\n                new Credentials(\n                    $data[$profile]['aws_access_key_id'],\n                    $data[$profile]['aws_secret_access_key'],\n                    $data[$profile]['aws_session_token']\n                )\n            );\n        };\n    }", "label": 2}
{"code": "public function setState($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Firestore\\Admin\\V1\\Index_State::class);\n        $this->state = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def children(opt = {})\n      raise ArgumentError, '#children can not take an index value' if opt[:index]\n\n      xpath_adjacent(opt.merge(adjacent: :child, plural: true))\n    end", "label": 4}
{"code": "def dSbus_dV(Y, V):\n    \"\"\" Computes the partial derivative of power injection w.r.t. voltage.\n\n        References:\n            Ray Zimmerman, \"dSbus_dV.m\", MATPOWER, version 3.2,\n            PSERC (Cornell), http://www.pserc.cornell.edu/matpower/\n    \"\"\"\n    I = Y * V\n\n    diagV = spdiag(V)\n    diagIbus = spdiag(I)\n    diagVnorm = spdiag(div(V, abs(V))) # Element-wise division.\n\n    dS_dVm = diagV * conj(Y * diagVnorm) + conj(diagIbus) * diagVnorm\n    dS_dVa = 1j * diagV * conj(diagIbus - Y * diagV)\n\n    return dS_dVm, dS_dVa", "label": 1}
{"code": "public function setJobQuery($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\JobQuery::class);\n        $this->job_query = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def initialize_page_options(options)\n      @page_margins = PageMargins.new options[:page_margins] if options[:page_margins]\n      @page_setup = PageSetup.new options[:page_setup]  if options[:page_setup]\n      @print_options = PrintOptions.new options[:print_options] if options[:print_options]\n      @header_footer = HeaderFooter.new options[:header_footer] if options[:header_footer]\n      @row_breaks = RowBreaks.new\n      @col_breaks = ColBreaks.new\n    end", "label": 4}
{"code": "func (a *LocalKeyAgent) AddKey(key *Key) (*agent.AddedKey, error) {\n\t// save it to disk (usually into ~/.tsh)\n\terr := a.keyStore.AddKey(a.proxyHost, a.username, key)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\t// load key into the teleport agent and system agent\n\treturn a.LoadKey(*key)\n}", "label": 5}
{"code": "def first(n = nil)\n      occurrences = enumerate_occurrences(start_time).take(n || 1)\n      n.nil? ? occurrences.first : occurrences\n    end", "label": 4}
{"code": "def get_iso_time_str(timestamp: Union[int, float, str, datetime]=None) -> str:\n    \"\"\"Get the ISO time string from a timestamp or date obj. Returns current time str if no timestamp is passed\"\"\"\n    if isinstance(timestamp, (int, float)):\n        maya_dt = maya.MayaDT(timestamp)\n    elif isinstance(timestamp, str):\n        maya_dt = maya.when(timestamp)\n    elif timestamp is None:\n        maya_dt = maya.now()\n    else:\n        raise ValueError(f'`{type(timestamp)}` is not supported')\n    return maya_dt.iso8601()", "label": 1}
{"code": "func WithContext(ctx context.Context, t TestReporter) (*Controller, context.Context) {\n\th, ok := t.(TestHelper)\n\tif !ok {\n\t\th = nopTestHelper{t}\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\treturn NewController(&cancelReporter{h, cancel}), ctx\n}", "label": 5}
{"code": "def _get_doc_by_line_offset(self, doc_id):\n        \"\"\"\n        Load document from xml using line offset information.\n        This is much slower than _get_doc_by_raw_offset but should\n        work everywhere.\n        \"\"\"\n        bounds = self._get_meta()[str(doc_id)].bounds\n        return xml_utils.load_chunk(self.filename, bounds, slow=True)", "label": 1}
{"code": "func (c *RPCClient) Close() error {\n\t// Call the control channel and ask it to gracefully exit. If this\n\t// errors, then we save it so that we always return an error but we\n\t// want to try to close the other channels anyways.\n\tvar empty struct{}\n\treturnErr := c.control.Call(\"Control.Quit\", true, &empty)\n\n\t// Close the other streams we have\n\tif err := c.control.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.stdout.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.stderr.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.broker.Close(); err != nil {\n\t\treturn err\n\t}\n\n\t// Return back the error we got from Control.Quit. This is very important\n\t// since we MUST return non-nil error if this fails so that Client.Kill\n\t// will properly try a process.Kill.\n\treturn returnErr\n}", "label": 5}
{"code": "func ObjectContentToType(o types.ObjectContent) (interface{}, error) {\n\t// Expect no properties in the missing set\n\tfor _, p := range o.MissingSet {\n\t\tif ignoreMissingProperty(o.Obj, p) {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn nil, soap.WrapVimFault(p.Fault.Fault)\n\t}\n\n\tti := typeInfoForType(o.Obj.Type)\n\tv, err := ti.LoadFromObjectContent(o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn v.Elem().Interface(), nil\n}", "label": 5}
{"code": "def reload_relations\n      relations.each_pair do |name, meta|\n        if instance_variable_defined?(\"@_#{name}\")\n          if _parent.nil? || instance_variable_get(\"@_#{name}\") != _parent\n            remove_instance_variable(\"@_#{name}\")\n          end\n        end\n      end\n    end", "label": 4}
{"code": "def graphic_state(graphic_state_dictionary = {})\n      # if the graphic state exists, return it's name\n      resources[:ExtGState] ||= {}\n      gs_res = resources[:ExtGState][:referenced_object] || resources[:ExtGState]\n      gs_res.each do |k, v|\n        return k if v.is_a?(Hash) && v == graphic_state_dictionary\n      end\n      # set graphic state type\n      graphic_state_dictionary[:Type] = :ExtGState\n      # set a secure name for the graphic state\n      name = SecureRandom.hex(9).to_sym\n      # add object to reasource\n      gs_res[name] = graphic_state_dictionary\n      # return name\n      name\n    end", "label": 4}
{"code": "@Override\r\n  @SuppressWarnings(\"unchecked\")\r\n  public V put(K key, V value) {\r\n    if (value == null) {\r\n      return put(key, (V)nullValue);\r\n    }\r\n    // key could be not in original or in deltaMap\r\n    // key could be not in original but in deltaMap\r\n    // key could be in original but removed from deltaMap\r\n    // key could be in original but mapped to something else in deltaMap\r\n    V result = deltaMap.put(key, value);\r\n    if (result == null) {\r\n      return originalMap.get(key);\r\n    }\r\n    if (result == nullValue) {\r\n      return null;\r\n    }\r\n    if (result == removedValue) {\r\n      return null;\r\n    }\r\n    return result;\r\n  }", "label": 0}
{"code": "def edit(self, id, seq, resource): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Edit a highlight.\n\n        :param id: Result ID as an int.\n        :param seq: TestResult sequence ID as an int.\n        :param resource: :class:`highlights.Highlight <highlights.Highlight>` object\n        :return: :class:`highlights.Highlight <highlights.Highlight>` object\n        :rtype: highlights.Highlight\n        \"\"\"\n        return self.create_or_edit(id, seq, resource)", "label": 1}
{"code": "public function basic_reject($delivery_tag, $requeue)\n    {\n        list($class_id, $method_id, $args) = $this->protocolWriter->basicReject($delivery_tag, $requeue);\n        $this->send_method_frame(array($class_id, $method_id), $args);\n    }", "label": 2}
{"code": "def make_enum(enum_mappings):\n        \"\"\"\n        Creates a type converter for an enumeration or text-to-value mapping.\n\n        :param enum_mappings: Defines enumeration names and values.\n        :return: Type converter function object for the enum/mapping.\n        \"\"\"\n        if (inspect.isclass(enum_mappings) and\n            issubclass(enum_mappings, enum.Enum)):\n            enum_class = enum_mappings\n            enum_mappings = enum_class.__members__\n\n        def convert_enum(text):\n            if text not in convert_enum.mappings:\n                text = text.lower()     # REQUIRED-BY: parse re.IGNORECASE\n            return convert_enum.mappings[text]    #< text.lower() ???\n        convert_enum.pattern = r\"|\".join(enum_mappings.keys())\n        convert_enum.mappings = enum_mappings\n        return convert_enum", "label": 1}
{"code": "func (s *APIServer) deleteReverseTunnel(auth ClientI, w http.ResponseWriter, r *http.Request, p httprouter.Params, version string) (interface{}, error) {\n\tdomainName := p.ByName(\"domain\")\n\terr := auth.DeleteReverseTunnel(domainName)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn message(fmt.Sprintf(\"reverse tunnel %v deleted\", domainName)), nil\n}", "label": 5}
{"code": "def _all_pred(opts)\n      predicate = opts[:predicate]\n      raise 'predicate must be provided' unless predicate\n\n      visible = opts.fetch :visible, true\n      %($.mainApp().getAllWithPredicate(\"#{predicate}\", #{visible});)\n    end", "label": 4}
{"code": "func SetupUser(process *service.TeleportProcess, username string, roles []services.Role) error {\n\tauth := process.GetAuthServer()\n\tteleUser, err := services.NewUser(username)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tif len(roles) == 0 {\n\t\trole := services.RoleForUser(teleUser)\n\t\trole.SetLogins(services.Allow, []string{username})\n\n\t\t// allow tests to forward agent, still needs to be passed in client\n\t\troleOptions := role.GetOptions()\n\t\troleOptions.ForwardAgent = services.NewBool(true)\n\t\trole.SetOptions(roleOptions)\n\n\t\terr = auth.UpsertRole(role)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tteleUser.AddRole(role.GetMetadata().Name)\n\t\troles = append(roles, role)\n\t} else {\n\t\tfor _, role := range roles {\n\t\t\terr := auth.UpsertRole(role)\n\t\t\tif err != nil {\n\t\t\t\treturn trace.Wrap(err)\n\t\t\t}\n\t\t\tteleUser.AddRole(role.GetName())\n\t\t}\n\t}\n\terr = auth.UpsertUser(teleUser)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function benchBatch(targets, cb, idx) {\n  idx |= 0;\n  if (targets.length == 0) return cb(idx);\n\n  var target = targets.shift();\n  process.stdout.write(util.format('[%s] ', idx+1));\n  try {\n    main.bench(target.name, target.func);\n    idx++;\n  } catch (err) {\n    console.log('%s failed!', target.name);\n  }\n\n  //No more targets, no need to wait\n  if (targets.length == 0) return cb(idx);\n\n  //We need to wait some seconds before the next test,\n  //or the results could vary depending on the order\n  setTimeout(function() {\n    benchBatch(targets, cb, idx); //Yeah, recursivity...\n  }, 10000);\n}", "label": 3}
{"code": "def get_portfolios3():\n    \"\"\" Returns portfolios with U12 and U20 generators removed and generators\n    of the same type at the same bus aggregated.\n    \"\"\"\n    g1 = [0]\n    g2 = [1]\n    g7 = [2]\n    g13 = [3]\n    g14 = [4] # sync cond\n    g15 = [5]\n    g16 = [6]\n    g18 = [7]\n    g21 = [8]\n    g22 = [9]\n    g23 = [10, 11]\n\n    portfolios = [g1 + g15 + g18,\n                  g2 + g16 + g21,\n                  g13 + g22,\n                  g7 + g23]\n\n    passive = g14 # sync_cond\n\n    return portfolios, passive", "label": 1}
{"code": "def sendRequest(self, name, args):\n        \"\"\"sends a request to the peer\"\"\"\n        (respEvt, id) = self.newResponseEvent()\n        self.sendMessage({\"id\":id, \"method\":name, \"params\": args})\n        return respEvt", "label": 1}
{"code": "public static function format($value, $format)\n    {\n        if ($value instanceof \\DateTime) {\n            $value = $value->getTimestamp();\n        } elseif (is_string($value)) {\n            $value = strtotime($value);\n        } elseif (!is_int($value)) {\n            throw new \\InvalidArgumentException('Unable to handle the provided'\n                . ' timestamp type: ' . gettype($value));\n        }\n\n        switch ($format) {\n            case 'iso8601':\n                return gmdate('Y-m-d\\TH:i:s\\Z', $value);\n            case 'rfc822':\n                return gmdate('D, d M Y H:i:s \\G\\M\\T', $value);\n            case 'unixTimestamp':\n                return $value;\n            default:\n                throw new \\UnexpectedValueException('Unknown timestamp format: '\n                    . $format);\n        }\n    }", "label": 2}
{"code": "public static nstrace get(nitro_service service) throws Exception{\n\t\tnstrace obj = new nstrace();\n\t\tnstrace[] response = (nstrace[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def call(env)\n      req = Rack::Request.new(env)\n      status, headers, response = @app.call(env)\n\n      config = SecureHeaders.config_for(req)\n      flag_cookies!(headers, override_secure(env, config.cookies)) unless config.cookies == OPT_OUT\n      headers.merge!(SecureHeaders.header_hash_for(req))\n      [status, headers, response]\n    end", "label": 4}
{"code": "func (c *Config) SSHProxyHostPort() (string, int) {\n\tif c.SSHProxyAddr != \"\" {\n\t\taddr, err := utils.ParseAddr(c.SSHProxyAddr)\n\t\tif err == nil {\n\t\t\treturn addr.Host(), addr.Port(defaults.SSHProxyListenPort)\n\t\t}\n\t}\n\n\twebProxyHost, _ := c.WebProxyHostPort()\n\treturn webProxyHost, defaults.SSHProxyListenPort\n}", "label": 5}
{"code": "function createOverlay(config) {\n\n    var id = MODAL_OVERLAY_ID;\n    var overlayText = config.text || MODAL_OVERLAY_TXT;\n    var overlayClass = config.prefixClass + MODAL_OVERLAY_CLASS_SUFFIX;\n    var overlayBackgroundEnabled = config.backgroundEnabled === 'disabled' ? 'disabled' : 'enabled';\n\n    return '<span\\n                    id=\"' + id + '\"\\n                    class=\"' + overlayClass + '\"\\n                    ' + MODAL_OVERLAY_BG_ENABLED_ATTR + '=\"' + overlayBackgroundEnabled + '\"\\n                    title=\"' + overlayText + '\"\\n                    >\\n                    <span class=\"' + VISUALLY_HIDDEN_CLASS + '\">' + overlayText + '</span>\\n                  </span>';\n  }", "label": 3}
{"code": "public function setFound($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\V1\\Document::class);\n        $this->writeOneof(1, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "protected function serializeCriteria()\n    {\n        try {\n            return serialize($this->getCriteria());\n        } catch (Exception $e) {\n            return serialize($this->getCriteria()->map(function ($criterion) {\n                return $this->serializeCriterion($criterion);\n            }));\n        }\n    }", "label": 2}
{"code": "def spatialDomainNoGrid(self):\r\n    \"\"\"\r\n    Superposition of analytical solutions without a gridded domain\r\n    \"\"\"\r\n    self.w = np.zeros(self.xw.shape)\r\n\r\n    if self.Debug:\r\n      print(\"w = \")\r\n      print(self.w.shape)\r\n    \r\n    for i in range(len(self.q)):\r\n      # More efficient if we have created some 0-load points\r\n      # (e.g., for where we want output)\r\n      if self.q[i] != 0:\r\n        dist = np.abs(self.xw - self.x[i])\r\n        self.w -= self.q[i] * self.coeff * np.exp(-dist/self.alpha) * \\\r\n          ( np.cos(dist/self.alpha) + np.sin(dist/self.alpha) )", "label": 1}
{"code": "def from_dict(cls, json_dict):\n        '''Return a macaroon obtained from the given dictionary as\n        deserialized from JSON.\n        @param json_dict The deserialized JSON object.\n        '''\n        json_macaroon = json_dict.get('m')\n        if json_macaroon is None:\n            # Try the v1 format if we don't have a macaroon field.\n            m = pymacaroons.Macaroon.deserialize(\n                json.dumps(json_dict), json_serializer.JsonSerializer())\n            macaroon = Macaroon(root_key=None, id=None,\n                                namespace=legacy_namespace(),\n                                version=_bakery_version(m.version))\n            macaroon._macaroon = m\n            return macaroon\n\n        version = json_dict.get('v', None)\n        if version is None:\n            raise ValueError('no version specified')\n        if (version < VERSION_3 or\n                version > LATEST_VERSION):\n            raise ValueError('unknown bakery version {}'.format(version))\n        m = pymacaroons.Macaroon.deserialize(json.dumps(json_macaroon),\n                                             json_serializer.JsonSerializer())\n        if m.version != macaroon_version(version):\n            raise ValueError(\n                'underlying macaroon has inconsistent version; '\n                'got {} want {}'.format(m.version, macaroon_version(version)))\n        namespace = checkers.deserialize_namespace(json_dict.get('ns'))\n        cdata = json_dict.get('cdata', {})\n        caveat_data = {}\n        for id64 in cdata:\n            id = b64decode(id64)\n            data = b64decode(cdata[id64])\n            caveat_data[id] = data\n        macaroon = Macaroon(root_key=None, id=None,\n                            namespace=namespace,\n                            version=version)\n        macaroon._caveat_data = caveat_data\n        macaroon._macaroon = m\n        return macaroon", "label": 1}
{"code": "public function setRange($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\CompensationInfo_CompensationRange::class);\n        $this->writeOneof(4, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public ForeignkeyDef getForeignkey(String name, String tableName)\r\n    {\r\n        String        realName = (name == null ? \"\" : name);\r\n        ForeignkeyDef def      = null;\r\n\r\n        for (Iterator it = getForeignkeys(); it.hasNext();)\r\n        {\r\n            def = (ForeignkeyDef)it.next();\r\n            if (realName.equals(def.getName()) &&\r\n                def.getTableName().equals(tableName))\r\n            {\r\n                return def;\r\n            }\r\n        }\r\n        return null;\r\n    }", "label": 0}
{"code": "def get_android_inspect(class_name = false)\n      source = get_source\n\n      doctype_string = '<!doctyp'\n      source_header  = source[0..doctype_string.length].downcase\n      source_is_html = source_header.start_with?(doctype_string, '<html')\n\n      parser = if source_is_html # parse html from webview\n                 @android_html_parser ||= Nokogiri::HTML::SAX::Parser.new(Appium::Common::HTMLElements.new)\n               else\n                 @android_native_parser ||= Nokogiri::XML::SAX::Parser.new(AndroidElements.new)\n               end\n      parser.document.reset # ensure document is reset before parsing\n      parser.document.filter = class_name\n      parser.parse source\n      result = parser.document.result\n      parser.document.reset # clean up any created objects after parsing\n      result\n    end", "label": 4}
{"code": "func (f *Fpdf) outbuf(r io.Reader) {\n\tif f.state == 2 {\n\t\tf.pages[f.page].ReadFrom(r)\n\t\tf.pages[f.page].WriteString(\"\\n\")\n\t} else {\n\t\tf.buffer.ReadFrom(r)\n\t\tf.buffer.WriteString(\"\\n\")\n\t}\n}", "label": 5}
{"code": "func TryExclusiveKeyLock(lockDir string, key string) (*KeyLock, error) {\n\treturn createAndLock(lockDir, key, keyLockExclusive|keyLockNonBlocking)\n}", "label": 5}
{"code": "public function beginSignedUploadSession(array $options = [])\n    {\n        $expires = new \\DateTimeImmutable('+1 minute');\n        $startUri = $this->signedUploadUrl($expires, $options);\n\n        $uploaderOptions = $this->pluckArray([\n            'contentType',\n            'origin'\n        ], $options);\n\n        if (!isset($uploaderOptions['origin'])) {\n            $uploaderOptions['origin'] = '*';\n        }\n\n        $uploader = new SignedUrlUploader($this->connection->requestWrapper(), '', $startUri, $uploaderOptions);\n\n        return $uploader->getResumeUri();\n    }", "label": 2}
{"code": "def set_current_scope(scope, klass)\n      if scope.nil?\n        if Thread.current[CURRENT_SCOPE_KEY]\n          Thread.current[CURRENT_SCOPE_KEY].delete(klass)\n          Thread.current[CURRENT_SCOPE_KEY] = nil if Thread.current[CURRENT_SCOPE_KEY].empty?\n        end\n      else\n        Thread.current[CURRENT_SCOPE_KEY] ||= {}\n        Thread.current[CURRENT_SCOPE_KEY][klass] = scope\n      end\n    end", "label": 4}
{"code": "public static dnsview[] get(nitro_service service, String viewname[]) throws Exception{\n\t\tif (viewname !=null && viewname.length>0) {\n\t\t\tdnsview response[] = new dnsview[viewname.length];\n\t\t\tdnsview obj[] = new dnsview[viewname.length];\n\t\t\tfor (int i=0;i<viewname.length;i++) {\n\t\t\t\tobj[i] = new dnsview();\n\t\t\t\tobj[i].set_viewname(viewname[i]);\n\t\t\t\tresponse[i] = (dnsview) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "private function retryCommandOnFailure(CommandInterface $command, $method)\n    {\n        $failure = false;\n\n        RETRY_COMMAND: {\n            try {\n                $response = $this->getConnection($command)->$method($command);\n            } catch (ConnectionException $exception) {\n                $connection = $exception->getConnection();\n                $connection->disconnect();\n\n                $this->remove($connection);\n\n                if ($failure) {\n                    throw $exception;\n                } elseif ($this->useClusterSlots) {\n                    $this->askSlotsMap();\n                }\n\n                $failure = true;\n\n                goto RETRY_COMMAND;\n            }\n        }\n\n        return $response;\n    }", "label": 2}
{"code": "function ParsedArgs (args) {\n  /**\n   * The command to run (\"browserify\" or \"watchify\")\n   * @type {string}\n   */\n  this.cmd = \"browserify\";\n\n  /**\n   * The base directory for the entry-file glob pattern.\n   * See {@link helpers#getBaseDir} for details.\n   * @type {string}\n   */\n  this.baseDir = \"\";\n\n  /**\n   * Options for how the entry-file glob pattern should be parsed.\n   * For example if an --exclude argument is specified, then `globOptions.ignore` will be set accordingly.\n   * @type {object}\n   */\n  this.globOptions = { ignore: []};\n\n  /**\n   * The index of the entry-file glob argument.\n   * If there is no entry-file argument, or it's not a glob pattern, then this will be -1.\n   * @type {number}\n   */\n  this.globIndex = -1;\n\n  /**\n   * The index of the outfile argument.\n   * If there is no outfile argument, or it's not a glob pattern, then this will be -1;\n   * @type {number}\n   */\n  this.outfileIndex = -1;\n\n  /**\n   * The arguments to pass to browserify.\n   * If {@link globIndex} or {@link outfileIndex} are set, then the corresponding elements in\n   * this array will be the corresponding functions.\n   * @type {Array}\n   */\n  this.args = [];\n\n  args = args || [];\n  while (args.length > 0) {\n    parseOutfile(args, this) ||\n    parseExclude(args, this) ||\n    parseWatch(args, this) ||\n    parseSubArgs(args, this) ||\n    parseDashArgs(args, this) ||\n    parseGlobs(args, this) ||\n    passThrough(args, this);\n  }\n}", "label": 3}
{"code": "function hashCode() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var hash = 0;\n    for (var i = 0; i < args.length; ++i) {\n        var str = args[i] || '';\n        for (var j = 0, l = str.length; j < l; ++j) {\n            var char = str.charCodeAt(j);\n            hash = ((hash << 5) - hash) + char;\n            hash |= 0; // Convert to 32bit integer\n        }\n    }\n    return hash;\n}", "label": 3}
{"code": "function shouldBeIncluded(file) {\n  let isIncluded = false\n  let isIgnored = false\n  if (hasIgnorePattern) {\n    return !ignorePattern.test(file)\n  }\n  if (hasIncludePattern) {\n    return includePattern.test(file)\n  }\n  return true\n}", "label": 3}
{"code": "func (p *Collector) Create(ctx context.Context) (*Collector, error) {\n\treq := types.CreatePropertyCollector{\n\t\tThis: p.Reference(),\n\t}\n\n\tres, err := methods.CreatePropertyCollector(ctx, p.roundTripper, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewp := Collector{\n\t\troundTripper: p.roundTripper,\n\t\treference:    res.Returnval,\n\t}\n\n\treturn &newp, nil\n}", "label": 5}
{"code": "func (r *Role) String() string {\n\tswitch string(*r) {\n\tcase string(RoleSignup):\n\t\treturn \"User signup\"\n\tcase string(RoleTrustedCluster), string(LegacyClusterTokenType):\n\t\treturn \"trusted_cluster\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"%v\", string(*r))\n\t}\n}", "label": 5}
{"code": "function HttpBackend() {\n    this.requests = [];\n    this.expectedRequests = [];\n    const self = this;\n\n    // All the promises our flush requests have returned. When all these promises are\n    // resolved or rejected, there are no more flushes in progress.\n    // For simplicity we never remove promises from this loop: this is a mock utility\n    // for short duration tests, so this keeps it simpler.\n    this._flushPromises = [];\n\n    // the request function dependency that the SDK needs.\n    this.requestFn = function(opts, callback) {\n        const req = new Request(opts, callback);\n        console.log(`${Date.now()} HTTP backend received request: ${req}`);\n        self.requests.push(req);\n\n        const abort = function() {\n            const idx = self.requests.indexOf(req);\n            if (idx >= 0) {\n                console.log(\"Aborting HTTP request: %s %s\", opts.method,\n                            opts.uri);\n                self.requests.splice(idx, 1);\n                req.callback(\"aborted\");\n            }\n        };\n\n        return {\n            abort: abort,\n        };\n    };\n\n    // very simplistic mapping from the whatwg fetch interface onto the request\n    // interface, so we can use the same mock backend for both.\n    this.fetchFn = function(input, init) {\n        init = init || {};\n        const requestOpts = {\n            uri: input,\n            method: init.method || 'GET',\n            body: init.body,\n        };\n\n        return new Promise((resolve, reject) => {\n            function callback(err, response, body) {\n                if (err) {\n                    reject(err);\n                }\n                resolve({\n                    ok: response.statusCode >= 200 && response.statusCode < 300,\n                    json: () => JSON.parse(body),\n                });\n            };\n\n            const req = new Request(requestOpts, callback);\n            console.log(`HTTP backend received request: ${req}`);\n            self.requests.push(req);\n        });\n    };\n}", "label": 3}
{"code": "public static base_responses delete(nitro_service client, String Dnssuffix[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (Dnssuffix != null && Dnssuffix.length > 0) {\n\t\t\tdnssuffix deleteresources[] = new dnssuffix[Dnssuffix.length];\n\t\t\tfor (int i=0;i<Dnssuffix.length;i++){\n\t\t\t\tdeleteresources[i] = new dnssuffix();\n\t\t\t\tdeleteresources[i].Dnssuffix = Dnssuffix[i];\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function (driver, remote, options, deferred, response) {\n      this.data = '';\n      response.on('data', driver._concatDataChunks.bind(this));\n      response.on('end', driver._onResponseEnd.bind(this, driver, response, remote, options, deferred));\n      return this;\n    }", "label": 3}
{"code": "def exec_psql(self, command, psql_opts=['-qtA']):\n        \"\"\"\n        Execute a ``psql`` command inside a running container. By default the\n        container's database is connected to.\n\n        :param command: the command to run (passed to ``-c``)\n        :param psql_opts: a list of extra options to pass to ``psql``\n        :returns: a tuple of the command exit code and output\n        \"\"\"\n        cmd = ['psql'] + psql_opts + [\n            '--dbname', self.database,\n            '-U', self.user,\n            '-c', command,\n        ]\n        return self.inner().exec_run(cmd, user='postgres')", "label": 1}
{"code": "function processInputs(config) {\n    for (const profileKey in config) {\n        const profile = config[profileKey];\n        if (profile.skip) {\n            continue;\n        }\n\n        verifyProfile(profile, profileKey);\n\n        if (profile.file) {\n            handleFileSwagger(profile, profileKey);\n        } else {\n            handleUrlSwagger(profile, profileKey);\n        }\n    }\n}", "label": 3}
{"code": "function guessLanguage(request){\n\t//console.log(\"guessLanguage\");\n    if(typeof request === 'object'){\n        var language_header = request.headers['accept-language'],\n        languages = [];\n        regions = [];\n        request.languages = [currentLocale];\n\t\t/*\n\t\tfor (x in request.languages)\n\t\t{\n\t\t\tconsole.log(request.languages[x] + x);\n\t\t}\n\t\t*/\n        request.regions = [currentLocale];\n        request.language = currentLocale;\n        request.region = currentLocale;\n\n        if (language_header) {\n            language_header.split(',').forEach(function(l) {\n                header = l.split(';', 1)[0];\n                lr = header.split('-', 2);\n                if (lr[0]) {\n                    languages.push(lr[0].toLowerCase());\n                }\n                if (lr[1]) {\n                    regions.push(lr[1].toLowerCase());\n                }\n            });\n\n            if (languages.length > 0) {\n                request.languages = languages;\n                request.language = languages[0];\n            }\n\n            if (regions.length > 0) {\n                request.regions = regions;\n                request.region = regions[0];\n            }\n        }\n        i18n.setLocale(request.language);\n    }\n}", "label": 3}
{"code": "protected function formatClosureListener(Closure $listener)\n    {\n        $listener = new ReflectionFunction($listener);\n\n        return sprintf('Closure at %s[%s:%s]',\n            $listener->getFileName(),\n            $listener->getStartLine(),\n            $listener->getEndLine()\n        );\n    }", "label": 2}
{"code": "public function registerJob($identifier, $func, array $options = [])\n    {\n        if ($func instanceof \\Closure) {\n            throw new \\InvalidArgumentException('Closure is not allowed');\n        }\n        // Always work on the latest data\n        $result = $this->configStorage->lock();\n        if ($result === false) {\n            return false;\n        }\n        $this->config = $this->configStorage->load();\n        $this->config->registerJob(\n            $identifier,\n            function ($id) use ($identifier, $func, $options) {\n                return new BatchJob($identifier, $func, $id, $options);\n            }\n        );\n\n        try {\n            $result = $this->configStorage->save($this->config);\n        } finally {\n            $this->configStorage->unlock();\n        }\n        return $result;\n    }", "label": 2}
{"code": "def call_action(matches)\n      @action.arity > 0 ? @action.call(matches) : @action.call\n    rescue => ex\n      UI.error \"Problem with watch action!\\n#{ex.message}\"\n      UI.error ex.backtrace.join(\"\\n\")\n    end", "label": 4}
{"code": "def update(self):\n        \"\"\" Updates information about the NepDate \"\"\"\n        functions.check_valid_bs_range(self)\n        # Here's a trick to find the gregorian date:\n        # We find the number of days from earliest nepali date to the current\n        # day. We then add the number of days to the earliest english date\n        self.en_date = values.START_EN_DATE + \\\n            (\n                self - NepDate(\n                    values.START_NP_YEAR,\n                    1,\n                    1\n                )\n            )\n        return self", "label": 1}
{"code": "function(s) {\n    s = s.replace(/\\s/, \"\");\n    var v = window.parseFloat(s);\n\n    return s.match(/[^m]s$/i)\n      ? v * 1000\n      : v;\n  }", "label": 3}
{"code": "def definition_for_nil_entry\n      reference = @entry.at_xpath('./*/cda:outboundRelationship/cda:criteriaReference', HQMF2::Document::NAMESPACES)\n      ref_id = nil\n      unless reference.nil?\n        ref_id = \"#{HQMF2::Utilities.attr_val(reference, 'cda:id/@extension')}_#{HQMF2::Utilities.attr_val(reference, 'cda:id/@root')}\"\n      end\n      reference_criteria = @data_criteria_references[strip_tokens(ref_id)] unless ref_id.nil?\n      if reference_criteria\n        # we only want to copy the reference criteria definition, status, and code_list_id if this is this is not a grouping criteria (i.e., there are no children)\n        if @children_criteria.blank?\n          @definition = reference_criteria.definition\n          @status = reference_criteria.status\n          if @specific_occurrence\n            @title = reference_criteria.title\n            @description = reference_criteria.description\n            @code_list_id = reference_criteria.code_list_id\n          end\n        else\n          # if this is a grouping data criteria (has children) mark it as derived and only pull title and description from the reference criteria\n          @definition = 'derived'\n          if @specific_occurrence\n            @title = reference_criteria.title\n            @description = reference_criteria.description\n          end\n        end\n      else\n        puts \"MISSING_DC_REF: #{ref_id}\" unless @variable\n        @definition = 'variable'\n      end\n    end", "label": 4}
{"code": "func (c *ChainInfo) Forward(action Action, ip net.IP, port int, proto, destAddr string, destPort int, bridgeName string) error {\n\tdaddr := ip.String()\n\tif ip.IsUnspecified() {\n\t\t// iptables interprets \"0.0.0.0\" as \"0.0.0.0/32\", whereas we\n\t\t// want \"0.0.0.0/0\". \"0/0\" is correctly interpreted as \"any\n\t\t// value\" by both iptables and ip6tables.\n\t\tdaddr = \"0/0\"\n\t}\n\n\targs := []string{\n\t\t\"-p\", proto,\n\t\t\"-d\", daddr,\n\t\t\"--dport\", strconv.Itoa(port),\n\t\t\"-j\", \"DNAT\",\n\t\t\"--to-destination\", net.JoinHostPort(destAddr, strconv.Itoa(destPort))}\n\tif !c.HairpinMode {\n\t\targs = append(args, \"!\", \"-i\", bridgeName)\n\t}\n\tif err := ProgramRule(Nat, c.Name, action, args); err != nil {\n\t\treturn err\n\t}\n\n\targs = []string{\n\t\t\"!\", \"-i\", bridgeName,\n\t\t\"-o\", bridgeName,\n\t\t\"-p\", proto,\n\t\t\"-d\", destAddr,\n\t\t\"--dport\", strconv.Itoa(destPort),\n\t\t\"-j\", \"ACCEPT\",\n\t}\n\tif err := ProgramRule(Filter, c.Name, action, args); err != nil {\n\t\treturn err\n\t}\n\n\targs = []string{\n\t\t\"-p\", proto,\n\t\t\"-s\", destAddr,\n\t\t\"-d\", destAddr,\n\t\t\"--dport\", strconv.Itoa(destPort),\n\t\t\"-j\", \"MASQUERADE\",\n\t}\n\n\tif err := ProgramRule(Nat, \"POSTROUTING\", action, args); err != nil {\n\t\treturn err\n\t}\n\n\tif proto == \"sctp\" {\n\t\t// Linux kernel v4.9 and below enables NETIF_F_SCTP_CRC for veth by\n\t\t// the following commit.\n\t\t// This introduces a problem when conbined with a physical NIC without\n\t\t// NETIF_F_SCTP_CRC. As for a workaround, here we add an iptables entry\n\t\t// to fill the checksum.\n\t\t//\n\t\t// https://github.com/torvalds/linux/commit/c80fafbbb59ef9924962f83aac85531039395b18\n\t\targs = []string{\n\t\t\t\"-p\", proto,\n\t\t\t\"--sport\", strconv.Itoa(destPort),\n\t\t\t\"-j\", \"CHECKSUM\",\n\t\t\t\"--checksum-fill\",\n\t\t}\n\t\tif err := ProgramRule(Mangle, \"POSTROUTING\", action, args); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "func NewLogActionFn(ctx RuleContext) interface{} {\n\tl := &LogAction{ctx: ctx}\n\twriter, ok := ctx.(io.Writer)\n\tif ok && writer != nil {\n\t\tl.writer = writer\n\t}\n\treturn l.Log\n}", "label": 5}
{"code": "function analyze (entry, options) {\n  options = options || {}\n\n  let result = {}\n\n  // support array\n  if (!Array.isArray(entry)) {\n    entry = [entry]\n  }\n\n  entry.forEach(file => {\n    let content\n\n    // normalize file\n    if (typeof file === 'string') {\n      content = fs.readFileSync(file, 'utf8')\n    } else {\n      content = file.content\n      file = file.file\n    }\n\n    let filter = options.filter\n    let depResolve = options.depResolve\n    let depth = options.depth\n\n    analyzeFile(file, content, filter, depResolve, depth, result)\n  })\n\n  return result\n}", "label": 3}
{"code": "private function createRepository(EntityManagerInterface $entityManager, $entityName)\n    {\n        /** @var ClassMetadata $metadata */\n        $metadata            = $entityManager->getClassMetadata($entityName);\n        $repositoryClassName = $metadata->getCustomRepositoryClassName()\n            ?: $entityManager->getConfiguration()->getDefaultRepositoryClassName();\n\n        return new $repositoryClassName($entityManager, $metadata);\n    }", "label": 2}
{"code": "def get_step_index(self, step=None):\n        \"\"\"\n        Returns the index for the given `step` name. If no step is given,\n        the current step will be used to get the index.\n        \"\"\"\n        if step is None:\n            step = self.steps.current\n        return self.get_form_list().keyOrder.index(step)", "label": 1}
{"code": "func (s *gRPCBrokerServer) Recv() (*plugin.ConnInfo, error) {\n\tselect {\n\tcase <-s.quit:\n\t\treturn nil, errors.New(\"broker closed\")\n\tcase i := <-s.recv:\n\t\treturn i, nil\n\t}\n}", "label": 5}
{"code": "def seek_to(topic, partition, offset)\n      @processed_offsets[topic] ||= {}\n      @processed_offsets[topic][partition] = offset\n\n      @fetcher.seek(topic, partition, offset)\n    end", "label": 4}
{"code": "func (s *AccessService) GetRole(name string) (services.Role, error) {\n\tif name == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing role name\")\n\t}\n\titem, err := s.Get(context.TODO(), backend.Key(rolesPrefix, name, paramsPrefix))\n\tif err != nil {\n\t\tif trace.IsNotFound(err) {\n\t\t\treturn nil, trace.NotFound(\"role %v is not found\", name)\n\t\t}\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn services.GetRoleMarshaler().UnmarshalRole(item.Value,\n\t\tservices.WithResourceID(item.ID), services.WithExpires(item.Expires))\n}", "label": 5}
{"code": "private function processComponent(\n        OutputInterface $output,\n        GitHub $github,\n        Split $split,\n        array $component,\n        $splitBinaryPath,\n        $parentTagSource\n    ) {\n        $output->writeln('');\n        $localVersion = current($this->componentManager->componentsVersion($component['id']));\n        $isAlreadyTagged = $github->doesTagExist($component['target'], $localVersion);\n\n        $output->writeln(sprintf(\n            '<comment>%s</comment>: Starting on component. Target version <info>%s</info>',\n            $component['id'],\n            $localVersion\n        ));\n\n        $this->writeDiv($output);\n\n        if ($isAlreadyTagged) {\n            $output->writeln(sprintf(\n                'Version <info>%s</info> already exists on target <info>%s</info>',\n                $localVersion,\n                $component['target']\n            ));\n\n            $output->writeln('<comment>[info]</comment> Skipping.');\n            return true;\n        }\n\n        $output->writeln(sprintf(\n            '<comment>%s</comment>: Running splitsh',\n            $component['id']\n        ));\n\n        $splitBranch = $split->execute($splitBinaryPath, $this->rootPath, $component['path']);\n        if ($splitBranch) {\n            $output->writeln(sprintf('Split succeeded, branch <info>%s</info> created.', $splitBranch));\n        } else {\n            $output->writeln('<error>Split failed!</error>');\n\n            return false;\n        }\n\n        $output->writeln('');\n\n        $output->writeln(sprintf(\n            '<comment>%s</comment>: Push to github target %s',\n            $component['id'],\n            $component['target']\n        ));\n\n        $res = $github->push($component['target'], $splitBranch);\n        if ($res[0]) {\n            $output->writeln(sprintf('<comment>%s</comment>: Push succeeded.', $component['id']));\n        } else {\n            $output->writeln(sprintf('<error>%s</error>: Push failed.', $component['id']));\n\n            return false;\n        }\n\n        $output->writeln('');\n        $output->writeln('<comment>[info]</comment> Creating GitHub tag.');\n\n        // @todo once the release builder is refactored, this should generate\n        //       actually useful release notes for the component in question.\n        $notes = sprintf(\n            'For release notes, please see the [associated Google Cloud PHP release](%s).',\n            $parentTagSource\n        );\n\n        $res = $github->createRelease(\n            $component['target'],\n            $localVersion,\n            $component['displayName'] . ' ' . $localVersion,\n            $notes\n        );\n\n        if ($res) {\n            $output->writeln(sprintf('<comment>%s</comment>: Tag succeeded.', $component['id']));\n        } else {\n            $output->writeln(sprintf('<error>%s</error>: Tag failed.', $component['id']));\n\n            return false;\n        }\n\n        return true;\n    }", "label": 2}
{"code": "func New(ctx context.Context, opts ...KeygenOption) (*Keygen, error) {\n\tctx, cancel := context.WithCancel(ctx)\n\tk := &Keygen{\n\t\tctx:             ctx,\n\t\tcancel:          cancel,\n\t\tprecomputeCount: PrecomputedNum,\n\t\tclock:           clockwork.NewRealClock(),\n\t}\n\tfor _, opt := range opts {\n\t\tif err := opt(k); err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t}\n\n\tif k.precomputeCount > 0 {\n\t\tlog.Debugf(\"SSH cert authority is going to pre-compute %v keys.\", k.precomputeCount)\n\t\tk.keysCh = make(chan keyPair, k.precomputeCount)\n\t\tgo k.precomputeKeys()\n\t} else {\n\t\tlog.Debugf(\"SSH cert authority started with no keys pre-compute.\")\n\t}\n\n\treturn k, nil\n}", "label": 5}
{"code": "private function applyRegexFilter(\n        $objectsIterator,\n        $logKeyPrefix,\n        $candidatePrefix\n    ) {\n        // If the prefix and candidate prefix are not the same, then there were\n        // WILDCARDs.\n        if ($logKeyPrefix !== $candidatePrefix) {\n            // Turn the candidate prefix into a regex by trimming and\n            // converting WILDCARDs to regex notation.\n            $regex = rtrim($candidatePrefix, '/' . self::PREFIX_WILDCARD) . '/';\n            $regex = strtr($regex, [self::PREFIX_WILDCARD => '[^/]+']);\n\n            // After trimming WILDCARDs or the end, if the regex is the same as\n            // the prefix, then no regex is needed.\n            if ($logKeyPrefix !== $regex) {\n                // Apply a regex filter iterator to remove files that don't\n                // match the provided options.\n                $objectsIterator = new \\CallbackFilterIterator(\n                    $objectsIterator,\n                    function ($object) use ($regex) {\n                        return preg_match(\"#{$regex}#\", $object['Key']);\n                    }\n                );\n            }\n        }\n\n        return $objectsIterator;\n    }", "label": 2}
{"code": "def history(amount, before_id = nil, after_id = nil, around_id = nil)\n      logs = API::Channel.messages(@bot.token, @id, amount, before_id, after_id, around_id)\n      JSON.parse(logs).map { |message| Message.new(message, @bot) }\n    end", "label": 4}
{"code": "def process(self, document):\n        \"\"\"Processing a group of tasks.\"\"\"\n        self.logger.info(\"Processing group of tasks (parallel=%s)\", self.get_parallel_mode())\n        self.pipeline.data.env_list[2] = {}\n\n        output, shells = [], []\n        result = Adapter({'success': True, 'output': []})\n        for task_entry in document:\n            key, entry = list(task_entry.items())[0]\n\n            if (not self.parallel or key == 'env') and len(shells) > 0:\n                result = Adapter(self.process_shells(shells))\n                output += result.output\n                shells = []\n                if not result.success:\n                    break\n\n            if key == 'env':\n                self.pipeline.data.env_list[2].update(entry)\n\n            elif key in ['shell', 'docker(container)', 'docker(image)', 'python',\n                         'packer', 'ansible(simple)']:\n                self.prepare_shell_data(shells, key, entry)\n\n        if result.success:\n            result = Adapter(self.process_shells(shells))\n            output += result.output\n\n        self.event.delegate(result.success)\n        return {'success': result.success, 'output': output}", "label": 1}
{"code": "def start(inqueue, outqueue=None):\r\n    \"\"\"Starts the listener with incoming and outgoing queues.\"\"\"\r\n    conf.init(), db.init(conf.DbPath)\r\n    Listener(inqueue, outqueue).run()", "label": 1}
{"code": "func (f *Fpdf) SetErrorf(fmtStr string, args ...interface{}) {\n\tif f.err == nil {\n\t\tf.err = fmt.Errorf(fmtStr, args...)\n\t}\n}", "label": 5}
{"code": "function checkTypeParameterListsIdentical(node, symbol) {\n            if (symbol.declarations.length === 1) {\n                return;\n            }\n            var firstDecl;\n            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {\n                var declaration = _a[_i];\n                if (declaration.kind === 221 /* ClassDeclaration */ || declaration.kind === 222 /* InterfaceDeclaration */) {\n                    if (!firstDecl) {\n                        firstDecl = declaration;\n                    }\n                    else if (!areTypeParametersIdentical(firstDecl.typeParameters, node.typeParameters)) {\n                        error(node.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, node.name.text);\n                    }\n                }\n            }\n        }", "label": 3}
{"code": "public String login(Authentication authentication) {\n\t\tString token = getToken();\n\t\treturn login(token, authentication);\n\t}", "label": 0}
{"code": "function(value) {\n            if(system.isObject(value)) {\n                value = value.can || false;\n            }\n\n            if(system.isString(value)) {\n                return ko.utils.arrayIndexOf(this.affirmations, value.toLowerCase()) !== -1;\n            }\n\n            return value;\n        }", "label": 3}
{"code": "def run_without_lock\n        migration = migrations.detect { |m| m.version == @target_version }\n        raise UnknownMigrationVersionError.new(@target_version) if migration.nil?\n        result = execute_migration_in_transaction(migration, @direction)\n\n        record_environment\n        result\n      end", "label": 4}
{"code": "async function maybeApi ({ apiAddress, apiOpts, ipfsConnectionTest, IpfsApi }) {\n  try {\n    const ipfs = new IpfsApi(apiAddress, apiOpts)\n    await ipfsConnectionTest(ipfs)\n    return { ipfs, provider, apiAddress }\n  } catch (error) {\n    console.log('Failed to connect to ipfs-api', apiAddress)\n  }\n}", "label": 3}
{"code": "func IsGroupMember(gid int) (bool, error) {\n\tgroups, err := os.Getgroups()\n\tif err != nil {\n\t\treturn false, trace.ConvertSystemError(err)\n\t}\n\tfor _, group := range groups {\n\t\tif group == gid {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}", "label": 5}
{"code": "def to_xml_string(str='')\n      return if empty?\n      str << '<hyperlinks>'\n      each { |hyperlink| hyperlink.to_xml_string(str) }\n      str << '</hyperlinks>'\n    end", "label": 4}
{"code": "def matches_conditions?(action, subject, attribute = nil, *extra_args)\n      return call_block_with_all(action, subject, extra_args) if @match_all\n      return matches_block_conditions(subject, attribute, *extra_args) if @block\n      return matches_non_block_conditions(subject) unless conditions_empty?\n\n      true\n    end", "label": 4}
{"code": "public void ojbAdd(Object anObject)\r\n    {\r\n        DSetEntry entry = prepareEntry(anObject);\r\n        entry.setPosition(elements.size());\r\n        elements.add(entry);\r\n    }", "label": 0}
{"code": "def send_to_cloudshark(self, id, seq, intf, inline=False): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Send a capture to a CloudShark Appliance. Both\n        cloudshark_appliance_url and cloudshark_appliance_token must\n        be properly configured via system preferences.\n\n        :param id: Result ID as an int.\n        :param seq: TestResult sequence ID as an int.\n        :param intf: Interface name as string.\n        :param inline: (optional) Use inline version of capture file.\n        :return: :class:`captures.CloudShark <captures.CloudShark>` object\n        :rtype: captures.CloudShark\n        \"\"\"\n        schema = CloudSharkSchema()\n        resp = self.service.post(self._base(id, seq)+str(intf)+'/cloudshark/', params={'inline': inline})\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "private function mapOperator($operator)\n    {\n        if (array_key_exists($operator, $this->shortOperators)) {\n            $operator = $this->shortOperators[$operator];\n        }\n\n        if (!in_array($operator, $this->allowedOperators)) {\n            throw new InvalidArgumentException(sprintf(\n                'Invalid operator `%s` given. Valid operators are %s.',\n                $operator,\n                implode(', ', $this->allowedOperators)\n            ));\n        }\n\n        return $operator;\n    }", "label": 2}
{"code": "func (s *Server) Close(p *Packet) (interface{}, error) {\n\treq := new(RequestClose)\n\terr := UnmarshalBinary(p.Payload, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession, err := s.getSession(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.mu.Lock()\n\tfile, ok := session.files[req.Handle]\n\tif ok {\n\t\tdelete(session.files, req.Handle)\n\t}\n\tsession.mu.Unlock()\n\n\tif ok {\n\t\terr = file.Close()\n\t} else {\n\t\treturn nil, &Status{Code: StatusInvalidHandle}\n\t}\n\n\treturn &ReplyClose{}, err\n}", "label": 5}
{"code": "def inherit_settings(namespace_stackable)\n      inheritable_setting.route[:saved_validations] += namespace_stackable[:validations]\n      parent_declared_params = namespace_stackable[:declared_params]\n\n      if parent_declared_params\n        inheritable_setting.route[:declared_params] ||= []\n        inheritable_setting.route[:declared_params].concat(parent_declared_params.flatten)\n      end\n\n      endpoints && endpoints.each { |e| e.inherit_settings(namespace_stackable) }\n    end", "label": 4}
{"code": "public static aaauser_intranetip_binding[] get(nitro_service service, String username) throws Exception{\n\t\taaauser_intranetip_binding obj = new aaauser_intranetip_binding();\n\t\tobj.set_username(username);\n\t\taaauser_intranetip_binding response[] = (aaauser_intranetip_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def iter_all_children(self):\n        '''Return an iterator that yields every node which is a child of this one.\n\n        This includes inline children, and control structure `else` clauses.\n        '''\n        \n        if self.inline_child:\n            yield self.inline_child\n        for x in self.children:\n            yield x", "label": 1}
{"code": "def cut_levels(nodes, start_level):\n    \"\"\"\n    cutting nodes away from menus\n    \"\"\"\n    final = []\n    removed = []\n    for node in nodes:\n        if not hasattr(node, 'level'):\n            # remove and ignore nodes that don't have level information\n            remove(node, removed)\n            continue\n        if node.attr.get('soft_root', False):\n            # remove and ignore nodes that are behind a node marked as 'soft_root'\n            remove(node, removed)\n            continue\n        if node.level == start_level:\n            # turn nodes that are on from_level into root nodes\n            final.append(node)\n            node.parent = None\n            if not node.visible and not node.children:\n                remove(node, removed)\n        elif node.level == start_level + 1:\n            # remove nodes that are deeper than one level\n            node.children = []\n        else:\n            remove(node, removed)\n        if not node.visible:\n            keep_node = False\n            for child in node.children:\n                keep_node = keep_node or child.visible\n            if not keep_node:\n                remove(node, removed)\n    for node in removed:\n        if node in final:\n            final.remove(node)\n    return final", "label": 1}
{"code": "function (e) { \n                var e = e || window.event; \n\n                if (typeof callback === 'function') {\n                    callback.call(ctx, e);\n                }\n            }", "label": 3}
{"code": "def profile\n      response = Discordrb::API::User.profile(@token)\n      LightProfile.new(JSON.parse(response), self)\n    end", "label": 4}
{"code": "public function setRelations(array $relations): self\n    {\n        // Parse and set the relations.\n        $this->relations = $this->newModelQuery()\n            ->with($relations)\n            ->getEagerLoads();\n\n        return $this;\n    }", "label": 2}
{"code": "def with_index_lock\n      lock_path = \"#{@index_file}.lock\"\n      File.open(lock_path, \"w+\") do |f|\n        f.flock(File::LOCK_EX)\n        yield\n      end\n    end", "label": 4}
{"code": "def add_first_occurring_tag_to_prs(tags, prs)\n      total = prs.count\n\n      prs_left = associate_tagged_prs(tags, prs, total)\n      prs_left = associate_release_branch_prs(prs_left, total)\n      prs_left = associate_rebase_comment_prs(tags, prs_left, total) if prs_left.any?\n      # PRs in prs_left will be untagged, not in release branch, and not\n      # rebased. They should not be included in the changelog as they probably\n      # have been merged to a branch other than the release branch.\n      @pull_requests -= prs_left\n      Helper.log.info \"Associating PRs with tags: #{total}/#{total}\"\n    end", "label": 4}
{"code": "def make_index_for(package, index_dir, verbose=True):\n    \"\"\"\n    Create an 'index.html' for one package.\n\n    :param package:   Package object to use.\n    :param index_dir: Where 'index.html' should be created.\n    \"\"\"\n    index_template = \"\"\"\\\n<html>\n<head><title>{title}</title></head>\n<body>\n<h1>{title}</h1>\n<ul>\n{packages}\n</ul>\n</body>\n</html>\n\"\"\"\n    item_template = '<li><a href=\"{1}\">{0}</a></li>'\n    index_filename = os.path.join(index_dir, \"index.html\")\n    if not os.path.isdir(index_dir):\n        os.makedirs(index_dir)\n\n    parts = []\n    for pkg_filename in package.files:\n        pkg_name = os.path.basename(pkg_filename)\n        if pkg_name == \"index.html\":\n            # -- ROOT-INDEX:\n            pkg_name = os.path.basename(os.path.dirname(pkg_filename))\n        else:\n            pkg_name = package.splitext(pkg_name)\n        pkg_relpath_to = os.path.relpath(pkg_filename, index_dir)\n        parts.append(item_template.format(pkg_name, pkg_relpath_to))\n\n    if not parts:\n        print(\"OOPS: Package %s has no files\" % package.name)\n        return\n\n    if verbose:\n        root_index = not Package.isa(package.files[0])\n        if root_index:\n            info = \"with %d package(s)\" % len(package.files)\n        else:\n            package_versions = sorted(set(package.versions))\n            info = \", \".join(reversed(package_versions))\n        message = \"%-30s  %s\" % (package.name, info)\n        print(message)\n\n    with open(index_filename, \"w\") as f:\n        packages = \"\\n\".join(parts)\n        text = index_template.format(title=package.name, packages=packages)\n        f.write(text.strip())\n        f.close()", "label": 1}
{"code": "private void checkAllEnvelopes(PersistenceBroker broker)\r\n    {\r\n        Iterator iter = ((List) mvOrderOfIds.clone()).iterator();\r\n        while(iter.hasNext())\r\n        {\r\n            ObjectEnvelope mod = (ObjectEnvelope) mhtObjectEnvelopes.get(iter.next());\r\n            // only non transient objects should be performed\r\n            if(!mod.getModificationState().isTransient())\r\n            {\r\n                mod.markReferenceElements(broker);\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "public function getOperationDocs($operation)\n    {\n        return isset($this->docs['operations'][$operation])\n            ? $this->docs['operations'][$operation]\n            : null;\n    }", "label": 2}
{"code": "def path_to_uri(path)\n    return unless path\n\n    params = { :scheme => 'file' }\n\n    if Puppet::Util::Platform.windows?\n      path = path.gsub(/\\\\/, '/')\n\n      if unc = /^\\/\\/([^\\/]+)(\\/.+)/.match(path)\n        params[:host] = unc[1]\n        path = unc[2]\n      elsif path =~ /^[a-z]:\\//i\n        path = '/' + path\n      end\n    end\n\n    # have to split *after* any relevant escaping\n    params[:path], params[:query] = uri_encode(path).split('?')\n    search_for_fragment = params[:query] ? :query : :path\n    if params[search_for_fragment].include?('#')\n      params[search_for_fragment], _, params[:fragment] = params[search_for_fragment].rpartition('#')\n    end\n\n    begin\n      URI::Generic.build(params)\n    rescue => detail\n      raise Puppet::Error, _(\"Failed to convert '%{path}' to URI: %{detail}\") % { path: path, detail: detail }, detail.backtrace\n    end\n  end", "label": 4}
{"code": "public function setHadoopJob($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dataproc\\V1\\HadoopJob::class);\n        $this->writeOneof(2, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def _get_demand_array_construct(self):\n        \"\"\" Returns a construct for an array of power demand data.\n        \"\"\"\n        bus_no = integer.setResultsName(\"bus_no\")\n        s_rating = real.setResultsName(\"s_rating\") # MVA\n        p_direction = real.setResultsName(\"p_direction\") # p.u.\n        q_direction = real.setResultsName(\"q_direction\") # p.u.\n        p_bid_max = real.setResultsName(\"p_bid_max\") # p.u.\n        p_bid_min = real.setResultsName(\"p_bid_min\") # p.u.\n        p_optimal_bid = Optional(real).setResultsName(\"p_optimal_bid\")\n        p_fixed = real.setResultsName(\"p_fixed\") # $/hr\n        p_proportional = real.setResultsName(\"p_proportional\") # $/MWh\n        p_quadratic = real.setResultsName(\"p_quadratic\") # $/MW^2h\n        q_fixed = real.setResultsName(\"q_fixed\") # $/hr\n        q_proportional = real.setResultsName(\"q_proportional\") # $/MVArh\n        q_quadratic = real.setResultsName(\"q_quadratic\") # $/MVAr^2h\n        commitment = boolean.setResultsName(\"commitment\")\n        cost_tie_break = real.setResultsName(\"cost_tie_break\") # $/MWh\n        cost_cong_up = real.setResultsName(\"cost_cong_up\") # $/h\n        cost_cong_down = real.setResultsName(\"cost_cong_down\") # $/h\n        status = Optional(boolean).setResultsName(\"status\")\n\n        demand_data = bus_no + s_rating + p_direction + q_direction + \\\n            p_bid_max + p_bid_min + p_optimal_bid + p_fixed + \\\n            p_proportional + p_quadratic + q_fixed + q_proportional + \\\n            q_quadratic + commitment + cost_tie_break + cost_cong_up + \\\n            cost_cong_down + status + scolon\n\n        demand_data.setParseAction(self.push_demand)\n\n        demand_array = Literal(\"Demand.con\") + \"=\" + \"[\" + \"...\" + \\\n            ZeroOrMore(demand_data + Optional(\"]\" + scolon))\n\n        return demand_array", "label": 1}
{"code": "def thumbnail(options = {})\n      options = { geometry: nil, strip: false }.merge(options)\n      geometry = convert_to_geometry(options[:geometry])\n      thumbnail = image\n      thumbnail = thumbnail.thumb(geometry) if geometry\n      thumbnail = thumbnail.strip if options[:strip]\n      thumbnail\n    end", "label": 4}
{"code": "def get_time_of_tag(tag_name)\n      raise ChangelogGeneratorError, \"tag_name is nil\" if tag_name.nil?\n\n      name_of_tag = tag_name.fetch(\"name\")\n      time_for_tag_name = @tag_times_hash[name_of_tag]\n      return time_for_tag_name if time_for_tag_name\n\n      @fetcher.fetch_date_of_tag(tag_name).tap do |time_string|\n        @tag_times_hash[name_of_tag] = time_string\n      end\n    end", "label": 4}
{"code": "def SAS(self):\n    \"\"\"\n    Set-up for the rectangularly-gridded superposition of analytical solutions \n    method for solving flexure\n    \"\"\"\n    if self.x is None:\n      self.x = np.arange(self.dx/2., self.dx * self.qs.shape[0], self.dx)\n    if self.filename:\n      # Define the (scalar) elastic thickness\n      self.Te = self.configGet(\"float\", \"input\", \"ElasticThickness\")\n      # Define a stress-based qs = q0\n      self.qs = self.q0.copy()\n      # Remove self.q0 to avoid issues with multiply-defined inputs\n      # q0 is the parsable input to either a qs grid or contains (x,(y),q)\n      del self.q0\n    if self.dimension == 2:\n      if self.y is None:\n        self.y = np.arange(self.dy/2., self.dy * self.qs.shape[0], self.dy)\n      # Define a stress-based qs = q0\n      # But only if the latter has not already been defined\n      # (e.g., by the getters and setters)\n      try:\n        self.qs\n      except:\n        self.qs = self.q0.copy()\n        # Remove self.q0 to avoid issues with multiply-defined inputs\n        # q0 is the parsable input to either a qs grid or contains (x,(y),q)\n        del self.q0\n      from scipy.special import kei", "label": 1}
{"code": "def print_all_metadata(fname):\n    \"\"\" high level that prints all as long list \"\"\"\n    print(\"Filename   :\", fname )\n    print(\"Basename   :\", os.path.basename(fname))\n    print(\"Path       :\", os.path.dirname(fname))\n    print(\"Size       :\", os.path.getsize(fname))\n    img = Image.open(fname)\n    # get the image's width and height in pixels\n    width, height = img.size\n    # get the largest dimension\n    #max_dim = max(img.size)\n    print(\"Width      :\", width)\n    print(\"Height     :\", height)\n    print(\"Format     :\", img.format)\n    print(\"palette    :\", img.palette )\n     \n    print_stats(img)\n    #print_exif_data(img)\n    exif_data = get_exif_data(img)\n    (lat, lon) = get_lat_lon(exif_data)\n    print(\"GPS Lat    :\", lat )\n    print(\"GPS Long   :\", lon )", "label": 1}
{"code": "def postComponents(self, name, status, **kwargs):\n        '''Create a new component.\n\n        :param name: Name of the component\n        :param status: Status of the component; 1-4\n        :param description: (optional) Description of the component\n        :param link: (optional) A hyperlink to the component\n        :param order: (optional) Order of the component\n        :param group_id: (optional) The group id that the component is within\n        :param enabled: (optional)\n        :return: :class:`Response <Response>` object\n        :rtype: requests.Response\n        '''\n\n        kwargs['name'] = name\n        kwargs['status'] = status\n        return self.__postRequest('/components', kwargs)", "label": 1}
{"code": "function restrictSubmissionForSummary(submission) {\n  submission.formFields = _.filter(submission.formFields, function(formField) {\n    return CONSTANTS.FIELD_TYPES_INCLUDED_IN_SUMMARY.indexOf(formField.fieldId.type) >= 0;\n  });\n\n  submission.formFields = _.first(submission.formFields, CONSTANTS.NUM_FIELDS_INCLUDED_IN_SUMMARY);\n\n  return submission;\n}", "label": 3}
{"code": "function loadAdapters() {\n        var adapters = {};\n        var adaptersDir = path.join(this.injector.rootDir, this.injector.servicesDir + '/adapters');\n\n        if (!fs.existsSync(adaptersDir)) {\n            return this.injector.adapters || {};\n        }\n\n        var me = this;\n        var adapterNames = fs.readdirSync(adaptersDir);\n\n        _.each(adapterNames, function (adapterName) {\n            if (adapterName.substring(adapterName.length - 3) !== '.js') {  // only dirs, not js files\n                var adapterImpl = me.injector.adapterMap[adapterName];\n                adapterName = utils.getPascalCase(adapterImpl + '.' + adapterName + '.adapter');\n                adapters[adapterName] = me.injector.loadModule(adapterName);\n            }\n        });\n\n        // add the adapters that come from plugins to the list\n        _.extend(adapters, this.injector.adapters);\n\n        // return the adapters\n        return adapters;\n    }", "label": 3}
{"code": "function isInsideJsxElementOrAttribute(sourceFile, position) {\n        var token = getTokenAtPosition(sourceFile, position);\n        if (!token) {\n            return false;\n        }\n        if (token.kind === 244 /* JsxText */) {\n            return true;\n        }\n        // <div>Hello |</div>\n        if (token.kind === 25 /* LessThanToken */ && token.parent.kind === 244 /* JsxText */) {\n            return true;\n        }\n        // <div> { | </div> or <div a={| </div>\n        if (token.kind === 25 /* LessThanToken */ && token.parent.kind === 248 /* JsxExpression */) {\n            return true;\n        }\n        // <div> {\n        // |\n        // } < /div>\n        if (token && token.kind === 16 /* CloseBraceToken */ && token.parent.kind === 248 /* JsxExpression */) {\n            return true;\n        }\n        // <div>|</div>\n        if (token.kind === 25 /* LessThanToken */ && token.parent.kind === 245 /* JsxClosingElement */) {\n            return true;\n        }\n        return false;\n    }", "label": 3}
{"code": "public function setSessionEntityType($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\SessionEntityType::class);\n        $this->session_entity_type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def most_common_nucleotides(partitioned_read_sequences):\n    \"\"\"\n    Find the most common nucleotide at each offset to the left and\n    right of a variant.\n\n    Parameters\n    ----------\n    partitioned_read_sequences : list of tuples\n        Each tuple has three elements:\n            - sequence before mutant nucleotides\n            - mutant nucleotides\n            - sequence after mutant nucleotides\n\n    Returns a tuple with the following elements:\n        - nucleotide sequence from most common nucleotide at each offset\n           relative to the variant\n        - an array of counts indicating how many reads supported this nucleotide\n        - an array of counts for all the *other* nucleotides at that position\n    \"\"\"\n    counts, variant_column_indices = nucleotide_counts(\n        partitioned_read_sequences)\n    max_count_per_column = counts.max(axis=0)\n\n    assert len(max_count_per_column) == counts.shape[1]\n    max_nucleotide_index_per_column = np.argmax(counts, axis=0)\n    assert len(max_nucleotide_index_per_column) == counts.shape[1]\n    nucleotides = [\n        index_to_dna_nucleotide[idx]\n        for idx in max_nucleotide_index_per_column\n    ]\n    other_nucleotide_counts = counts.sum(axis=0) - max_count_per_column\n    return \"\".join(nucleotides), max_count_per_column, other_nucleotide_counts", "label": 1}
{"code": "def _get_all_children(self,):\n        \"\"\" \n        return the list of children of a node\n        \"\"\"\n        res = ''\n        if self.child_nodes:\n            for c in self.child_nodes:\n                res += ' child = ' + str(c) + '\\n'\n                if c.child_nodes:\n                    for grandchild in c.child_nodes:\n                        res += '   child = ' + str(grandchild) + '\\n'\n        else:\n            res += ' child = None\\n'\n        return res", "label": 1}
{"code": "func (i *Idm) Release(id uint64) {\n\ti.handle.Unset(id - i.start)\n}", "label": 5}
{"code": "function changelog(from, to) {\n    return vowExec(util.format('git log --format=\"%%s\" %s..%s', from, to))\n        .then(function (stdout) {\n            return stdout.split('\\n');\n        });\n}", "label": 3}
{"code": "def colors_from_hash(match, hash)\n      match[0] = mode(hash[:mode])                   if mode(hash[:mode])\n      match[1] = color(hash[:color])                 if color(hash[:color])\n      match[2] = background_color(hash[:background]) if background_color(hash[:background])\n    end", "label": 4}
{"code": "function(callback) {\n  tox.on('friendRequest', function(evt) {\n    console.log('Accepting friend request from ' + evt.publicKeyHex());\n    // Automatically accept the request\n    tox.addFriendNoRequestAsync(evt.publicKey()).then(function() {\n      console.log('Successfully accepted the friend request!');\n    }).catch(function(err) {\n      console.error('Couldn\\'t accept the friend request:', err);\n    });\n  });\n\n  tox.on('friendMessage', function(evt) {\n    console.log('Message from friend ' + evt.friend() + ': ' + evt.message());\n    // Echo message back to friend\n    tox.sendMessageAsync(evt.friend(), evt.message()).then(function(receipt) {\n      console.log('Echoed message back to friend, received receipt ' + receipt);\n    }).catch(function(err) {\n      console.error('Couldn\\'t echo message back to friend:', err);\n    });\n  });\n\n  // Setup friendMessage callback to listen for groupchat invite requests\n  tox.on('friendMessage', function(evt) {\n    if(evt.message() === 'invite text') {\n      tox.inviteAsync(evt.friend(), groupchats['text']).then(function() {\n        console.log('Invited ' + evt.friend() + ' to the text groupchat');\n      });\n    } else if(evt.message() === 'invite av') {\n      tox.inviteAsync(evt.friend(), groupchats['av']).then(function() {\n        console.log('Invited ' + evt.friend() + ' to the audio/video groupchat');\n      });\n    }\n  });\n\n  callback();\n}", "label": 3}
{"code": "def responders(*responders)\n      self.responder = responders.inject(Class.new(responder)) do |klass, responder|\n        responder = case responder\n          when Module\n            responder\n          when String, Symbol\n            Responders.const_get(\"#{responder.to_s.camelize}Responder\")\n          else\n            raise \"responder has to be a string, a symbol or a module\"\n          end\n\n        klass.send(:include, responder)\n        klass\n      end\n    end", "label": 4}
{"code": "public static base_responses disable(nitro_service client, String trapname[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (trapname != null && trapname.length > 0) {\n\t\t\tsnmpalarm disableresources[] = new snmpalarm[trapname.length];\n\t\t\tfor (int i=0;i<trapname.length;i++){\n\t\t\t\tdisableresources[i] = new snmpalarm();\n\t\t\t\tdisableresources[i].trapname = trapname[i];\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, disableresources,\"disable\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def provide_temporary_scripts_path(self):\n        \"\"\"When configured trying to ensure that path does exist.\"\"\"\n        if len(self.options.temporary_scripts_path) > 0:\n            if os.path.isfile(self.options.temporary_scripts_path):\n                self.logger.error(\"Error: configured script path seems to be a file!\")\n                # it's ok to leave because called before the collector runs\n                sys.exit(1)\n\n            if not os.path.isdir(self.options.temporary_scripts_path):\n                os.makedirs(self.options.temporary_scripts_path)", "label": 1}
{"code": "function () {\n        var i = 0;\n        var len = 0;\n        var uuid = '';\n\n        if (!this._periodicActionUUIDs) {\n            return;\n        }\n\n        len = this._periodicActionUUIDs.length;\n\n        for (; i < len; i += 1) {\n            uuid = this._periodicActionUUIDs[i];\n            this.stopPeriodicAction(uuid);\n        }\n    }", "label": 3}
{"code": "function addToArrayByNode(node, code) {\n  // node: the arr expression node\n  // code: added as the last element of the array\n\n  const multilines = node.loc.start.line !== node.loc.end.line;\n  let insertPos = node.start + 1; // insert after '['\n\n  if (node.elements.length) {\n    const ele = _.last(node.elements);\n    insertPos = ele.end;\n  }\n\n  let replacement;\n  if (multilines) {\n    const indent = _.repeat(' ', node.loc.end.column - 1);\n    replacement = `\\n${indent}  ${code}`;\n    if (node.elements.length) {\n      replacement = `,${replacement}`;\n    } else {\n      replacement = `${replacement},`;\n    }\n  } else {\n    replacement = code;\n    if (node.elements.length > 0) {\n      replacement = `, ${code}`;\n    }\n  }\n  return [\n    {\n      start: insertPos,\n      end: insertPos,\n      replacement,\n    },\n  ];\n}", "label": 3}
{"code": "async function signupUser(form) {\n  await client.connect();\n  try {\n    await api.signup(\n      {\n        credentials: {\n          login: form.login.value,\n          password: form.password.value\n        },\n        profile: {\n          email: form.email.value\n        }\n      },\n      'user'\n    );\n    displayMessage(\n      'Account created',\n      'Your account has been created, please check your emails to confirm your account',\n      'is-success'\n    );\n    goTo('login');\n  } catch (e) {\n    displayMessage('Account not created', `Your account could not been created. Cause: ${e.message}`, 'is-danger');\n  }\n}", "label": 3}
{"code": "func (c *networkConfiguration) Conflicts(o *networkConfiguration) error {\n\tif o == nil {\n\t\treturn errors.New(\"same configuration\")\n\t}\n\n\t// Also empty, because only one network with empty name is allowed\n\tif c.BridgeName == o.BridgeName {\n\t\treturn errors.New(\"networks have same bridge name\")\n\t}\n\n\t// They must be in different subnets\n\tif (c.AddressIPv4 != nil && o.AddressIPv4 != nil) &&\n\t\t(c.AddressIPv4.Contains(o.AddressIPv4.IP) || o.AddressIPv4.Contains(c.AddressIPv4.IP)) {\n\t\treturn errors.New(\"networks have overlapping IPv4\")\n\t}\n\n\t// They must be in different v6 subnets\n\tif (c.AddressIPv6 != nil && o.AddressIPv6 != nil) &&\n\t\t(c.AddressIPv6.Contains(o.AddressIPv6.IP) || o.AddressIPv6.Contains(c.AddressIPv6.IP)) {\n\t\treturn errors.New(\"networks have overlapping IPv6\")\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public static String getTabularData(String[] labels, String[][] data, int padding) {\n    int[] size = new int[labels.length];\n    \n    for (int i = 0; i < labels.length; i++) {\n      size[i] = labels[i].length() + padding;\n    }\n    \n    for (String[] row : data) {\n      for (int i = 0; i < labels.length; i++) {\n        if (row[i].length() >= size[i]) {\n          size[i] = row[i].length() + padding;\n        }\n      }\n    }\n    \n    StringBuffer tabularData = new StringBuffer();\n    \n    for (int i = 0; i < labels.length; i++) {\n      tabularData.append(labels[i]);\n      tabularData.append(fill(' ', size[i] - labels[i].length()));\n    }\n    \n    tabularData.append(\"\\n\");\n    \n    for (int i = 0; i < labels.length; i++) {\n      tabularData.append(fill('=', size[i] - 1)).append(\" \");\n    }\n    \n    tabularData.append(\"\\n\");\n    \n    \n    for (String[] row : data) {\n      for (int i = 0; i < labels.length; i++) {\n        tabularData.append(row[i]);\n        tabularData.append(fill(' ', size[i] - row[i].length()));\n      }\n      \n      tabularData.append(\"\\n\");\n    }\n    \n    return tabularData.toString();\n  }", "label": 0}
{"code": "func NewManager(client *vim25.Client) *Manager {\n\tm := Manager{\n\t\tCommon: object.NewCommon(client, *client.ServiceContent.PerfManager),\n\t}\n\n\tm.pm.PerformanceManager = new(mo.PerformanceManager)\n\n\treturn &m\n}", "label": 5}
{"code": "func AuthUserUserPermissionByUserIDPermissionID(db XODB, userID float64, permissionID float64) (*AuthUserUserPermission, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`id, user_id, permission_id ` +\n\t\t`FROM django.auth_user_user_permissions ` +\n\t\t`WHERE user_id = :1 AND permission_id = :2`\n\n\t// run query\n\tXOLog(sqlstr, userID, permissionID)\n\tauup := AuthUserUserPermission{\n\t\t_exists: true,\n\t}\n\n\terr = db.QueryRow(sqlstr, userID, permissionID).Scan(&auup.ID, &auup.UserID, &auup.PermissionID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &auup, nil\n}", "label": 5}
{"code": "def pyenv():\n    '''Install or update the pyenv python environment.\n\n    Checkout or update the pyenv repo at ~/.pyenv and enable the pyenv.\n    Pyenv wird also als Github-Repo \"installiert\" unter ~/.pyenv\n\n    More info:\n     * https://github.com/yyuu/pyenv\n     * https://github.com/yyuu/pyenv/wiki/Common-build-problems#requirements\n    Tutorial:\n     * http://amaral-lab.org/resources/guides/pyenv-tutorial\n    '''\n    install_packages([\n        'make',\n        'build-essential',\n        'libssl-dev',\n        'zlib1g-dev',\n        'libbz2-dev',\n        'libreadline-dev',\n        'libsqlite3-dev',\n        'wget',\n        'curl',\n        'llvm',\n        'libncurses5-dev',\n        'libncursesw5-dev',\n    ])\n    if exists('~/.pyenv'):\n        run('cd ~/.pyenv  &&  git pull')\n        run('~/.pyenv/bin/pyenv update')\n    else:\n        run('curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/'\n            'master/bin/pyenv-installer | bash')\n\n    # add pyenv to $PATH and set up pyenv init\n    bash_snippet = '~/.bashrc_pyenv'\n    install_file_legacy(path=bash_snippet)\n    prefix = flo('if [ -f {bash_snippet} ]; ')\n    enabler = flo('if [ -f {bash_snippet} ]; then source {bash_snippet}; fi')\n    if env.host == 'localhost':\n        # FIXME: next function currently only works for localhost\n        uncomment_or_update_or_append_line(filename='~/.bashrc', prefix=prefix,\n                                           new_line=enabler)\n    else:\n        print(cyan('\\nappend to ~/.bashrc:\\n\\n    ') + enabler)", "label": 1}
{"code": "def submit_tag(text = \"Save changes\", options = {})\n      options = options.stringify_keys\n\n      content_tag :button, text, { \"type\" => \"submit\", \"name\" => \"commit\" }.update(options)\n    end", "label": 4}
{"code": "def info_build_id(id)\n      result = OneGadget::Gadget.builds_info(id)\n      return false if result.nil? # invalid form or BuildID not found\n\n      OneGadget::Logger.info(\"Information of #{id}:\\n#{result.join(\"\\n\")}\")\n      true\n    end", "label": 4}
{"code": "public function setQueues($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Tasks\\V2\\Queue::class);\n        $this->queues = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "private function createExceptionMessage($message)\n    {\n        $parameters = $this->parameters;\n\n        if ($parameters->scheme === 'unix') {\n            return \"$message [$parameters->scheme:$parameters->path]\";\n        }\n\n        if (filter_var($parameters->host, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {\n            return \"$message [$parameters->scheme://[$parameters->host]:$parameters->port]\";\n        }\n\n        return \"$message [$parameters->scheme://$parameters->host:$parameters->port]\";\n    }", "label": 2}
{"code": "def input(name, options = {})\n      if options[:as]\n        send(options[:as].to_s, name, options[:input] || {})\n      else\n        type = find_input_type(name.to_s)\n        input_field(name, type)\n      end\n    end", "label": 4}
{"code": "public function setLabel($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Language\\V1\\DependencyEdge_Label::class);\n        $this->label = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function scan(str, re) {\n  var match = null;\n  var ret = [];\n\n  while (match = re.exec(str)) {\n    ret.push(match);\n  }\n\n  return ret;\n}", "label": 3}
{"code": "public function setFrom($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Firestore\\V1\\StructuredQuery\\CollectionSelector::class);\n        $this->from = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function _gpfNodeBuffer2JsArray (buffer) {\n    var result = [],\n        len = buffer.length,\n        idx;\n    for (idx = 0; idx < len; ++idx) {\n        result.push(buffer.readUInt8(idx));\n    }\n    return result;\n}", "label": 3}
{"code": "func (s *handler) AttachedTags(ref vim.ManagedObjectReference) ([]vim.VslmTagEntry, vim.BaseMethodFault) {\n\toid := internal.AssociatedObject(ref)\n\tvar tags []vim.VslmTagEntry\n\tfor id, objs := range s.Association {\n\t\tif objs[oid] {\n\t\t\ttag := s.Tag[id]\n\t\t\tcat := s.Category[tag.CategoryID]\n\t\t\ttags = append(tags, vim.VslmTagEntry{\n\t\t\t\tTagName:            tag.Name,\n\t\t\t\tParentCategoryName: cat.Name,\n\t\t\t})\n\t\t}\n\t}\n\treturn tags, nil\n}", "label": 5}
{"code": "func sortTemplates(templates map[string]Template, catalogSort bool) []Template {\n\tchain := make([]Template, 0, len(templates)*2)\n\n\t// build a full set of dependency chains\n\tvar keyList []string\n\tvar key string\n\tvar t Template\n\tkeyList = templateKeyList(templates, catalogSort)\n\tfor _, key = range keyList {\n\t\tt = templates[key]\n\t\ttlist := templateChainDependencies(t)\n\t\tfor _, tt := range tlist {\n\t\t\tif tt != nil {\n\t\t\t\tchain = append(chain, tt)\n\t\t\t}\n\t\t}\n\t}\n\n\t// reduce that to make a simple list\n\tsorted := make([]Template, 0, len(templates))\nchain:\n\tfor _, t := range chain {\n\t\tfor _, already := range sorted {\n\t\t\tif t == already {\n\t\t\t\tcontinue chain\n\t\t\t}\n\t\t}\n\t\tsorted = append(sorted, t)\n\t}\n\n\treturn sorted\n}", "label": 5}
{"code": "def load_from_filesystem(options)\n      return if options[:skip_metadata]\n\n      # Load localised data\n      ignore_validation = options[:ignore_language_directory_validation]\n      Loader.language_folders(options[:metadata_path], ignore_validation).each do |lang_folder|\n        language = File.basename(lang_folder)\n        (LOCALISED_VERSION_VALUES + LOCALISED_APP_VALUES).each do |key|\n          path = File.join(lang_folder, \"#{key}.txt\")\n          next unless File.exist?(path)\n\n          UI.message(\"Loading '#{path}'...\")\n          options[key] ||= {}\n          options[key][language] ||= File.read(path)\n        end\n      end\n\n      # Load non localised data\n      (NON_LOCALISED_VERSION_VALUES + NON_LOCALISED_APP_VALUES).each do |key|\n        path = File.join(options[:metadata_path], \"#{key}.txt\")\n        next unless File.exist?(path)\n\n        UI.message(\"Loading '#{path}'...\")\n        options[key] ||= File.read(path)\n      end\n\n      # Load trade representative contact information\n      options[:trade_representative_contact_information] ||= {}\n      TRADE_REPRESENTATIVE_CONTACT_INFORMATION_VALUES.values.each do |option_name|\n        path = File.join(options[:metadata_path], TRADE_REPRESENTATIVE_CONTACT_INFORMATION_DIR, \"#{option_name}.txt\")\n        next unless File.exist?(path)\n        next if options[:trade_representative_contact_information][option_name].to_s.length > 0\n\n        UI.message(\"Loading '#{path}'...\")\n        options[:trade_representative_contact_information][option_name] ||= File.read(path)\n      end\n\n      # Load review information\n      options[:app_review_information] ||= {}\n      REVIEW_INFORMATION_VALUES.values.each do |option_name|\n        path = File.join(options[:metadata_path], REVIEW_INFORMATION_DIR, \"#{option_name}.txt\")\n        next unless File.exist?(path)\n        next if options[:app_review_information][option_name].to_s.length > 0\n\n        UI.message(\"Loading '#{path}'...\")\n        options[:app_review_information][option_name] ||= File.read(path)\n      end\n    end", "label": 4}
{"code": "function( e ) {\r\n      // Reset error windows from all elements\r\n      this.reset( FIELDS );\r\n      // Start control each elements\r\n      this.checkFields( e );\r\n      if( e.type !== 'submit' ) return; // if event type is not submit, break\r\n      // This is for when running remote request, return false and wait request response\r\n      else if ( this.handler === 'pending' ) return false;\r\n      // if event type is submit and handler is true, break submit and call onError() function\r\n      else if( this.handler === true ) { this.options.onError.call( this, e ); return false; }\r\n      else return this.options.onValid.call( this, e ); // if form is valid call onValid() function\r\n    }", "label": 3}
{"code": "def bam_conversion(job, samfile, sample_type, univ_options):\n    \"\"\"\n    This module converts SAMFILE from sam to bam\n\n    ARGUMENTS\n    1. samfile: <JSid for a sam file>\n    2. sample_type: string of 'tumor_dna' or 'normal_dna'\n    3. univ_options: Dict of universal arguments used by almost all tools\n         univ_options\n                +- 'dockerhub': <dockerhub to use>\n    RETURN VALUES\n    1. output_files: REFER output_files in run_bwa()\n    \"\"\"\n    job.fileStore.logToMaster('Running sam2bam on %s:%s' % (univ_options['patient'], sample_type))\n    work_dir = job.fileStore.getLocalTempDir()\n    input_files = {\n        'aligned.sam': samfile}\n    input_files = get_files_from_filestore(job, input_files, work_dir,\n                                           docker=True)\n    bamfile = '/'.join([work_dir, 'aligned.bam'])\n    parameters = ['view',\n                  '-bS',\n                  '-o', docker_path(bamfile),\n                  input_files['aligned.sam']\n                  ]\n    docker_call(tool='samtools', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'])\n    output_file = job.fileStore.writeGlobalFile(bamfile)\n    job.fileStore.deleteGlobalFile(samfile)\n    reheader_bam = job.wrapJobFn(fix_bam_header, output_file, sample_type, univ_options, disk='60G')\n    job.addChild(reheader_bam)\n    return reheader_bam.rv()", "label": 1}
{"code": "public static hanode_routemonitor6_binding[] get(nitro_service service, Long id) throws Exception{\n\t\thanode_routemonitor6_binding obj = new hanode_routemonitor6_binding();\n\t\tobj.set_id(id);\n\t\thanode_routemonitor6_binding response[] = (hanode_routemonitor6_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public void postDoNotUseArtifact(final String gavc, final Boolean doNotUse, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {\n        final Client client = getClient(user, password);\n        final WebResource resource = client.resource(serverURL).path(RequestUtils.getDoNotUseArtifact(gavc));\n        final ClientResponse response = resource.queryParam(ServerAPI.DO_NOT_USE, doNotUse.toString())\n                .accept(MediaType.APPLICATION_JSON).post(ClientResponse.class);\n\n        client.destroy();\n        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){\n            final String message = \"Failed to post do not use artifact\";\n            if(LOG.isErrorEnabled()) {\n                LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, message, response.getStatus()));\n            }\n            throw new GrapesCommunicationException(message, response.getStatus());\n        }\n    }", "label": 0}
{"code": "def merge_uri_option(target, value, name)\n      if target.key?(name)\n        if REPEATABLE_OPTIONS.include?(name)\n          target[name] += value\n        else\n          log_warn(\"Repeated option key: #{name}.\")\n        end\n      else\n        target.merge!(name => value)\n      end\n    end", "label": 4}
{"code": "public function setType($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Talent\\V4beta1\\ProfileEvent_ProfileEventType::class);\n        $this->type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def update_guild_member(data)\n      server_id = data['guild_id'].to_i\n      server = self.server(server_id)\n\n      member = server.member(data['user']['id'].to_i)\n      member.update_roles(data['roles'])\n      member.update_nick(data['nick'])\n    end", "label": 4}
{"code": "public static Envelope getTileBounds(TileCode code, Envelope maxExtent, double scale) {\n\t\tdouble[] layerSize = getTileLayerSize(code, maxExtent, scale);\n\t\tif (layerSize[0] == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tdouble cX = maxExtent.getMinX() + code.getX() * layerSize[0];\n\t\tdouble cY = maxExtent.getMinY() + code.getY() * layerSize[1];\n\t\treturn new Envelope(cX, cX + layerSize[0], cY, cY + layerSize[1]);\n\t}", "label": 0}
{"code": "func (a *Api) availableNodeMetrics(request *restful.Request, response *restful.Response) {\n\ta.processMetricNamesRequest(core.NodeKey(request.PathParameter(\"node-name\")), response)\n}", "label": 5}
{"code": "public <T extends CoreLabel> Datum<String, String> makeDatum(List<IN> info, int loc, FeatureFactory featureFactory) {\r\n    PaddedList<IN> pInfo = new PaddedList<IN>(info, pad);\r\n\r\n    Collection<String> features = new ArrayList<String>();\r\n    List<Clique> cliques = featureFactory.getCliques();\r\n    for (Clique c : cliques) {\r\n      Collection<String> feats = featureFactory.getCliqueFeatures(pInfo, loc, c);\r\n      feats = addOtherClasses(feats, pInfo, loc, c);\r\n      features.addAll(feats);\r\n    }\r\n\r\n    printFeatures(pInfo.get(loc), features);\r\n    CoreLabel c = info.get(loc);\r\n    return new BasicDatum<String, String>(features, c.get(AnswerAnnotation.class));\r\n  }", "label": 0}
{"code": "public function setSnapshotInspectTemplate($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\InspectTemplate::class);\n        $this->snapshot_inspect_template = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def channel(id, server = nil)\n      id = id.resolve_id\n\n      raise Discordrb::Errors::NoPermission if @restricted_channels.include? id\n\n      debug(\"Obtaining data for channel with id #{id}\")\n      return @channels[id] if @channels[id]\n\n      begin\n        begin\n          response = API::Channel.resolve(token, id)\n        rescue RestClient::ResourceNotFound\n          return nil\n        end\n        channel = Channel.new(JSON.parse(response), self, server)\n        @channels[id] = channel\n      rescue Discordrb::Errors::NoPermission\n        debug \"Tried to get access to restricted channel #{id}, blacklisting it\"\n        @restricted_channels << id\n        raise\n      end\n    end", "label": 4}
{"code": "function(firstName, lang) {\n  if (lang && male[firstName] && male[firstName][lang] && female[firstName] && female[firstName][lang]) {\n    return 'unisex';\n  } else if (lang && male[firstName] && male[firstName][lang]) {\n    return 'male';\n  } else if (lang && female[firstName] && female[firstName][lang]) {\n    return 'female';\n  } else if (male[firstName] && female[firstName]) {\n    return 'unisex';\n  } else if (male[firstName]) {\n    return 'male';\n  } else if (female[firstName]) {\n    return 'female';\n  }\n  return 'unknown';\n}", "label": 3}
{"code": "def make_delete_table(table: Table, delete_prefix='delete_from__') -> Table:\n    \"\"\"Table referencing a delete from using primary key join.\"\"\"\n\n    name = delete_prefix + table.name\n    primary_key = table.primary_key\n    key_names = set(primary_key.column_names)\n    columns = [column for column in table.columns if column.name in key_names]\n    table = Table(name, columns, primary_key)\n\n    return table", "label": 1}
{"code": "def is_valid(self, context, sid):\n\t\t\"\"\"Identify if the given session ID is currently valid.\n\t\t\n\t\tReturn True if valid, False if explicitly invalid, None if unknown.\n\t\t\"\"\"\n\t\t\n\t\trecord = self._Document.find_one(sid, project=('expires', ))\n\t\t\n\t\tif not record:\n\t\t\treturn\n\t\t\n\t\treturn not record._expired", "label": 1}
{"code": "function(done) {\n  return {\n    success: function(res) {\n      done(null, res);\n    },\n    error: function(res, err) {\n      done(err);\n    }\n  };\n}", "label": 3}
{"code": "static void init() {// NOPMD\n\n\t\tdetermineIfNTEventLogIsSupported();\n\n\t\tURL resource = null;\n\n\t\tfinal String configurationOptionStr = OptionConverter.getSystemProperty(DEFAULT_CONFIGURATION_KEY, null);\n\n\t\tif (configurationOptionStr != null) {\n\t\t\ttry {\n\t\t\t\tresource = new URL(configurationOptionStr);\n\t\t\t} catch (MalformedURLException ex) {\n\t\t\t\t// so, resource is not a URL:\n\t\t\t\t// attempt to get the resource from the class path\n\t\t\t\tresource = Loader.getResource(configurationOptionStr);\n\t\t\t}\n\t\t}\n\t\tif (resource == null) {\n\t\t\tresource = Loader.getResource(DEFAULT_CONFIGURATION_FILE); // NOPMD\n\t\t}\n\n\t\tif (resource == null) {\n\t\t\tSystem.err.println(\"[FoundationLogger] Can not find resource: \" + DEFAULT_CONFIGURATION_FILE); // NOPMD\n\t\t\tthrow new FoundationIOException(\"Can not find resource: \" + DEFAULT_CONFIGURATION_FILE); // NOPMD\n\t\t}\n\n\t\t// update the log manager to use the Foundation repository.\n\t\tfinal RepositorySelector foundationRepositorySelector = new FoundationRepositorySelector(FoundationLogFactory.foundationLogHierarchy);\n\t\tLogManager.setRepositorySelector(foundationRepositorySelector, null);\n\n\t\t// set logger to info so we always want to see these logs even if root\n\t\t// is set to ERROR.\n\t\tfinal Logger logger = getLogger(FoundationLogger.class);\n\n\t\tfinal String logPropFile = resource.getPath();\n\t\tlog4jConfigProps = getLogProperties(resource);\n\t\t\n\t\t// select and configure again so the loggers are created with the right\n\t\t// level after the repository selector was updated.\n\t\tOptionConverter.selectAndConfigure(resource, null, FoundationLogFactory.foundationLogHierarchy);\n\n\t\t// start watching for property changes\n\t\tsetUpPropFileReloading(logger, logPropFile, log4jConfigProps);\n\n\t\t// add syslog appender or windows event viewer appender\n//\t\tsetupOSSystemLog(logger, log4jConfigProps);\n\n\t\t// parseMarkerPatterns(log4jConfigProps);\n\t\t// parseMarkerPurePattern(log4jConfigProps);\n//\t\tudpateMarkerStructuredLogOverrideMap(logger);\n\n        AbstractFoundationLoggingMarker.init();\n\n\t\tupdateSniffingLoggersLevel(logger);\n\n        setupJULSupport(resource);\n\n    }", "label": 0}
{"code": "def list_metafeatures(cls, group=\"all\"):\n        \"\"\"\n        Returns a list of metafeatures computable by the Metafeatures class.\n        \"\"\"\n        # todo make group for intractable metafeatures for wide datasets or\n        # datasets with high cardinality categorical columns:\n        # PredPCA1, PredPCA2, PredPCA3, PredEigen1, PredEigen2, PredEigen3,\n        # PredDet, kNN1NErrRate, kNN1NKappa, LinearDiscriminantAnalysisKappa,\n        # LinearDiscriminantAnalysisErrRate\n        if group == \"all\":\n            return copy.deepcopy(cls.IDS)\n        elif group == \"landmarking\":\n            return list(filter(\n                lambda mf_id: \"ErrRate\" in mf_id or \"Kappa\" in mf_id, cls.IDS\n            ))\n        elif group == \"target_dependent\":\n            return list(filter(\n                cls._resource_is_target_dependent, cls.IDS\n            ))\n        else:\n            raise ValueError(f\"Unknown group {group}\")", "label": 1}
{"code": "function getIndentLevel(node, profile) {\n\t// Increase indent level IF NOT:\n\t// * parent is text-only node\n\t// * there\u2019s a parent node with a name that is explicitly set to decrease level\n\tconst skip = profile.get('formatSkip') || [];\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tif (skip.indexOf( (ctx.name || '').toLowerCase() ) === -1) {\n\t\t\tlevel++;\n\t\t}\n\t}\n\n\treturn level < 0 ? 0 : level;\n}", "label": 3}
{"code": "async def load_cache(self, archive: bool = False) -> int:\n        \"\"\"\n        Load caches and archive enough to go offline and be able to verify proof\n        on content marked of interest in configuration.\n\n        Return timestamp (epoch seconds) of cache load event, also used as subdirectory\n        for cache archives.\n\n        :param archive: whether to archive caches to disk\n        :return: cache load event timestamp (epoch seconds)\n        \"\"\"\n\n        LOGGER.debug('Verifier.load_cache >>> archive: %s', archive)\n\n        rv = int(time())\n        for s_id in self.cfg.get('archive-on-close', {}).get('schema_id', {}):\n            with SCHEMA_CACHE.lock:\n                await self.get_schema(s_id)\n        for cd_id in self.cfg.get('archive-on-close', {}).get('cred_def_id', {}):\n            with CRED_DEF_CACHE.lock:\n                await self.get_cred_def(cd_id)\n        for rr_id in self.cfg.get('archive-on-close', {}).get('rev_reg_id', {}):\n            await self._get_rev_reg_def(rr_id)\n            with REVO_CACHE.lock:\n                revo_cache_entry = REVO_CACHE.get(rr_id, None)\n                if revo_cache_entry:\n                    try:\n                        await revo_cache_entry.get_state_json(self._build_rr_state_json, rv, rv)\n                    except ClosedPool:\n                        LOGGER.warning(\n                            'Verifier %s is offline from pool %s, cannot update revo cache reg state for %s to %s',\n                            self.wallet.name,\n                            self.pool.name,\n                            rr_id,\n                            rv)\n\n        if archive:\n            Caches.archive(self.dir_cache)\n        LOGGER.debug('Verifier.load_cache <<< %s', rv)\n        return rv", "label": 1}
{"code": "function configure() {\n      var pkg = this.square.package\n        , configuration = pkg.configuration\n        , type = this.type || Plugin.modifier\n        , self = this\n        , load = [];\n\n      // Check for the distribution and if it should accept the given extension,\n      // extend self with the context of the plugin.\n      if (!~type.indexOf('once') && (!this.distributable() || !this.accepted())) {\n        this.logger.debug(\n            'disregarding this plugin for extension: '+ this.extension\n          +', distribution: '+ this.distribution\n        );\n        return this.emit('disregard');\n      }\n\n      // Check if there are any configuration options in the package.\n      if (_.isObject(pkg.plugins) && this.id in pkg.plugins) {\n        this.merge(this, pkg.plugins[this.id]);\n      }\n\n      // Merge in the plugin configuration.\n      if (\n           configuration\n        && _.isObject(configuration.plugins)\n        && this.id in configuration.plugins\n      ) {\n        this.merge(this, configuration.plugins[this.id]);\n      }\n\n      // Check if the bundle it self also had specific configurations for this\n      // plugin.\n      if (this.id in this && _.isObject(this[this.id])) {\n        this.merge(this, this[this.id]);\n      }\n\n      // Ensure that our requires is an array, before we continue\n      if (!Array.isArray(this.requires)) this.requires = [this.requires];\n\n      // Check if we need to lazy load any dependencies\n      if (this.requires && this.requires.length) {\n        load = this.requires.map(function (file) {\n          if (typeof file !== 'object') return file;\n          if (!('extension' in file)) return file.name || file;\n          if (file.extension === self.extension) return file.name || file;\n\n          return undefined;\n        }).filter(Boolean); // Only get existing files\n\n        // Only fetch shizzle when we actually have shizzle to fetch here\n        if (load.length) return canihaz.apply(canihaz, load.concat(function canihaz(err) {\n          if (err) return self.emit('error', err);\n\n          // Add all the libraries to the context, the `canihaz#all` returns an\n          // error first, and then all libraries it installed or required in the\n          // order as given to it, which is in our case the `this.requires` order.\n          Array.prototype.slice.call(arguments, 1).forEach(function (lib, index) {\n            self[load[index]] = lib;\n          });\n\n          // We are now fully initialized.\n          if (self.initialize) self.initialize();\n        }));\n      }\n\n      // We are now fully initialized.\n      if (self.initialize) self.initialize();\n    }", "label": 3}
{"code": "function(opts) {\n  this._emitter = new events.EventEmitter();\n  this._libpath = opts.path;\n  this._tox = opts.tox;\n  this._library = this.createLibrary(this._libpath);\n  this._initCallbacks();\n}", "label": 3}
{"code": "function debug(message) {\n            if (enplug.debug) {\n                arguments[0] = TAG + arguments[0];\n                console.log.apply(console, arguments);\n            }\n        }", "label": 3}
{"code": "func copyImage(img *v1alpha.Image) *v1alpha.Image {\n\treturn &v1alpha.Image{\n\t\tBaseFormat:      img.BaseFormat,\n\t\tId:              img.Id,\n\t\tName:            img.Name,\n\t\tVersion:         img.Version,\n\t\tImportTimestamp: img.ImportTimestamp,\n\t\tManifest:        img.Manifest,\n\t\tSize:            img.Size,\n\t\tAnnotations:     img.Annotations,\n\t\tLabels:          img.Labels,\n\t}\n}", "label": 5}
{"code": "protected function getServerParameter($parameter, ServerRequestInterface $request, $default = null)\n    {\n        return isset($request->getServerParams()[$parameter]) ? $request->getServerParams()[$parameter] : $default;\n    }", "label": 2}
{"code": "public function setAssets($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Asset\\V1\\TemporalAsset::class);\n        $this->assets = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function defineCommand($commandID, $class)\n    {\n        $reflection = new \\ReflectionClass($class);\n\n        if (!$reflection->isSubclassOf('Predis\\Command\\CommandInterface')) {\n            throw new \\InvalidArgumentException(\"The class '$class' is not a valid command class.\");\n        }\n\n        $this->commands[strtoupper($commandID)] = $class;\n    }", "label": 2}
{"code": "public function allocateIdsToEntities(array $entities)\n    {\n        $this->validateBatch($entities, EntityInterface::class);\n\n        $incompleteKeys = [];\n        foreach ($entities as $entity) {\n            if ($entity->key()->state() === Key::STATE_INCOMPLETE) {\n                $incompleteKeys[] = $entity->key();\n            }\n        }\n\n        if (!empty($incompleteKeys)) {\n            $keys = $this->allocateIds($incompleteKeys);\n        }\n\n        return $entities;\n    }", "label": 2}
{"code": "function update(instance) {\n  instance.isValid = isValid(instance._date);\n  instance.timeString = instance.toString();\n  return instance;\n}", "label": 3}
{"code": "public function updateBreakpoint(array $args)\n    {\n        return $this->send([$this->controllerClient, 'updateActiveBreakpoint'], [\n            $this->pluck('debuggeeId', $args),\n            $this->serializer->decodeMessage(\n                new Breakpoint(),\n                $this->pluck('breakpoint', $args)\n            ),\n            $args\n        ]);\n    }", "label": 2}
{"code": "function pluckFromArrayOptions (cell, modelPath, models, cellDefinitions) {\n  if (cell.arrayOptions.tupleCells) {\n    cell.arrayOptions.tupleCells.forEach(function (cell, index) {\n      pluckModels(cell, modelPath.concat(index), models, cellDefinitions)\n    })\n  }\n  if (cell.arrayOptions.itemCell) {\n    const itemCell = cell.arrayOptions.itemCell\n    if (Array.isArray(itemCell)) {\n      itemCell.forEach(function (cell, index) {\n        pluckModels(cell, modelPath.concat(index), models, cellDefinitions)\n      })\n    } else {\n      pluckModels(itemCell, modelPath.concat('0'), models, cellDefinitions)\n    }\n  }\n}", "label": 3}
{"code": "def nepali_number(number):\n    \"\"\"\n    Convert a number to nepali\n    \"\"\"\n    nepnum = \"\"\n    for n in str(number):\n        nepnum += values.NEPDIGITS[int(n)]\n    return nepnum", "label": 1}
{"code": "public function update(array $data)\n    {\n        $this->attributes = new Collection(array_merge($this->attributes->toArray(), $data));\n\n        return $this->save();\n    }", "label": 2}
{"code": "public function addAllowedAccess($domain, $ports = '*', $secure = false) {\n        if (!$this->validateDomain($domain)) {\n           throw new \\UnexpectedValueException('Invalid domain');\n        }\n\n        if (!$this->validatePorts($ports)) {\n           throw new \\UnexpectedValueException('Invalid Port');\n        }\n\n        $this->_access[]   = array($domain, $ports, (boolean)$secure);\n        $this->_cacheValid = false;\n\n        return $this;\n    }", "label": 2}
{"code": "def write_json_base64(str)\n      @context.write(trans)\n      trans.write(@@kJSONStringDelimiter)\n      trans.write(Base64.strict_encode64(str))\n      trans.write(@@kJSONStringDelimiter)\n    end", "label": 4}
{"code": "function redirectToNext(req, res) {\n  var redirectTo = req.session.next || '';\n  req.session.next = null; // Null it so that we do not use it again.\n  res.redirect(redirectTo);\n}", "label": 3}
{"code": "public ArrayList getPrimaryKeys()\r\n    {\r\n        ArrayList          result = new ArrayList();\r\n        FieldDescriptorDef fieldDef;\r\n\r\n        for (Iterator it = getFields(); it.hasNext();)\r\n        {\r\n            fieldDef = (FieldDescriptorDef)it.next();\r\n            if (fieldDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_PRIMARYKEY, false))\r\n            {\r\n                result.add(fieldDef);\r\n            }\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "public static appfwglobal_auditsyslogpolicy_binding[] get(nitro_service service) throws Exception{\n\t\tappfwglobal_auditsyslogpolicy_binding obj = new appfwglobal_auditsyslogpolicy_binding();\n\t\tappfwglobal_auditsyslogpolicy_binding response[] = (appfwglobal_auditsyslogpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function registerNode (host, node, insertBefore, func) {\n  const index = indexOfNode(host, insertBefore);\n  eachNodeOrFragmentNodes(node, (eachNode, eachIndex) => {\n    func(eachNode, eachIndex);\n\n    if (canPatchNativeAccessors) {\n      nodeToParentNodeMap.set(eachNode, host);\n    } else {\n      staticProp(eachNode, 'parentNode', host);\n    }\n\n    // When childNodes is artificial, do manual house keeping.\n    if (Array.isArray(host.childNodes)) {\n      if (index > -1) {\n        arrProto.splice.call(host.childNodes, index + eachIndex, 0, eachNode);\n      } else {\n        arrProto.push.call(host.childNodes, eachNode);\n      }\n    }\n  });\n}", "label": 3}
{"code": "def members(params = {})\n      members = Member.from_response client.get(\"/organizations/#{id}/members/all\", params)\n      MultiAssociation.new(self, members).proxy\n    end", "label": 4}
{"code": "function updateVersion2gitTag(pkg) {\n\tlet tag = child_process.execSync('git describe --tag').toString().trim();\n\tpkg.version = tag;\n}", "label": 3}
{"code": "def database_names(filter = {}, opts = {})\n      list_databases(filter, true, opts).collect{ |info| info[Database::NAME] }\n    end", "label": 4}
{"code": "public function setBreakpoint($path, $line, array $options = [])\n    {\n        $resp = $this->connection->setBreakpoint([\n            'debuggeeId' => $this->id,\n            'location' => [\n                'path' => $path,\n                'line' => $line\n            ]\n        ] + $options);\n        return new Breakpoint($resp['breakpoint']);\n    }", "label": 2}
{"code": "function (line) {\n            if (this._content) {\n                this._content = this._content + this._newLine + line;\n            } else {\n                this._values = [];\n                this._content = line;\n            }\n            return this._parseContent();\n        }", "label": 3}
{"code": "def color_hist(fg, bg)\n      img = number_colors > 256 ? quantize(256) : self\n\n      begin\n        hist = img.color_histogram\n      rescue NotImplementedError\n        warn 'The color_histogram method is not supported by this version '\\\n                     'of ImageMagick/GraphicsMagick'\n      else\n        pixels = hist.keys.sort_by { |pixel| hist[pixel] }\n        scale = HISTOGRAM_ROWS / (hist.values.max * AIR_FACTOR)\n\n        histogram = Image.new(HISTOGRAM_COLS, HISTOGRAM_ROWS) do\n          self.background_color = bg\n          self.border_color = fg\n        end\n\n        x = 0\n        pixels.each do |pixel|\n          column = Array.new(HISTOGRAM_ROWS).fill { Pixel.new }\n          HISTOGRAM_ROWS.times do |y|\n            column[y] = pixel if y >= HISTOGRAM_ROWS - (hist[pixel] * scale)\n          end\n          histogram.store_pixels(x, 0, 1, HISTOGRAM_ROWS, column)\n          x = x.succ\n        end\n\n        histogram['Label'] = 'Color Frequency'\n        return histogram\n      end\n    end", "label": 4}
{"code": "private void appendSubQuery(Query subQuery, StringBuffer buf)\r\n    {\r\n        buf.append(\" (\");\r\n        buf.append(getSubQuerySQL(subQuery));\r\n        buf.append(\") \");\r\n    }", "label": 0}
{"code": "public static service_stats get(nitro_service service, String name) throws Exception{\n\t\tservice_stats obj = new service_stats();\n\t\tobj.set_name(name);\n\t\tservice_stats response = (service_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static base_response unset(nitro_service client, ipv6 resource, String[] args) throws Exception{\n\t\tipv6 unsetresource = new ipv6();\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "def number_format(national, format_data)\n      format_data && format_data.find do |format|\n        (format[Core::LEADING_DIGITS].nil? || \\\n            national.match(cr(\"^(#{format[Core::LEADING_DIGITS]})\"))) && \\\n          national.match(cr(\"^(#{format[Core::PATTERN]})$\"))\n      end || Core::DEFAULT_NUMBER_FORMAT\n    end", "label": 4}
{"code": "def bfd(items, targets, **kwargs):\n    \"\"\"Best-Fit Decreasing\n\n    Complexity O(n^2)\n    \"\"\"\n    sizes = zip(items, weight(items, **kwargs))\n    sizes = sorted(sizes, key=operator.itemgetter(1), reverse=True)\n    items = map(operator.itemgetter(0), sizes)\n    return bf(items, targets, **kwargs)", "label": 1}
{"code": "public Object get(String name, ObjectFactory<?> factory) {\n\t\tThreadScopeContext context = ThreadScopeContextHolder.getContext();\n\n\t\tObject result = context.getBean(name);\n\t\tif (null == result) {\n\t\t\tresult = factory.getObject();\n\t\t\tcontext.setBean(name, result);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def listen(hosts, port)\n      hosts.each do |host|\n        @server.listen(host, port)\n      end\n      true\n    rescue Errno::EADDRINUSE\n      ChefZero::Log.warn(\"Port #{port} not available\")\n      @server.listeners.each { |l| l.close }\n      @server.listeners.clear\n      false\n    end", "label": 4}
{"code": "func (c CertAuthType) Check() error {\n\tif c != HostCA && c != UserCA {\n\t\treturn trace.BadParameter(\"'%v' authority type is not supported\", c)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def from_db(klass, attributes = nil, criteria = nil, selected_fields = nil)\n      if criteria\n        selected_fields ||= criteria.options[:fields]\n      end\n      type = (attributes || {})[TYPE]\n      if type.blank?\n        obj = klass.instantiate(attributes, selected_fields)\n        if criteria && criteria.association && criteria.parent_document\n          obj.set_relation(criteria.association.inverse, criteria.parent_document)\n        end\n        obj\n      else\n        camelized = type.camelize\n\n        # Check if the class exists\n        begin\n          constantized = camelized.constantize\n        rescue NameError\n          raise Errors::UnknownModel.new(camelized, type)\n        end\n\n        # Check if the class is a Document class\n        if !constantized.respond_to?(:instantiate)\n          raise Errors::UnknownModel.new(camelized, type)\n        end\n\n        constantized.instantiate(attributes, selected_fields)\n      end\n    end", "label": 4}
{"code": "public function param_dump( $_, $assoc_args ) {\n\t\t$spec = \\WP_CLI::get_configurator()->get_spec();\n\n\t\tif ( \\WP_CLI\\Utils\\get_flag_value( $assoc_args, 'with-values' ) ) {\n\t\t\t$config = \\WP_CLI::get_configurator()->to_array();\n\t\t\t// Copy current config values to $spec\n\t\t\tforeach ( $spec as $key => $value ) {\n\t\t\t\t$current = null;\n\t\t\t\tif ( isset( $config[0][ $key ] ) ) {\n\t\t\t\t\t$current = $config[0][ $key ];\n\t\t\t\t}\n\t\t\t\t$spec[ $key ]['current'] = $current;\n\t\t\t}\n\t\t}\n\n\t\tif ( 'var_export' === \\WP_CLI\\Utils\\get_flag_value( $assoc_args, 'format' ) ) {\n\t\t\tvar_export( $spec );\n\t\t} else {\n\t\t\techo json_encode( $spec );\n\t\t}\n\t}", "label": 2}
{"code": "public void add(ServiceReference<S> declarationBinderRef) throws InvalidFilterException {\n        BinderDescriptor binderDescriptor = new BinderDescriptor(declarationBinderRef);\n        declarationBinders.put(declarationBinderRef, binderDescriptor);\n    }", "label": 0}
{"code": "protected void appendWhereClause(ClassDescriptor cld, boolean useLocking, StringBuffer stmt)\r\n    {\r\n        FieldDescriptor[] pkFields = cld.getPkFields();\r\n        FieldDescriptor[] fields;\r\n\r\n        fields = pkFields;\r\n        if(useLocking)\r\n        {\r\n            FieldDescriptor[] lockingFields = cld.getLockingFields();\r\n            if(lockingFields.length > 0)\r\n            {\r\n                fields = new FieldDescriptor[pkFields.length + lockingFields.length];\r\n                System.arraycopy(pkFields, 0, fields, 0, pkFields.length);\r\n                System.arraycopy(lockingFields, 0, fields, pkFields.length, lockingFields.length);\r\n            }\r\n        }\r\n\r\n        appendWhereClause(fields, stmt);\r\n    }", "label": 0}
{"code": "private function parseSingleMutationResult(array $res)\n    {\n        $mutationResult = $res['mutationResults'][0];\n\n        if (isset($mutationResult['conflictDetected']) && $mutationResult['conflictDetected']) {\n            throw new DomainException(\n                'A conflict was detected in the mutation. ' .\n                'The operation failed.'\n            );\n        }\n\n        // cast to string for conformance between REST and gRPC.\n        return (string) $mutationResult['version'];\n    }", "label": 2}
{"code": "def update_break_type(id, body, opts = {})\n      data, _status_code, _headers = update_break_type_with_http_info(id, body, opts)\n      return data\n    end", "label": 4}
{"code": "def flush(self):\n        \"\"\"\n        This only needs to be called manually\n        from unit tests\n        \"\"\"\n        self.logger.debug('Flush joining')\n        self.queue.join()\n        self.logger.debug('Flush joining ready')", "label": 1}
{"code": "def Point2HexColor(a, lfrac, tfrac):\n    \"\"\"\n    Return web-safe hex triplets.\n\n    \"\"\"\n\n    [H,S,V] = [math.floor(360 * a), lfrac, tfrac]\n\n    RGB = hsvToRGB(H, S, V)\n\n    H = [hex(int(math.floor(255 * x))) for x in RGB]\n\n    HEX = [a[a.find('x') + 1:] for a in H]\n    HEX = ['0' + h if len(h) == 1 else h for h in HEX]\n\n    return '#' + ''.join(HEX)", "label": 1}
{"code": "def send_embed(message = '', embed = nil)\n      embed ||= Discordrb::Webhooks::Embed.new\n      yield(embed) if block_given?\n      send_message(message, false, embed)\n    end", "label": 4}
{"code": "function _gpfReduceContext (path, reducer) {\n    var rootContext,\n        pathToReduce;\n    if (path[_GPF_START] === \"gpf\") {\n        rootContext = gpf;\n        pathToReduce = _gpfArrayTail(path);\n    } else {\n        rootContext = _gpfMainContext;\n        pathToReduce = path;\n    }\n    return pathToReduce.reduce(reducer, rootContext);\n}", "label": 3}
{"code": "function(element, selector, event, callback, capturePhase) {\n    const delegateElement = $(element).array[0]\n    $(element).forEach(function(ctx) {\n      $(ctx).on(event, function(e) {\n        let target = e.target\n        if (e.target.nodeType === 3) {\n          target = e.target.parentNode\n        }\n        $(ctx).find(selector).forEach(function(delegateElement) {\n          if (delegateElement === target) {\n            callback.call(delegateElement, e)\n          } else {\n            try {\n              const ancestor = $(target).closest(selector)\n              if (delegateElement === ancestor.array[0]) {\n                callback.call(delegateElement, e)\n              }\n            } catch (err) {}\n          }\n        })\n      }, capturePhase)\n    })\n  }", "label": 3}
{"code": "function(input, delaySort)\n  {\n    var key = this.buildKeyFromInput( input );\n    var removing = this.map.get( key );\n\n    if ( removing )\n    {\n      var i = this.map.indices[ key ];\n\n      this.map.remove( key );\n      this.trigger( Collection.Events.Remove, [this, removing, i] );\n\n      if ( !delaySort )\n      {\n        this.sort();\n      }\n    }\n\n    return removing;\n  }", "label": 3}
{"code": "function(args) {\n      View.apply(this, arguments);\n      args = args || {};\n\n      var collection = args.collection || this.collection;\n\n      this.template = args.template || this.template;\n      this.emptyTemplate = args.emptyTemplate || this.emptyTemplate;\n      this.itemView = args.itemView || this.itemView;\n      this.itemContainer = args.itemContainer || this.itemContainer;\n      if (this.template && !this.itemContainer) {\n        throw 'Item container is required when using a template';\n      }\n      this.modelsToRender = args.modelsToRender || this.modelsToRender;\n      this.__itemContext = args.itemContext || this.__itemContext;\n      this.__modelToViewMap = {};\n      this.__renderWait = args.renderWait || this.__renderWait;\n      this.__modelId = args.modelId || this.modelId || 'cid';\n      this.__modelName = args.modelName || this.modelName || 'model';\n      this.__orderedModelIdList = [];\n      this.__createItemViews();\n      this.__delayedRender = aggregateRenders(this.__renderWait, this);\n\n      if (collection) {\n        this.setCollection(collection, true);\n      }\n      this.on('render:after-dom-update', this.__cleanupItemViewsAfterAttachedToParent);\n    }", "label": 3}
{"code": "def parse_chromosome_string(job, chromosome_string):\n    \"\"\"\n    Parse a chromosome string into a list.\n\n    :param chromosome_string: Input chromosome string\n    :return: list of chromosomes to handle\n    :rtype: list\n    \"\"\"\n    if chromosome_string is None:\n        return []\n    else:\n        assert isinstance(chromosome_string, str)\n        chroms = [c.strip() for c in chromosome_string.split(',')]\n        if 'canonical' in chroms:\n            assert 'canonical_chr' not in chroms, 'Cannot have canonical and canonical_chr'\n            chr_prefix = False\n            chroms.remove('canonical')\n            out_chroms = [str(c) for c in range(1, 23)] + ['X', 'Y']\n        elif 'canonical_chr' in chroms:\n            assert 'canonical' not in chroms, 'Cannot have canonical and canonical_chr'\n            chr_prefix = True\n            chroms.remove('canonical_chr')\n            out_chroms = ['chr' + str(c) for c in range(1, 23)] + ['chrX', 'chrY']\n        else:\n            chr_prefix = None\n            out_chroms = []\n        for chrom in chroms:\n            if chr_prefix is not None and chrom.startswith('chr') is not chr_prefix:\n                job.fileStore.logToMaster('chromosome %s does not match the rest that %s begin '\n                                          'with \"chr\".' % (chrom,\n                                                           'all' if chr_prefix else 'don\\'t'),\n                                          level=logging.WARNING)\n            out_chroms.append(chrom)\n        return chrom_sorted(out_chroms)", "label": 1}
{"code": "def user=(new_user)\n      if new_user && !new_user.respond_to?(:to_str)\n        raise TypeError, \"Can't convert #{new_user.class} into String.\"\n      end\n      @user = new_user ? new_user.to_str : nil\n\n      # You can't have a nil user with a non-nil password\n      if password != nil\n        @user = EMPTY_STR if @user.nil?\n      end\n\n      # Reset dependent values\n      remove_instance_variable(:@userinfo) if defined?(@userinfo)\n      remove_instance_variable(:@normalized_userinfo) if defined?(@normalized_userinfo)\n      remove_instance_variable(:@authority) if defined?(@authority)\n      remove_instance_variable(:@normalized_user) if defined?(@normalized_user)\n      remove_composite_values\n\n      # Ensure we haven't created an invalid URI\n      validate()\n    end", "label": 4}
{"code": "public function setCombiner($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Monitoring\\V3\\AlertPolicy_ConditionCombinerType::class);\n        $this->combiner = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def set_nick(nick, reason = nil)\n      # Discord uses the empty string to signify 'no nickname' so we convert nil into that\n      nick ||= ''\n\n      if @user.current_bot?\n        API::User.change_own_nickname(@bot.token, @server.id, nick, reason)\n      else\n        API::Server.update_member(@bot.token, @server.id, @user.id, nick: nick, reason: nil)\n      end\n    end", "label": 4}
{"code": "public Rectangle toRelative(Rectangle rect) {\n\t\treturn new Rectangle(rect.getLeft() - origX, rect.getBottom() - origY, rect.getRight() - origX, rect.getTop()\n\t\t\t\t- origY);\n\t}", "label": 0}
{"code": "public function setDatabase(Database $database)\n    {\n        $this->database = $database;\n        $identity = $database->identity();\n        $this->cacheKey = sprintf(\n            self::CACHE_KEY_TEMPLATE,\n            $identity['projectId'],\n            $identity['instance'],\n            $identity['database']\n        );\n\n        if (!isset($this->config['lock'])) {\n            $this->config['lock'] = $this->getDefaultLock();\n        }\n    }", "label": 2}
{"code": "def search_star_cluster(cluster):\n    '''\n    It is also possible to query the star clusters by label, here is an example of querying for the star cluster labeled Berkeley 59\n\n    http://star-api.herokuapp.com/api/v1/open_cluster/Berkeley 59\n    '''\n\n    base_url = \"http://star-api.herokuapp.com/api/v1/open_cluster/\"\n\n    if not isinstance(cluster, str):\n        raise ValueError(\"The cluster arg you provided is not the type of str\")\n    else:\n        base_url += cluster\n\n    return dispatch_http_get(base_url)", "label": 1}
{"code": "func Clear(fg, bg Attribute) {\n\tst := mkStyle(fg, bg)\n\tw, h := screen.Size()\n\tfor row := 0; row < h; row++ {\n\t\tfor col := 0; col < w; col++ {\n\t\t\tscreen.SetContent(col, row, ' ', nil, st)\n\t\t}\n\t}\n}", "label": 5}
{"code": "def adjust_inventory(location_id, variation_id, body, opts = {})\n      data, _status_code, _headers = adjust_inventory_with_http_info(location_id, variation_id, body, opts)\n      return data\n    end", "label": 4}
{"code": "func (k *streamKeepAliver) recv() {\n\terr := k.stream.RecvMsg(&empty.Empty{})\n\tk.closeWithError(trail.FromGRPC(err))\n}", "label": 5}
{"code": "async def _dump_message_field(self, writer, msg, field, fvalue=None):\n        \"\"\"\n        Dumps a message field to the writer. Field is defined by the message field specification.\n\n        :param writer:\n        :param msg:\n        :param field:\n        :param fvalue:\n        :return:\n        \"\"\"\n        fname, ftype, params = field[0], field[1], field[2:]\n        fvalue = getattr(msg, fname, None) if fvalue is None else fvalue\n        await self.dump_field(writer, fvalue, ftype, params)", "label": 1}
{"code": "private function recreateInnerSql(\n        OrderByClause $orderByClause,\n        array $identifiers,\n        string $innerSql\n    ) : string {\n        [$searchPatterns, $replacements] = $this->generateSqlAliasReplacements();\n\n        $orderByItems = [];\n\n        foreach ($orderByClause->orderByItems as $orderByItem) {\n            // Walk order by item to get string representation of it and\n            // replace path expressions in the order by clause with their column alias\n            $orderByItemString = preg_replace(\n                $searchPatterns,\n                $replacements,\n                $this->walkOrderByItem($orderByItem)\n            );\n\n            $orderByItems[] = $orderByItemString;\n            $identifier     = substr($orderByItemString, 0, strrpos($orderByItemString, ' '));\n\n            if (! in_array($identifier, $identifiers, true)) {\n                $identifiers[] = $identifier;\n            }\n        }\n\n        return $sql = sprintf(\n            'SELECT DISTINCT %s FROM (%s) dctrn_result_inner ORDER BY %s',\n            implode(', ', $identifiers),\n            $innerSql,\n            implode(', ', $orderByItems)\n        );\n    }", "label": 2}
{"code": "func ImageNameToAppName(name types.ACIdentifier) (*types.ACName, error) {\n\tparts := strings.Split(name.String(), \"/\")\n\tlast := parts[len(parts)-1]\n\n\tsn, err := types.SanitizeACName(last)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn types.MustACName(sn), nil\n}", "label": 5}
{"code": "def print_summary(ui)\n      # Print whether it passed/failed at the top\n      if failed?\n        ui.puts \"\\n[!] Failed\\n\".red\n      else\n        ui.notice \"Passed\"\n      end\n\n      # A generic proc to handle the similarities between\n      # errors and warnings.\n      do_rules = proc do |name, rules|\n        unless rules.empty?\n          ui.puts \"\"\n          ui.section(name.bold) do\n            rules.each do |rule|\n              title = rule.title.bold + \" - #{rule.object_applied_to}\"\n              subtitles = [rule.description, link(rule.ref)]\n              subtitles += [rule.metadata[:files].join(\":\")] if rule.metadata[:files]\n              ui.labeled(title, subtitles)\n              ui.puts \"\"\n            end\n          end\n        end\n      end\n\n      # Run the rules\n      do_rules.call(\"Errors\".red, errors)\n      do_rules.call(\"Warnings\".yellow, warnings)\n    end", "label": 4}
{"code": "public function getAttribute($key)\n    {\n        if (! is_null($value = parent::getAttribute($key))) {\n            return $value;\n        }\n\n        // If a custom relation with this key has been set up, then we will load\n        // and return results from the query and hydrate the relationship's\n        // value on the \"relationships\" array.\n        if (! $this->relationLoaded($key) && ($relation = $this->getCustomRelation($key))) {\n            if (! $relation instanceof Relation) {\n                throw new LogicException(\n                    'Relationship method must return an object of type '.Relation::class\n                );\n            }\n\n            return $this->relations[$key] = $relation->getResults();\n        }\n    }", "label": 2}
{"code": "func archiveRead(u *url.URL, tr *tar.Reader) error {\n\tfor {\n\t\theader, err := tr.Next()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tname := filepath.Join(u.Path, header.Name)\n\t\tmode := os.FileMode(header.Mode)\n\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeDir:\n\t\t\terr = os.MkdirAll(name, mode)\n\t\tcase tar.TypeReg:\n\t\t\t_ = os.MkdirAll(filepath.Dir(name), 0750)\n\n\t\t\tvar f *os.File\n\n\t\t\tf, err = os.OpenFile(name, os.O_CREATE|os.O_RDWR|os.O_TRUNC, mode)\n\t\t\tif err == nil {\n\t\t\t\t_, cerr := io.Copy(f, tr)\n\t\t\t\terr = f.Close()\n\t\t\t\tif cerr != nil {\n\t\t\t\t\terr = cerr\n\t\t\t\t}\n\t\t\t}\n\t\tcase tar.TypeSymlink:\n\t\t\terr = os.Symlink(header.Linkname, name)\n\t\t}\n\n\t\t// TODO: Uid/Gid may not be meaningful here without some mapping.\n\t\t// The other option to consider would be making use of the guest auth user ID.\n\t\t// os.Lchown(name, header.Uid, header.Gid)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}", "label": 5}
{"code": "public static ResourceKey key(Class<?> clazz, String id) {\n        return new ResourceKey(clazz.getName(), id);\n    }", "label": 0}
{"code": "function isKeyComparator(arg) {\n            let result = __getParameterCount(arg) === 2;\n            const first = self.first();\n            try {\n                const key = keySelector(first);\n                // if this is a key comparator, it must return truthy values for equal values and falsy ones if they're different\n                result = result && arg(key, key) && !arg(key, {});\n            }\n            catch (err) {\n                // if the function throws an error for values, it can't be a keyComparator\n                result = false;\n            }\n            return result;\n        }", "label": 3}
{"code": "function($el, newView, options) {\n      var currentDeferred = $.Deferred(),\n        parentView = this;\n      options = _.extend({}, options);\n      _.defaults(options, {\n        parentView: this,\n        newView: newView\n      });\n      newView.transitionIn(function() {\n        parentView.attachView($el, newView, options);\n      }, currentDeferred.resolve, options);\n      return currentDeferred.promise();\n    }", "label": 3}
{"code": "private function normalizeUriPath($cname, $resource)\n    {\n        if ($cname !== self::DEFAULT_DOWNLOAD_HOST) {\n            $resourceParts = explode('/', trim($resource, '/'));\n            array_shift($resourceParts);\n\n            // Resource is a Bucket.\n            if (empty($resourceParts)) {\n                $resource = '/';\n            } else {\n                $resource = '/' . implode('/', $resourceParts);\n            }\n        }\n\n        return $resource;\n    }", "label": 2}
{"code": "function handleFocusToOpenEvent( event ) {\n\n        // Stop the event from propagating to the doc.\n        event.stopPropagation()\n\n        // If it\u2019s a focus event, add the \u201cfocused\u201d class to the root.\n        if ( event.type == 'focus' ) {\n            P.$root.addClass( CLASSES.focused )\n        }\n\n        // And then finally open the picker.\n        P.open()\n    }", "label": 3}
{"code": "function (callback) {\n                var self = this;\n\n                var deferred = Q.defer();\n                callback = Qext.makeNodeResolver(deferred, callback);\n\n                var breakExec = {};\n                Async.waterfall([\n                    function (next) {\n                        if (!self.collectionName) {\n                            next({\n                                name: 'InternalError',\n                                err: \"collectionName property is not set for model \" + self.identity\n                            });\n                        } else {\n                            var dbName = self.dbName || Shared.config(\"environment.defaultMongoDatabase\");\n                            var db = self.db(dbName);\n                            if (db) {\n                                next(null, db);\n                            }\n                            else {\n                                next({\n                                    name: 'InternalError',\n                                    err: \"No connection to database \" + self.identity\n                                });\n                            }\n                        }\n                    },\n                    function (db, next) {\n\n                        if (!db || _.isEmpty(db)) {\n                            Logger.error(\"No db connection\");\n                            next(\"No db connection\");\n                        }\n                        else {\n                            //try to get exiting collection\n                            db.collection(self.collectionName, {strict: true}, function (err, collection) {\n                                if (!err) {\n                                    //collection exists already\n                                    self._collection = collection;\n                                    //do not apply indexes to exiting collection, since this operation is time consuming\n                                    next(breakExec, collection);\n                                }\n                                else {\n                                    var collectionOptions = self.collectionOptions || {};\n                                    db.createCollection(self.collectionName, collectionOptions, function (err, collection) {\n                                        if (!err) {\n                                            next(null, collection);\n                                        }\n                                        else {\n                                            db.collection(self.collectionName, {strict: true}, function (err, collection) {\n                                                if (!err) {\n                                                    //collection exists already\n                                                    self._collection = collection;\n                                                    //do not apply indexes to exiting collection, since this operation is time consuming\n                                                    next(breakExec, collection);\n                                                }\n                                                else {\n                                                    Logger.error(err);\n                                                    next(err);\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                    },\n                    function (collection, next) {\n                        //store new collection\n                        self._collection = collection;\n\n                        if (_skipDatabaseIndexingOnNewCollections()) {\n                            return next(null, collection);\n                        }\n\n                        //apply all indexes on collection\n                        self.ensureAllIndexes(function (err) {\n                            next(err, collection);\n                        });\n                    },\n                    function (collection, next) {\n                        //return collection\n                        next(null, collection);\n                    }\n                ], function (err, collection) {\n                    if (!err || err === breakExec) {\n                        callback(null, collection);\n                    }\n                    else {\n                        callback(err);\n                    }\n                });\n\n                return deferred.promise;\n            }", "label": 3}
{"code": "public function setHorizontalPodAutoscaling($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Container\\V1\\HorizontalPodAutoscaling::class);\n        $this->horizontal_pod_autoscaling = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def MRA(biomf, sampleIDs=None, transform=None):\n    \"\"\"\n    Calculate the mean relative abundance percentage.\n\n    :type biomf: A BIOM file.\n    :param biomf: OTU table format.\n\n    :type sampleIDs: list\n    :param sampleIDs: A list of sample id's from BIOM format OTU table.\n\n    :param transform: Mathematical function which is used to transform smax to another\n                      format. By default, the function has been set to None.\n\n    :rtype: dict\n    :return: A dictionary keyed on OTUID's and their mean relative abundance for a given\n             number of sampleIDs.\n    \"\"\"\n    ra = relative_abundance(biomf, sampleIDs)\n    if transform is not None:\n        ra = {sample: {otuID: transform(abd) for otuID, abd in ra[sample].items()}\n              for sample in ra.keys()}\n    otuIDs = biomf.ids(axis=\"observation\")\n    return mean_otu_pct_abundance(ra, otuIDs)", "label": 1}
{"code": "public void postLicense(final License license, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {\n        final Client client = getClient(user, password);\n        final WebResource resource = client.resource(serverURL).path(RequestUtils.licenseResourcePath());\n        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class, license);\n\n        client.destroy();\n        if(ClientResponse.Status.CREATED.getStatusCode() != response.getStatus()){\n            final String message = \"Failed to POST license\";\n            if(LOG.isErrorEnabled()) {\n                LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, message, response.getStatus()));\n            }\n            throw new GrapesCommunicationException(message, response.getStatus());\n        }\n    }", "label": 0}
{"code": "function _class (Constructor, members, Base) {\n    var ResultConstructor;\n    if (Base) {\n        ResultConstructor = function () {\n            Base.apply(this, arguments);\n            Constructor.apply(this, arguments);\n        };\n        ResultConstructor.prototype = new Base();\n    } else {\n        ResultConstructor = function () {\n            Constructor.apply(this, arguments);\n        };\n    }\n    if (members) {\n        Object.keys(members).forEach(function (memberName) {\n            ResultConstructor.prototype[memberName] = members[memberName];\n        });\n    }\n    return ResultConstructor;\n}", "label": 3}
{"code": "def memberwise(op, x)\n      case x\n      when Benchmark::Tms\n        Benchmark::Tms.new(utime.__send__(op, x.utime),\n                           stime.__send__(op, x.stime),\n                           cutime.__send__(op, x.cutime),\n                           cstime.__send__(op, x.cstime),\n                           real.__send__(op, x.real)\n                           )\n      else\n        Benchmark::Tms.new(utime.__send__(op, x),\n                           stime.__send__(op, x),\n                           cutime.__send__(op, x),\n                           cstime.__send__(op, x),\n                           real.__send__(op, x)\n                           )\n      end\n    end", "label": 4}
{"code": "public int getVertices(double[] coords) {\n        for (int i = 0; i < numVertices; i++) {\n            Point3d pnt = pointBuffer[vertexPointIndices[i]].pnt;\n            coords[i * 3 + 0] = pnt.x;\n            coords[i * 3 + 1] = pnt.y;\n            coords[i * 3 + 2] = pnt.z;\n        }\n        return numVertices;\n    }", "label": 0}
{"code": "def run_on_server(gen_each_reply, requests)\n      replies = nil\n\n      # Pass in the optional call object parameter if possible\n      if gen_each_reply.arity == 1\n        replies = gen_each_reply.call(requests)\n      elsif gen_each_reply.arity == 2\n        replies = gen_each_reply.call(requests, @req_view)\n      else\n        fail 'Illegal arity of reply generator'\n      end\n\n      write_loop(replies, is_client: false)\n    end", "label": 4}
{"code": "private static int getTrimmedWidth(BufferedImage img) {\n    int height = img.getHeight();\n    int width = img.getWidth();\n    int trimmedWidth = 0;\n\n    for (int i = 0; i < height; i++) {\n      for (int j = width - 1; j >= 0; j--) {\n        if (img.getRGB(j, i) != Color.WHITE.getRGB() && j > trimmedWidth) {\n          trimmedWidth = j;\n          break;\n        }\n      }\n    }\n\n    return trimmedWidth;\n  }", "label": 0}
{"code": "protected static function storeEntriesAfterWorkerLoop($app)\n    {\n        $app['events']->listen(JobProcessing::class, function () {\n            static::startRecording();\n\n            static::$processingJobs[] = true;\n        });\n\n        $app['events']->listen(JobProcessed::class, function ($event) use ($app) {\n            static::storeIfDoneProcessingJob($event, $app);\n        });\n\n        $app['events']->listen(JobFailed::class, function ($event) use ($app) {\n            static::storeIfDoneProcessingJob($event, $app);\n        });\n\n        $app['events']->listen(JobExceptionOccurred::class, function () {\n            array_pop(static::$processingJobs);\n        });\n    }", "label": 2}
{"code": "function createImportHook() {\n  var imports = {};\n  return function (fpath, kind, cb) {\n    if (imports[fpath]) {\n      // Already imported, return nothing to avoid duplicating attributes.\n      process.nextTick(cb);\n      return;\n    }\n    imports[fpath] = true;\n    fs.readFile(fpath, {encoding: 'utf8'}, cb);\n  };\n}", "label": 3}
{"code": "func hostAddr(addr string) string {\n\t_, port := splitHostPort(addr)\n\tif port == \"\" {\n\t\treturn addr + \":443\"\n\t}\n\treturn addr\n}", "label": 5}
{"code": "public function appendValidate(callable $middleware, $name = null)\n    {\n        $this->add(self::VALIDATE, $name, $middleware);\n    }", "label": 2}
{"code": "public double[] Kernel1D(int size) {\n        if (((size % 2) == 0) || (size < 3) || (size > 101)) {\n            try {\n                throw new Exception(\"Wrong size\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        int r = size / 2;\n        // kernel\n        double[] kernel = new double[size];\n\n        // compute kernel\n        for (int x = -r, i = 0; i < size; x++, i++) {\n            kernel[i] = Function1D(x);\n        }\n\n        return kernel;\n    }", "label": 0}
{"code": "public function setDebuggee($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Debugger\\V2\\Debuggee::class);\n        $this->debuggee = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static <IN> PaddedList<IN> valueOf(List<IN> list, IN padding) {\r\n    return new PaddedList<IN>(list, padding);\r\n  }", "label": 0}
{"code": "function stopPropagation(e) {\n                e.cancelBubble = true;\n                if (e.stopPropagation) { e.stopPropagation(); }\n                return false;\n            }", "label": 3}
{"code": "public void localCommit()\r\n    {\r\n        if (log.isDebugEnabled()) log.debug(\"commit was called\");\r\n        if (!this.isInLocalTransaction)\r\n        {\r\n            throw new TransactionNotInProgressException(\"Not in transaction, call begin() before commit()\");\r\n        }\r\n        try\r\n        {\r\n            if(!broker.isManaged())\r\n            {\r\n                if (batchCon != null)\r\n                {\r\n                    batchCon.commit();\r\n                }\r\n                else if (con != null)\r\n                {\r\n                    con.commit();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if(log.isDebugEnabled()) log.debug(\r\n                        \"Found managed environment setting in PB, will skip Connection.commit() call\");\r\n            }\r\n        }\r\n        catch (SQLException e)\r\n        {\r\n            log.error(\"Commit on underlying connection failed, try to rollback connection\", e);\r\n            this.localRollback();\r\n            throw new TransactionAbortedException(\"Commit on connection failed\", e);\r\n        }\r\n        finally\r\n        {\r\n            this.isInLocalTransaction = false;\r\n            restoreAutoCommitState();\r\n            this.releaseConnection();\r\n        }\r\n    }", "label": 0}
{"code": "func (d *driver) RevokeExternalConnectivity(nid, eid string) error {\n\tdata := &api.RevokeExternalConnectivityRequest{\n\t\tNetworkID:  nid,\n\t\tEndpointID: eid,\n\t}\n\terr := d.call(\"RevokeExternalConnectivity\", data, &api.RevokeExternalConnectivityResponse{})\n\tif err != nil && plugins.IsNotFound(err) {\n\t\t// It is not mandatory yet to support this method\n\t\treturn nil\n\t}\n\treturn err\n}", "label": 5}
{"code": "function updateFormRules(cb) {\n\n    //Filters out any conditional statements that are no longer valid.\n    function filterConditionalStatements(rule) {\n      return _.filter(rule.ruleConditionalStatements, function(ruleCondStatement) {\n        var sourceField = ruleCondStatement.sourceField.toString();\n\n        if (invalidFields[sourceField]) {\n          /**\n           * If the user flagged the field in this rule for deletion, flag the rule for deletion.\n           */\n          if (ruleDeletionFlags[sourceField]) {\n            rulesFlaggedForDeletion[rule._id.toString()] = true;\n          }\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n\n    var updatedFieldRules = _.map(form.fieldRules, function(fieldRule) {\n      var filteredConditionalStatements = filterConditionalStatements(fieldRule);\n      var filteredTargets = _.filter(fieldRule.targetField, function(targetField) {\n        if (invalidFields[targetField]) {\n          return false;\n        } else {\n          return true;\n        }\n      });\n\n      fieldRule.ruleConditionalStatements = filteredConditionalStatements;\n      fieldRule.targetField = filteredTargets;\n      return fieldRule;\n    });\n\n    var updatedPageRules = _.map(form.pageRules, function(pageRule) {\n      pageRule.ruleConditionalStatements = filterConditionalStatements(pageRule);\n      return pageRule;\n    });\n\n    fieldRulesToDelete = _.filter(updatedFieldRules, function(fieldRule) {\n      var targetFields = fieldRule.targetField;\n      var conditionalStatements = fieldRule.ruleConditionalStatements;\n      var fieldRuleId = fieldRule._id.toString();\n\n      return targetFields.length === 0 || conditionalStatements.length === 0 || rulesFlaggedForDeletion[fieldRuleId];\n    });\n\n    pageRulesToDelete = _.filter(updatedPageRules, function(pageRule) {\n      var conditionalStatements = pageRule.ruleConditionalStatements;\n      var pageRuleId = pageRule._id.toString();\n\n      return conditionalStatements.length === 0 || rulesFlaggedForDeletion[pageRuleId];\n    });\n\n    fieldRulesToDelete = _.map(fieldRulesToDelete, function(fieldRule) {\n      return fieldRule._id.toString();\n    });\n\n    pageRulesToDelete = _.map(pageRulesToDelete, function(pageRule) {\n      return pageRule._id.toString();\n    });\n\n    //Now have all the rules that need to be deleted, these rules need to be removed from the field and page rules\n    updatedFieldRules = _.filter(updatedFieldRules, function(updatedFieldRule) {\n      return fieldRulesToDelete.indexOf(updatedFieldRule._id.toString()) === -1;\n    });\n\n\n    updatedPageRules = _.filter(updatedPageRules, function(updatedPageRule) {\n      return pageRulesToDelete.indexOf(updatedPageRule._id.toString()) === -1;\n    });\n\n    form.fieldRules = updatedFieldRules;\n    form.pageRules = updatedPageRules;\n\n    form.save(function(err) {\n      return cb(err);\n    });\n  }", "label": 3}
{"code": "public static boolean hasAnnotation(Method method, Class<? extends Annotation> annotation) {\n        return !searchForAnnotation(method, annotation).isEmpty();\n    }", "label": 0}
{"code": "public static base_response add(nitro_service client, vpnsessionaction resource) throws Exception {\n\t\tvpnsessionaction addresource = new vpnsessionaction();\n\t\taddresource.name = resource.name;\n\t\taddresource.httpport = resource.httpport;\n\t\taddresource.winsip = resource.winsip;\n\t\taddresource.dnsvservername = resource.dnsvservername;\n\t\taddresource.splitdns = resource.splitdns;\n\t\taddresource.sesstimeout = resource.sesstimeout;\n\t\taddresource.clientsecurity = resource.clientsecurity;\n\t\taddresource.clientsecuritygroup = resource.clientsecuritygroup;\n\t\taddresource.clientsecuritymessage = resource.clientsecuritymessage;\n\t\taddresource.clientsecuritylog = resource.clientsecuritylog;\n\t\taddresource.splittunnel = resource.splittunnel;\n\t\taddresource.locallanaccess = resource.locallanaccess;\n\t\taddresource.rfc1918 = resource.rfc1918;\n\t\taddresource.spoofiip = resource.spoofiip;\n\t\taddresource.killconnections = resource.killconnections;\n\t\taddresource.transparentinterception = resource.transparentinterception;\n\t\taddresource.windowsclienttype = resource.windowsclienttype;\n\t\taddresource.defaultauthorizationaction = resource.defaultauthorizationaction;\n\t\taddresource.authorizationgroup = resource.authorizationgroup;\n\t\taddresource.clientidletimeout = resource.clientidletimeout;\n\t\taddresource.proxy = resource.proxy;\n\t\taddresource.allprotocolproxy = resource.allprotocolproxy;\n\t\taddresource.httpproxy = resource.httpproxy;\n\t\taddresource.ftpproxy = resource.ftpproxy;\n\t\taddresource.socksproxy = resource.socksproxy;\n\t\taddresource.gopherproxy = resource.gopherproxy;\n\t\taddresource.sslproxy = resource.sslproxy;\n\t\taddresource.proxyexception = resource.proxyexception;\n\t\taddresource.proxylocalbypass = resource.proxylocalbypass;\n\t\taddresource.clientcleanupprompt = resource.clientcleanupprompt;\n\t\taddresource.forcecleanup = resource.forcecleanup;\n\t\taddresource.clientoptions = resource.clientoptions;\n\t\taddresource.clientconfiguration = resource.clientconfiguration;\n\t\taddresource.sso = resource.sso;\n\t\taddresource.ssocredential = resource.ssocredential;\n\t\taddresource.windowsautologon = resource.windowsautologon;\n\t\taddresource.usemip = resource.usemip;\n\t\taddresource.useiip = resource.useiip;\n\t\taddresource.clientdebug = resource.clientdebug;\n\t\taddresource.loginscript = resource.loginscript;\n\t\taddresource.logoutscript = resource.logoutscript;\n\t\taddresource.homepage = resource.homepage;\n\t\taddresource.icaproxy = resource.icaproxy;\n\t\taddresource.wihome = resource.wihome;\n\t\taddresource.citrixreceiverhome = resource.citrixreceiverhome;\n\t\taddresource.wiportalmode = resource.wiportalmode;\n\t\taddresource.clientchoices = resource.clientchoices;\n\t\taddresource.epaclienttype = resource.epaclienttype;\n\t\taddresource.iipdnssuffix = resource.iipdnssuffix;\n\t\taddresource.forcedtimeout = resource.forcedtimeout;\n\t\taddresource.forcedtimeoutwarning = resource.forcedtimeoutwarning;\n\t\taddresource.ntdomain = resource.ntdomain;\n\t\taddresource.clientlessvpnmode = resource.clientlessvpnmode;\n\t\taddresource.emailhome = resource.emailhome;\n\t\taddresource.clientlessmodeurlencoding = resource.clientlessmodeurlencoding;\n\t\taddresource.clientlesspersistentcookie = resource.clientlesspersistentcookie;\n\t\taddresource.allowedlogingroups = resource.allowedlogingroups;\n\t\taddresource.securebrowse = resource.securebrowse;\n\t\taddresource.storefronturl = resource.storefronturl;\n\t\taddresource.kcdaccount = resource.kcdaccount;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public function setWebEntities($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\WebDetection\\WebEntity::class);\n        $this->web_entities = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def split_header_value(str)\n      return [] if str.nil?\n      str = str.dup.strip\n      binary_encode(str)\n      str.scan(%r'\\G((?:\"(?:\\\\.|[^\"])+?\"|[^\",]+)+)\n                    (?:,\\s*|\\Z)'xn).flatten\n    end", "label": 4}
{"code": "async def dump_message(self, msg, msg_type=None):\n        \"\"\"\n        Dumps message to the writer.\n\n        :param msg:\n        :param msg_type:\n        :return:\n        \"\"\"\n        mtype = msg.__class__ if msg_type is None else msg_type\n        fields = mtype.f_specs()\n        for field in fields:\n            await self.message_field(msg=msg, field=field)", "label": 1}
{"code": "func (a *CellView) MakeVisible(x, y int) {\n\ta.port.MakeVisible(x, y)\n}", "label": 5}
{"code": "private function input(Request $request)\n    {\n        $files = $request->files->all();\n\n        array_walk_recursive($files, function (&$file) {\n            $file = [\n                'name' => $file->getClientOriginalName(),\n                'size' => $file->isFile() ? ($file->getSize() / 1000).'KB' : '0',\n            ];\n        });\n\n        return array_replace_recursive($request->input(), $files);\n    }", "label": 2}
{"code": "def as_translation_key(self):\n        \"\"\"\n        Project Translation object or any other derived class into just a\n        TranslationKey, which has fewer fields and can be used as a\n        dictionary key.\n        \"\"\"\n        return TranslationKey(**{\n            name: getattr(self, name)\n            for name in TranslationKey._fields})", "label": 1}
{"code": "def decktape():\n    '''Install DeckTape.\n\n    DeckTape is a \"high-quality PDF exporter for HTML5 presentation\n    frameworks\".  It can be used to create PDFs from reveal.js presentations.\n\n    More info:\n      https://github.com/astefanutti/decktape\n      https://github.com/hakimel/reveal.js/issues/1252#issuecomment-198270915\n    '''\n    run('mkdir -p ~/bin/decktape')\n    if not exists('~/bin/decktape/decktape-1.0.0'):\n        print_msg('\\n## download decktape 1.0.0\\n')\n        run('cd ~/bin/decktape && '\n            'curl -L https://github.com/astefanutti/decktape/archive/'\n            'v1.0.0.tar.gz | tar -xz --exclude phantomjs')\n        run('cd ~/bin/decktape/decktape-1.0.0 && '\n            'curl -L https://github.com/astefanutti/decktape/releases/'\n            'download/v1.0.0/phantomjs-linux-x86-64 -o phantomjs')\n        run('cd ~/bin/decktape/decktape-1.0.0 && '\n            'chmod +x phantomjs')\n    run('ln -snf ~/bin/decktape/decktape-1.0.0 ~/bin/decktape/active',\n        msg='\\n## link installed decktape version as active')\n    print_msg('\\nCreate PDF from reveal.js presentation:\\n\\n    '\n              '# serve presentation:\\n    '\n              'cd ~/repos/my_presi/reveal.js/ && npm start\\n\\n    '\n              '# create pdf in another shell:\\n    '\n              'cd ~/bin/decktape/active && \\\\\\n    '\n              './phantomjs decktape.js --size 1280x800  localhost:8000  '\n              '~/repos/my_presi/my_presi.pdf')", "label": 1}
{"code": "function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }", "label": 3}
{"code": "public void createProductDelivery(final String productLogicalName, final Delivery delivery, final String user, final String password) throws GrapesCommunicationException, AuthenticationException {      \n    \tfinal Client client = getClient(user, password);\n        final WebResource resource = client.resource(serverURL).path(RequestUtils.getProductDelivery(productLogicalName));\n        final ClientResponse response = resource.type(MediaType.APPLICATION_JSON).post(ClientResponse.class, delivery);\n\n        client.destroy();\n        if(ClientResponse.Status.CREATED.getStatusCode() != response.getStatus()){\n            final String message = \"Failed to create a delivery\";\n            if(LOG.isErrorEnabled()) {\n                LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, message, response.getStatus()));\n            }\n            throw new GrapesCommunicationException(message, response.getStatus());\n        }\n    }", "label": 0}
{"code": "def auth_mech_props(value)\n      properties = hash_extractor('authMechanismProperties', value)\n      if properties[:canonicalize_host_name]\n        properties.merge!(canonicalize_host_name:\n          %w(true TRUE).include?(properties[:canonicalize_host_name]))\n      end\n      properties\n    end", "label": 4}
{"code": "private Query getReportQueryByCriteriaCount(ReportQueryByCriteria aQuery)\r\n    {\r\n        ReportQueryByCriteria countQuery = (ReportQueryByCriteria) getQueryByCriteriaCount(aQuery);\r\n\r\n        // BRJ: keep the original columns to build the Join\r\n        countQuery.setJoinAttributes(aQuery.getAttributes());\r\n\r\n        // BRJ: we have to preserve groupby information\r\n        Iterator iter = aQuery.getGroupBy().iterator();\r\n        while(iter.hasNext())\r\n        {\r\n            countQuery.addGroupBy((FieldHelper) iter.next());\r\n        }\r\n\r\n        return countQuery;\r\n    }", "label": 0}
{"code": "func (c *Client) loadServerCert(cert string) error {\n\tcertPool := x509.NewCertPool()\n\n\tasn1, err := base64.RawStdEncoding.DecodeString(cert)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tx509Cert, err := x509.ParseCertificate([]byte(asn1))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcertPool.AddCert(x509Cert)\n\n\tc.config.TLSConfig.RootCAs = certPool\n\treturn nil\n}", "label": 5}
{"code": "public function getFullIsoDescription()\n    {\n        $region = $this->getRegionName();\n        $variant = $this->getVariantName();\n\n        return $this->getFullIsoName().($region ? ' ('.$region.')' : '').($variant ? ' ('.$variant.')' : '');\n    }", "label": 2}
{"code": "public function set_nack_handler($callback)\n    {\n        if (!is_callable($callback)) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Given callback \"%s\" should be callable. %s type was given.',\n                $callback,\n                gettype($callback)\n            ));\n        }\n\n        $this->nack_handler = $callback;\n    }", "label": 2}
{"code": "func AppRootfsPath(root string, appName types.ACName) string {\n\treturn filepath.Join(AppPath(root, appName), aci.RootfsDir)\n}", "label": 5}
{"code": "def reference_contexts_for_variants(\n        variants,\n        context_size,\n        transcript_id_whitelist=None):\n    \"\"\"\n    Extract a set of reference contexts for each variant in the collection.\n\n    Parameters\n    ----------\n    variants : varcode.VariantCollection\n\n    context_size : int\n        Max of nucleotides to include to the left and right of the variant\n        in the context sequence.\n\n    transcript_id_whitelist : set, optional\n        If given, then only consider transcripts whose IDs are in this set.\n\n    Returns a dictionary from variants to lists of ReferenceContext objects,\n    sorted by max coding sequence length of any transcript.\n    \"\"\"\n    result = OrderedDict()\n    for variant in variants:\n        result[variant] = reference_contexts_for_variant(\n            variant=variant,\n            context_size=context_size,\n            transcript_id_whitelist=transcript_id_whitelist)\n    return result", "label": 1}
{"code": "func (ds *DjangoSession) Save(db XODB) error {\n\tif ds.Exists() {\n\t\treturn ds.Update(db)\n\t}\n\n\treturn ds.Insert(db)\n}", "label": 5}
{"code": "def shell(jaide, commands):\n    \"\"\" Send shell commands to a device.\n\n    @param jaide: The jaide connection to the device.\n    @type jaide: jaide.Jaide object\n    @param commands: The shell commands to send to the device.\n    @type commands: str or list.\n\n    @returns: The output of the commands.\n    @rtype str\n    \"\"\"\n    out = \"\"\n    for cmd in clean_lines(commands):\n        out += color('> %s\\n' % cmd, 'yel')\n        out += jaide.shell_cmd(cmd) + '\\n'\n    return out", "label": 1}
{"code": "func (c *Client) Client() (ClientProtocol, error) {\n\t_, err := c.Start()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.l.Lock()\n\tdefer c.l.Unlock()\n\n\tif c.client != nil {\n\t\treturn c.client, nil\n\t}\n\n\tswitch c.protocol {\n\tcase ProtocolNetRPC:\n\t\tc.client, err = newRPCClient(c)\n\n\tcase ProtocolGRPC:\n\t\tc.client, err = newGRPCClient(c.doneCtx, c)\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown server protocol: %s\", c.protocol)\n\t}\n\n\tif err != nil {\n\t\tc.client = nil\n\t\treturn nil, err\n\t}\n\n\treturn c.client, nil\n}", "label": 5}
{"code": "def find_input(attribute_name, options = {}, &block)\n      column     = find_attribute_column(attribute_name)\n      input_type = default_input_type(attribute_name, column, options)\n\n      if block_given?\n        SimpleForm::Inputs::BlockInput.new(self, attribute_name, column, input_type, options, &block)\n      else\n        find_mapping(input_type).new(self, attribute_name, column, input_type, options)\n      end\n    end", "label": 4}
{"code": "def remove_diacritic(*diacritics):\n    \"\"\"\n    Given a collection of Unicode diacritics, return a function that takes a\n    string and returns the string without those diacritics.\n    \"\"\"\n    def _(text):\n        return unicodedata.normalize(\"NFC\", \"\".join(\n            ch\n            for ch in unicodedata.normalize(\"NFD\", text)\n            if ch not in diacritics)\n        )\n    return _", "label": 1}
{"code": "def __parse_ws_data(jsondata, latitude=52.091579, longitude=5.119734):\n    \"\"\"Parse the buienradar json and rain data.\"\"\"\n    log.info(\"Parse ws data: latitude: %s, longitude: %s\", latitude, longitude)\n    result = {SUCCESS: False, MESSAGE: None, DATA: None}\n\n    # select the nearest weather station\n    loc_data = __select_nearest_ws(jsondata, latitude, longitude)\n    # process current weather data from selected weatherstation\n    if not loc_data:\n        result[MESSAGE] = 'No location selected.'\n        return result\n\n    if not __is_valid(loc_data):\n        result[MESSAGE] = 'Location data is invalid.'\n        return result\n\n    # add distance to weatherstation\n    log.debug(\"Raw location data: %s\", loc_data)\n    result[DISTANCE] = __get_ws_distance(loc_data, latitude, longitude)\n    result = __parse_loc_data(loc_data, result)\n\n    # extract weather forecast\n    try:\n        fc_data = jsondata[__FORECAST][__FIVEDAYFORECAST]\n    except (json.JSONDecodeError, KeyError):\n        result[MESSAGE] = 'Unable to extract forecast data.'\n        log.exception(result[MESSAGE])\n        return result\n\n    if fc_data:\n        # result = __parse_fc_data(fc_data, result)\n        log.debug(\"Raw forecast data: %s\", fc_data)\n        # pylint: disable=unsupported-assignment-operation\n        result[DATA][FORECAST] = __parse_fc_data(fc_data)\n\n    return result", "label": 1}
{"code": "def show(options = {}, &block)\n      config.set_page_presenter :show, ActiveAdmin::PagePresenter.new(options, &block)\n    end", "label": 4}
{"code": "public static <T> void addAll(Collection<T> collection, Iterable<? extends T> items) {\r\n    for (T item : items) {\r\n      collection.add(item);\r\n    }\r\n  }", "label": 0}
{"code": "def remove_record(self, record):\n        \"\"\"Remove an already accepted record from the community.\n\n        :param record: Record object.\n        :type record: `invenio_records.api.Record`\n        \"\"\"\n        if not self.has_record(record):\n            current_app.logger.warning(\n                'Community removal: record {uuid} was not in community '\n                '\"{comm}\"'.format(uuid=record.id, comm=self.id))\n        else:\n            key = current_app.config['COMMUNITIES_RECORD_KEY']\n            record[key] = [c for c in record[key] if c != self.id]\n\n        if current_app.config['COMMUNITIES_OAI_ENABLED']:\n            if self.oaiset.has_record(record):\n                self.oaiset.remove_record(record)", "label": 1}
{"code": "public function setFields($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\BigQuery\\DataTransfer\\V1\\DataSourceParameter::class);\n        $this->fields = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (uw *UnitWriter) Activate(unit, wantPath string) {\n\tif uw.err != nil {\n\t\treturn\n\t}\n\n\tif err := os.Symlink(path.Join(\"..\", unit), wantPath); err != nil && !os.IsExist(err) {\n\t\tuw.err = errwrap.Wrap(errors.New(\"failed to link service want\"), err)\n\t}\n}", "label": 5}
{"code": "@GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @Path(\"/graph/{name}/{version}\")\n    public Response getModuleGraph(@PathParam(\"name\") final String moduleName,\n                                   @PathParam(\"version\") final String moduleVersion,\n                                   @Context final UriInfo uriInfo){\n\n        LOG.info(\"Dependency Checker got a get module graph export request.\");\n\n        if(moduleName == null || moduleVersion == null){\n            return Response.serverError().status(HttpStatus.NOT_ACCEPTABLE_406).build();\n        }\n\n        final FiltersHolder filters = new FiltersHolder();\n        filters.init(uriInfo.getQueryParameters());\n\n        final String moduleId = DbModule.generateID(moduleName, moduleVersion);\n        final AbstractGraph moduleGraph = getGraphsHandler(filters).getModuleGraph(moduleId);\n\n        return Response.ok(moduleGraph).build();\n    }", "label": 0}
{"code": "def find_server(client, address_str)\n      client.cluster.servers_list.detect{ |s| s.address.to_s == address_str }\n    end", "label": 4}
{"code": "def start(self):\n        \"\"\"\n        Given the pipeline topology starts ``Pipers`` in the order input -> \n        output. See ``Piper.start``. ``Pipers`` instances are started in two \n        stages, which allows them to share ``NuMaps``.\n        \n        \"\"\"\n        # top - > bottom of pipeline\n        pipers = self.postorder()\n        # \n        for piper in pipers:\n            piper.start(stages=(0, 1))\n        for piper in pipers:\n            piper.start(stages=(2,))", "label": 1}
{"code": "public static <T extends Comparable<T>> int compareLists(List<T> list1, List<T> list2) {\r\n    if (list1 == null && list2 == null)\r\n      return 0;\r\n    if (list1 == null || list2 == null) {\r\n      throw new IllegalArgumentException();\r\n    }\r\n    int size1 = list1.size();\r\n    int size2 = list2.size();\r\n    int size = Math.min(size1, size2);\r\n    for (int i = 0; i < size; i++) {\r\n      int c = list1.get(i).compareTo(list2.get(i));\r\n      if (c != 0)\r\n        return c;\r\n    }\r\n    if (size1 < size2)\r\n      return -1;\r\n    if (size1 > size2)\r\n      return 1;\r\n    return 0;\r\n  }", "label": 0}
{"code": "function DgeToPbn(opts) {\n    if (!(this instanceof DgeToPbn)) return new DgeToPbn(opts);\n\n    opts = opts || {};\n    this.needDirectives = true;\n    this.boardNumber = opts.boardNumber || 1;\n\n    stream.Transform.call(this, opts);\n}", "label": 3}
{"code": "def from_ad_date(cls, date):\n        \"\"\" Gets a NepDate object from gregorian calendar date \"\"\"\n        functions.check_valid_ad_range(date)\n        days = values.START_EN_DATE - date\n\n        # Add the required number of days to the start nepali date\n        start_date = NepDate(values.START_NP_YEAR, 1, 1)\n        # No need to update as addition already calls update\n        return start_date + (date - values.START_EN_DATE)", "label": 1}
{"code": "def _pre_activate_injection(self):\n        \"\"\"\n        Injects functions before the activation routine of child classes gets called\n        \"\"\"\n        # Let's be sure that this plugins class is registered and available on application level under\n        # application.plugins.classes. This allows to reuse this class for *new* plugins.\n        if not self.app.plugins.classes.exist(self.__class__.__name__):\n            self.app.plugins.classes.register([self.__class__])\n\n        self._load_needed_plugins()\n\n        self.app.signals.send(\"plugin_activate_pre\", self)", "label": 1}
{"code": "func getFontKey(familyStr, styleStr string) string {\n\tfamilyStr = strings.ToLower(familyStr)\n\tstyleStr = strings.ToUpper(styleStr)\n\tif styleStr == \"IB\" {\n\t\tstyleStr = \"BI\"\n\t}\n\treturn familyStr + styleStr\n}", "label": 5}
{"code": "func (nDB *NetworkDB) SetPrimaryKey(key []byte) {\n\tlogrus.Debugf(\"Primary Key %.5s\", hex.EncodeToString(key))\n\tnDB.RLock()\n\tdefer nDB.RUnlock()\n\tfor _, dbKey := range nDB.config.Keys {\n\t\tif bytes.Equal(key, dbKey) {\n\t\t\tif nDB.keyring != nil {\n\t\t\t\tnDB.keyring.UseKey(dbKey)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n}", "label": 5}
{"code": "func (fs *FSLocalKeyStore) DeleteKey(host string, username string) error {\n\tdirPath, err := fs.dirFor(host, false)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tfiles := []string{\n\t\tfilepath.Join(dirPath, username+fileExtCert),\n\t\tfilepath.Join(dirPath, username+fileExtTLSCert),\n\t\tfilepath.Join(dirPath, username+fileExtPub),\n\t\tfilepath.Join(dirPath, username),\n\t}\n\tfor _, fn := range files {\n\t\tif err = os.Remove(fn); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "func (l VirtualDeviceList) CreateIDEController() (types.BaseVirtualDevice, error) {\n\tide := &types.VirtualIDEController{}\n\tide.Key = l.NewKey()\n\treturn ide, nil\n}", "label": 5}
{"code": "public function setReturnType($php_type, $new_type, $phpdoc_type, $is_php_compatible, $description)\n    {\n        $new_type = str_replace(['<mixed, mixed>', '<array-key, mixed>', '<empty, empty>'], '', $new_type);\n\n        $this->new_php_return_type = $php_type;\n        $this->new_phpdoc_return_type = $phpdoc_type;\n        $this->new_psalm_return_type = $new_type;\n        $this->return_type_is_php_compatible = $is_php_compatible;\n        $this->return_type_description = $description;\n    }", "label": 2}
{"code": "public static cmppolicy_cmppolicylabel_binding[] get(nitro_service service, String name) throws Exception{\n\t\tcmppolicy_cmppolicylabel_binding obj = new cmppolicy_cmppolicylabel_binding();\n\t\tobj.set_name(name);\n\t\tcmppolicy_cmppolicylabel_binding response[] = (cmppolicy_cmppolicylabel_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def with_ruby_from_stdin(ruby, &_block)\n      original_stdin = $stdin\n      stdin = StringIO.new\n      stdin.write(ruby)\n      stdin.rewind\n      $stdin = stdin\n      yield\n    ensure\n      $stdin = original_stdin\n    end", "label": 4}
{"code": "func MyQueryColumns(args *internal.ArgType, inspect []string) ([]*models.Column, error) {\n\tvar err error\n\n\t// create temporary view xoid\n\txoid := \"_xo_\" + internal.GenRandomID()\n\tviewq := `CREATE VIEW ` + xoid + ` AS (` + strings.Join(inspect, \"\\n\") + `)`\n\tmodels.XOLog(viewq)\n\t_, err = args.DB.Exec(viewq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// load columns\n\tcols, err := models.MyTableColumns(args.DB, args.Schema, xoid)\n\n\t// drop inspect view\n\tdropq := `DROP VIEW ` + xoid\n\tmodels.XOLog(dropq)\n\t_, _ = args.DB.Exec(dropq)\n\n\t// load column information\n\treturn cols, err\n}", "label": 5}
{"code": "func TickmarkPrecision(div float64) int {\n\treturn int(math.Max(-math.Floor(math.Log10(div)), 0))\n}", "label": 5}
{"code": "private function displayCommitSummary(OutputInterface $output, array $commitRelease)\n    {\n        $output->writeln('Commit Summary');\n        $output->writeln('-----');\n\n        foreach ($commitRelease as $key => $releaseInfo) {\n            $output->writeln(sprintf('<info>google/%s</info> [<info>%s</info>]', $key, $this->levels[$releaseInfo['level']]));\n            $output->writeln(sprintf('  - Message: <info>%s</info>', $releaseInfo['message']));\n        }\n    }", "label": 2}
{"code": "public function extend($throttle)\n    {\n        if (is_callable($throttle)) {\n            $throttle = call_user_func($throttle, $this->container);\n        }\n\n        $this->throttles->push($throttle);\n    }", "label": 2}
{"code": "def initialize(self,  **kwargs):\n        \"\"\"\n        Transfer functions may need additional information before the\n        supplied numpy array can be modified in place. For instance,\n        transfer functions may have state which needs to be allocated\n        in memory with a certain size. In other cases, the transfer\n        function may need to know about the coordinate system\n        associated with the input data.\n        \"\"\"\n        if not set(kwargs.keys()).issuperset(self.init_keys):\n            raise Exception(\"TransferFn needs to be initialized with %s\"\n                            % ','.join(repr(el) for el in self.init_keys))", "label": 1}
{"code": "func AppStatusPath(root, appName string) string {\n\treturn filepath.Join(AppsStatusesPath(root), appName)\n}", "label": 5}
{"code": "func (self *realKubeFramework) ParseRBAC(filePath string) (*rbacv1.ClusterRoleBinding, error) {\n\tobj, err := self.loadRBACObject(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trbac, ok := obj.(*rbacv1.ClusterRoleBinding)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"Failed to cast clusterrolebinding: %v\", obj)\n\t}\n\treturn rbac, nil\n}", "label": 5}
{"code": "def dependency_spec\n      spec = {}\n\n      @dependencies.each do |dependency|\n        unless dependency.compiled?\n          raise DirectorError,\n                'Cannot generate package dependency spec ' \\\n                \"for '#{@package.name}', \" \\\n                \"'#{dependency.package.name}' hasn't been compiled yet\"\n        end\n\n        compiled_package = dependency.compiled_package\n\n        spec[compiled_package.name] = {\n          'name' => compiled_package.name,\n          'version' => \"#{compiled_package.version}.#{compiled_package.build}\",\n          'sha1' => compiled_package.sha1,\n          'blobstore_id' => compiled_package.blobstore_id,\n        }\n      end\n\n      spec\n    end", "label": 4}
{"code": "func (f *Fpdf) Bookmark(txtStr string, level int, y float64) {\n\tif y == -1 {\n\t\ty = f.y\n\t}\n\tf.outlines = append(f.outlines, outlineType{text: txtStr, level: level, y: y, p: f.PageNo(), prev: -1, last: -1, next: -1, first: -1})\n}", "label": 5}
{"code": "protected function filter($query, EntryQueryOptions $options)\n    {\n        if ($options->familyHash || $options->tag || $options->batchId) {\n            return $this;\n        }\n\n        $query->where('should_display_on_index', true);\n\n        return $this;\n    }", "label": 2}
{"code": "def creator(entry, config):\n        \"\"\"Creator function for creating an instance of a Bash.\"\"\"\n        template_file = os.path.join(os.path.dirname(__file__), 'templates/docker-container.sh.j2')\n\n        with open(template_file) as handle:\n            template = handle.read()\n            # all fields are re-rendered via the Bash script\n            wrapped_script = render(template, container={\n                'image': 'centos:7' if 'image' not in entry else entry['image'],\n                'remove': True if 'remove' not in entry else str(entry['remove']).lower(),\n                'background': False if 'background' not in entry else str(entry['background']).lower(),\n                'mount': False if 'mount' not in entry else str(entry['mount']).lower(),\n                'network': '' if 'network' not in entry else entry['network'],\n                'labels': {} if 'labels' not in entry else entry['labels'],\n                'script': config.script\n            })\n\n            config.script = wrapped_script\n\n        return Container(config)", "label": 1}
{"code": "function drawBufferInfo(gl, bufferInfo, primitiveType, count, offset) {\n    var indices = bufferInfo.indices;\n    primitiveType = primitiveType === undefined ? gl.TRIANGLES : primitiveType;\n    var numElements = count === undefined ? bufferInfo.numElements : count;\n    offset = offset === undefined ? offset : 0;\n    if (indices) {\n      gl.drawElements(primitiveType, numElements, gl.UNSIGNED_SHORT, offset);\n    } else {\n      gl.drawArrays(primitiveType, offset, numElements);\n    }\n  }", "label": 3}
{"code": "func SetLabels(labels map[string]string,\n\tcmdLabels services.CommandLabels) ServerOption {\n\treturn func(s *Server) error {\n\t\t// make sure to clone labels to avoid\n\t\t// concurrent writes to the map during reloads\n\t\tcmdLabels = cmdLabels.Clone()\n\t\tfor name, label := range cmdLabels {\n\t\t\tif label.GetPeriod() < time.Second {\n\t\t\t\tlabel.SetPeriod(time.Second)\n\t\t\t\tcmdLabels[name] = label\n\t\t\t\tlog.Warningf(\"label period can't be less that 1 second. Period for label '%v' was set to 1 second\", name)\n\t\t\t}\n\t\t}\n\t\ts.labels = labels\n\t\ts.cmdLabels = cmdLabels\n\t\treturn nil\n\t}\n}", "label": 5}
{"code": "def trim_N_nucleotides(prefix, suffix):\n    \"\"\"\n    Drop all occurrences of 'N' from prefix and suffix nucleotide strings\n    by trimming.\n    \"\"\"\n    if 'N' in prefix:\n        # trim prefix to exclude all occurrences of N\n        rightmost_index = prefix.rfind('N')\n        logger.debug(\n            \"Trimming %d nucleotides from read prefix '%s'\",\n            rightmost_index + 1, prefix)\n        prefix = prefix[rightmost_index + 1:]\n\n    if 'N' in suffix:\n        leftmost_index = suffix.find('N')\n        logger.debug(\n            \"Trimming %d nucleotides from read suffix '%s'\",\n            len(suffix) - leftmost_index,\n            suffix)\n        suffix = suffix[:leftmost_index]\n\n    return prefix, suffix", "label": 1}
{"code": "def update_cloneable_associations\n      associations_for_cloning.each do |association|\n        type = @klass.reflect_on_association(association)\n        through_record = type.through_reflection\n\n        if through_record.present?\n          clone_join_relationships(through_record.plural_name)\n        else\n          clone_has_one_relationship(association,type) if type.macro == :has_one\n          clone_has_many_relationships(association) if type.macro == :has_many\n        end\n      end\n    end", "label": 4}
{"code": "def delete(attribute, type = nil, **options)\n      attribute, type, options = normalize_arguments(attribute, type, options)\n      matches = where(attribute, type, options)\n      matches.each do |error|\n        @errors.delete(error)\n      end\n      matches.map(&:message)\n    end", "label": 4}
{"code": "public function deserializeFile($filename, $className = 'OpenApi\\Annotations\\OpenApi')\n    {\n        if (!$this->isValidClassName($className)) {\n            throw new \\Exception($className.' is not defined in OpenApi PHP Annotations');\n        }\n        $jsonString = file_get_contents($filename);\n        return $this->doDeserialize(json_decode($jsonString), $className);\n    }", "label": 2}
{"code": "def process(sexp, level = :expr)\n      return fragment('', scope) if sexp.nil?\n\n      if handler = handlers[sexp.type]\n        return handler.new(sexp, level, self).compile_to_fragments\n      else\n        error \"Unsupported sexp: #{sexp.type}\"\n      end\n    end", "label": 4}
{"code": "public static ResourceKey key(Enum<?> enumValue, String key) {\n        return new ResourceKey(enumValue.getClass().getName(), enumValue.name()).child(key);\n    }", "label": 0}
{"code": "def to_xml(options = {})\n      deprecation_removal_warning(:to_xml)\n      to_a.to_xml({ root: \"errors\", skip_types: true }.merge!(options))\n    end", "label": 4}
{"code": "function docker(cwd, cmd) {\n  console.log(cwd, chalk.blue('running docker', cmd));\n  return spawn('docker', (cmd || 'build .').split(' '), {cwd, env});\n}", "label": 3}
{"code": "public function removeById($connectionID)\n    {\n        if ($connection = $this->getConnectionById($connectionID)) {\n            return $this->remove($connection);\n        }\n\n        return false;\n    }", "label": 2}
{"code": "def stream(keep_open = false)\n      scheduler = env['async.callback'] ? EventMachine : Stream\n      current   = @params.dup\n      body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } }\n    end", "label": 4}
{"code": "function appendTypeParameters(typeParameters, declarations) {\n            for (var _i = 0, declarations_2 = declarations; _i < declarations_2.length; _i++) {\n                var declaration = declarations_2[_i];\n                var tp = getDeclaredTypeOfTypeParameter(getSymbolOfNode(declaration));\n                if (!typeParameters) {\n                    typeParameters = [tp];\n                }\n                else if (!ts.contains(typeParameters, tp)) {\n                    typeParameters.push(tp);\n                }\n            }\n            return typeParameters;\n        }", "label": 3}
{"code": "def get_gene_ids(fusion_bed):\n    \"\"\"\n    Parses FusionInspector bed file to ascertain the ENSEMBL gene ids\n\n    :param str fusion_bed: path to fusion annotation\n    :return: dict\n    \"\"\"\n    with open(fusion_bed, 'r') as f:\n        gene_to_id = {}\n        regex = re.compile(r'(?P<gene>ENSG\\d*)')\n        for line in f:\n            line = line.split('\\t')\n            transcript, gene_bit, name = line[3].split(';')\n            m = regex.search(gene_bit)\n            if m:\n                gene_to_id[name] = m.group('gene')\n    return gene_to_id", "label": 1}
{"code": "def load_file_to_string(self):\n        \"\"\" load a file to a string \"\"\"\n        try:\n            with open(self.fullname, 'r') as f:\n                txt = f.read()\n            return txt\n        except IOError:\n            return ''", "label": 1}
{"code": "func (vm *VirtualMachine) updateDiskLayouts() types.BaseMethodFault {\n\tvar disksLayout []types.VirtualMachineFileLayoutDiskLayout\n\tvar disksLayoutEx []types.VirtualMachineFileLayoutExDiskLayout\n\n\tdisks := object.VirtualDeviceList(vm.Config.Hardware.Device).SelectByType((*types.VirtualDisk)(nil))\n\tfor _, disk := range disks {\n\t\tdisk := disk.(*types.VirtualDisk)\n\t\tdiskBacking := disk.Backing.(*types.VirtualDiskFlatVer2BackingInfo)\n\n\t\tdiskLayout := &types.VirtualMachineFileLayoutDiskLayout{Key: disk.Key}\n\t\tdiskLayoutEx := &types.VirtualMachineFileLayoutExDiskLayout{Key: disk.Key}\n\n\t\t// Iterate through disk and its parents\n\t\tfor {\n\t\t\tdFileName := diskBacking.GetVirtualDeviceFileBackingInfo().FileName\n\n\t\t\tvar fileKeys []int32\n\n\t\t\tdm := Map.VirtualDiskManager()\n\t\t\t// Add disk descriptor and extent files\n\t\t\tfor _, diskName := range dm.names(dFileName) {\n\t\t\t\t// get full path including datastore location\n\t\t\t\tp, fault := parseDatastorePath(diskName)\n\t\t\t\tif fault != nil {\n\t\t\t\t\treturn fault\n\t\t\t\t}\n\n\t\t\t\tdatastore := vm.useDatastore(p.Datastore)\n\t\t\t\tdFilePath := path.Join(datastore.Info.GetDatastoreInfo().Url, p.Path)\n\n\t\t\t\tvar fileSize int64\n\t\t\t\t// If file can not be opened - fileSize will be 0\n\t\t\t\tif dFileInfo, err := os.Stat(dFilePath); err == nil {\n\t\t\t\t\tfileSize = dFileInfo.Size()\n\t\t\t\t}\n\n\t\t\t\tdiskKey := vm.addFileLayoutEx(*p, fileSize)\n\t\t\t\tfileKeys = append(fileKeys, diskKey)\n\t\t\t}\n\n\t\t\tdiskLayout.DiskFile = append(diskLayout.DiskFile, dFileName)\n\t\t\tdiskLayoutEx.Chain = append(diskLayoutEx.Chain, types.VirtualMachineFileLayoutExDiskUnit{\n\t\t\t\tFileKey: fileKeys,\n\t\t\t})\n\n\t\t\tif parent := diskBacking.Parent; parent != nil {\n\t\t\t\tdiskBacking = parent\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tdisksLayout = append(disksLayout, *diskLayout)\n\t\tdisksLayoutEx = append(disksLayoutEx, *diskLayoutEx)\n\t}\n\n\tvm.Layout.Disk = disksLayout\n\n\tvm.LayoutEx.Disk = disksLayoutEx\n\tvm.LayoutEx.Timestamp = time.Now()\n\n\tvm.updateStorage()\n\n\treturn nil\n}", "label": 5}
{"code": "function buildCSVsForSingleMergedForm(formSubmissionModel, params, cb) {\n  var formId = params.formId;\n  var formName = params.formName;\n  var date = params.date;\n  var mergedFields = params.mergedFields;\n  var fieldHeader = params.fieldHeader;\n  var singleFormQuery = params.singleFormQuery;\n  var downloadUrl = params.downloadUrl;\n\n  var fullSubmissionCSVString = \"\";\n  //Form Name might not be unique but the ID will always be.\n  var fileName = date + \"-\" + formId + \"-\" + (formName.split(' ').join('_'));\n  //Query the submissions for the formId\n  //LEAN\n  //Select only the metadata and formFields in the submission.\n  // Stream response\n  // Build CSV string for each entry.\n  // Add to the zip file.\n  cb = _.once(cb);\n\n  params.statusUpdaterFunction({\n    message: \"Beginning export of submissions for form ID: \" + formId\n  });\n\n  var exportProgressInterval = setInterval(function() {\n    params.statusUpdaterFunction({\n      message: \"Exporting submission \" + params.exportCounter.numSubsExported + \" of \" + params.exportCounter.numSubmissionsToExport\n    });\n  }, 1000);\n\n  //First, generate headers.\n  fullSubmissionCSVString = csvHeaders.generateCSVHeaders(_.keys(mergedFields[formId]), mergedFields[formId], fieldHeader);\n\n  var submissionQueryStream = formSubmissionModel.find(singleFormQuery).select({\n    \"formSubmittedAgainst.pages\": 0,\n    \"formSubmittedAgainst.pageRules\": 0,\n    \"formSubmittedAgainst.fieldRules\": 0\n  }).lean().stream();\n\n  submissionQueryStream.on('data', function addSubmissionToCSV(submissionJSON) {\n    //Merge the form fields\n    fullSubmissionCSVString += processSingleSubmission({\n      mergedFields: mergedFields,\n      submission: submissionJSON,\n      date: date,\n      fieldHeader: fieldHeader,\n      downloadUrl: downloadUrl\n    });\n\n    params.exportCounter.numSubsExported ++;\n  }).on('error', function(err) {\n    logger.error(\"Error streaming submissions \", err);\n    clearInterval(exportProgressInterval);\n    return cb(err);\n  }).on('close', function() {\n    clearInterval(exportProgressInterval);\n    return cb(undefined, {\n      formId: formId,\n      fileName: fileName,\n      csvString: fullSubmissionCSVString\n    });\n  });\n}", "label": 3}
{"code": "public function sendNode($node, $encrypt = true)\n    {\n        $this->timeout = time();\n        $this->debugPrint($node->nodeString('tx  ').\"\\n\");\n        $this->sendData($this->writer->write($node, $encrypt));\n    }", "label": 2}
{"code": "public static base_responses update(nitro_service client, scpolicy resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tscpolicy updateresources[] = new scpolicy[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new scpolicy();\n\t\t\t\tupdateresources[i].name = resources[i].name;\n\t\t\t\tupdateresources[i].url = resources[i].url;\n\t\t\t\tupdateresources[i].rule = resources[i].rule;\n\t\t\t\tupdateresources[i].delay = resources[i].delay;\n\t\t\t\tupdateresources[i].maxconn = resources[i].maxconn;\n\t\t\t\tupdateresources[i].action = resources[i].action;\n\t\t\t\tupdateresources[i].altcontentsvcname = resources[i].altcontentsvcname;\n\t\t\t\tupdateresources[i].altcontentpath = resources[i].altcontentpath;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "func (r *Rotation) PhaseDescription() string {\n\tswitch r.Phase {\n\tcase RotationPhaseInit:\n\t\treturn \"initialized\"\n\tcase RotationPhaseStandby, \"\":\n\t\treturn \"on standby\"\n\tcase RotationPhaseUpdateClients:\n\t\treturn \"rotating clients\"\n\tcase RotationPhaseUpdateServers:\n\t\treturn \"rotating servers\"\n\tcase RotationPhaseRollback:\n\t\treturn \"rolling back\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"unknown phase: %q\", r.Phase)\n\t}\n}", "label": 5}
{"code": "public static base_response unset(nitro_service client, snmpalarm resource, String[] args) throws Exception{\n\t\tsnmpalarm unsetresource = new snmpalarm();\n\t\tunsetresource.trapname = resource.trapname;\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "public function setListSelect($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\Intent_Message_ListSelect::class);\n        $this->writeOneof(11, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_response delete(nitro_service client, String Dnssuffix) throws Exception {\n\t\tdnssuffix deleteresource = new dnssuffix();\n\t\tdeleteresource.Dnssuffix = Dnssuffix;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "public function rollback(Session $session, $transactionId, array $options = [])\n    {\n        return $this->connection->rollback([\n            'transactionId' => $transactionId,\n            'session' => $session->name(),\n            'database' => $session->info()['database']\n        ] + $options);\n    }", "label": 2}
{"code": "def implemented?(an_rpc)\n      mth = an_rpc.method.to_sym\n      return an_rpc if rpc_descs.key?(mth)\n      GRPC.logger.warn(\"UNIMPLEMENTED: #{an_rpc}\")\n      noop = proc { |x| x }\n\n      # Create a new active call that knows that\n      # metadata hasn't been sent yet\n      c = ActiveCall.new(an_rpc.call, noop, noop, an_rpc.deadline,\n                         metadata_received: true, started: false)\n      c.send_status(GRPC::Core::StatusCodes::UNIMPLEMENTED, '')\n      nil\n    end", "label": 4}
{"code": "public void remove(Identity oid)\r\n    {\r\n        try\r\n        {\r\n            jcsCache.remove(oid.toString());\r\n        }\r\n        catch (CacheException e)\r\n        {\r\n            throw new RuntimeCacheException(e.getMessage());\r\n        }\r\n    }", "label": 0}
{"code": "def delete(path, options = {}, &block)\n      perform_request Net::HTTP::Delete, path, options, &block\n    end", "label": 4}
{"code": "function clear () {\n  var str = '';\n  for (var i = 0; i < 20; i++) {\n    if (Math.random() < 0.5) {\n      str += '\\u200B';\n    } else {\n      str += ' ';\n    }\n  }\n  return str;\n}", "label": 3}
{"code": "function(data, name, $field, $el, field, callback) {\n      data[name] = self.getArea($el, name);\n\n      if (field.required && (apos.areaIsEmpty(data[name]))) {\n        return apos.afterYield(_.partial(callback, 'required'));\n      }\n      return apos.afterYield(callback);\n    }", "label": 3}
{"code": "function (templatePath, path, data, name) {\n    var templateString = fs.readFileSync(templatePath);\n\n    // generate scenarioData.js contents by inserting data into template\n    var templateData = {scenarioData: data};\n    templateData.scenarioDataName = name || '';\n\n    var output = _.template(templateString)(templateData);\n\n    mkdirp.sync(getDirName(path));\n    fs.writeFileSync(path, output);\n  }", "label": 3}
{"code": "def autowidth(widtharray)\n      return if value.nil?\n      if styles.cellXfs[style].alignment && styles.cellXfs[style].alignment.wrap_text\n        first = true\n        value.to_s.split(/\\r?\\n/, -1).each do |line|\n          if first\n            first = false\n          else\n            widtharray << 0\n          end\n          widtharray[-1] += string_width(line, font_size)\n        end\n      else\n        widtharray[-1] += string_width(value.to_s, font_size)\n      end\n      widtharray\n    end", "label": 4}
{"code": "public static final boolean setSelectedValue(ListBox list, String value, boolean addMissingValues) {\n\tif (value == null) {\n\t    list.setSelectedIndex(0);\n\t    return false;\n\t}\n\telse {\n\t    int index = findValueInListBox(list, value);\n\t    if (index >= 0) {\n\t\tlist.setSelectedIndex(index);\n\t\treturn true;\n\t    }\n\n\t    if (addMissingValues) {\n\t\tlist.addItem(value, value);\n\n\t\t// now that it's there, search again\n\t\tindex = findValueInListBox(list, value);\n\t\tlist.setSelectedIndex(index);\n\t\treturn true;\n\t    }\n\n\t    return false;\n\t}\n    }", "label": 0}
{"code": "public static Class<?> getRawType(Type type) {\n\t\tif (type instanceof Class) {\n\t\t\treturn (Class<?>) type;\n\t\t} else if (type instanceof ParameterizedType) {\n\t\t\tParameterizedType actualType = (ParameterizedType) type;\n\t\t\treturn getRawType(actualType.getRawType());\n\t\t} else if (type instanceof GenericArrayType) {\n\t\t\tGenericArrayType genericArrayType = (GenericArrayType) type;\n\t\t\tObject rawArrayType = Array.newInstance(getRawType(genericArrayType\n\t\t\t\t\t.getGenericComponentType()), 0);\n\t\t\treturn rawArrayType.getClass();\n\t\t} else if (type instanceof WildcardType) {\n\t\t\tWildcardType castedType = (WildcardType) type;\n\t\t\treturn getRawType(castedType.getUpperBounds()[0]);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Type \\'\"\n\t\t\t\t\t\t\t+ type\n\t\t\t\t\t\t\t+ \"\\' is not a Class, \"\n\t\t\t\t\t\t\t+ \"ParameterizedType, or GenericArrayType. Can't extract class.\");\n\t\t}\n\t}", "label": 0}
{"code": "func (m Manager) CreateTaskView(ctx context.Context, watch *types.ManagedObjectReference) (*TaskView, error) {\n\tl, err := m.CreateListView(ctx, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttv := &TaskView{\n\t\tListView: l,\n\t\tWatch:    watch,\n\t}\n\n\treturn tv, nil\n}", "label": 5}
{"code": "def add_field(self, name, label, field_type, *args, **kwargs):\n        \"\"\" Add the field to the internal configuration dictionary. \"\"\"\n        if name in self._dyn_fields:\n            raise AttributeError('Field already added to the form.')\n        else:\n            self._dyn_fields[name] = {'label': label, 'type': field_type,\n                                      'args': args, 'kwargs': kwargs}", "label": 1}
{"code": "public void forAllProcedureArguments(String template, Properties attributes) throws XDocletException\r\n    {\r\n        String argNameList = _curProcedureDef.getProperty(PropertyHelper.OJB_PROPERTY_ARGUMENTS);\r\n\r\n        for (CommaListIterator it = new CommaListIterator(argNameList); it.hasNext();)\r\n        {\r\n            _curProcedureArgumentDef = _curClassDef.getProcedureArgument(it.getNext());\r\n            generate(template);\r\n        }\r\n        _curProcedureArgumentDef = null;\r\n    }", "label": 0}
{"code": "public function setTranslationEvaluationMetrics($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\AutoMl\\V1beta1\\TranslationEvaluationMetrics::class);\n        $this->writeOneof(9, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "func (ts *Store) Remove(id string) error {\n\ttreeStoreKeyLock, err := lock.ExclusiveKeyLock(ts.lockDir, id)\n\tif err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error locking tree store\"), err)\n\t}\n\tdefer treeStoreKeyLock.Close()\n\n\tif err := ts.remove(id); err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error removing the tree store\"), err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "func procInstEncoding(s string) string {\n\t// TODO: this parsing is somewhat lame and not exact.\n\t// It works for all actual cases, though.\n\tidx := strings.Index(s, \"encoding=\")\n\tif idx == -1 {\n\t\treturn \"\"\n\t}\n\tv := s[idx+len(\"encoding=\"):]\n\tif v == \"\" {\n\t\treturn \"\"\n\t}\n\tif v[0] != '\\'' && v[0] != '\"' {\n\t\treturn \"\"\n\t}\n\tidx = strings.IndexRune(v[1:], rune(v[0]))\n\tif idx == -1 {\n\t\treturn \"\"\n\t}\n\treturn v[1 : idx+1]\n}", "label": 5}
{"code": "public static function autoSelect($server)\n    {\n        if (isset($server['GAE_SERVICE'])) {\n            if (isset($server['GAE_ENV']) && $server['GAE_ENV'] === 'standard') {\n                return new GAEStandardMetadataProvider($server);\n            }\n            return new GAEFlexMetadataProvider($server);\n        }\n        return new EmptyMetadataProvider();\n    }", "label": 2}
{"code": "public void set(int i, double value) {\n        switch (i) {\n            case 0: {\n                x = value;\n                break;\n            }\n            case 1: {\n                y = value;\n                break;\n            }\n            case 2: {\n                z = value;\n                break;\n            }\n            default: {\n                throw new ArrayIndexOutOfBoundsException(i);\n            }\n        }\n    }", "label": 0}
{"code": "private function handleInsert(array $options)\n    {\n        $attempt = 0;\n        $metadata = $this->pluck('tableMetadata', $options, false) ?: [];\n        $autoCreate = $this->pluck('autoCreate', $options, false) ?: false;\n        $maxRetries = $this->pluck('maxRetries', $options, false) ?: self::MAX_RETRIES;\n\n        while (true) {\n            try {\n                return $this->connection->insertAllTableData(\n                    $this->identity + $options\n                );\n            } catch (NotFoundException $ex) {\n                if ($autoCreate === true && $attempt <= $maxRetries) {\n                    if (!isset($metadata['schema'])) {\n                        throw new \\InvalidArgumentException(\n                            'A schema is required when creating a table.'\n                        );\n                    }\n\n                    $this->usleep(mt_rand(1, self::INSERT_CREATE_MAX_DELAY_MICROSECONDS));\n\n                    try {\n                        $this->connection->insertTable($metadata + [\n                            'projectId' => $this->identity['projectId'],\n                            'datasetId' => $this->identity['datasetId'],\n                            'tableReference' => $this->identity,\n                            'retries' => 0\n                        ]);\n                    } catch (ConflictException $ex) {\n                    } catch (\\Exception $ex) {\n                        $retryFunction = $this->getRetryFunction();\n\n                        if (!$retryFunction($ex)) {\n                            throw $ex;\n                        }\n                    }\n\n                    $this->usleep(self::INSERT_CREATE_MAX_DELAY_MICROSECONDS);\n                    $attempt++;\n                } else {\n                    throw $ex;\n                }\n            }\n        }\n    }", "label": 2}
{"code": "def create_schema_from_xsd_directory(directory, version):\n    \"\"\"Create and fill the schema from a directory which contains xsd\n    files. It calls fill_schema_from_xsd_file for each xsd file\n    found.\n\n    \"\"\"\n    schema = Schema(version)\n    for f in _get_xsd_from_directory(directory):\n        logger.info(\"Loading schema %s\" % f)\n        fill_schema_from_xsd_file(f, schema)\n    return schema", "label": 1}
{"code": "function(map, attr, val) {\n\tvar serializer = attr === \"*\" ? false : getPropDefineBehavior(\"serialize\", attr, map.define);\n\tif (serializer === undefined) {\n\t\treturn oldSingleSerialize.call(map, attr, val);\n\t} else if (serializer !== false) {\n\t\treturn typeof serializer === \"function\" ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);\n\t}\n}", "label": 3}
{"code": "public function touchCurrentConversation()\n    {\n        if (! is_null($this->currentConversationData)) {\n            $touched = $this->currentConversationData;\n            $touched['time'] = microtime();\n\n            $this->cache->put($this->message->getConversationIdentifier(), $touched, $this->config['config']['conversation_cache_time'] ?? 30);\n        }\n    }", "label": 2}
{"code": "func (f *fileFetcher) Hash(aciPath string, a *asc) (string, error) {\n\tensureLogger(f.Debug)\n\tabsPath, err := filepath.Abs(aciPath)\n\tif err != nil {\n\t\treturn \"\", errwrap.Wrap(fmt.Errorf(\"failed to get an absolute path for %q\", aciPath), err)\n\t}\n\taciPath = absPath\n\n\taciFile, err := f.getFile(aciPath, a)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer aciFile.Close()\n\n\tkey, err := f.S.WriteACI(aciFile, imagestore.ACIFetchInfo{\n\t\tLatest: false,\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn key, nil\n}", "label": 5}
{"code": "public static appfwprofile_cookieconsistency_binding[] get(nitro_service service, String name) throws Exception{\n\t\tappfwprofile_cookieconsistency_binding obj = new appfwprofile_cookieconsistency_binding();\n\t\tobj.set_name(name);\n\t\tappfwprofile_cookieconsistency_binding response[] = (appfwprofile_cookieconsistency_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (process *TeleportProcess) initAuthStorage() (bk backend.Backend, err error) {\n\tbc := &process.Config.Auth.StorageConfig\n\tprocess.Debugf(\"Using %v backend.\", bc.Type)\n\tswitch bc.Type {\n\tcase lite.GetName():\n\t\tbk, err = lite.New(context.TODO(), bc.Params)\n\t\t// legacy bolt backend, import all data into SQLite and return\n\t\t// SQLite data\n\tcase boltbk.GetName():\n\t\tlitebk, err := lite.New(context.TODO(), bc.Params)\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\terr = legacy.Import(context.TODO(), litebk, func() (legacy.Exporter, error) {\n\t\t\treturn boltbk.New(legacy.Params(bc.Params))\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tbk = litebk\n\t\t// legacy filesystem backend, import all data into SQLite and return\n\t\t// SQLite data\n\tcase dir.GetName():\n\t\tlitebk, err := lite.New(context.TODO(), bc.Params)\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\terr = legacy.Import(context.TODO(), litebk, func() (legacy.Exporter, error) {\n\t\t\treturn dir.New(legacy.Params(bc.Params))\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tbk = litebk\n\t// DynamoDB backend:\n\tcase dynamo.GetName():\n\t\tbk, err = dynamo.New(context.TODO(), bc.Params)\n\t// etcd backend:\n\tcase etcdbk.GetName():\n\t\tbk, err = etcdbk.New(context.TODO(), bc.Params)\n\tdefault:\n\t\terr = trace.BadParameter(\"unsupported secrets storage type: %q\", bc.Type)\n\t}\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treporter, err := backend.NewReporter(backend.ReporterConfig{\n\t\tComponent:        teleport.ComponentBackend,\n\t\tBackend:          backend.NewSanitizer(bk),\n\t\tTrackTopRequests: process.Config.Debug,\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tprocess.setReporter(reporter)\n\treturn reporter, nil\n}", "label": 5}
{"code": "def resolve(cells)\n      cells.each do |cell|\n        cell_hash = cell.value\n        if index = @unique_cells[cell_hash]\n          cell.send :ssti=, index\n        else\n          cell.send :ssti=, @index\n          @shared_xml_string << '<si>' << CellSerializer.run_xml_string(cell) << '</si>'\n          @unique_cells[cell_hash] = @index\n          @index += 1\n        end\n      end\n    end", "label": 4}
{"code": "public function startQuery(JobConfigurationInterface $query, array $options = [])\n    {\n        $config = $query->toArray();\n        $response = $this->connection->insertJob($config + $options);\n\n        return new Job(\n            $this->connection,\n            $config['jobReference']['jobId'],\n            $this->projectId,\n            $this->mapper,\n            $response\n        );\n    }", "label": 2}
{"code": "function _gpfFromBaseANY (base, text, pad) {\n    var baseLength = base.length,\n        result = 0,\n        idx = _gpfSkipPad(text, pad || base.charAt(0));\n    while (idx < text.length) {\n        result = baseLength * result + base.indexOf(text.charAt(idx++));\n    }\n    return result;\n}", "label": 3}
{"code": "public function setManagedCluster($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dataproc\\V1\\ManagedCluster::class);\n        $this->writeOneof(1, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public function annotateBatch(array $images, array $options = [])\n    {\n        $this->validateBatch($images, Image::class);\n\n        $requests = [];\n        foreach ($images as $image) {\n            $requests[] = $image->requestObject();\n        }\n\n        $res = $this->connection->annotate([\n            'requests' => $requests\n        ] + $options);\n\n        $annotations = [];\n        if (isset($res['responses'])) {\n            foreach ($res['responses'] as $response) {\n                $annotations[] = new Annotation($response);\n            }\n        }\n\n        return $annotations;\n    }", "label": 2}
{"code": "function _gpfProcessDefineParamCheckIfRelativeName (rootNamespace, params) {\n    var name = params[_GPF_DEFINE_PARAM_NAME];\n    if (-1 === name.indexOf(\".\")) {\n        params[_GPF_DEFINE_PARAM_NAME] = rootNamespace + name;\n    }\n}", "label": 3}
{"code": "def request_withdrawal(self, amount: Number, address: str, subtract_fee: bool=False, **params) -> Withdrawal:\n        \"\"\"Request a withdrawal.\"\"\"\n        self.log.debug(f'Requesting {self.currency} withdrawal from {self.name} to {address}')\n        amount = self._parse_money(amount)\n\n        if self.dry_run:\n            withdrawal = Withdrawal.create_default(TxType.WITHDRAWAL, self.currency, amount, address)\n            self.log.warning(f'DRY RUN: Withdrawal requested on {self.name}: {withdrawal}')\n            return withdrawal\n\n        try:\n            withdrawal = self._withdraw(amount, address, subtract_fee, **params)\n        except Exception as e:\n            msg = f'Failed requesting withdrawal on {self.name}!: amount={amount}, address={address}'\n            raise self.exception(InvalidWithdrawal, msg, e) from e\n\n        self.log.info(f'Withdrawal requested on {self.name}: {withdrawal}')\n        return withdrawal", "label": 1}
{"code": "def script_sha(conn, file_name)\n      if (sha = SCRIPT_SHAS.get(file_name))\n        return sha\n      end\n\n      sha = conn.script(:load, script_source(file_name))\n      SCRIPT_SHAS.put(file_name, sha)\n      sha\n    end", "label": 4}
{"code": "def outline_level_columns(start_index, end_index, level = 1, collapsed = true)\n      outline column_info, (start_index..end_index), level, collapsed\n    end", "label": 4}
{"code": "public function setToken($token, $tokenSecret)\n    {\n        $this->token = $token;\n        $this->tokenSecret = $tokenSecret;\n\n        return $this;\n    }", "label": 2}
{"code": "protected function basic_ack_from_server(AMQPReader $reader)\n    {\n        $delivery_tag = $reader->read_longlong();\n        $multiple = (bool) $reader->read_bit();\n\n        if (!isset($this->published_messages[$delivery_tag])) {\n            throw new AMQPRuntimeException(sprintf(\n                'Server ack\\'ed unknown delivery_tag \"%s\"',\n                $delivery_tag\n            ));\n        }\n\n        $this->internal_ack_handler($delivery_tag, $multiple, $this->ack_handler);\n    }", "label": 2}
{"code": "def fetch_profiles\n      UI.message(\"Fetching profiles...\")\n      results = profile_type.find_by_bundle_id(bundle_id: Sigh.config[:app_identifier],\n                                                     mac: Sigh.config[:platform].to_s == 'macos',\n                                            sub_platform: Sigh.config[:platform].to_s == 'tvos' ? 'tvOS' : nil)\n      results = results.find_all do |current_profile|\n        if current_profile.valid? || Sigh.config[:force]\n          true\n        else\n          UI.message(\"Provisioning Profile '#{current_profile.name}' is not valid, skipping this one...\")\n          false\n        end\n      end\n\n      # Take the provisioning profile name into account\n      results = filter_profiles_by_name(results) if Sigh.config[:provisioning_name].to_s.length > 0\n      return results if Sigh.config[:skip_certificate_verification]\n\n      UI.message(\"Verifying certificates...\")\n      return results.find_all do |current_profile|\n        installed = false\n\n        # Attempts to download all certificates from this profile\n        # for checking if they are installed.\n        # `cert.download_raw` can fail if the user is a\n        # \"member\" and not an a \"admin\"\n        raw_certs = current_profile.certificates.map do |cert|\n          begin\n            raw_cert = cert.download_raw\n          rescue => error\n            UI.important(\"Cannot download cert #{cert.id} - #{error.message}\")\n            raw_cert = nil\n          end\n          { downloaded: raw_cert, cert: cert }\n        end\n\n        # Makes sure we have the certificate installed on the local machine\n        raw_certs.each do |current_cert|\n          # Skip certificates that failed to download\n          next unless current_cert[:downloaded]\n          file = Tempfile.new('cert')\n          file.write(current_cert[:downloaded])\n          file.close\n          if FastlaneCore::CertChecker.installed?(file.path)\n            installed = true\n          else\n            UI.message(\"Certificate for Provisioning Profile '#{current_profile.name}' not available locally: #{current_cert[:cert].id}, skipping this one...\")\n          end\n        end\n        installed && current_profile.certificate_valid?\n      end\n    end", "label": 4}
{"code": "function getChanges(log, regex) {\n      var changes = [];\n      var match;\n\n      while ((match = regex.exec(log))) {\n        var change = '';\n\n        for (var i = 1, len = match.length; i < len; i++) {\n          change += match[i];\n        }\n\n        changes.push(change.trim());\n      }\n\n      return changes;\n    }", "label": 3}
{"code": "public function setSessionEntityTypes($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dialogflow\\V2\\SessionEntityType::class);\n        $this->session_entity_types = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function commit(array $mutations, array $options = [])\n    {\n        $options += [\n            'transaction' => null\n        ];\n\n        $res = $this->connection->commit($options + [\n            'mode' => ($options['transaction']) ? 'TRANSACTIONAL' : 'NON_TRANSACTIONAL',\n            'mutations' => $mutations,\n            'projectId' => $this->projectId\n        ]);\n\n        return $res;\n    }", "label": 2}
{"code": "def get_properties(attributes):\n        \"\"\"Return tuple of names of defined properties.\n\n        :type attributes: dict\n        :rtype: list\n        \"\"\"\n        return [key for key, value in six.iteritems(attributes)\n                if isinstance(value, property)]", "label": 1}
{"code": "def import_from(self, other_ns, replace=False):\n        \"\"\"Imports namespaces into this set, from other_ns.\n\n        Args:\n            other_ns (NamespaceSet): The set to import from\n            replace (bool): If a namespace exists in both sets, do we replace\n                our data with other_ns's data?  We could get fancy and define\n                some merge strategies, but for now, this is very simple.  It's\n                either do nothing, or wholesale replacement.  There is no\n                merging.\n\n        Raises:\n            DuplicatePrefixError: If the other NamespaceSet is mapping any\n                prefixes incompatibly with respect to this set.\n        \"\"\"\n        for other_ns_uri in other_ns.namespace_uris:\n            ni = self.__ns_uri_map.get(other_ns_uri)\n\n            if ni is None:\n                other_ni = other_ns._NamespaceSet__ns_uri_map[other_ns_uri]\n\n                # Gotta make sure that the other set isn't mapping its prefixes\n                # incompatibly with respect to this set.\n                for other_prefix in other_ni.prefixes:\n                    self.__check_prefix_conflict(other_ns_uri, other_prefix)\n\n                cloned_ni = copy.deepcopy(other_ni)\n                self.__add_namespaceinfo(cloned_ni)\n            elif replace:\n                other_ni = other_ns._NamespaceSet__ns_uri_map[other_ns_uri]\n                for other_prefix in other_ni.prefixes:\n                    self.__check_prefix_conflict(ni, other_prefix)\n\n                cloned_ni = copy.deepcopy(other_ni)\n                self.remove_namespace(other_ns_uri)\n                self.__add_namespaceinfo(cloned_ni)\n            else:\n                continue", "label": 1}
{"code": "def inject_compile_log(response)\n      if response['value'] && response['value'].is_a?(Hash) &&\n        response['value']['result'].is_a?(Hash) &&\n        blob_id = response['value']['result']['compile_log_id']\n        compile_log = download_and_delete_blob(blob_id)\n        response['value']['result']['compile_log'] = compile_log\n      end\n    end", "label": 4}
{"code": "def sum(self, axis):\n        \"\"\"Sums all data along axis, returns d-1 dimensional histogram\"\"\"\n        axis = self.get_axis_number(axis)\n        if self.dimensions == 2:\n            new_hist = Hist1d\n        else:\n            new_hist = Histdd\n        return new_hist.from_histogram(np.sum(self.histogram, axis=axis),\n                                       bin_edges=itemgetter(*self.other_axes(axis))(self.bin_edges),\n                                       axis_names=self.axis_names_without(axis))", "label": 1}
{"code": "public function entity($key = null, array $entity = [], array $options = [])\n    {\n        $options += [\n            'className' => null\n        ];\n\n        if ($key && !is_string($key) && !($key instanceof Key)) {\n            throw new \\InvalidArgumentException(\n                '$key must be an instance of Key or a string'\n            );\n        }\n\n        if (is_string($key)) {\n            $key = $this->key($key);\n        }\n\n        $className = $options['className'];\n        if (!is_null($className) && !is_subclass_of($className, EntityInterface::class)) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Given classname %s must implement EntityInterface',\n                $className\n            ));\n        }\n\n        if (is_null($className)) {\n            $className = Entity::class;\n        }\n\n        return $className::build($key, $entity, $options);\n    }", "label": 2}
{"code": "def find_variable(key, raise_on_not_found: true)\n      # This was changed from find() to find_index() because this is a very hot\n      # path and find_index() is optimized in MRI to reduce object allocation\n      index = @scopes.find_index { |s| s.key?(key) }\n      scope = @scopes[index] if index\n\n      variable = nil\n\n      if scope.nil?\n        @environments.each do |e|\n          variable = lookup_and_evaluate(e, key, raise_on_not_found: raise_on_not_found)\n          # When lookup returned a value OR there is no value but the lookup also did not raise\n          # then it is the value we are looking for.\n          if !variable.nil? || @strict_variables && raise_on_not_found\n            scope = e\n            break\n          end\n        end\n      end\n\n      scope ||= @environments.last || @scopes.last\n      variable ||= lookup_and_evaluate(scope, key, raise_on_not_found: raise_on_not_found)\n\n      variable = variable.to_liquid\n      variable.context = self if variable.respond_to?(:context=)\n\n      variable\n    end", "label": 4}
{"code": "function list(connections, params, cb) {\n  async.waterfall([\n    function findDataTargets(cb) {\n      lookUpDataTargets(connections, {\n        query: {},\n        lean: true\n      }, function(err, dataTargets) {\n        if (err) {\n          return cb(buildErrorResponse({\n            error: err,\n            userDetail: \"Unexpected Error When Searching For A Data Target\",\n            code: ERROR_CODES.FH_FORMS_UNEXPECTED_ERROR\n          }));\n        }\n\n        return cb(undefined, dataTargets);\n      });\n    }\n  ], cb);\n}", "label": 3}
{"code": "public function getConnectionByKey($key)\n    {\n        $hash = $this->strategy->getSlotByKey($key);\n        $node = $this->distributor->getBySlot($hash);\n\n        return $node;\n    }", "label": 2}
{"code": "protected function prepareScriptArguments(array $arguments)\n    {\n        $args = [];\n        foreach ($arguments as $key => $value) {\n            if ($value instanceof WebDriverElement) {\n                $args[$key] = ['ELEMENT' => $value->getID()];\n            } else {\n                if (is_array($value)) {\n                    $value = $this->prepareScriptArguments($value);\n                }\n                $args[$key] = $value;\n            }\n        }\n\n        return $args;\n    }", "label": 2}
{"code": "func globGetArgs(args []string) globArgs {\n\tf, target := standardFlags(globCmd)\n\tsuffix := f.String(\"suffix\", \"\", \"File suffix (example: .go)\")\n\tglobbingMode := f.String(\"glob-mode\", \"all\", \"Which files to glob (normal, dot-files, all [default])\")\n\tfilelist := f.String(\"filelist\", \"\", \"Read all the files from this file\")\n\tvar mapTo []string\n\tmapToWrapper := common.StringSliceWrapper{Slice: &mapTo}\n\tf.Var(&mapToWrapper, \"map-to\", \"Map contents of filelist to this directory, can be used multiple times\")\n\n\tf.Parse(args)\n\tif *target == \"\" {\n\t\tcommon.Die(\"--target parameter must be specified and cannot be empty\")\n\t}\n\tmode := globModeFromString(*globbingMode)\n\tif *filelist == \"\" {\n\t\tcommon.Die(\"--filelist parameter must be specified and cannot be empty\")\n\t}\n\tif len(mapTo) < 1 {\n\t\tcommon.Die(\"--map-to parameter must be specified at least once\")\n\t}\n\treturn globArgs{\n\t\ttarget:   *target,\n\t\tsuffix:   *suffix,\n\t\tmode:     mode,\n\t\tfilelist: *filelist,\n\t\tmapTo:    mapTo,\n\t}\n}", "label": 5}
{"code": "public function setClusterSelector($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dataproc\\V1\\ClusterSelector::class);\n        $this->writeOneof(2, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def lookahead\n      @lookahead ||= begin\n        ast_node = selected_operation\n        root_type = warden.root_type_for_operation(ast_node.operation_type || \"query\")\n        root_type = root_type.metadata[:type_class] || raise(\"Invariant: `lookahead` only works with class-based types\")\n        GraphQL::Execution::Lookahead.new(query: self, root_type: root_type, ast_nodes: [ast_node])\n      end\n    end", "label": 4}
{"code": "protected function callFallbackMessage()\n    {\n        $messages = $this->getMessages();\n\n        if (! isset($messages[0])) {\n            return;\n        }\n\n        $this->message = $messages[0];\n\n        $this->fallbackMessage = $this->getCallable($this->fallbackMessage);\n\n        \\call_user_func($this->fallbackMessage, $this);\n    }", "label": 2}
{"code": "def split_fqn(fqn):\n    \"\"\"\n    Returns the left and right part of the import.\n\n    ``fqn`` can be either a string of the form ``appname.modulename.ClassName``\n    or a function that returns such a string.\n\n    \"\"\"\n    if hasattr(fqn, '__call__'):\n        fqn_string = fqn()\n    else:\n        fqn_string = fqn\n    return fqn_string.rsplit('.', 1)", "label": 1}
{"code": "def save(self):\n        \"\"\"Save the resource to the API server\n\n        If the resource doesn't have a uuid the resource will be created.\n        If uuid is present the resource is updated.\n\n        :rtype: Resource\n        \"\"\"\n        if self.path.is_collection:\n            self.session.post_json(self.href,\n                                   {self.type: dict(self.data)},\n                                   cls=ResourceEncoder)\n        else:\n            self.session.put_json(self.href,\n                                  {self.type: dict(self.data)},\n                                  cls=ResourceEncoder)\n        return self.fetch(exclude_children=True, exclude_back_refs=True)", "label": 1}
{"code": "public function read( $key, $ttl = null ) {\n\t\t$filename = $this->has( $key, $ttl );\n\n\t\tif ( $filename ) {\n\t\t\treturn file_get_contents( $filename );\n\t\t}\n\n\t\treturn false;\n\t}", "label": 2}
{"code": "function nodeToString(node) {\n    switch (node.type) {\n        case (\"BinaryExpression\"): {\n            return nodeToString(node.left) + node.operator.toString() + nodeToString(node.right);\n        }\n        case (\"CallExpression\"): {\n            var args = node.arguments.map(function(arg) {\n                return nodeToString(arg);\n            }).toString();\n            return nodeToString(node.callee) + \"(\" + args + \")\";\n        }\n        case (\"ConditionalExpression\"): {\n            return nodeToString(node.test) + \"?\" + nodeToString(node.consequent) + \":\" + nodeToString(node.alternate);\n        }\n        case (\"Identifier\"): {\n            return node.name.toString();\n        }\n        case (\"Literal\"): {\n            return node.value.toString();\n        }\n        case (\"MemberExpression\"): {\n            return nodeToString(node.object) + \"[\" + nodeToString(node.property) + \"]\";\n        }\n        case (\"TemplateElement\"): {\n            return node.value.raw.toString();\n        }\n        case (\"TemplateLiteral\"): {\n            // interleave quasis with expressions\n            var s = [];\n            node.quasis.forEach(function(quasi, i) {\n                if (quasi.value.raw) {\n                    s.push(nodeToString(quasi));\n                }\n                var expression = node.expressions[i];\n                if (expression) {\n                    s.push(nodeToString(expression));\n                }\n            });\n            return s.join(\"\");\n        }\n        default: {\n            // Silently ignore Nodes with types we don't handle\n            return \"\";\n        }\n    }\n}", "label": 3}
{"code": "def from_mongo(cls, data, expired=False, **kw):\n\t\t\"\"\"In the event a value that has technically already expired is loaded, swap it for None.\"\"\"\n\t\t\n\t\tvalue = super(Expires, cls).from_mongo(data, **kw)\n\t\t\n\t\tif not expired and value.is_expired:\n\t\t\treturn None\n\t\t\n\t\treturn value", "label": 1}
{"code": "@Nonnull\n\tpublic static InterfaceAnalysis analyze(@Nonnull final String code) {\n\t\tCheck.notNull(code, \"code\");\n\n\t\tfinal CompilationUnit unit = Check.notNull(SourceCodeReader.parse(code), \"compilationUnit\");\n\t\tfinal List<TypeDeclaration> types = Check.notEmpty(unit.getTypes(), \"typeDeclarations\");\n\t\tCheck.stateIsTrue(types.size() == 1, \"only one interface declaration per analysis is supported\");\n\n\t\tfinal ClassOrInterfaceDeclaration type = (ClassOrInterfaceDeclaration) types.get(0);\n\n\t\tfinal Imports imports = SourceCodeReader.findImports(unit.getImports());\n\t\tfinal Package pkg = unit.getPackage() != null ? new Package(unit.getPackage().getName().toString()) : Package.UNDEFINED;\n\t\tfinal List<Annotation> annotations = SourceCodeReader.findAnnotations(type.getAnnotations(), imports);\n\t\tfinal List<Method> methods = SourceCodeReader.findMethods(type.getMembers(), imports);\n\t\tCheck.stateIsTrue(!hasPossibleMutatingMethods(methods), \"The passed interface '%s' seems to have mutating methods\", type.getName());\n\t\tfinal List<Interface> extendsInterfaces = SourceCodeReader.findExtends(type);\n\t\tfinal String interfaceName = type.getName();\n\t\treturn new ImmutableInterfaceAnalysis(annotations, extendsInterfaces, imports.asList(), interfaceName, methods, pkg);\n\t}", "label": 0}
{"code": "func PgOpfamilyByOid(db XODB, oid pgtypes.Oid) (*PgOpfamily, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, opfmethod, opfname, opfnamespace, opfowner ` +\n\t\t`FROM pg_catalog.pg_opfamily ` +\n\t\t`WHERE oid = $1`\n\n\t// run query\n\tXOLog(sqlstr, oid)\n\tpo := PgOpfamily{}\n\n\terr = db.QueryRow(sqlstr, oid).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Oid, &po.Ctid, &po.Opfmethod, &po.Opfname, &po.Opfnamespace, &po.Opfowner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &po, nil\n}", "label": 5}
{"code": "def lockfile(lockfile_name, lock_wait_timeout=-1):\n    \"\"\"\n    Only runs the method if the lockfile is not acquired.\n\n    You should create a setting ``LOCKFILE_PATH`` which points to\n    ``/home/username/tmp/``.\n\n    In your management command, use it like so::\n\n        LOCKFILE = os.path.join(\n            settings.LOCKFILE_FOLDER, 'command_name')\n\n        class Command(NoArgsCommand):\n            @lockfile(LOCKFILE)\n            def handle_noargs(self, **options):\n                # your command here\n\n    :lockfile_name: A unique name for a lockfile that belongs to the wrapped\n      method.\n    :lock_wait_timeout: Seconds to wait if lockfile is acquired. If ``-1`` we\n      will not wait and just quit.\n\n    \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            lock = FileLock(lockfile_name)\n            try:\n                lock.acquire(lock_wait_timeout)\n            except AlreadyLocked:\n                return\n            except LockTimeout:\n                return\n            try:\n                result = func(*args, **kwargs)\n            finally:\n                lock.release()\n            return result\n\n        return wrapper\n    return decorator", "label": 1}
{"code": "def definitions\n      defined_items.each_with_object({}) do |word, defs|\n        word_type = \"#{word.capitalize.to_s + 'Definitions'}\"\n        defs[word] = Chronic.const_get(word_type).new(options).definitions\n      end\n    end", "label": 4}
{"code": "func NewRoles(in []string) (Roles, error) {\n\tvar roles Roles\n\tfor _, val := range in {\n\t\trole := Role(val)\n\t\tif err := role.Check(); err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\troles = append(roles, role)\n\t}\n\treturn roles, nil\n}", "label": 5}
{"code": "public function getLocationOnScreenOnceScrolledIntoView()\n    {\n        $location = $this->executor->execute(\n            DriverCommand::GET_ELEMENT_LOCATION_ONCE_SCROLLED_INTO_VIEW,\n            [':id' => $this->id]\n        );\n\n        return new WebDriverPoint($location['x'], $location['y']);\n    }", "label": 2}
{"code": "public function fullyQualifiedName($class)\n    {\n        if ($this->namespace) {\n            $namespace = str_replace('\\\\\\\\', '\\\\', '\\\\' . $this->namespace . '\\\\');\n        } else {\n            $namespace = '\\\\'; // global namespace\n        }\n\n        if ($this->class === null) {\n            $this->class = '';\n        }\n\n        if ($class === null) {\n            return '';\n        }\n\n        if (strcasecmp($class, $this->class) === 0) {\n            return $namespace . $this->class;\n        }\n        $pos = strpos($class, '\\\\');\n        if ($pos !== false) {\n            if ($pos === 0) {\n                // Fully qualified name (\\Foo\\Bar)\n                return $class;\n            }\n            // Qualified name (Foo\\Bar)\n            if ($this->uses) {\n                foreach ($this->uses as $alias => $aliasedNamespace) {\n                    $alias .= '\\\\';\n                    if (strcasecmp(substr($class, 0, strlen($alias)), $alias) === 0) {\n                        // Aliased namespace (use \\Long\\Namespace as Foo)\n                        return '\\\\' . $aliasedNamespace . substr($class, strlen($alias) - 1);\n                    }\n                }\n            }\n        } elseif ($this->uses) {\n            // Unqualified name (Foo)\n            foreach ($this->uses as $alias => $aliasedNamespace) {\n                if (strcasecmp($alias, $class) === 0) {\n                    return '\\\\' . $aliasedNamespace;\n                }\n            }\n        }\n\n        return $namespace . $class;\n    }", "label": 2}
{"code": "def _run(args: nil, reraise_errors: false)\n      if args.nil? && que_target\n        args = que_target.que_attrs.fetch(:args)\n      end\n\n      run(*args)\n      default_resolve_action if que_target && !que_target.que_resolved\n    rescue => error\n      raise error unless que_target\n\n      que_target.que_error = error\n\n      run_error_notifier =\n        begin\n          handle_error(error)\n        rescue => error_2\n          Que.notify_error(error_2, que_target.que_attrs)\n          true\n        end\n\n      Que.notify_error(error, que_target.que_attrs) if run_error_notifier\n      retry_in_default_interval unless que_target.que_resolved\n\n      raise error if reraise_errors\n    end", "label": 4}
{"code": "async def query(self, path, method='get', **params):\n        \"\"\"\n        Do a query to the System API\n\n        :param path: url to the API\n        :param method: the kind of query to do\n        :param params: a dict with all the\n        necessary things to query the API\n        :return json data\n        \"\"\"\n        if method in ('get', 'post', 'patch', 'delete', 'put'):\n            full_path = self.host + path\n            if method == 'get':\n                resp = await self.aio_sess.get(full_path, params=params)\n            elif method == 'post':\n                resp = await self.aio_sess.post(full_path, data=params)\n            elif method == 'patch':\n                resp = await self.aio_sess.patch(full_path, data=params)\n            elif method == 'delete':\n                resp = await self.aio_sess.delete(full_path, params=params, headers=params)\n            elif method == 'put':\n                resp = await self.aio_sess.put(full_path, data=params)\n\n            async with resp:\n                # return the content if its a binary one\n                if resp.content_type.startswith('application/pdf') or \\\n                        resp.content_type.startswith('application/epub'):\n                    return await resp.read()\n\n                return await self.handle_json_response(resp)\n        else:\n            raise ValueError('method expected: get, post, patch, delete, put')", "label": 1}
{"code": "def run_muse_perchrom(job, tumor_bam, normal_bam, univ_options, muse_options, chrom):\n    \"\"\"\n    Run MuSE call on a single chromosome in the input bams.\n\n    :param dict tumor_bam: Dict of bam and bai for tumor DNA-Seq\n    :param dict normal_bam: Dict of bam and bai for normal DNA-Seq\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict muse_options: Options specific to MuSE\n    :param str chrom: Chromosome to process\n    :return: fsID for the chromsome vcf\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    work_dir = os.getcwd()\n    input_files = {\n        'tumor.bam': tumor_bam['tumor_dna_fix_pg_sorted.bam'],\n        'tumor.bam.bai': tumor_bam['tumor_dna_fix_pg_sorted.bam.bai'],\n        'normal.bam': normal_bam['normal_dna_fix_pg_sorted.bam'],\n        'normal.bam.bai': normal_bam['normal_dna_fix_pg_sorted.bam.bai'],\n        'genome.fa.tar.gz': muse_options['genome_fasta'],\n        'genome.fa.fai.tar.gz': muse_options['genome_fai']}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n\n    for key in ('genome.fa', 'genome.fa.fai'):\n        input_files[key] = untargz(input_files[key + '.tar.gz'], work_dir)\n    input_files = {key: docker_path(path) for key, path in input_files.items()}\n\n    output_prefix = os.path.join(work_dir, chrom)\n\n    parameters = ['call',\n                  '-f', input_files['genome.fa'],\n                  '-r', chrom,\n                  '-O', docker_path(output_prefix),\n                  input_files['tumor.bam'],\n                  input_files['normal.bam']]\n    docker_call(tool='muse', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], tool_version=muse_options['version'])\n    outfile = job.fileStore.writeGlobalFile(''.join([output_prefix, '.MuSE.txt']))\n    job.fileStore.logToMaster('Ran MuSE on %s:%s successfully' % (univ_options['patient'], chrom))\n    return outfile", "label": 1}
{"code": "func (p *Pod) SandboxManifest() (*schema.PodManifest, error) {\n\t_, pm, err := p.PodManifest() // this takes the lock fd to load the manifest, hence path is not needed here\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"error loading pod manifest\"), err)\n\t}\n\n\tms, ok := pm.Annotations.Get(\"coreos.com/rkt/stage1/mutable\")\n\tif ok {\n\t\tp.mutable, err = strconv.ParseBool(ms)\n\t\tif err != nil {\n\t\t\treturn nil, errwrap.Wrap(errors.New(\"error parsing mutable annotation\"), err)\n\t\t}\n\t}\n\n\tif !p.mutable {\n\t\treturn nil, ErrImmutable\n\t}\n\n\treturn pm, nil\n}", "label": 5}
{"code": "def delete_expired_requests():\n    \"\"\"Delete expired inclusion requests.\"\"\"\n    InclusionRequest.query.filter_by(\n        InclusionRequest.expiry_date > datetime.utcnow()).delete()\n    db.session.commit()", "label": 1}
{"code": "def authorization_form_for(record, options = {}, &block)\n      default_options = {\n        builder: AuthorizationFormBuilder,\n        as: \"authorization_handler\",\n        url: decidim_verifications.authorizations_path\n      }\n\n      options = default_options.merge(options)\n      decidim_form_for(record, options, &block)\n    end", "label": 4}
{"code": "private function validate_input( $assoc_args, $grouping ) {\n\t\t// Check if valid arguments were passed.\n\t\t$arg_match = preg_grep( '/^set-(\\w+)/i', array_keys( $assoc_args ) );\n\n\t\t// Verify passed-arguments.\n\t\tif ( empty( $grouping ) && empty( $arg_match ) ) {\n\t\t\tWP_CLI::error( 'No valid arguments passed.' );\n\t\t}\n\n\t\t// Check whether passed arguments contain value or not.\n\t\t$assoc_arg_values = array_filter( array_intersect_key( $assoc_args, array_flip( $arg_match ) ) );\n\n\t\tif ( empty( $grouping ) && empty( $assoc_arg_values ) ) {\n\t\t\tWP_CLI::error( 'No value passed to arguments.' );\n\t\t}\n\t}", "label": 2}
{"code": "def get_receiver(self, receiver=None):\n        \"\"\"\n        Returns a single receiver or a dictionary of receivers for this plugin.\n        \"\"\"\n        return self.__app.signals.get_receiver(receiver, self._plugin)", "label": 1}
{"code": "public static base_response disable(nitro_service client, Long clid) throws Exception {\n\t\tclusterinstance disableresource = new clusterinstance();\n\t\tdisableresource.clid = clid;\n\t\treturn disableresource.perform_operation(client,\"disable\");\n\t}", "label": 0}
{"code": "def build_board_checkers():\n    \"\"\" builds a checkers starting board \n    Printing Grid\n     0     B     0     B     0     B     0     B\n     B     0     B     0     B     0     B     0\n     0     0     0     0     0     0     0     0\n     0     0     0     0     0     0     0     0\n     0     0     0     0     0     0     0     0\n     0     0     0     0     0     0     0     0\n     0     W     0     W     0     W     0     W\n     W     0     W     0     W     0     W     0\n    \"\"\"\n    grd = Grid(8,8, [\"B\",\"W\"])\n    for c in range(4):\n        grd.set_tile(0,(c*2) - 1, \"B\")\n        grd.set_tile(1,(c*2) - 0, \"B\")\n        grd.set_tile(6,(c*2) + 1, \"W\")\n        grd.set_tile(7,(c*2) - 0, \"W\")\n    print(grd)\n\n    return grd", "label": 1}
{"code": "func PgEventTriggerByEvtname(db XODB, evtname pgtypes.Name) (*PgEventTrigger, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, evtname, evtevent, evtowner, evtfoid, evtenabled, evttags ` +\n\t\t`FROM pg_catalog.pg_event_trigger ` +\n\t\t`WHERE evtname = $1`\n\n\t// run query\n\tXOLog(sqlstr, evtname)\n\tpet := PgEventTrigger{}\n\n\terr = db.QueryRow(sqlstr, evtname).Scan(&pet.Tableoid, &pet.Cmax, &pet.Xmax, &pet.Cmin, &pet.Xmin, &pet.Oid, &pet.Ctid, &pet.Evtname, &pet.Evtevent, &pet.Evtowner, &pet.Evtfoid, &pet.Evtenabled, &pet.Evttags)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pet, nil\n}", "label": 5}
{"code": "def trigger_rollback(user = AnonymousUser.new, env: nil, force: false)\n      rollback = build_rollback(user, env: env, force: force)\n      rollback.save!\n      rollback.enqueue\n\n      lock_reason = \"A rollback for #{rollback.since_commit.sha} has been triggered. \" \\\n        \"Please make sure the reason for the rollback has been addressed before deploying again.\"\n      stack.update!(lock_reason: lock_reason, lock_author_id: user.id)\n\n      rollback\n    end", "label": 4}
{"code": "def committed(list=nil, timeout_ms=1200)\n      if list.nil?\n        list = assignment\n      elsif !list.is_a?(TopicPartitionList)\n        raise TypeError.new(\"list has to be nil or a TopicPartitionList\")\n      end\n      tpl = list.to_native_tpl\n      response = Rdkafka::Bindings.rd_kafka_committed(@native_kafka, tpl, timeout_ms)\n      if response != 0\n        raise Rdkafka::RdkafkaError.new(response)\n      end\n      TopicPartitionList.from_native_tpl(tpl)\n    end", "label": 4}
{"code": "func (c *crontime) calculateEvent(baseTime time.Time) time.Time {\n\tc.calculationInProgress = true\n\tdefer c.setCalculationInProgress(false)\n\tbaseTime = setNanoecond(baseTime, 10000)\n\tc.calculatedTime = baseTime // Ignore all Events in the Past & initial 'result'\n\t//c.calculatedTime = setNanoecond(c.calculatedTime, 10000)\n\tc.nextValidMonth(baseTime)\n\tc.nextValidDay(baseTime)\n\tc.nextValidHour(baseTime)\n\tc.nextValidMinute(baseTime)\n\tc.nextValidSecond(baseTime)\n\tlog.Println(\"Cronbee has found a time stamp: \", c.calculatedTime)\n\treturn c.calculatedTime\n}", "label": 5}
{"code": "public static systemmemory_stats get(nitro_service service) throws Exception{\n\t\tsystemmemory_stats obj = new systemmemory_stats();\n\t\tsystemmemory_stats[] response = (systemmemory_stats[])obj.stat_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def send_request(method, url_or_path, params, headers, &block)\n      with_retry do\n        response = @client.send(method, url_or_path, params, headers, &block)\n        log_response(method, url_or_path, response, headers, &block)\n\n        resp_hash = response.to_hash\n        if resp_hash[:status] == 401\n          msg = \"Auth lost\"\n          logger.warn(msg)\n          raise UnauthorizedAccessError.new, \"Unauthorized Access\"\n        end\n\n        if response.body.to_s.include?(\"<title>302 Found</title>\")\n          raise AppleTimeoutError.new, \"Apple 302 detected - this might be temporary server error, check https://developer.apple.com/system-status/ to see if there is a known downtime\"\n        end\n\n        if response.body.to_s.include?(\"<h3>Bad Gateway</h3>\")\n          raise BadGatewayError.new, \"Apple 502 detected - this might be temporary server error, try again later\"\n        end\n\n        return response\n      end\n    end", "label": 4}
{"code": "public Object getBean(String name) {\n\t\tBean bean = beans.get(name);\n\t\tif (null == bean) {\n\t\t\treturn null;\n\t\t}\n\t\treturn bean.object;\n\t}", "label": 0}
{"code": "def prefixed_working_directory(working_directory)\n      if self.storage_mode == \"git\"\n        return working_directory\n      elsif self.storage_mode == \"google_cloud\"\n        # We fall back to \"*\", which means certificates and profiles\n        # from all teams that use this bucket would be installed. This is not ideal, but\n        # unless the user provides a `team_id`, we can't know which one to use\n        # This only happens if `readonly` is activated, and no `team_id` was provided\n        @_folder_prefix ||= self.currently_used_team_id\n        if @_folder_prefix.nil?\n          # We use a `@_folder_prefix` variable, to keep state between multiple calls of this\n          # method, as the value won't change. This way the warning is only printed once\n          UI.important(\"Looks like you run `match` in `readonly` mode, and didn't provide a `team_id`. This will still work, however it is recommended to provide a `team_id` in your Appfile or Matchfile\")\n          @_folder_prefix = \"*\"\n        end\n        return File.join(working_directory, @_folder_prefix)\n      else\n        UI.crash!(\"No implementation for `prefixed_working_directory`\")\n      end\n    end", "label": 4}
{"code": "func (nDB *NetworkDB) deleteNetworkNode(nid string, nodeName string) {\n\tnodes, ok := nDB.networkNodes[nid]\n\tif !ok || len(nodes) == 0 {\n\t\treturn\n\t}\n\tnewNodes := make([]string, 0, len(nodes)-1)\n\tfor _, name := range nodes {\n\t\tif name == nodeName {\n\t\t\tcontinue\n\t\t}\n\t\tnewNodes = append(newNodes, name)\n\t}\n\tnDB.networkNodes[nid] = newNodes\n}", "label": 5}
{"code": "function validateDataTarget(connections, dataTarget, cb) {\n  var DataTarget = models.get(connections.mongooseConnection, models.MODELNAMES.DATA_TARGET);\n  var testDataTarget = new DataTarget(dataTarget);\n  //Validating Without Saving\n  testDataTarget.validate(function(err) {\n    if (err) {\n      return cb(buildErrorResponse({\n        error: err,\n        userDetail: \"Invalid Data Target Creation Data.\",\n        systemDetail: err.errors,\n        code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS\n      }));\n    }\n\n    return cb(undefined, dataTarget);\n  });\n}", "label": 3}
{"code": "function getTypeOf(item) {\n  var type = null;\n\n  if(item) {\n    var strValue = item.toString();\n    var isObject = /\\[object/.test(strValue);\n    var isFunction = /function/.test(strValue);\n    var isArray = Array.isArray(item);\n\n    if(isArray) {\n      type = Array;\n    } else if(isFunction) {\n      type = Function;\n    } else if(isObject) {\n      type = Object;\n    } else {\n      type = null;\n    }\n  } else {\n    type = null;\n  }\n\n  return type;\n}", "label": 3}
{"code": "func OptionLabels(labels []string) Option {\n\treturn func(c *Config) {\n\t\tfor _, label := range labels {\n\t\t\tif strings.HasPrefix(label, netlabel.Prefix) {\n\t\t\t\tc.Daemon.Labels = append(c.Daemon.Labels, label)\n\t\t\t}\n\t\t}\n\t}\n}", "label": 5}
{"code": "public function handle(Saving $event)\n    {\n        // Non-admin users pose no problem\n        if (! $event->actor->isAdmin()) {\n            return;\n        }\n\n        // Only admins can demote users, which means demoting other users is\n        // fine, because we still have at least one admin (the actor) left\n        if ($event->actor->id !== $event->user->id) {\n            return;\n        }\n\n        $groups = array_get($event->data, 'relationships.groups.data');\n\n        // If there is no group data (not even an empty array), this means\n        // groups were not changed (and thus not removed) - we're fine!\n        if (! isset($groups)) {\n            return;\n        }\n\n        $adminGroups = array_filter($groups, function ($group) {\n            return $group['id'] == Group::ADMINISTRATOR_ID;\n        });\n\n        // As long as the user is still part of the admin group, all is good\n        if ($adminGroups) {\n            return;\n        }\n\n        // If we get to this point, we have to prohibit the edit\n        throw new PermissionDeniedException;\n    }", "label": 2}
{"code": "function(collection, preventUpdate) {\n      this.stopListening(this.collection, 'remove', removeItemView);\n      this.stopListening(this.collection, 'add', addItemView);\n      this.stopListening(this.collection, 'sort', this.reorder);\n      this.stopListening(this.collection, 'reset', this.update);\n\n      this.collection = collection;\n\n      this.listenTo(this.collection, 'remove', removeItemView);\n      this.listenTo(this.collection, 'add', addItemView);\n      this.listenTo(this.collection, 'sort', this.reorder);\n      this.listenTo(this.collection, 'reset', this.update);\n\n      if (!preventUpdate) {\n        this.update();\n      }\n    }", "label": 3}
{"code": "def print_plugin_information(references)\n      rows = references.collect do |current|\n        if current[1][:actions].empty?\n          # Something is wrong with this plugin, no available actions\n          [current[0].red, current[1][:version_number], \"No actions found\".red]\n        else\n          [current[0], current[1][:version_number], current[1][:actions].join(\"\\n\")]\n        end\n      end\n\n      require 'terminal-table'\n      puts(Terminal::Table.new({\n        rows: FastlaneCore::PrintTable.transform_output(rows),\n        title: \"Used plugins\".green,\n        headings: [\"Plugin\", \"Version\", \"Action\"]\n      }))\n      puts(\"\")\n    end", "label": 4}
{"code": "func AuthUserGroupByUserIDGroupID(db XODB, userID int, groupID int) (*AuthUserGroup, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`id, user_id, group_id ` +\n\t\t`FROM auth_user_groups ` +\n\t\t`WHERE user_id = ? AND group_id = ?`\n\n\t// run query\n\tXOLog(sqlstr, userID, groupID)\n\taug := AuthUserGroup{\n\t\t_exists: true,\n\t}\n\n\terr = db.QueryRow(sqlstr, userID, groupID).Scan(&aug.ID, &aug.UserID, &aug.GroupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &aug, nil\n}", "label": 5}
{"code": "private static void tryWritePreferenceOnDisk(Preferences preference) throws BackingStoreException {\n        final String DUMMY_PROP=\"dummywrite\";\n        instance.put(DUMMY_PROP,\"test\");\n        instance.flush();\n        instance.remove(DUMMY_PROP);\n        instance.flush();\n    }", "label": 0}
{"code": "protected function getComponent($name)\n    {\n        $formatter = $this->cache->rememberForever('flarum.formatter', function () {\n            return $this->getConfigurator()->finalize();\n        });\n\n        return $formatter[$name];\n    }", "label": 2}
{"code": "def all_of(value, *args):\n    \"\"\" All the items in value should match \"\"\"\n\n    if len(args):\n        value = (value,) + args\n\n    return ExpectationAll(value)", "label": 1}
{"code": "def get(self, id, seq, intf): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Get a capture.\n\n        :param id: Result ID as an int.\n        :param seq: TestResult sequence ID as an int.\n        :param intf: Interface name as string.\n        :return: :class:`captures.Capture <captures.Capture>` object\n        :rtype: captures.Capture\n        \"\"\"\n        schema = CaptureSchema()\n        resp = self.service.get_id(self._base(id, seq), intf)\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "function(aClauses, bClauses) {\n\t\tvar self = this;\n\t\tvar differentTypes = [];\n\n\t\teach(clause.TYPES, function(type) {\n\t\t\tif( !self.evaluateOperator(compare.equal, aClauses[type], bClauses[type], {isProperties: true},{isProperties:true}) ) {\n\t\t\t\tdifferentTypes.push(type);\n\t\t\t}\n\t\t});\n\n\t\treturn differentTypes;\n\t}", "label": 3}
{"code": "def stats_keyboard(events, table):\r\n    \"\"\"Return statistics and collated events for keyboard events.\"\"\"\r\n    if len(events) < 2: return [], []\r\n    deltas, prev_dt = [], None\r\n    sessions, session = [], None\r\n    UNBROKEN_DELTA = datetime.timedelta(seconds=conf.KeyboardSessionMaxDelta)\r\n    blank = collections.defaultdict(lambda: collections.defaultdict(int))\r\n    collated = [blank.copy()] # [{dt, keys: {key: count}}]\r\n    for e in events:\r\n        if prev_dt:\r\n            if (prev_dt.second != e[\"dt\"].second\r\n            or prev_dt.minute != e[\"dt\"].minute or prev_dt.hour != e[\"dt\"].hour):\r\n                collated.append(blank.copy())\r\n            delta = e[\"dt\"] - prev_dt\r\n            deltas.append(delta)\r\n            if delta > UNBROKEN_DELTA:\r\n                session = None\r\n            else:\r\n                if not session:\r\n                    session = []\r\n                    sessions.append(session)\r\n                session.append(delta)\r\n        collated[-1][\"dt\"] = e[\"dt\"]\r\n        collated[-1][\"keys\"][e[\"realkey\"]] += 1\r\n        prev_dt = e[\"dt\"]\r\n    longest_session = max(sessions + [[datetime.timedelta()]], key=lambda x: sum(x, datetime.timedelta()))\r\n    stats = [\r\n        (\"Average interval between combos\",\r\n         sum(deltas, datetime.timedelta()) / len(deltas)),\r\n    ] if \"combos\" == table else [\r\n        (\"Keys per hour\",\r\n         int(3600 * len(events) / timedelta_seconds(events[-1][\"dt\"] - events[0][\"dt\"]))),\r\n        (\"Average interval between keys\",\r\n         sum(deltas, datetime.timedelta()) / len(deltas)),\r\n        (\"Typing sessions (key interval < %ss)\" % UNBROKEN_DELTA.seconds,\r\n         len(sessions)),\r\n        (\"Average keys in session\",\r\n         sum(len(x) + 1 for x in sessions) / len(sessions)),\r\n        (\"Average session duration\", sum((sum(x, datetime.timedelta())\r\n         for x in sessions), datetime.timedelta()) / len(sessions)),\r\n        (\"Longest session duration\",\r\n         sum(longest_session, datetime.timedelta())),\r\n        (\"Keys in longest session\",\r\n         len(longest_session) + 1),\r\n        (\"Most keys in session\",\r\n         max(len(x) + 1 for x in sessions)),\r\n    ]\r\n    return stats, collated", "label": 1}
{"code": "public static nspbr[] get(nitro_service service, nspbr_args args) throws Exception{\n\t\tnspbr obj = new nspbr();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tnspbr[] response = (nspbr[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function setCondition($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\V2\\RowFilter_Condition::class);\n        $this->writeOneof(3, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public function update($attributes)\n    {\n        $this->attributes = array_merge($this->attributes, array_filter($attributes, function ($attribute) {\n            return ! is_null($attribute);\n        }));\n\n        return $this;\n    }", "label": 2}
{"code": "public function resume($resumeUri)\n    {\n        if (!$this->data->isSeekable()) {\n            throw new GoogleException('Cannot resume upload on a stream which cannot be seeked.');\n        }\n\n        $this->resumeUri = $resumeUri;\n        $response = $this->getStatusResponse();\n\n        if ($response->getBody()->getSize() > 0) {\n            return $this->decodeResponse($response);\n        }\n\n        $this->rangeStart = $this->getRangeStart($response->getHeaderLine('Range'));\n\n        return $this->upload();\n    }", "label": 2}
{"code": "private Query getQueryBySqlCount(QueryBySQL aQuery)\r\n    {\r\n        String countSql = aQuery.getSql();\r\n\r\n        int fromPos = countSql.toUpperCase().indexOf(\" FROM \");\r\n        if(fromPos >= 0)\r\n        {\r\n            countSql = \"select count(*)\" + countSql.substring(fromPos);\r\n        }\r\n\r\n        int orderPos = countSql.toUpperCase().indexOf(\" ORDER BY \");\r\n        if(orderPos >= 0)\r\n        {\r\n            countSql = countSql.substring(0, orderPos);\r\n        }\r\n\r\n        return new QueryBySQL(aQuery.getSearchClass(), countSql);\r\n    }", "label": 0}
{"code": "def get_cards_stats(ctx, currency, skip_owned, appid, foil):\n    \"\"\"Prints out price stats for cards available in Steam user inventory.\"\"\"\n\n    username = ctx.obj['username']\n    cards_by_app = defaultdict(list)\n\n    inventory = User(username).traverse_inventory(item_filter=TAG_ITEM_CLASS_CARD)\n    for item in inventory:\n        appid_ = item.app.appid\n        if not appid or appid_ in appid:\n            cards_by_app[appid_].append(item)\n\n    if not cards_by_app:\n        click.secho('User `%s` has no cards' % username, fg='red', err=True)\n        return\n\n    for appid_, cards in cards_by_app.items():\n        app = cards[0].app\n        print_card_prices(\n            app.appid, currency,\n            owned_cards=[card.title for card in cards],\n            skip_owned=skip_owned,\n            foil=foil,\n        )", "label": 1}
{"code": "public function findWhereNotIn($field, array $values, $columns = ['*'])\n    {\n        $this->applyCriteria();\n        $this->applyScope();\n        $model = $this->model->whereNotIn($field, $values)->get($columns);\n        $this->resetModel();\n\n        return $this->parserResult($model);\n    }", "label": 2}
{"code": "func (f *file) lintErrorReturn() {\n\tf.walk(func(n ast.Node) bool {\n\t\tfn, ok := n.(*ast.FuncDecl)\n\t\tif !ok || fn.Type.Results == nil {\n\t\t\treturn true\n\t\t}\n\t\tret := fn.Type.Results.List\n\t\tif len(ret) <= 1 {\n\t\t\treturn true\n\t\t}\n\t\tif isIdent(ret[len(ret)-1].Type, \"error\") {\n\t\t\treturn true\n\t\t}\n\t\t// An error return parameter should be the last parameter.\n\t\t// Flag any error parameters found before the last.\n\t\tfor _, r := range ret[:len(ret)-1] {\n\t\t\tif isIdent(r.Type, \"error\") {\n\t\t\t\tf.errorf(fn, 0.9, category(\"arg-order\"), \"error should be the last type when returning multiple items\")\n\t\t\t\tbreak // only flag one\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n}", "label": 5}
{"code": "function isImportedReference(node) {\n                var declaration = resolver.getReferencedImportDeclaration(node);\n                return declaration && (declaration.kind === 231 /* ImportClause */ || declaration.kind === 234 /* ImportSpecifier */);\n            }", "label": 3}
{"code": "public CRFDatum<List<String>, CRFLabel> makeDatum(List<IN> info, int loc,\r\n      edu.stanford.nlp.sequences.FeatureFactory<IN> featureFactory) {\r\n    pad.set(AnswerAnnotation.class, flags.backgroundSymbol);\r\n    PaddedList<IN> pInfo = new PaddedList<IN>(info, pad);\r\n\r\n    ArrayList<List<String>> features = new ArrayList<List<String>>();\r\n\r\n    // for (int i = 0; i < windowSize; i++) {\r\n    // List featuresC = new ArrayList();\r\n    // for (int j = 0; j < FeatureFactory.win[i].length; j++) {\r\n    // featuresC.addAll(featureFactory.features(info, loc,\r\n    // FeatureFactory.win[i][j]));\r\n    // }\r\n    // features.add(featuresC);\r\n    // }\r\n\r\n    Collection<Clique> done = new HashSet<Clique>();\r\n    for (int i = 0; i < windowSize; i++) {\r\n      List<String> featuresC = new ArrayList<String>();\r\n      List<Clique> windowCliques = FeatureFactory.getCliques(i, 0);\r\n      windowCliques.removeAll(done);\r\n      done.addAll(windowCliques);\r\n      for (Clique c : windowCliques) {\r\n        featuresC.addAll(featureFactory.getCliqueFeatures(pInfo, loc, c)); //todo useless copy because of typing reasons\r\n      }\r\n      features.add(featuresC);\r\n    }\r\n\r\n    int[] labels = new int[windowSize];\r\n\r\n    for (int i = 0; i < windowSize; i++) {\r\n      String answer = pInfo.get(loc + i - windowSize + 1).get(AnswerAnnotation.class);\r\n      labels[i] = classIndex.indexOf(answer);\r\n    }\r\n\r\n    printFeatureLists(pInfo.get(loc), features);\r\n\r\n    CRFDatum<List<String>, CRFLabel> d = new CRFDatum<List<String>, CRFLabel>(features, new CRFLabel(labels));\r\n    // System.err.println(d);\r\n    return d;\r\n  }", "label": 0}
{"code": "private static String wordShapeDan1(String s) {\r\n    boolean digit = true;\r\n    boolean upper = true;\r\n    boolean lower = true;\r\n    boolean mixed = true;\r\n    for (int i = 0; i < s.length(); i++) {\r\n      char c = s.charAt(i);\r\n      if (!Character.isDigit(c)) {\r\n        digit = false;\r\n      }\r\n      if (!Character.isLowerCase(c)) {\r\n        lower = false;\r\n      }\r\n      if (!Character.isUpperCase(c)) {\r\n        upper = false;\r\n      }\r\n      if ((i == 0 && !Character.isUpperCase(c)) || (i >= 1 && !Character.isLowerCase(c))) {\r\n        mixed = false;\r\n      }\r\n    }\r\n    if (digit) {\r\n      return \"ALL-DIGITS\";\r\n    }\r\n    if (upper) {\r\n      return \"ALL-UPPER\";\r\n    }\r\n    if (lower) {\r\n      return \"ALL-LOWER\";\r\n    }\r\n    if (mixed) {\r\n      return \"MIXED-CASE\";\r\n    }\r\n    return \"OTHER\";\r\n  }", "label": 0}
{"code": "private static function create_composite_command( $parent, $name, $callable ) {\n\t\t$reflection  = new ReflectionClass( $callable );\n\t\t$doc_comment = self::get_doc_comment( $reflection );\n\t\tif ( ! $doc_comment ) {\n\t\t\t\\WP_CLI::debug( null === $doc_comment ? \"Failed to get doc comment for {$name}.\" : \"No doc comment for {$name}.\", 'commandfactory' );\n\t\t}\n\t\t$docparser = new \\WP_CLI\\DocParser( $doc_comment );\n\n\t\t$container = new CompositeCommand( $parent, $name, $docparser );\n\n\t\tforeach ( $reflection->getMethods() as $method ) {\n\t\t\tif ( ! self::is_good_method( $method ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$class      = is_object( $callable ) ? $callable : $reflection->name;\n\t\t\t$subcommand = self::create_subcommand( $container, false, array( $class, $method->name ), $method );\n\n\t\t\t$subcommand_name = $subcommand->get_name();\n\n\t\t\t$container->add_subcommand( $subcommand_name, $subcommand );\n\t\t}\n\n\t\treturn $container;\n\t}", "label": 2}
{"code": "private static function parse_contributors_from_pull_requests( $pull_requests ) {\n\t\t$contributors = array();\n\t\tforeach ( $pull_requests as $pull_request ) {\n\t\t\tif ( ! empty( $pull_request->user ) ) {\n\t\t\t\t$contributors[ $pull_request->user->html_url ] = $pull_request->user->login;\n\t\t\t}\n\t\t}\n\t\treturn $contributors;\n\t}", "label": 2}
{"code": "func getLoginShell(username string) (string, error) {\n\t// See if the username is valid.\n\t_, err := user.Lookup(username)\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\n\t// Based on stdlib user/lookup_unix.go packages which does not return\n\t// user shell: https://golang.org/src/os/user/lookup_unix.go\n\tvar pwd C.struct_passwd\n\tvar result *C.struct_passwd\n\n\tbufSize := C.sysconf(C._SC_GETPW_R_SIZE_MAX)\n\tif bufSize == -1 {\n\t\tbufSize = 1024\n\t}\n\tif bufSize <= 0 || bufSize > 1<<20 {\n\t\treturn \"\", trace.BadParameter(\"lookupPosixShell: unreasonable _SC_GETPW_R_SIZE_MAX of %d\", bufSize)\n\t}\n\tbuf := C.malloc(C.size_t(bufSize))\n\tdefer C.free(buf)\n\tvar rv C.int\n\tnameC := C.CString(username)\n\tdefer C.free(unsafe.Pointer(nameC))\n\trv = C.mygetpwnam_r(nameC,\n\t\t&pwd,\n\t\t(*C.char)(buf),\n\t\tC.size_t(bufSize),\n\t\t&result)\n\tif rv != 0 || result == nil {\n\t\tlog.Errorf(\"lookupPosixShell: lookup username %s: %s\", username, syscall.Errno(rv))\n\t\treturn \"\", trace.BadParameter(\"cannot determine shell for %s\", username)\n\t}\n\n\t// If no shell was found, return trace.NotFound to allow the caller to set\n\t// the default shell.\n\tshellCmd := strings.TrimSpace(C.GoString(pwd.pw_shell))\n\tif len(shellCmd) == 0 {\n\t\treturn \"\", trace.NotFound(\"no shell specified for %v\", username)\n\t}\n\n\treturn shellCmd, nil\n}", "label": 5}
{"code": "function Policy(overrides) {\n  if (!(this instanceof Policy))\n    return new Policy(overrides);\n\n  u.defaults(this, overrides, {\n    /**\n     * support subjects in link names with the following characteristics:\n     * receiver: \"amq.topic/news\", means a filter on the ReceiverLink will be made\n     *           for messages send with a subject \"news\"\n     *\n     * sender: \"amq.topic/news\", will automatically set \"news\" as the subject for\n     *         messages sent on this link, unless the user explicitly overrides\n     *         the subject.\n     *\n     * @name Policy#defaultSubjects\n     * @property {boolean}\n     */\n    defaultSubjects: true,\n\n    /**\n     * Options related to the reconnect behavior of the client. If this value is `null` reconnect\n     * is effectively disabled\n     *\n     * @name Policy#reconnect\n     * @type {Object|null}\n     * @property {number|null} [retries] How many times to attempt reconnection\n     * @property {string} [strategy='fibonacci'] The algorithm used for backoff. Can be `fibonacci` or `exponential`\n     * @property {boolean} [forever] Whether or not to attempt reconnection forever\n     */\n    reconnect: {\n      retries: 10,\n      strategy: 'fibonacci', // || 'exponential'\n      forever: true\n    },\n\n    /**\n     * @name Policy#connect\n     * @type {object}\n     * @property {object} options Options passed into the open performative on initial connection\n     * @property {string|function} options.containerId The id of the source container\n     * @property {string} options.hostname The name of the target host\n     * @property {number} options.maxFrameSize The largest frame size that the sending peer is able to accept on this connection\n     * @property {number} options.channelMax The channel-max value is the highest channel number that can be used on the connection\n     * @property {number} options.idleTimeout The idle timeout required by the sender\n     * @property {array<string>|null} options.outgoingLocales A list of the locales that the peer supports for sending informational text\n     * @property {array<string>|null} options.incomingLocales A list of locales that the sending peer permits for incoming informational text\n     * @property {array<string>|null} options.offeredCapabilities A list of extension capabilities the peer may use if the sender offers them\n     * @property {array|null} options.desiredCapabilities The desired-capability list defines which extension capabilities the sender may use if the receiver offers them\n     * @property {object|null} options.properties The properties map contains a set of fields intended to indicate information about the connection and its container\n     * @property {object} sslOptions Options used to initiate a TLS/SSL connection, with the exception of the following options all options in this object are passed directly to node's [tls.connect](https://nodejs.org/api/tls.html#tls_tls_connect_options_callback) method.\n     * @property {string|null} sslOptions.keyFile Path to the file containing the private key for the client\n     * @property {string|null} sslOptions.certFile Path to the file containing the certificate key for the client\n     * @property {string|null} sslOptions.caFile Path to the file containing the trusted cert for the client\n     * @property {boolean} sslOptions.rejectUnauthorized\n     * @property {string|null} saslMechanism Allows the sasl mechanism to be overriden by policy\n     */\n    connect: {\n      options: {\n        containerId: containerName(),\n        hostname: 'localhost',\n        maxFrameSize: constants.defaultMaxFrameSize,\n        channelMax: constants.defaultChannelMax,\n        idleTimeout: constants.defaultIdleTimeout,\n        outgoingLocales: constants.defaultOutgoingLocales,\n        incomingLocales: constants.defaultIncomingLocales,\n        offeredCapabilities: null,\n        desiredCapabilities: null,\n        properties: {},\n      },\n      sslOptions: {\n        keyFile: null,\n        certFile: null,\n        caFile: null,\n        rejectUnauthorized: false\n      },\n      saslMechanism: null\n    },\n\n    /**\n     * @name Policy#session\n     * @type {object}\n     * @property {object} options Options passed into the `begin` performative on session start\n     * @property {number} options.nextOutgoingId The transfer-id to assign to the next transfer frame\n     * @property {number} options.incomingWindow The maximum number of incoming transfer frames that the endpoint can currently receive\n     * @property {number} options.outgoingWindow The maximum number of outgoing transfer frames that the endpoint can currently send\n     * @property {function} window A function used to calculate how/when the flow control window should change\n     * @property {number} windowQuantum Quantum used in predefined window policies\n     * @property {boolean} enableSessionFlowControl Whether or not session flow control should be performed at all\n     * @property {object|null} reestablish=null Whether the session should attempt to reestablish when ended by the broker\n     */\n    session: {\n      options: {\n        nextOutgoingId: constants.session.defaultOutgoingId,\n        incomingWindow: constants.session.defaultIncomingWindow,\n        outgoingWindow: constants.session.defaultOutgoingWindow\n      },\n\n      window: putils.WindowPolicies.RefreshAtHalf,\n      windowQuantum: constants.session.defaultIncomingWindow,\n      enableSessionFlowControl: true,\n      reestablish: null\n    },\n\n    /**\n     * @name Policy#senderLink\n     * @type {object}\n     * @property {object} attach Options passed into the `attach` performative on link attachment\n     * @property {string|function} attach.name This name uniquely identifies the link from the container of the source to the container of the target node\n     * @property {string|boolean} attach.role The role being played by the peer\n     * @property {string|number} attach.sndSettleMode The delivery settlement policy for the sender\n     * @property {number} attach.maxMessageSize The maximum message size supported by the link endpoint\n     * @property {number} attach.initialDeliveryCount This must not be null if role is sender, and it is ignored if the role is receiver.\n     * @property {string} callback Determines when a send should call its callback ('settle', 'sent', 'none')\n     * @property {function|null} encoder=null The optional encoder used for all outgoing sends\n     * @property {boolean|null} reattach=null Whether the link should attempt reattach on detach\n     */\n    senderLink: {\n      attach: {\n        name: linkName('sender'),\n        role: constants.linkRole.sender,\n        sndSettleMode: constants.senderSettleMode.mixed,\n        maxMessageSize: 0,\n        initialDeliveryCount: 1\n      },\n\n      callback: putils.SenderCallbackPolicies.OnSettle,\n      encoder: null,\n      reattach: null\n    },\n\n    /**\n     * @name Policy#receiverLink\n     * @type {object}\n     * @property {object} attach Options passed into the `attach` performative on link attachment\n     * @property {string|function} attach.name This name uniquely identifies the link from the container of the source to the container of the target node\n     * @property {boolean} attach.role The role being played by the peer\n     * @property {number|string} attach.rcvSettleMode The delivery settlement policy for the receiver\n     * @property {number} attach.maxMessageSize The maximum message size supported by the link endpoint\n     * @property {number} attach.initialDeliveryCount This must not be null if role is sender, and it is ignored if the role is receiver.\n     * @property {function} credit A function that determines when (if ever) to refresh the receiver link's credit\n     * @property {number} creditQuantum Quantum used in pre-defined credit policy functions\n     * @property {function|null} decoder=null The optional decoder used for all incoming data\n     * @property {boolean|null} reattach=null Whether the link should attempt reattach on detach\n     */\n    receiverLink: {\n      attach: {\n        name: linkName('receiver'),\n        role: constants.linkRole.receiver,\n        rcvSettleMode: constants.receiverSettleMode.autoSettle,\n        maxMessageSize: 10000, // Arbitrary choice\n        initialDeliveryCount: 1\n      },\n      credit: putils.CreditPolicies.RefreshAtHalf,\n      creditQuantum: 100,\n      decoder: null,\n      reattach: null\n    },\n  });\n\n  putils.fixDeprecatedLinkOptions(this.senderLink);\n  putils.fixDeprecatedLinkOptions(this.receiverLink);\n  return this;\n}", "label": 3}
{"code": "private function setSocketOptions($socket, ParametersInterface $parameters)\n    {\n        if ($parameters->scheme !== 'unix') {\n            if (!socket_set_option($socket, SOL_TCP, TCP_NODELAY, 1)) {\n                $this->emitSocketError();\n            }\n\n            if (!socket_set_option($socket, SOL_SOCKET, SO_REUSEADDR, 1)) {\n                $this->emitSocketError();\n            }\n        }\n\n        if (isset($parameters->read_write_timeout)) {\n            $rwtimeout = (float) $parameters->read_write_timeout;\n            $timeoutSec = floor($rwtimeout);\n            $timeoutUsec = ($rwtimeout - $timeoutSec) * 1000000;\n\n            $timeout = array(\n                'sec' => $timeoutSec,\n                'usec' => $timeoutUsec,\n            );\n\n            if (!socket_set_option($socket, SOL_SOCKET, SO_SNDTIMEO, $timeout)) {\n                $this->emitSocketError();\n            }\n\n            if (!socket_set_option($socket, SOL_SOCKET, SO_RCVTIMEO, $timeout)) {\n                $this->emitSocketError();\n            }\n        }\n    }", "label": 2}
{"code": "func NewProvisionToken(token string, roles teleport.Roles, expires time.Time) (ProvisionToken, error) {\n\tt := &ProvisionTokenV2{\n\t\tKind:    KindToken,\n\t\tVersion: V2,\n\t\tMetadata: Metadata{\n\t\t\tName:      token,\n\t\t\tExpires:   &expires,\n\t\t\tNamespace: defaults.Namespace,\n\t\t},\n\t\tSpec: ProvisionTokenSpecV2{\n\t\t\tRoles: roles,\n\t\t},\n\t}\n\tif err := t.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn t, nil\n}", "label": 5}
{"code": "def variant_indices(self):\n        \"\"\"\n        When we combine prefix + alt + suffix into a single string,\n        what are is base-0 index interval which gets us back the alt\n        sequence? First returned index is inclusive, the second is exclusive.\n        \"\"\"\n        variant_start_index = len(self.prefix)\n        variant_len = len(self.alt)\n        variant_end_index = variant_start_index + variant_len\n        return variant_start_index, variant_end_index", "label": 1}
{"code": "public function dir_rewinddir()\n    {\n        try {\n            $this->directoryIterator = $this->bucket->objects([\n                'prefix' => $this->file,\n                'fields' => 'items/name,nextPageToken'\n            ]);\n        } catch (ServiceException $e) {\n            return false;\n        }\n        return true;\n    }", "label": 2}
{"code": "function render(engine, str, locals, engineOptions) {\n  try {\n    var output = engine.render(engine.engine, str, locals, engineOptions)\n  } catch(e) {\n    throw new Error(\n      NAME + ': there was a problem rendering the template:\\n' + e)\n  }\n  return output\n}", "label": 3}
{"code": "protected function sendRequestFileUpload($b64hash, $type, $size, $filepath, $to, $caption = '')\n    {\n        $id = $this->createIqId();\n\n        if (!is_array($to)) {\n            $to = $this->getJID($to);\n        }\n\n        $mediaNode = new ProtocolNode('media', [\n            'hash'  => $b64hash,\n            'type'  => $type,\n            'size'  => $size,\n        ], null, null);\n\n        $node = new ProtocolNode('iq', [\n            'id'    => $id,\n            'to'    => Constants::WHATSAPP_SERVER,\n            'type'  => 'set',\n            'xmlns' => 'w:m',\n        ], [$mediaNode], null);\n\n        //add to queue\n        $messageId = $this->createMsgId();\n        $this->mediaQueue[$id] = [\n            'messageNode' => $node,\n            'filePath'    => $filepath,\n            'to'          => $to,\n            'message_id'  => $messageId,\n            'caption'     => $caption,\n        ];\n\n        $this->sendNode($node);\n        $this->waitForServer($id);\n\n        // Return message ID. Make pull request for this.\n        return $messageId;\n    }", "label": 2}
{"code": "public function createSink($name, $destination, array $options = [])\n    {\n        $response =  $this->connection->createSink($options + [\n            'parent' => $this->formattedProjectName,\n            'name' => $name,\n            'destination' => $destination,\n            'outputVersionFormat' => 'VERSION_FORMAT_UNSPECIFIED'\n        ]);\n\n        return new Sink($this->connection, $name, $this->projectId, $response);\n    }", "label": 2}
{"code": "def synchronize updater\n      raise 'Invalid synchronization' unless updater.filename == filename\n      real_code = updater.write(@code)\n      if real_code == @code\n        @version = updater.version\n        return self\n      end\n      synced = Source.new(real_code, filename)\n      if synced.parsed?\n        synced.version = updater.version\n        return synced\n      end\n      incr_code = updater.repair(@repaired)\n      synced = Source.new(incr_code, filename)\n      synced.error_ranges.concat (error_ranges + updater.changes.map(&:range))\n      synced.code = real_code\n      synced.version = updater.version\n      synced\n    end", "label": 4}
{"code": "function(file, errorCount, warningCount) {\n        if (errorCount > 0 || warningCount > 0) {\n            var message = '';\n            if (errorCount > 0) {\n                message += colors.red(errorCount + ' lint ' + (errorCount === 1 ? 'error' : 'errors'));\n            }\n\n            if (warningCount > 0) {\n                if (errorCount > 0) {\n                    message += ' and ';\n                }\n                message += colors.yellow(warningCount + ' lint ' + (warningCount === 1 ? 'warning' : 'warnings'));\n            }\n            message += ' found in file ' + file.path;\n            log.notice(message);\n        } else {\n            log.info(colors.green(file.path + ' is lint free!'));\n        }\n    }", "label": 3}
{"code": "public function setProductSet($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Vision\\V1\\ProductSet::class);\n        $this->product_set = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function(database, models, remoteData)\n  {\n    Class.props(this, {\n      database: database,\n      map: new Map()\n    });\n\n    this.map.values = this;\n    this.reset( models, remoteData );\n\n    return this;\n  }", "label": 3}
{"code": "func (s Style) Foreground(c Color) Style {\n\tif c == ColorDefault {\n\t\treturn (s &^ (0x1ffffff00000000 | styleFgSet))\n\t}\n\treturn (s &^ Style(0x1ffffff00000000)) |\n\t\t((Style(c) & 0x1ffffff) << 32) | styleFgSet\n}", "label": 5}
{"code": "function _arrEquals(a, b) {\n    return a.length == b.length &&\n        a.every((el, i) => _equals(el, b[i]));\n}", "label": 3}
{"code": "def reflect(self, data, width):\n        \"\"\"\n        reflect a data word, i.e. reverts the bit order.\n        \"\"\"\n        x = data & 0x01\n        for i in range(width - 1):\n            data >>= 1\n            x = (x << 1) | (data & 0x01)\n        return x", "label": 1}
{"code": "private function nextToken(&$tokens, $context)\n    {\n        while (true) {\n            $token = next($tokens);\n            if ($token[0] === T_WHITESPACE) {\n                continue;\n            }\n            if ($token[0] === T_COMMENT) {\n                $pos = strpos($token[1], '@OA\\\\');\n                if ($pos) {\n                    $line = $context->line ? $context->line + $token[2] : $token[2];\n                    $commentContext = new Context(['line' => $line], $context);\n                    Logger::notice('Annotations are only parsed inside `/**` DocBlocks, skipping ' . $commentContext);\n                }\n                continue;\n            }\n\n            return $token;\n        }\n    }", "label": 2}
{"code": "def get_config(self, bot_label, config_name=None, require_ready=True):\n        \"\"\"\n        Return the config matching the given bot_label and config_name.\n        config_name is case-insensitive.\n        Raise LookupError if no bot exists with this label, or no config\n        exists with this name in the bot. Raise ValueError if called with a\n        single argument that doesn't contain exactly one dot.\n        \"\"\"\n        if require_ready:\n            self.check_configs_ready()\n        else:\n            self.check_bots_ready()\n\n        if config_name is None:\n            config_name = defaults.BOT_CONFIG\n\n        bot = self.get_bot(bot_label)\n\n        if not require_ready and bot.configs is None:\n            bot.import_configs()\n\n        return bot.get_config(config_name, require_ready=require_ready)", "label": 1}
{"code": "def lock_machine(uuid)\n      lock_path = @data_dir.join(\"#{uuid}.lock\")\n      lock_file = lock_path.open(\"w+\")\n      if lock_file.flock(File::LOCK_EX | File::LOCK_NB) === false\n        lock_file.close\n        lock_file = nil\n      end\n\n      lock_file\n    end", "label": 4}
{"code": "func RelAppPath(appName types.ACName) string {\n\treturn filepath.Join(stage2Dir, appName.String())\n}", "label": 5}
{"code": "public function setSource($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Vision\\V1\\ImageSource::class);\n        $this->source = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function Perf (stats, name, filter, rename) {\n  this.stats = stats\n  this.name = name\n  this.filter = filter || function () { return true }\n  this.rename = rename || function (name) { return name }\n}", "label": 3}
{"code": "def handle_derived_specific_occurrences\n      return unless @definition == 'derived'\n\n      # remove \"_source\" from source data critera. It gets added in in SpecificOccurrenceAndSource but\n      # when it gets added we have not yet determined the definition of the data criteria so we cannot\n      # skip adding it.  Determining the definition before SpecificOccurrenceAndSource processes doesn't\n      # work because we need to know if it is a specific occurrence to be able to figure out the definition\n      @source_data_criteria = @source_data_criteria.gsub(\"_source\",'') if @source_data_criteria\n\n      # Adds a child if none exists (specifically the source criteria)\n      @children_criteria << @source_data_criteria if @children_criteria.empty?\n      return if @children_criteria.length != 1 ||\n                (@source_data_criteria.present? && @children_criteria.first != @source_data_criteria)\n      # if child.first is nil, it will be caught in the second statement\n      reference_criteria = @data_criteria_references[@children_criteria.first]\n      return if reference_criteria.nil?\n      @is_derived_specific_occurrence_variable = true # easier to track than all testing all features of these cases\n      @subset_operators ||= reference_criteria.subset_operators\n      @derivation_operator ||= reference_criteria.derivation_operator\n      @description = reference_criteria.description\n      @variable = reference_criteria.variable\n    end", "label": 4}
{"code": "def TaxonomicAmendmentStore(repos_dict=None,\n                            repos_par=None,\n                            with_caching=True,\n                            assumed_doc_version=None,\n                            git_ssh=None,\n                            pkey=None,\n                            git_action_class=TaxonomicAmendmentsGitAction,\n                            mirror_info=None,\n                            infrastructure_commit_author='OpenTree API <api@opentreeoflife.org>'):\n    \"\"\"Factory function for a _TaxonomicAmendmentStore object.\n\n    A wrapper around the _TaxonomicAmendmentStore class instantiation for\n    the most common use case: a singleton _TaxonomicAmendmentStore.\n    If you need distinct _TaxonomicAmendmentStore objects, you'll need to\n    call that class directly.\n    \"\"\"\n    global _THE_TAXONOMIC_AMENDMENT_STORE\n    if _THE_TAXONOMIC_AMENDMENT_STORE is None:\n        _THE_TAXONOMIC_AMENDMENT_STORE = _TaxonomicAmendmentStore(repos_dict=repos_dict,\n                                                                  repos_par=repos_par,\n                                                                  with_caching=with_caching,\n                                                                  assumed_doc_version=assumed_doc_version,\n                                                                  git_ssh=git_ssh,\n                                                                  pkey=pkey,\n                                                                  git_action_class=git_action_class,\n                                                                  mirror_info=mirror_info,\n                                                                  infrastructure_commit_author=infrastructure_commit_author)\n    return _THE_TAXONOMIC_AMENDMENT_STORE", "label": 1}
{"code": "def restore_cherry_pick_state\n      if @cherry_head\n        File.open(File.expand_path('CHERRY_PICK_HEAD',\n                                   Overcommit::Utils.git_dir), 'w') do |f|\n          f.write(@cherry_head)\n        end\n        @cherry_head = nil\n      end\n    end", "label": 4}
{"code": "def _init_boto3_clients(self, profile, region):\n        \"\"\"\n        The utililty requires boto3 clients to CloudFormation.\n\n        Args:\n            None\n\n        Returns:\n            Good or Bad; True or False\n        \"\"\"\n        try:\n            session = None\n            if profile and region:\n                session = boto3.session.Session(profile_name=profile, region_name=region)\n            elif profile:\n                session = boto3.session.Session(profile_name=profile)\n            elif region:\n                session = boto3.session.Session(region_name=region)\n            else:\n                session = boto3.session.Session()\n\n            self._cloud_formation = session.client('cloudformation')\n            return True\n        except Exception as wtf:\n            logging.error(wtf, exc_info=True)\n            return False", "label": 1}
{"code": "func writeMethodSelection(conn net.Conn) error {\n\tmessage := []byte{socks5Version, socks5AuthNotRequired}\n\n\tn, err := conn.Write(message)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tif n != len(message) {\n\t\treturn trace.BadParameter(\"wrote: %v wanted to write: %v\", n, len(message))\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "function getInputValue() {\n      var input = _this.getInput();\n\n      if (!input) {\n        return null;\n      }\n\n      switch (innerParams.input) {\n        case 'checkbox':\n          return input.checked ? 1 : 0;\n\n        case 'radio':\n          return input.checked ? input.value : null;\n\n        case 'file':\n          return input.files.length ? input.files[0] : null;\n\n        default:\n          return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n      }\n    }", "label": 3}
{"code": "func (f *Fpdf) EndLayer() {\n\tif f.layer.currentLayer >= 0 {\n\t\tf.out(\"EMC\")\n\t\tf.layer.currentLayer = -1\n\t}\n}", "label": 5}
{"code": "def policy(name)\n      json = client.get(\"/v1/sys/policy/#{encode_path(name)}\")\n      return Policy.decode(json)\n    rescue HTTPError => e\n      return nil if e.code == 404\n      raise\n    end", "label": 4}
{"code": "def resolve_path(target, start=os.path.curdir):\n\tr\"\"\"\n\tFind a path from start to target where target is relative to start.\n\n\t>>> tmp = str(getfixture('tmpdir_as_cwd'))\n\n\t>>> findpath('d:\\\\')\n\t'd:\\\\'\n\n\t>>> findpath('d:\\\\', tmp)\n\t'd:\\\\'\n\n\t>>> findpath('\\\\bar', 'd:\\\\')\n\t'd:\\\\bar'\n\n\t>>> findpath('\\\\bar', 'd:\\\\foo') # fails with '\\\\bar'\n\t'd:\\\\bar'\n\n\t>>> findpath('bar', 'd:\\\\foo')\n\t'd:\\\\foo\\\\bar'\n\n\t>>> findpath('\\\\baz', 'd:\\\\foo\\\\bar') # fails with '\\\\baz'\n\t'd:\\\\baz'\n\n\t>>> os.path.abspath(findpath('\\\\bar')).lower()\n\t'c:\\\\bar'\n\n\t>>> os.path.abspath(findpath('bar'))\n\t'...\\\\bar'\n\n\t>>> findpath('..', 'd:\\\\foo\\\\bar')\n\t'd:\\\\foo'\n\n\tThe parent of the root directory is the root directory.\n\t>>> findpath('..', 'd:\\\\')\n\t'd:\\\\'\n\t\"\"\"\n\treturn os.path.normpath(join(start, target))", "label": 1}
{"code": "function (defer, xhr) {\n                var errorType = xhr.type || xhr.status;\n                var errorMessage = xhr.responseText || xhr.message || xhr.statusText;\n                defer.reject(new ApiError(errorType, errorMessage));\n            }", "label": 3}
{"code": "public static function decryptRefundContents($contents): string\n    {\n        return openssl_decrypt(\n            base64_decode($contents),\n            'AES-256-ECB',\n            md5(self::$instance->key),\n            OPENSSL_RAW_DATA\n        );\n    }", "label": 2}
{"code": "func SplitHostPort(hostname string) (string, string, error) {\n\thost, port, err := net.SplitHostPort(hostname)\n\tif err != nil {\n\t\treturn \"\", \"\", trace.Wrap(err)\n\t}\n\tif host == \"\" {\n\t\treturn \"\", \"\", trace.BadParameter(\"empty hostname\")\n\t}\n\treturn host, port, nil\n}", "label": 5}
{"code": "func (s *Server) Open(p *Packet) (interface{}, error) {\n\treq := new(RequestOpen)\n\terr := UnmarshalBinary(p.Payload, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession, err := s.getSession(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tname := req.FileName.Path()\n\tmode := req.OpenMode\n\n\tif mode != OpenModeReadOnly {\n\t\treturn nil, &Status{\n\t\t\tErr:  fmt.Errorf(\"open mode(%d) not supported for file %q\", mode, name),\n\t\t\tCode: StatusAccessDenied,\n\t\t}\n\t}\n\n\tfile, err := s.OpenFile(name, mode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres := &ReplyOpen{\n\t\tHandle: s.newHandle(),\n\t}\n\n\tsession.mu.Lock()\n\tsession.files[res.Handle] = file\n\tsession.mu.Unlock()\n\n\treturn res, nil\n}", "label": 5}
{"code": "protected function getReadOnlyOperations()\n    {\n        return array(\n            'EXISTS' => true,\n            'TYPE' => true,\n            'KEYS' => true,\n            'SCAN' => true,\n            'RANDOMKEY' => true,\n            'TTL' => true,\n            'GET' => true,\n            'MGET' => true,\n            'SUBSTR' => true,\n            'STRLEN' => true,\n            'GETRANGE' => true,\n            'GETBIT' => true,\n            'LLEN' => true,\n            'LRANGE' => true,\n            'LINDEX' => true,\n            'SCARD' => true,\n            'SISMEMBER' => true,\n            'SINTER' => true,\n            'SUNION' => true,\n            'SDIFF' => true,\n            'SMEMBERS' => true,\n            'SSCAN' => true,\n            'SRANDMEMBER' => true,\n            'ZRANGE' => true,\n            'ZREVRANGE' => true,\n            'ZRANGEBYSCORE' => true,\n            'ZREVRANGEBYSCORE' => true,\n            'ZCARD' => true,\n            'ZSCORE' => true,\n            'ZCOUNT' => true,\n            'ZRANK' => true,\n            'ZREVRANK' => true,\n            'ZSCAN' => true,\n            'ZLEXCOUNT' => true,\n            'ZRANGEBYLEX' => true,\n            'ZREVRANGEBYLEX' => true,\n            'HGET' => true,\n            'HMGET' => true,\n            'HEXISTS' => true,\n            'HLEN' => true,\n            'HKEYS' => true,\n            'HVALS' => true,\n            'HGETALL' => true,\n            'HSCAN' => true,\n            'HSTRLEN' => true,\n            'PING' => true,\n            'AUTH' => true,\n            'SELECT' => true,\n            'ECHO' => true,\n            'QUIT' => true,\n            'OBJECT' => true,\n            'BITCOUNT' => true,\n            'BITPOS' => true,\n            'TIME' => true,\n            'PFCOUNT' => true,\n            'SORT' => array($this, 'isSortReadOnly'),\n            'BITFIELD' => array($this, 'isBitfieldReadOnly'),\n            'GEOHASH' => true,\n            'GEOPOS' => true,\n            'GEODIST' => true,\n            'GEORADIUS' => array($this, 'isGeoradiusReadOnly'),\n            'GEORADIUSBYMEMBER' => array($this, 'isGeoradiusReadOnly'),\n        );\n    }", "label": 2}
{"code": "def match_value_to_text(self, text):\n        \"\"\"\n        this is going to be the tricky bit - probably not possible\n        to get the 'exact' rating for a value. Will need to do sentiment\n        analysis of the text to see how it matches the rating. Even that\n        sounds like it wont work - maybe a ML algorithm would do it, but\n        that requires a large body of text already matched to values - and\n        values aren't even defined as far as I have found.\n\n        UPDATE - this could work if we assume values can be single words,\n        eg tax=0.3, freedom=0.7, healthcare=0.3, welfare=0.3 etc\n        \"\"\"\n\n        if self.nme in text:\n\n            res = 0.8\n        else:\n            res = 0.2\n\n        return self.nme + ' = ' + str(res) + ' match against ' + text", "label": 1}
{"code": "def update_cache(from_currency, to_currency):\n\t\"\"\" update from_currency to_currency pair in cache if\n\tlast update for that pair is over 30 minutes ago by request API info \"\"\"\n\tif check_update(from_currency, to_currency) is True:\n\t\tccache[from_currency][to_currency]['value'] = convert_using_api(from_currency, to_currency)\n\t\tccache[from_currency][to_currency]['last_update'] = time.time()\n\t\tcache.write(ccache)", "label": 1}
{"code": "def match?(attribute, type = nil, **options)\n      if @attribute != attribute || (type && @type != type)\n        return false\n      end\n\n      options.each do |key, value|\n        if @options[key] != value\n          return false\n        end\n      end\n\n      true\n    end", "label": 4}
{"code": "func (h *Handler) getWebConfig(w http.ResponseWriter, r *http.Request, p httprouter.Params) (interface{}, error) {\n\thttplib.SetWebConfigHeaders(w.Header())\n\n\tauthProviders := []ui.WebConfigAuthProvider{}\n\tsecondFactor := teleport.OFF\n\n\t// get all OIDC connectors\n\toidcConnectors, err := h.cfg.ProxyClient.GetOIDCConnectors(false)\n\tif err != nil {\n\t\tlog.Errorf(\"Cannot retrieve OIDC connectors: %v.\", err)\n\t}\n\tfor _, item := range oidcConnectors {\n\t\tauthProviders = append(authProviders, ui.WebConfigAuthProvider{\n\t\t\tType:        ui.WebConfigAuthProviderOIDCType,\n\t\t\tWebAPIURL:   ui.WebConfigAuthProviderOIDCURL,\n\t\t\tName:        item.GetName(),\n\t\t\tDisplayName: item.GetDisplay(),\n\t\t})\n\t}\n\n\t// get all SAML connectors\n\tsamlConnectors, err := h.cfg.ProxyClient.GetSAMLConnectors(false)\n\tif err != nil {\n\t\tlog.Errorf(\"Cannot retrieve SAML connectors: %v.\", err)\n\t}\n\tfor _, item := range samlConnectors {\n\t\tauthProviders = append(authProviders, ui.WebConfigAuthProvider{\n\t\t\tType:        ui.WebConfigAuthProviderSAMLType,\n\t\t\tWebAPIURL:   ui.WebConfigAuthProviderSAMLURL,\n\t\t\tName:        item.GetName(),\n\t\t\tDisplayName: item.GetDisplay(),\n\t\t})\n\t}\n\n\t// get all Github connectors\n\tgithubConnectors, err := h.cfg.ProxyClient.GetGithubConnectors(false)\n\tif err != nil {\n\t\tlog.Errorf(\"Cannot retrieve Github connectors: %v.\", err)\n\t}\n\tfor _, item := range githubConnectors {\n\t\tauthProviders = append(authProviders, ui.WebConfigAuthProvider{\n\t\t\tType:        ui.WebConfigAuthProviderGitHubType,\n\t\t\tWebAPIURL:   ui.WebConfigAuthProviderGitHubURL,\n\t\t\tName:        item.GetName(),\n\t\t\tDisplayName: item.GetDisplay(),\n\t\t})\n\t}\n\n\t// get second factor type\n\tcap, err := h.cfg.ProxyClient.GetAuthPreference()\n\tif err != nil {\n\t\tlog.Errorf(\"Cannot retrieve AuthPreferences: %v.\", err)\n\t} else {\n\t\tsecondFactor = cap.GetSecondFactor()\n\t}\n\n\t// disable joining sessions if proxy session recording is enabled\n\tvar canJoinSessions = true\n\tclsCfg, err := h.cfg.ProxyClient.GetClusterConfig()\n\tif err != nil {\n\t\tlog.Errorf(\"Cannot retrieve ClusterConfig: %v.\", err)\n\t} else {\n\t\tcanJoinSessions = clsCfg.GetSessionRecording() != services.RecordAtProxy\n\t}\n\n\tauthSettings := ui.WebConfigAuthSettings{\n\t\tProviders:    authProviders,\n\t\tSecondFactor: secondFactor,\n\t}\n\n\twebCfg := ui.WebConfig{\n\t\tAuth:            authSettings,\n\t\tCanJoinSessions: canJoinSessions,\n\t}\n\n\tout, err := json.Marshal(webCfg)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tfmt.Fprintf(w, \"var GRV_CONFIG = %v;\", string(out))\n\treturn nil, nil\n}", "label": 5}
{"code": "def custom_image(self, user):\n        \"\"\"Returns the path to the custom image set for this game, or None if\n        no image is set\"\"\"\n        for ext in self.valid_custom_image_extensions():\n            image_location = self._custom_image_path(user, ext)\n            if os.path.isfile(image_location):\n                return image_location\n        return None", "label": 1}
{"code": "func (d *driver) CreateNetwork(id string, option map[string]interface{}, nInfo driverapi.NetworkInfo, ipV4Data, ipV6Data []driverapi.IPAMData) error {\n\tif len(ipV4Data) == 0 || ipV4Data[0].Pool.String() == \"0.0.0.0/0\" {\n\t\treturn types.BadRequestErrorf(\"ipv4 pool is empty\")\n\t}\n\t// Sanity checks\n\td.Lock()\n\tif _, ok := d.networks[id]; ok {\n\t\td.Unlock()\n\t\treturn types.ForbiddenErrorf(\"network %s exists\", id)\n\t}\n\td.Unlock()\n\n\t// Parse and validate the config. It should not be conflict with existing networks' config\n\tconfig, err := parseNetworkOptions(id, option)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = config.processIPAM(id, ipV4Data, ipV6Data); err != nil {\n\t\treturn err\n\t}\n\n\t// start the critical section, from this point onward we are dealing with the list of networks\n\t// so to be consistent we cannot allow that the list changes\n\td.configNetwork.Lock()\n\tdefer d.configNetwork.Unlock()\n\n\t// check network conflicts\n\tif err = d.checkConflict(config); err != nil {\n\t\tnerr, ok := err.(defaultBridgeNetworkConflict)\n\t\tif !ok {\n\t\t\treturn err\n\t\t}\n\t\t// Got a conflict with a stale default network, clean that up and continue\n\t\tlogrus.Warn(nerr)\n\t\td.deleteNetwork(nerr.ID)\n\t}\n\n\t// there is no conflict, now create the network\n\tif err = d.createNetwork(config); err != nil {\n\t\treturn err\n\t}\n\n\treturn d.storeUpdate(config)\n}", "label": 5}
{"code": "def run_rsem(job, rna_bam, univ_options, rsem_options):\n    \"\"\"\n    Run rsem on the input RNA bam.\n\n    ARGUMENTS\n    :param toil.fileStore.FileID rna_bam: fsID of a transcriptome bam generated by STAR\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict rsem_options: Options specific to rsem\n    :return: Dict of gene- and isoform-level expression calls\n             output_files:\n                 |- 'rsem.genes.results': fsID\n                 +- 'rsem.isoforms.results': fsID\n    :rtype: dict\n    \"\"\"\n    work_dir = os.getcwd()\n    input_files = {\n        'star_transcriptome.bam': rna_bam,\n        'rsem_index.tar.gz': rsem_options['index']}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n\n    input_files['rsem_index'] = untargz(input_files['rsem_index.tar.gz'], work_dir)\n    input_files = {key: docker_path(path) for key, path in input_files.items()}\n\n    parameters = ['--paired-end',\n                  '-p', str(rsem_options['n']),\n                  '--bam',\n                  input_files['star_transcriptome.bam'],\n                  '--no-bam-output',\n                  '/'.join([input_files['rsem_index'], univ_options['ref']]),\n                  'rsem']\n    docker_call(tool='rsem', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], tool_version=rsem_options['version'])\n    output_files = {}\n    for filename in ('rsem.genes.results', 'rsem.isoforms.results'):\n        output_files[filename] = job.fileStore.writeGlobalFile('/'.join([work_dir, filename]))\n        export_results(job, output_files[filename], '/'.join([work_dir, filename]), univ_options,\n                       subfolder='expression')\n    job.fileStore.logToMaster('Ran rsem on %s successfully' % univ_options['patient'])\n    return output_files", "label": 1}
{"code": "protected function getQueuedStatus($event)\n    {\n        if (isset($event->data['__laravel_notification_queued'])) {\n            return $event->data['__laravel_notification_queued'];\n        }\n\n        return $event->data['__telescope_queued'] ?? false;\n    }", "label": 2}
{"code": "public function scopeWhereSubjectModel(Builder $query, string $class)\n    {\n        $notificationTypes = array_filter(self::getSubjectModels(), function ($modelClass) use ($class) {\n            return $modelClass === $class or is_subclass_of($class, $modelClass);\n        });\n\n        $query->whereIn('type', array_keys($notificationTypes));\n    }", "label": 2}
{"code": "function diffVersions(callback) {\n        var prior = null;\n        _.each(versions, function(version) {\n          if (!prior) {\n            version.diff = [ { value: '[NEW]', added: true } ];\n          } else {\n            version.diff = apos.diffPages(prior, version);\n          }\n          prior = version;\n        });\n        versions.reverse();\n        return callback(null);\n      }", "label": 3}
{"code": "def write_json_char(ch)\n      # This table describes the handling for the first 0x30 characters\n      # 0 : escape using \"\\u00xx\" notation\n      # 1 : just output index\n      # <other> : escape using \"\\<other>\" notation\n      kJSONCharTable = [\n          # 0 1 2 3 4 5 6 7 8 9 A B C D E F\n          0, 0, 0, 0, 0, 0, 0, 0,'b','t','n', 0,'f','r', 0, 0, # 0\n          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, # 1\n          1, 1,'\"', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, # 2\n      ]\n\n      ch_value = ch[0]\n      if (ch_value.kind_of? String)\n        ch_value = ch.bytes.first\n      end\n      if (ch_value >= 0x30)\n        if (ch == @@kJSONBackslash) # Only special character >= 0x30 is '\\'\n          trans.write(@@kJSONBackslash)\n          trans.write(@@kJSONBackslash)\n        else\n          trans.write(ch)\n        end\n      else\n        outCh = kJSONCharTable[ch_value];\n        # Check if regular character, backslash escaped, or JSON escaped\n        if outCh.kind_of? String\n          trans.write(@@kJSONBackslash)\n          trans.write(outCh)\n        elsif outCh == 1\n          trans.write(ch)\n        else\n          write_json_escape_char(ch)\n        end\n      end\n    end", "label": 4}
{"code": "def as_python(self, name: str) -> str:\n        \"\"\" Return the python representation of the class represented by this object \"\"\"\n        if self._map_valuetype:\n            return self.map_as_python(name)\n        else:\n            return self.obj_as_python(name)", "label": 1}
{"code": "def get_file(self, fid):\n        \"\"\"Get file from WeedFS.\n\n        Returns file content. May be problematic for large files as content is\n        stored in memory.\n\n        Args:\n            **fid**: File identifier <volume_id>,<file_name_hash>\n\n        Returns:\n            Content of the file with provided fid or None if file doesn't\n            exist on the server\n\n        .. versionadded:: 0.3.1\n        \"\"\"\n        url = self.get_file_url(fid)\n        return self.conn.get_raw_data(url)", "label": 1}
{"code": "function(label, css, excludeDots) {\n\t\t\n\t\t\tif(typeof css == \"boolean\" || !css) {\n\t\t\t\texcludeDots = css;\n\t\t\t\tcss = label;\n\t\t\t}\n\n\t\t\tvar dots = [\n\t\t\t\t'<span class=\"'+this.factory.classes.dot+' top\"></span>',\n\t\t\t\t'<span class=\"'+this.factory.classes.dot+' bottom\"></span>'\n\t\t\t].join('');\n\n\t\t\tif(excludeDots) {\n\t\t\t\tdots = '';\t\n\t\t\t}\n\n\t\t\tlabel = this.factory.localize(label);\n\n\t\t\tvar html = [\n\t\t\t\t'<span class=\"'+this.factory.classes.divider+' '+(css ? css : '').toLowerCase()+'\">',\n\t\t\t\t\t'<span class=\"'+this.factory.classes.label+'\">'+(label ? label : '')+'</span>',\n\t\t\t\t\tdots,\n\t\t\t\t'</span>'\n\t\t\t];\t\n\t\t\t\n\t\t\treturn $(html.join(''));\n\t\t}", "label": 3}
{"code": "function validateDuplicateName(cb) {\n    var themeId = themeData._id;\n    var themeName = themeData.name;\n\n    if (!themeName) {\n      return cb(new Error(\"No theme name passed.\"));\n    }\n\n    var query = {};\n\n    //If there is a theme id, then the query to the theme model must exclude the current theme id that is being updated.\n    if (themeId) {\n      query.name = themeName;\n      //Excluding the themeId that is being updated.\n      query[\"_id\"] = {\"$nin\": [themeId]};\n    } else { //Just checking that the theme name exists as a theme is being created\n      query.name = themeName;\n    }\n\n    themeModel.count(query, function(err, count) {\n      if (err) {\n        return cb(err);\n      }\n\n      //If the number of found theme is > 0, then there is another theme with the same name. Do not save the theme.\n      if (count > 0) {\n        return cb(new Error(\"Theme with name \" + themeName + \" already exists.\"));\n      } else {//No duplicates, can proceed with saving the theme.\n        return cb();\n      }\n    });\n  }", "label": 3}
{"code": "func typeName(item mo.Reference) string {\n\treturn reflect.TypeOf(item).Elem().Name()\n}", "label": 5}
{"code": "private function handleSession(array $session)\n    {\n        if ($this->isSessionValid($session)) {\n            return $session;\n        }\n\n        $this->config['lock']->synchronize(function () use ($session) {\n            $item = $this->cacheItemPool->getItem($this->cacheKey);\n            $data = $item->get();\n            unset($data['inUse'][$session['name']]);\n            $this->cacheItemPool->save($item->set($data));\n        });\n    }", "label": 2}
{"code": "public function getJobFromId($identifier)\n    {\n        return array_key_exists($identifier, $this->identifierToId)\n            ? $this->jobs[$identifier]\n            : null;\n    }", "label": 2}
{"code": "func SetIndexHTMLHeaders(h http.Header) {\n\tSetNoCacheHeaders(h)\n\tSetSameOriginIFrame(h)\n\tSetNoSniff(h)\n\n\t// X-Frame-Options indicates that the page can only be displayed in iframe on the same origin as the page itself\n\th.Set(\"X-Frame-Options\", \"SAMEORIGIN\")\n\n\t// X-XSS-Protection is a feature of Internet Explorer, Chrome and Safari that stops pages\n\t// from loading when they detect reflected cross-site scripting (XSS) attacks.\n\th.Set(\"X-XSS-Protection\", \"1; mode=block\")\n\n\t// Once a supported browser receives this header that browser will prevent any communications from\n\t// being sent over HTTP to the specified domain and will instead send all communications over HTTPS.\n\t// It also prevents HTTPS click through prompts on browsers\n\th.Set(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\")\n\n\t// Prevent web browsers from using content sniffing to discover a file\u2019s MIME type\n\th.Set(\"X-Content-Type-Options\", \"nosniff\")\n\n\t// Set content policy flags\n\tvar cspValue = strings.Join([]string{\n\t\t\"script-src 'self'\",\n\t\t// 'unsafe-inline' needed for reactjs inline styles\n\t\t\"style-src 'self' 'unsafe-inline'\",\n\t\t\"object-src 'none'\",\n\t\t\"img-src 'self' data: blob:\",\n\t}, \";\")\n\n\th.Set(\"Content-Security-Policy\", cspValue)\n}", "label": 5}
{"code": "function IDLFilePath(path) {\n      var extension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.graphql';\n      return Symbol.for(\"Path \".concat(path, \" Extension \").concat(extension));\n    }", "label": 3}
{"code": "func (cb *CellBuffer) Fill(r rune, style Style) {\n\tfor i := range cb.cells {\n\t\tc := &cb.cells[i]\n\t\tc.currMain = r\n\t\tc.currComb = nil\n\t\tc.currStyle = style\n\t\tc.width = 1\n\t}\n}", "label": 5}
{"code": "func getEnvString(v string, def string) string {\n\tr := os.Getenv(v)\n\tif r == \"\" {\n\t\treturn def\n\t}\n\n\treturn r\n}", "label": 5}
{"code": "def get_identity(user):\n    \"\"\"Create an identity for a given user instance.\n\n    Primarily useful for testing.\n    \"\"\"\n    identity = Identity(user.id)\n\n    if hasattr(user, 'id'):\n        identity.provides.add(UserNeed(user.id))\n\n    for role in getattr(user, 'roles', []):\n        identity.provides.add(RoleNeed(role.name))\n\n    identity.user = user\n    return identity", "label": 1}
{"code": "protected function responseWithHeaders($response)\n    {\n        foreach ($this->getHeaders() as $key => $value) {\n            $response->headers->set($key, $value);\n        }\n\n        return $response;\n    }", "label": 2}
{"code": "def exciter(self, Xexc, Pexc, Vexc):\n        \"\"\" Exciter model.\n\n        Based on Exciter.m from MatDyn by Stijn Cole, developed at Katholieke\n        Universiteit Leuven. See U{http://www.esat.kuleuven.be/electa/teaching/\n        matdyn/} for more information.\n        \"\"\"\n        exciters = self.exciters\n\n        F = zeros(Xexc.shape)\n\n        typ1 = [e.generator._i for e in exciters if e.model ==CONST_EXCITATION]\n        typ2 = [e.generator._i for e in exciters if e.model == IEEE_DC1A]\n\n        # Exciter type 1: constant excitation\n        F[typ1, :] = 0.0\n\n        # Exciter type 2: IEEE DC1A\n        Efd = Xexc[typ2, 0]\n        Uf = Xexc[typ2, 1]\n        Ur = Xexc[typ2, 2]\n\n        Ka = Pexc[typ2, 0]\n        Ta = Pexc[typ2, 1]\n        Ke = Pexc[typ2, 2]\n        Te = Pexc[typ2, 3]\n        Kf = Pexc[typ2, 4]\n        Tf = Pexc[typ2, 5]\n        Aex = Pexc[typ2, 6]\n        Bex = Pexc[typ2, 7]\n        Ur_min = Pexc[typ2, 8]\n        Ur_max = Pexc[typ2, 9]\n        Uref = Pexc[typ2, 10]\n        Uref2 = Pexc[typ2, 11]\n\n        U = Vexc[typ2, 1]\n\n        Ux = Aex * exp(Bex * Efd)\n        dUr = 1 / Ta * (Ka * (Uref - U + Uref2 - Uf) - Ur)\n        dUf = 1 / Tf * (Kf / Te * (Ur - Ux - Ke * Efd) - Uf)\n\n        if sum(flatnonzero(Ur > Ur_max)) >= 1:\n            Ur2 = Ur_max\n        elif sum(flatnonzero(Ur < Ur_max)) >= 1:\n            Ur2 = Ur_min\n        else:\n            Ur2 = Ur\n\n        dEfd = 1 / Te * (Ur2 - Ux - Ke * Efd)\n        F[typ2, :] = c_[dEfd, dUf, dUr]\n\n        # Exciter type 3:\n\n        # Exciter type 4:\n\n        return F", "label": 1}
{"code": "public function detachCallback($channel)\n    {\n        $callbackName = $this->getPrefixKeys().$channel;\n\n        if (isset($this->callbacks[$callbackName])) {\n            unset($this->callbacks[$callbackName]);\n            $this->pubsub->unsubscribe($channel);\n        }\n    }", "label": 2}
{"code": "protected function batchFactory()\n    {\n        return new WriteBatch(\n            $this->connection,\n            $this->valueMapper,\n            $this->databaseFromName($this->name)\n        );\n    }", "label": 2}
{"code": "def get_stage(self, matrix_name, stage_name):\n        \"\"\"\n        Get Stage of a concrete matrix.\n\n        Attributes:\n            matrix_name (str): name of the matrix\n            stage_name (str): name of the stage.\n\n        Returns:\n            CollectorStage: when stage has been found or None.\n        \"\"\"\n        found_stage = None\n        if matrix_name in self.data:\n            result = Select(self.data[matrix_name]).where(\n                lambda entry: entry.stage == stage_name).build()\n            found_stage = result[0] if len(result) > 0 else None\n        return found_stage", "label": 1}
{"code": "public static base_response save(nitro_service client) throws Exception {\n\t\tnsconfig saveresource = new nsconfig();\n\t\treturn saveresource.perform_operation(client,\"save\");\n\t}", "label": 0}
{"code": "function getEffectiveDecoratorFirstArgumentType(node) {\n            // The first argument to a decorator is its `target`.\n            if (node.kind === 221 /* ClassDeclaration */) {\n                // For a class decorator, the `target` is the type of the class (e.g. the\n                // \"static\" or \"constructor\" side of the class)\n                var classSymbol = getSymbolOfNode(node);\n                return getTypeOfSymbol(classSymbol);\n            }\n            if (node.kind === 142 /* Parameter */) {\n                // For a parameter decorator, the `target` is the parent type of the\n                // parameter's containing method.\n                node = node.parent;\n                if (node.kind === 148 /* Constructor */) {\n                    var classSymbol = getSymbolOfNode(node);\n                    return getTypeOfSymbol(classSymbol);\n                }\n            }\n            if (node.kind === 145 /* PropertyDeclaration */ ||\n                node.kind === 147 /* MethodDeclaration */ ||\n                node.kind === 149 /* GetAccessor */ ||\n                node.kind === 150 /* SetAccessor */) {\n                // For a property or method decorator, the `target` is the\n                // \"static\"-side type of the parent of the member if the member is\n                // declared \"static\"; otherwise, it is the \"instance\"-side type of the\n                // parent of the member.\n                return getParentTypeOfClassElement(node);\n            }\n            ts.Debug.fail(\"Unsupported decorator target.\");\n            return unknownType;\n        }", "label": 3}
{"code": "def reads_overlapping_variants(variants, samfile, **kwargs):\n    \"\"\"\n    Generates sequence of tuples, each containing a variant paired with\n    a list of AlleleRead objects.\n\n    Parameters\n    ----------\n    variants : varcode.VariantCollection\n\n    samfile : pysam.AlignmentFile\n\n    use_duplicate_reads : bool\n        Should we use reads that have been marked as PCR duplicates\n\n    use_secondary_alignments : bool\n        Should we use reads at locations other than their best alignment\n\n    min_mapping_quality : int\n        Drop reads below this mapping quality\n    \"\"\"\n    chromosome_names = set(samfile.references)\n    for variant in variants:\n        # I imagine the conversation went like this:\n        # A: \"Hey, I have an awesome idea\"\n        # B: \"What's up?\"\n        # A: \"Let's make two nearly identical reference genomes\"\n        # B: \"But...that sounds like it might confuse people.\"\n        # A: \"Nah, it's cool, we'll give the chromosomes different prefixes!\"\n        # B: \"OK, sounds like a good idea.\"\n        if variant.contig in chromosome_names:\n            chromosome = variant.contig\n        elif \"chr\" + variant.contig in chromosome_names:\n            chromosome = \"chr\" + variant.contig\n        else:\n            logger.warn(\n                \"Chromosome '%s' from variant %s not in alignment file %s\",\n                chromosome,\n                variant,\n                samfile.filename)\n            yield variant, []\n            continue\n        allele_reads = reads_overlapping_variant(\n            samfile=samfile,\n            chromosome=chromosome,\n            variant=variant,\n            **kwargs)\n        yield variant, allele_reads", "label": 1}
{"code": "public function write_short($n)\n    {\n        if ($n < 0 || $n > 65535) {\n            throw new AMQPInvalidArgumentException('Short out of range: ' . $n);\n        }\n\n        $this->out .= pack('n', $n);\n\n        return $this;\n    }", "label": 2}
{"code": "def main():\n    \"\"\"\n    This is the main module for the script.  The script will accept a file, or a directory, and then\n    encrypt it with a provided key before pushing it to S3 into a specified bucket.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=main.__doc__, add_help=True)\n    parser.add_argument('-M', '--master_key', dest='master_key', help='Path  to the master key ' +\n                        'used for the encryption.  Data is transferred without encryption if this' +\n                        'is not provided.', type=str, required=False, default=None)\n    parser.add_argument('-B', '--bucket', dest='bucket', help='S3 bucket.', type=str, required=True)\n    parser.add_argument('-R', '--remote_dir', dest='remote_dir', help='Pseudo directory within ' +\n                        'the bucket to store the file(s).  NOTE: Folder structure below ' +\n                        'REMOTE_DIR will be retained.', type=str, required=False, default='')\n    parser.add_argument('data', help='File(s) or folder(s) to transfer to S3.', type=str, nargs='+')\n    params = parser.parse_args()\n    # Input handling\n    if params.master_key and not os.path.exists(params.master_key):\n        raise InputParameterError('The master key was not found at ' +\n                                  params.master_key)\n    #  If the user doesn't have ~/.boto , it doesn't even make sense to go ahead\n    if not os.path.exists(os.path.expanduser('~/.boto')):\n        raise RuntimeError('~/.boto not found')\n    # Ensure that the remote directory doesn't start with a /\n    if params.remote_dir.startswith('/'):\n        raise InputParameterError('The remote dir cannot start with a \\'/\\'')\n\n    # Process each of the input arguments.\n    for datum in params.data:\n        datum = os.path.abspath(datum)\n        if not os.path.exists(datum):\n            print('ERROR: %s could not be found.' % datum, file=sys.stderr)\n            continue\n        write_to_s3(datum, params.master_key, params.bucket, params.remote_dir)\n    return None", "label": 1}
{"code": "function(){\n\t\tvar portHeight=parseFloat($(\"#workarea\").css(\"height\"));\n\t\tvar portWidth=parseFloat($(\"#workarea\").css(\"width\"));\n\t\tvar portX=$(\"#workarea\").scrollLeft();\n\t\tvar portY=$(\"#workarea\").scrollTop();\n\t\tvar windowWidth=parseFloat($(\"#svgcanvas\").css(\"width\"));\n\t\tvar windowHeight=parseFloat($(\"#svgcanvas\").css(\"height\"));\n\t\tvar overviewWidth=$(\"#overviewMiniView\").attr(\"width\");\n\t\tvar overviewHeight=$(\"#overviewMiniView\").attr(\"height\");\n\t\t\n\t\tvar viewBoxX=portX/windowWidth*overviewWidth;\n\t\tvar viewBoxY=portY/windowHeight*overviewHeight;\n\t\tvar viewBoxWidth=portWidth/windowWidth*overviewWidth;\n\t\tvar viewBoxHeight=portHeight/windowHeight*overviewHeight;\n\t\t\n\t\t$(\"#overview_window_view_box\").css(\"min-width\",viewBoxWidth+\"px\");\n\t\t$(\"#overview_window_view_box\").css(\"min-height\",viewBoxHeight+\"px\");\n\t\t$(\"#overview_window_view_box\").css(\"top\",viewBoxY+\"px\");\n\t\t$(\"#overview_window_view_box\").css(\"left\",viewBoxX+\"px\");\n\t}", "label": 3}
{"code": "def with_haml_buffer(buffer)\n      @haml_buffer, old_buffer = buffer, @haml_buffer\n      old_buffer.active, old_was_active = false, old_buffer.active? if old_buffer\n      @haml_buffer.active, was_active = true, @haml_buffer.active?\n      yield\n    ensure\n      @haml_buffer.active = was_active\n      old_buffer.active = old_was_active if old_buffer\n      @haml_buffer = old_buffer\n    end", "label": 4}
{"code": "public function setTableLocation($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\TableLocation::class);\n        $this->table_location = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static sslservice_sslcertkey_binding[] get(nitro_service service, String servicename) throws Exception{\n\t\tsslservice_sslcertkey_binding obj = new sslservice_sslcertkey_binding();\n\t\tobj.set_servicename(servicename);\n\t\tsslservice_sslcertkey_binding response[] = (sslservice_sslcertkey_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def context(name = :public, &block)\n      name = name.to_sym\n      @contexts ||= {}\n\n      if block\n        context = ParticipatorySpaceContextManifest.new\n        context.instance_eval(&block)\n        @contexts[name] = context\n      end\n\n      @contexts.fetch(name)\n    end", "label": 4}
{"code": "public function is_command_disabled( $command ) {\n\t\t$path = implode( ' ', array_slice( \\WP_CLI\\Dispatcher\\get_path( $command ), 1 ) );\n\t\treturn in_array( $path, $this->config['disabled_commands'], true );\n\t}", "label": 2}
{"code": "def method(self, returns, **parameter_types):\n        \"\"\"Syntactic sugar for registering a method\n\n        Example:\n\n            >>> registry = Registry()\n            >>> @registry.method(returns=int, x=int, y=int)\n            ... def add(x, y):\n            ...     return x + y\n\n        :param returns: The method's return type\n        :type returns: type\n        :param parameter_types: The types of the method's parameters\n        :type parameter_types: dict[str, type]\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        @wrapt.decorator\n        def type_check_wrapper(method, instance, args, kwargs):\n            \"\"\"Wraps a method so that it is type-checked.\n\n            :param method: The method to wrap\n            :type method: (T) -> U\n            :return: The result of calling the method with the given parameters\n            :rtype: U\n            \"\"\"\n            if instance is not None:\n                raise Exception(\"Instance shouldn't be set.\")\n\n            parameter_names = inspect.getargspec(method).args  # pylint: disable=deprecated-method\n            defaults = inspect.getargspec(method).defaults  # pylint: disable=deprecated-method\n            parameters = self._collect_parameters(parameter_names, args, kwargs, defaults)\n\n            parameter_checker.check_types(parameters, parameter_types, self._strict_floats)\n\n            result = method(*args, **kwargs)\n            parameter_checker.check_return_type(result, returns, self._strict_floats)\n\n            return result\n\n        def register_method(method):\n            \"\"\"Registers a method with its fully qualified name.\n\n            :param method: The method to register\n            :type method: function\n            :return: The original method wrapped into a type-checker\n            :rtype: function\n            \"\"\"\n            parameter_names = inspect.getargspec(method).args  # pylint: disable=deprecated-method\n            parameter_checker.check_type_declaration(parameter_names, parameter_types)\n\n            wrapped_method = type_check_wrapper(method, None, None, None)\n            fully_qualified_name = \"{}.{}\".format(method.__module__, method.__name__)\n            self.register(fully_qualified_name, wrapped_method,\n                          MethodSignature.create(parameter_names, parameter_types, returns))\n            return wrapped_method\n\n        return register_method", "label": 1}
{"code": "def repeat(obj, times=None):\n    \"\"\"Make an iterator that returns object over and over again.\"\"\"\n    if times is None:\n\n        return AsyncIterWrapper(sync_itertools.repeat(obj))\n\n    return AsyncIterWrapper(sync_itertools.repeat(obj, times))", "label": 1}
{"code": "def flush_dns_cache\n      if @flush_command && !@flush_command.empty?\n        stdout, stderr, status = Open3.capture3(@flush_command)\n        if status == 0\n          @logger.debug(\"Flushed #{stdout.chomp} records from DNS cache\")\n        else\n          @logger.warn(\"Failed to flush DNS cache: #{stderr.chomp}\")\n        end\n      end\n    end", "label": 4}
{"code": "func (i *nwIface) Statistics() (*types.InterfaceStatistics, error) {\n\ti.Lock()\n\tn := i.ns\n\ti.Unlock()\n\n\tl, err := n.nlHandle.LinkByName(i.DstName())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve the statistics for %s in netns %s: %v\", i.DstName(), n.path, err)\n\t}\n\n\tstats := l.Attrs().Statistics\n\tif stats == nil {\n\t\treturn nil, fmt.Errorf(\"no statistics were returned\")\n\t}\n\n\treturn &types.InterfaceStatistics{\n\t\tRxBytes:   uint64(stats.RxBytes),\n\t\tTxBytes:   uint64(stats.TxBytes),\n\t\tRxPackets: uint64(stats.RxPackets),\n\t\tTxPackets: uint64(stats.TxPackets),\n\t\tRxDropped: uint64(stats.RxDropped),\n\t\tTxDropped: uint64(stats.TxDropped),\n\t}, nil\n}", "label": 5}
{"code": "def send_temporary_message(channel, content, timeout, tts = false, embed = nil)\n      Thread.new do\n        Thread.current[:discordrb_name] = \"#{@current_thread}-temp-msg\"\n\n        message = send_message(channel, content, tts, embed)\n        sleep(timeout)\n        message.delete\n      end\n\n      nil\n    end", "label": 4}
{"code": "func (c *Client) Logout(ctx context.Context) error {\n\treq := internal.URL(c, internal.SessionPath).Request(http.MethodDelete)\n\treturn c.Do(ctx, req, nil)\n}", "label": 5}
{"code": "def fetch_compare(older, newer)\n      unless @compares[\"#{older}...#{newer}\"]\n        compare_data = check_github_response { @client.compare(user_project, older, newer || \"HEAD\") }\n        raise StandardError, \"Sha #{older} and sha #{newer} are not related; please file a github-changelog-generator issues and describe how to replicate this issue.\" if compare_data[\"status\"] == \"diverged\"\n\n        @compares[\"#{older}...#{newer}\"] = stringify_keys_deep(compare_data.to_hash)\n      end\n      @compares[\"#{older}...#{newer}\"]\n    end", "label": 4}
{"code": "func (c *CertAuthorityV2) SetRoleMap(m RoleMap) {\n\tc.Spec.RoleMap = []RoleMapping(m)\n}", "label": 5}
{"code": "function thisModule() {\n    var self = this;\n\n    /**\n     * Generate random hash value\n     * @returns {*}\n     */\n    self.getClientIP = function (req) {\n        req = req || {};\n        req.connection = req.connection || {};\n        req.socket = req.socket || {};\n        req.client = req.client || {};\n        var ipString = req.headers['x-forwarded-for'] || req.connection.remoteAddress || req.socket.remoteAddress || req.client.remoteAddress || req.ip || \"\";\n        var ips = ipString.split(\",\");\n\n        if (ips.length > 0) {\n            return ips[0];\n        }\n        else {\n            return;\n        }\n    };\n\n    return self;\n}", "label": 3}
{"code": "protected function wait_channel($channel_id, $timeout = 0)\n    {\n        // Keeping the original timeout unchanged.\n        $_timeout = $timeout;\n        while (true) {\n            $now = time();\n            try {\n                list($frame_type, $frame_channel, $payload) = $this->wait_frame($_timeout);\n            } catch (AMQPTimeoutException $e) {\n                if ( $this->heartbeat && microtime(true) - ($this->heartbeat*2) > $this->last_frame ) {\n                    $this->debug->debug_msg(\"missed server heartbeat (at threshold * 2)\");\n                    $this->setIsConnected(false);\n                    throw new AMQPHeartbeatMissedException(\"Missed server heartbeat\");\n                }\n\n                throw $e;\n            }\n\n            $this->last_frame = microtime(true);\n\n            if ($frame_channel === 0 && $frame_type === 8) {\n                // skip heartbeat frames and reduce the timeout by the time passed\n                $this->debug->debug_msg(\"received server heartbeat\");\n                if($_timeout > 0) {\n                    $_timeout -= time() - $now;\n                    if($_timeout <= 0) {\n                        // If timeout has been reached, throw the exception without calling wait_frame\n                        throw new AMQPTimeoutException(\"Timeout waiting on channel\");\n                    }\n                }\n                continue;\n\n            } else {\n\n                if ($frame_channel == $channel_id) {\n                    return array($frame_type, $payload);\n                }\n\n                // Not the channel we were looking for.  Queue this frame\n                //for later, when the other channel is looking for frames.\n                // Make sure the channel still exists, it could have been\n                // closed by a previous Exception.\n                if (isset($this->channels[$frame_channel])) {\n                    array_push($this->channels[$frame_channel]->frame_queue, array($frame_type, $payload));\n                }\n\n                // If we just queued up a method for channel 0 (the Connection\n                // itself) it's probably a close method in reaction to some\n                // error, so deal with it right away.\n                if (($frame_type == 1) && ($frame_channel == 0)) {\n                    $this->wait();\n                }\n            }\n        }\n    }", "label": 2}
{"code": "public static base_response rename(nitro_service client, nsacl6 resource, String new_acl6name) throws Exception {\n\t\tnsacl6 renameresource = new nsacl6();\n\t\trenameresource.acl6name = resource.acl6name;\n\t\treturn renameresource.rename_resource(client,new_acl6name);\n\t}", "label": 0}
{"code": "func Status(profileDir string, proxyHost string) (*ProfileStatus, []*ProfileStatus, error) {\n\tvar err error\n\tvar profile *ProfileStatus\n\tvar others []*ProfileStatus\n\n\t// remove ports from proxy host, because profile name is stored\n\t// by host name\n\tif proxyHost != \"\" {\n\t\tproxyHost, err = utils.Host(proxyHost)\n\t\tif err != nil {\n\t\t\treturn nil, nil, trace.Wrap(err)\n\t\t}\n\t}\n\n\t// Construct the full path to the profile requested and make sure it exists.\n\tprofileDir = FullProfilePath(profileDir)\n\tstat, err := os.Stat(profileDir)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\tif !stat.IsDir() {\n\t\treturn nil, nil, trace.BadParameter(\"profile path not a directory\")\n\t}\n\n\t// Construct the name of the profile requested. If an empty string was\n\t// passed in, the name of the active profile will be extracted from the\n\t// ~/.tsh/profile symlink.\n\tprofileName, err := fullProfileName(profileDir, proxyHost)\n\tif err != nil {\n\t\tif trace.IsNotFound(err) {\n\t\t\treturn nil, nil, trace.NotFound(\"not logged in\")\n\t\t}\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\n\t// Read in the active profile first. If readProfile returns trace.NotFound,\n\t// that means the profile may have been corrupted (for example keys were\n\t// deleted but profile exists), treat this as the user not being logged in.\n\tprofile, err = readProfile(profileDir, profileName)\n\tif err != nil {\n\t\tif !trace.IsNotFound(err) {\n\t\t\treturn nil, nil, trace.Wrap(err)\n\t\t}\n\t\t// Make sure the profile is nil, which tsh uses to detect that no\n\t\t// active profile exists.\n\t\tprofile = nil\n\t}\n\n\t// Next, get list of all other available profiles. Filter out logged in\n\t// profile if it exists and return a slice of *ProfileStatus.\n\tfiles, err := ioutil.ReadDir(profileDir)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tif file.Mode()&os.ModeSymlink != 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.HasSuffix(file.Name(), \".yaml\") {\n\t\t\tcontinue\n\t\t}\n\t\tif file.Name() == profileName {\n\t\t\tcontinue\n\t\t}\n\t\tps, err := readProfile(profileDir, file.Name())\n\t\tif err != nil {\n\t\t\t// parts of profile are missing?\n\t\t\t// status skips these files\n\t\t\tif trace.IsNotFound(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, nil, trace.Wrap(err)\n\t\t}\n\t\tothers = append(others, ps)\n\t}\n\n\treturn profile, others, nil\n}", "label": 5}
{"code": "def doctype(text)\n      raise SyntaxError.new(Error.message(:illegal_nesting_header), @next_line.index) if block_opened?\n      version, type, encoding = text[3..-1].strip.downcase.scan(DOCTYPE_REGEX)[0]\n      ParseNode.new(:doctype, @line.index + 1, :version => version, :type => type, :encoding => encoding)\n    end", "label": 4}
{"code": "public function setColors($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\ColorInfo::class);\n        $this->colors = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def extract_from_text(text):\n    \"\"\"\n    Extract HAL ids from a text.\n\n    :param text: The text to extract HAL ids from.\n    :returns: A list of matching HAL ids.\n\n    >>> sorted(extract_from_text(\"hal-01258754 hal-01258754v2 foobar\"))\n    ['hal-01258754', 'hal-01258754v2']\n    \"\"\"\n    return tools.remove_duplicates([i[0]\n                                    for i in REGEX.findall(text) if i != ''])", "label": 1}
{"code": "func (context *APIContext) NewAPIContext() smolder.APIContext {\n\tctx := &APIContext{\n\t\tConfig: context.Config,\n\t}\n\treturn ctx\n}", "label": 5}
{"code": "func passwordFromConsole() (string, error) {\n\tfd := syscall.Stdin\n\tstate, err := terminal.GetState(int(fd))\n\n\t// intercept Ctr+C and restore terminal\n\tsigCh := make(chan os.Signal, 1)\n\tcloseCh := make(chan int)\n\tif err != nil {\n\t\tlog.Warnf(\"failed reading terminal state: %v\", err)\n\t} else {\n\t\tsignal.Notify(sigCh, syscall.SIGINT)\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-sigCh:\n\t\t\t\tterminal.Restore(int(fd), state)\n\t\t\t\tos.Exit(1)\n\t\t\tcase <-closeCh:\n\t\t\t}\n\t\t}()\n\t}\n\tdefer func() {\n\t\tclose(closeCh)\n\t}()\n\n\tbytes, err := terminal.ReadPassword(int(fd))\n\treturn string(bytes), err\n}", "label": 5}
{"code": "public ValueContainer[] getKeyValues(ClassDescriptor cld, Object objectOrProxy) throws PersistenceBrokerException\r\n    {\r\n        return getKeyValues(cld, objectOrProxy, true);\r\n    }", "label": 0}
{"code": "function generateCSVHeaders(fieldKeys, mergedFieldEntries, fieldHeader) {\n  var csv = '';\n  var fieldRepeatIndex = 0;\n  // Here we need to add the metaDataHeaders\n  _.each(metaDataHeaders, function(headerName) {\n    csv += headerName + ',';\n  });\n\n  var fieldKeysProcessed = [];\n  var fieldsProcessed = {};\n  fieldKeys.forEach(function(fieldKey) {\n  // check if its a repeating form (and extra headers required)\n    var field = mergedFieldEntries[fieldKey];\n    if (field.type === 'sectionBreak' && field.repeating) {\n      var fieldsInThisSection = sectionUtils.getFieldsInSection(field._id, _.values(mergedFieldEntries));\n      _.each(fieldsInThisSection, function(field) {\n        fieldsProcessed[field._id] = true;\n      });\n\n      for (var i = 0; i < field.fieldOptions.definition.maxRepeat; i++) {\n        _.each(fieldsInThisSection, function(fieldInThisSection) {\n          fieldKeysProcessed.push({key: fieldInThisSection._id, sectionIndex: i + 1, inRepeatingForm: true});\n        });\n      }\n    } else if (!fieldsProcessed[fieldKey]) {\n      fieldKeysProcessed.push({key: fieldKey});\n    }\n  });\n\n  //for each form get each of the unique fields and add a header\n  fieldKeysProcessed.forEach(function(processedField) {\n    // check if its a repeating form (and extra headers required)\n    var field = mergedFieldEntries[processedField.key];\n\n    //Fields may not have a field code, if not just use the field name.\n    var headerName = typeof (field[fieldHeader]) === \"string\" ? field[fieldHeader] : field.name;\n\n    if (processedField.inRepeatingForm) {\n      headerName = '(section repeat: ' + processedField.sectionIndex + ') ' + headerName;\n    }\n    if (field.repeating === true) {\n      for (fieldRepeatIndex = 0; fieldRepeatIndex < field.fieldOptions.definition.maxRepeat; fieldRepeatIndex++) {\n        csv = generateCSVHeader(csv, field, headerName, fieldRepeatIndex);\n      }\n    } else {\n      csv = generateCSVHeader(csv, field, headerName, null);\n    }\n  });\n\n  csv += '\\r\\n';\n  return csv;\n}", "label": 3}
{"code": "def _gen_key(self, key):\n        \"\"\"\n            Return long integer for a given key, that represent it place on\n            the hash ring.\n        \"\"\"\n        b_key = self._md5_digest(key)\n        return self._hashi(b_key, lambda x: x)", "label": 1}
{"code": "function patch(config, nodes, offset) {\n  var position = config.location.toPosition\n  var length = nodes.length\n  var index = -1\n  var start = offset\n  var children\n  var node\n  var end\n\n  while (++index < length) {\n    node = nodes[index]\n    children = node.children\n\n    if (children) {\n      patch(config, children, start)\n    }\n\n    end = start + toString(node).length\n\n    node.position = {start: position(start), end: position(end)}\n\n    start = end\n  }\n\n  return nodes\n}", "label": 3}
{"code": "def upload_purchase_review_screenshot(app_id, upload_image)\n      data = du_client.upload_purchase_review_screenshot(app_id, upload_image, content_provider_id, sso_token_for_image)\n      {\n          \"value\" => {\n              \"assetToken\" => data[\"token\"],\n              \"sortOrder\" => 0,\n              \"type\" => du_client.get_picture_type(upload_image),\n              \"originalFileName\" => upload_image.file_name,\n              \"size\" => data[\"length\"],\n              \"height\" => data[\"height\"],\n              \"width\" => data[\"width\"],\n              \"checksum\" => data[\"md5\"]\n          }\n      }\n    end", "label": 4}
{"code": "function unzipToWorkingDir(params, callback) {\n  var unzipError;\n\n  var queue = async.queue(unzipWorker, params.queueConcurrency || 5);\n\n  //Pushing a single file unzip to the queue.\n  function getQueueEntry(zipfile) {\n    return function queueEntry(entry) {\n      queue.push({\n        zipfile: zipfile,\n        workingDir: params.workingDir,\n        entry: entry\n      }, function(err) {\n        if (err) {\n          logger.debug(\"Error unzipping file params.zipFilePath\", err);\n          //If one of the files has failed to unzip correctly. No point in continuing to unzip. Close the zip file.\n          zipfile.close();\n        }\n      });\n    };\n  }\n\n  unzip.open(params.zipFilePath, {lazyEntries: true}, function(err, zipfile) {\n    if (err) {\n      return callback(err);\n    }\n\n    zipfile.on(\"entry\", getQueueEntry(zipfile));\n    zipfile.readEntry();\n\n    zipfile.on('error', function(err) {\n      logger.error(\"Error unzipping Zip File \" + params.zipFilePath, err);\n      unzipError = err;\n    });\n\n    zipfile.on('close', function() {\n      //When the queue is empty and the zip file has finisihed scanning files, then the unzip is finished\n      logger.debug(\"Zip File \" + params.zipFilePath + \" Unzipped\");\n      callback(unzipError);\n    });\n  });\n}", "label": 3}
{"code": "def merge!(other)\n      criteria = other.to_criteria\n      selector.merge!(criteria.selector)\n      options.merge!(criteria.options)\n      self.documents = criteria.documents.dup unless criteria.documents.empty?\n      self.scoping_options = criteria.scoping_options\n      self.inclusions = (inclusions + criteria.inclusions).uniq\n      self\n    end", "label": 4}
{"code": "public function group(array $attributes, Closure $callback)\n    {\n        $previousGroupAttributes = $this->groupAttributes;\n        $this->groupAttributes = array_merge_recursive($previousGroupAttributes, $attributes);\n\n        \\call_user_func($callback, $this);\n\n        $this->groupAttributes = $previousGroupAttributes;\n    }", "label": 2}
{"code": "public function setDependencyEdge($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Language\\V1\\DependencyEdge::class);\n        $this->dependency_edge = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "private void ensureColumn(FieldDescriptorDef fieldDef, String checkLevel)\r\n    {\r\n        if (!fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_COLUMN))\r\n        {\r\n            String javaname = fieldDef.getName();\r\n\r\n            if (fieldDef.isNested())\r\n            {    \r\n                int pos = javaname.indexOf(\"::\");\r\n\r\n                // we convert nested names ('_' for '::')\r\n                if (pos > 0)\r\n                {\r\n                    StringBuffer newJavaname = new StringBuffer(javaname.substring(0, pos));\r\n                    int          lastPos     = pos + 2;\r\n\r\n                    do\r\n                    {\r\n                        pos = javaname.indexOf(\"::\", lastPos);\r\n                        newJavaname.append(\"_\");\r\n                        if (pos > 0)\r\n                        {    \r\n                            newJavaname.append(javaname.substring(lastPos, pos));\r\n                            lastPos = pos + 2;\r\n                        }\r\n                        else\r\n                        {\r\n                            newJavaname.append(javaname.substring(lastPos));\r\n                        }\r\n                    }\r\n                    while (pos > 0);\r\n                    javaname = newJavaname.toString();\r\n                }\r\n            }\r\n            fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_COLUMN, javaname);\r\n        }\r\n    }", "label": 0}
{"code": "func (m *MockIndex) Struct(arg0 struct{}) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Struct\", arg0)\n}", "label": 5}
{"code": "def page(pattern: SCAN_PATTERN, cursor: 0, page_size: 100)\n      redis do |conn|\n        total_size, digests = conn.multi do\n          conn.scard(UNIQUE_SET)\n          conn.sscan(UNIQUE_SET, cursor, match: pattern, count: page_size)\n        end\n\n        [total_size, digests[0], digests[1]]\n      end\n    end", "label": 4}
{"code": "def method_missing(method_name, *_args)\n      if attrs.key?(method_name.to_s)\n        attrs[method_name.to_s]\n      else\n        super(method_name)\n      end\n    end", "label": 4}
{"code": "func (h *Handle) New() datastore.KVObject {\n\th.Lock()\n\tdefer h.Unlock()\n\n\treturn &Handle{\n\t\tapp:   h.app,\n\t\tstore: h.store,\n\t}\n}", "label": 5}
{"code": "function findMap(array, callback) {\n        for (var i = 0, len = array.length; i < len; i++) {\n            var result = callback(array[i], i);\n            if (result) {\n                return result;\n            }\n        }\n        Debug.fail();\n    }", "label": 3}
{"code": "func CreateBackup(dir, backupsDir string, limit int) error {\n\ttmpBackupDir := filepath.Join(backupsDir, \"tmp\")\n\tif err := os.MkdirAll(backupsDir, 0750); err != nil {\n\t\treturn err\n\t}\n\tif err := fileutil.CopyTree(dir, tmpBackupDir, user.NewBlankUidRange()); err != nil {\n\t\treturn err\n\t}\n\tdefer os.RemoveAll(tmpBackupDir)\n\t// prune backups\n\tif err := pruneOldBackups(backupsDir, limit-1); err != nil {\n\t\treturn err\n\t}\n\tif err := shiftBackups(backupsDir, limit-2); err != nil {\n\t\treturn err\n\t}\n\tif err := os.Rename(tmpBackupDir, filepath.Join(backupsDir, \"0\")); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "label": 5}
{"code": "func Wait(ctx context.Context, ref types.ManagedObjectReference, pc *property.Collector, s progress.Sinker) (*types.TaskInfo, error) {\n\tcb := &taskCallback{}\n\n\t// Include progress sink if specified\n\tif s != nil {\n\t\tcb.ch = s.Sink()\n\t\tdefer close(cb.ch)\n\t}\n\n\terr := property.Wait(ctx, pc, ref, []string{\"info\"}, cb.fn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cb.info, cb.err\n}", "label": 5}
{"code": "protected function setFieldKey()\n    {\n        if (! $this->fieldValue || ! $this->rootValue) {\n            return;\n        }\n\n        $cacheFieldKey = $this->fieldValue\n            ->getParent()\n            ->getCacheKey();\n\n        if ($cacheFieldKey) {\n            $this->fieldKey = data_get($this->rootValue, $cacheFieldKey);\n        }\n    }", "label": 2}
{"code": "public function setErrorEvents($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\ErrorReporting\\V1beta1\\ErrorEvent::class);\n        $this->error_events = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function maybeTypeOfKind(type, kind) {\n            if (type.flags & kind) {\n                return true;\n            }\n            if (type.flags & 1572864 /* UnionOrIntersection */) {\n                var types = type.types;\n                for (var _i = 0, types_13 = types; _i < types_13.length; _i++) {\n                    var t = types_13[_i];\n                    if (maybeTypeOfKind(t, kind)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "label": 3}
{"code": "def get_distinct_values_from_cols(self, l_col_list):\n        \"\"\"\n        returns the list of distinct combinations in a dataset\n        based on the columns in the list. Note that this is \n        currently implemented as MAX permutations of the combo\n        so it is not guarenteed to have values in each case.\n        \"\"\"\n        uniq_vals = []\n        for l_col_name in l_col_list:\n            #print('col_name: ' + l_col_name)   \n            uniq_vals.append(set(self.get_col_data_by_name(l_col_name)))\n            #print(' unique values = ', uniq_vals)    \n        \n        #print(' unique values[0] = ', uniq_vals[0])\n        #print(' unique values[1] = ', uniq_vals[1])\n        if len(l_col_list) == 0:\n            return []\n        elif len(l_col_list) == 1:\n            return sorted([v for v in uniq_vals])\n        elif len(l_col_list) == 2:\n            res = []\n            res = [(a, b) for a in uniq_vals[0] for b in uniq_vals[1]]\n            return res\n        else:\n            print (\"TODO \")\n            return -44", "label": 1}
{"code": "def arrparse(ts)\n    ts = eat('[', ts)\n    arr = []\n\n    if ts[0][0] == ']'\n      return arr, ts[1..-1]\n    end\n\n    v, ts = valparse(ts)\n    arr << v\n\n    if ts[0][0] == ']'\n      return arr, ts[1..-1]\n    end\n\n    loop do\n      ts = eat(',', ts)\n\n      v, ts = valparse(ts)\n      arr << v\n\n      if ts[0][0] == ']'\n        return arr, ts[1..-1]\n      end\n    end\n  end", "label": 4}
{"code": "function rebuildInput(form) {\n\t\t\tform.empty();\n\t\t\tvar inp = $('<input type=\"file\" name=\"svg_file\">').appendTo(form);\n\t\t\t\n\t\t\t\n\t\t\tfunction submit() {\n\t\t\t\t// This submits the form, which returns the file data using svgEditor.processFile()\n\t\t\t\tform.submit();\n\t\t\t\t\n\t\t\t\trebuildInput(form);\n\t\t\t\t$.process_cancel(\"Uploading...\", function() {\n\t\t\t\t\tcancelled = true;\n\t\t\t\t\t$('#dialog_box').hide();\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tif(form[0] == open_svg_form[0]) {\n\t\t\t\tinp.change(function() {\n\t\t\t\t\t// This takes care of the \"are you sure\" dialog box\n\t\t\t\t\tsvgEditor.openPrep(function(ok) {\n\t\t\t\t\t\tif(!ok) {\n\t\t\t\t\t\t\trebuildInput(form);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsubmit();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tinp.change(function() {\n\t\t\t\t\t// This submits the form, which returns the file data using svgEditor.processFile()\n\t\t\t\t\tsubmit();\n\t\t\t\t});\n\t\t\t}\n\t\t}", "label": 3}
{"code": "def start(service_name, timeout: DEFAULT_TIMEOUT)\n      Puppet.debug _(\"Starting the %{service_name} service. Timeout set to: %{timeout} seconds\") % { service_name: service_name, timeout: timeout }\n\n      valid_initial_states = [\n        SERVICE_STOP_PENDING,\n        SERVICE_STOPPED,\n        SERVICE_START_PENDING\n      ]\n\n      transition_service_state(service_name, valid_initial_states, SERVICE_RUNNING, timeout) do |service|\n        if StartServiceW(service, 0, FFI::Pointer::NULL) == FFI::WIN32_FALSE\n          raise Puppet::Util::Windows::Error, _(\"Failed to start the service\")\n        end\n      end\n\n      Puppet.debug _(\"Successfully started the %{service_name} service\") % { service_name: service_name }\n    end", "label": 4}
{"code": "private Query getFKQuery(Object obj, ClassDescriptor cld, CollectionDescriptor cds)\r\n    {\r\n        Query fkQuery;\r\n        QueryByCriteria fkQueryCrit;\r\n\r\n        if (cds.isMtoNRelation())\r\n        {\r\n            fkQueryCrit = getFKQueryMtoN(obj, cld, cds);\r\n        }\r\n        else\r\n        {\r\n            fkQueryCrit = getFKQuery1toN(obj, cld, cds);\r\n        }\r\n\r\n        // check if collection must be ordered\r\n        if (!cds.getOrderBy().isEmpty())\r\n        {\r\n            Iterator iter = cds.getOrderBy().iterator();\r\n            while (iter.hasNext())\r\n            {\r\n                fkQueryCrit.addOrderBy((FieldHelper)iter.next());\r\n            }\r\n        }\r\n\r\n        // BRJ: customize the query\r\n        if (cds.getQueryCustomizer() != null)\r\n        {\r\n            fkQuery = cds.getQueryCustomizer().customizeQuery(obj, pb, cds, fkQueryCrit);\r\n        }\r\n        else\r\n        {\r\n            fkQuery = fkQueryCrit;\r\n        }\r\n\r\n        return fkQuery;\r\n    }", "label": 0}
{"code": "func (p *printer) deleteAttrPrefix(prefix string) {\n\tdelete(p.attrPrefix, p.attrNS[prefix])\n\tdelete(p.attrNS, prefix)\n}", "label": 5}
{"code": "public function setRules($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Bigtable\\Admin\\V2\\GcRule::class);\n        $this->rules = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "private function getArgsForAttempt($attempt)\n    {\n        $args = $this->args;\n\n        // Determine the delay.\n        $delay = ($attempt === 1)\n            ? $this->config['initDelay']\n            : $this->config['delay'];\n        if (is_callable($delay)) {\n            $delay = $delay($attempt);\n        }\n\n        // Set the delay. (Note: handlers except delay in milliseconds.)\n        if (!isset($args['@http'])) {\n            $args['@http'] = [];\n        }\n        $args['@http']['delay'] = $delay * 1000;\n\n        return $args;\n    }", "label": 2}
{"code": "function Model(defaults){\n\n    // Make sure \"new\" is always used,\n    // so we can use \"instanceof\" to check if something is a Model.\n    if (!(this instanceof Model)) {\n      return new Model(defaults);\n    }\n\n    // `model` is the public API object returned from invoking `new Model()`.\n    var model = this,\n\n        // The internal stored values for tracked properties. { property -> value }\n        values = {},\n\n        // The callback functions for each tracked property. { property -> [callback] }\n        listeners = {},\n\n        // The set of tracked properties. { property -> true }\n        trackedProperties = {};\n\n    // The functional reactive \"when\" operator.\n    //\n    //  * `properties` An array of property names (can also be a single property string).\n    //  * `callback` A callback function that is called:\n    //    * with property values as arguments, ordered corresponding to the properties array,\n    //    * only if all specified properties have values,\n    //    * once for initialization,\n    //    * whenever one or more specified properties change,\n    //    * on the next tick of the JavaScript event loop after properties change,\n    //    * only once as a result of one or more synchronous changes to dependency properties.\n    function when(properties, callback, thisArg){\n      \n      // Make sure the default `this` becomes \n      // the object you called `.on` on.\n      thisArg = thisArg || this;\n\n      // Handle either an array or a single string.\n      properties = (properties instanceof Array) ? properties : [properties];\n\n      // This function will trigger the callback to be invoked.\n      var listener = debounce(function (){\n        var args = properties.map(function(property){\n          return values[property];\n        });\n        if(allAreDefined(args)){\n          callback.apply(thisArg, args);\n        }\n      });\n\n      // Trigger the callback once for initialization.\n      listener();\n      \n      // Trigger the callback whenever specified properties change.\n      properties.forEach(function(property){\n        on(property, listener);\n      });\n\n      // Return this function so it can be removed later with `model.cancel(listener)`.\n      return listener;\n    }\n\n    // Adds a change listener for a given property with Backbone-like behavior.\n    // Similar to http://backbonejs.org/#Events-on\n    function on(property, callback, thisArg){\n      thisArg = thisArg || this;\n      getListeners(property).push(callback);\n      track(property, thisArg);\n    }\n    \n    // Gets or creates the array of listener functions for a given property.\n    function getListeners(property){\n      return listeners[property] || (listeners[property] = []);\n    }\n\n    // Tracks a property if it is not already tracked.\n    function track(property, thisArg){\n      if(!(property in trackedProperties)){\n        trackedProperties[property] = true;\n        values[property] = model[property];\n        Object.defineProperty(model, property, {\n          get: function () { return values[property]; },\n          set: function(newValue) {\n            var oldValue = values[property];\n            values[property] = newValue;\n            getListeners(property).forEach(function(callback){\n              callback.call(thisArg, newValue, oldValue);\n            });\n          }\n        });\n      }\n    }\n\n    // Cancels a listener returned by a call to `model.when(...)`.\n    function cancel(listener){\n      for(var property in listeners){\n        off(property, listener);\n      }\n    }\n\n    // Removes a change listener added using `on`.\n    function off(property, callback){\n      listeners[property] = listeners[property].filter(function (listener) {\n        return listener !== callback;\n      });\n    }\n\n    // Sets all of the given values on the model.\n    // `newValues` is an object { property -> value }.\n    function set(newValues){\n      for(var property in newValues){\n        model[property] = newValues[property];\n      }\n    }\n\n    // Transfer defaults passed into the constructor to the model.\n    set(defaults);\n\n    // Public API.\n    model.when = when;\n    model.cancel = cancel;\n    model.on = on;\n    model.off = off;\n    model.set = set;\n  }", "label": 3}
{"code": "def get_oa_version(doi):\n    \"\"\"\n    Get an OA version for a given DOI.\n\n    .. note::\n\n        Uses beta.dissem.in API.\n\n    :param doi: A canonical DOI.\n    :returns: The URL of the OA version of the given DOI, or ``None``.\n\n    >>> get_oa_version('10.1209/0295-5075/111/40005')\n    'http://arxiv.org/abs/1506.06690'\n    \"\"\"\n    try:\n        request = requests.get(\"%s%s\" % (DISSEMIN_API, doi))\n        request.raise_for_status()\n        result = request.json()\n        assert result[\"status\"] == \"ok\"\n        return result[\"paper\"][\"pdf_url\"]\n    except (AssertionError, ValueError, KeyError, RequestException):\n        return None", "label": 1}
{"code": "public static sslvserver_sslcipher_binding[] get(nitro_service service, String vservername) throws Exception{\n\t\tsslvserver_sslcipher_binding obj = new sslvserver_sslcipher_binding();\n\t\tobj.set_vservername(vservername);\n\t\tsslvserver_sslcipher_binding response[] = (sslvserver_sslcipher_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private function getCommits($org, $repo, $version)\n    {\n        $url = sprintf(\n            self::GITHUB_COMPARE_ENDPOINT,\n            $org,\n            $repo,\n            $version\n        );\n\n        $res = json_decode($this->http->get($url, [\n            'auth' => [null, $this->token]\n        ])->getBody(), true);\n        $commits = [];\n        foreach ($res['commits'] as $commit) {\n            $message = $commit['commit']['message'];\n\n            $description = explode(\"\\n\", $message)[0];\n            $matches = [];\n            if (preg_match('/(.{0,})\\(\\#(\\d{1,})\\)/', $description, $matches) === 1) {\n                $message = trim($matches[1]);\n                $prNumber = isset($matches[2]) ? $matches[2] : null;\n            } else {\n                $prNumber = $this->askForPrNumber($message);\n            }\n\n            if (strpos($message, '[CHANGE ME]') === 0 && $prNumber) {\n                $message = $this->getMessageFromPullRequest($org, $repo, $prNumber);\n            }\n\n            $commits[] = [\n                'url' => $commit['url'],\n                'htmlUrl' => $commit['html_url'],\n                'message' => $message,\n                'reference' => $prNumber,\n                'hash' => $commit['sha']\n            ];\n        }\n\n        return $commits;\n    }", "label": 2}
{"code": "func ParseMounts(pid uint) (Mounts, error) {\n\tvar procPath string\n\tif pid == 0 {\n\t\tprocPath = \"/proc/self/mountinfo\"\n\t} else {\n\t\tprocPath = fmt.Sprintf(\"/proc/%d/mountinfo\", pid)\n\t}\n\n\tmi, err := os.Open(procPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer mi.Close()\n\n\treturn parseMountinfo(mi)\n}", "label": 5}
{"code": "def size_for_work(work_id)\n        argz = { fl: \"id, #{file_size_field}\",\n                 fq: \"{!join from=#{member_ids_field} to=id}id:#{work_id}\" }\n        files = ::FileSet.search_with_conditions({}, argz)\n        files.reduce(0) { |sum, f| sum + f[file_size_field].to_i }\n      end", "label": 4}
{"code": "public DbOrganization getMatchingOrganization(final DbModule dbModule) {\n        if(dbModule.getOrganization() != null\n                && !dbModule.getOrganization().isEmpty()){\n            return getOrganization(dbModule.getOrganization());\n        }\n\n        for(final DbOrganization organization: repositoryHandler.getAllOrganizations()){\n            final CorporateFilter corporateFilter = new CorporateFilter(organization);\n            if(corporateFilter.matches(dbModule)){\n                return organization;\n            }\n        }\n\n        return null;\n    }", "label": 0}
{"code": "func (m VirtualDiskManager) ShrinkVirtualDisk(ctx context.Context, name string, dc *Datacenter, copy *bool) (*Task, error) {\n\treq := types.ShrinkVirtualDisk_Task{\n\t\tThis: m.Reference(),\n\t\tName: name,\n\t\tCopy: copy,\n\t}\n\n\tif dc != nil {\n\t\tref := dc.Reference()\n\t\treq.Datacenter = &ref\n\t}\n\n\tres, err := methods.ShrinkVirtualDisk_Task(ctx, m.c, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewTask(m.c, res.Returnval), nil\n}", "label": 5}
{"code": "private function readResultsFromChildren()\n    {\n        // Create an array of all active streams, indexed by\n        // resource id.\n        $streams = [];\n        foreach ($this->read_streams as $stream) {\n            $streams[intval($stream)] = $stream;\n        }\n\n        // Create an array for the content received on each stream,\n        // indexed by resource id.\n        $content = array_fill_keys(array_keys($streams), '');\n\n        // Read the data off of all the stream.\n        while (count($streams) > 0) {\n            $needs_read = array_values($streams);\n            $needs_write = null;\n            $needs_except = null;\n\n            // Wait for data on at least one stream.\n            $num = stream_select($needs_read, $needs_write, $needs_except, null /* no timeout */);\n            if ($num === false) {\n                error_log('unable to select on read stream');\n                exit(self::EXIT_FAILURE);\n            }\n\n            // For each stream that was ready, read the content.\n            foreach ($needs_read as $file) {\n                $buffer = fread($file, 1024);\n                if ($buffer) {\n                    $content[intval($file)] .= $buffer;\n                }\n\n                // If the stream has closed, stop trying to select on it.\n                if (feof($file)) {\n                    fclose($file);\n                    unset($streams[intval($file)]);\n                }\n            }\n        }\n\n        // Unmarshal the content into its original form.\n        return array_values(\n            array_map(\n                /**\n                 * @param string $data\n                 *\n                 * @return array\n                 */\n                function ($data) {\n                    /** @var array */\n                    $result = unserialize($data);\n                    /** @psalm-suppress DocblockTypeContradiction */\n                    if (!\\is_array($result)) {\n                        error_log(\n                            'Child terminated without returning a serialized array - response type=' . gettype($result)\n                        );\n                        $this->did_have_error = true;\n                    }\n\n                    return $result;\n                },\n                $content\n            )\n        );\n    }", "label": 2}
{"code": "public void delete(Vertex vtx) {\n        if (vtx.prev == null) {\n            head = vtx.next;\n        } else {\n            vtx.prev.next = vtx.next;\n        }\n        if (vtx.next == null) {\n            tail = vtx.prev;\n        } else {\n            vtx.next.prev = vtx.prev;\n        }\n    }", "label": 0}
{"code": "def parse_unifrac(unifracFN):\n    \"\"\"\n    Parses the unifrac results file into a dictionary\n\n    :type unifracFN: str\n    :param unifracFN: The path to the unifrac results file\n\n    :rtype: dict\n    :return: A dictionary with keys: 'pcd' (principle coordinates data) which is a\n             dictionary of the data keyed by sample ID, 'eigvals' (eigenvalues), and\n             'varexp' (variation explained)\n    \"\"\"\n    with open(unifracFN, \"rU\") as uF:\n        first = uF.next().split(\"\\t\")\n        lines = [line.strip() for line in uF]\n\n    unifrac = {\"pcd\": OrderedDict(), \"eigvals\": [], \"varexp\": []}\n    if first[0] == \"pc vector number\":\n        return parse_unifrac_v1_8(unifrac, lines)\n    elif first[0] == \"Eigvals\":\n        return parse_unifrac_v1_9(unifrac, lines)\n    else:\n        raise ValueError(\"File format not supported/recognized. Please check input \"\n                         \"unifrac file.\")", "label": 1}
{"code": "def read_bignum\n      sign = read_char == '-' ? -1 : 1\n      size = read_fixnum * 2\n      result = 0\n      (0...size).each do |exp|\n        result += read_char.ord * 2**(exp * 8)\n      end\n      result = result.to_i * sign\n      @object_cache << result\n      result\n    end", "label": 4}
{"code": "def accessors(options = {})\n      headers = extract_headers!(options)\n      json = client.list(\"/v1/auth/token/accessors\", options, headers)\n      return Secret.decode(json)\n    end", "label": 4}
{"code": "func (c *Client) ReattachConfig() *ReattachConfig {\n\tc.l.Lock()\n\tdefer c.l.Unlock()\n\n\tif c.address == nil {\n\t\treturn nil\n\t}\n\n\tif c.config.Cmd != nil && c.config.Cmd.Process == nil {\n\t\treturn nil\n\t}\n\n\t// If we connected via reattach, just return the information as-is\n\tif c.config.Reattach != nil {\n\t\treturn c.config.Reattach\n\t}\n\n\treturn &ReattachConfig{\n\t\tProtocol: c.protocol,\n\t\tAddr:     c.address,\n\t\tPid:      c.config.Cmd.Process.Pid,\n\t}\n}", "label": 5}
{"code": "public static function hexdump($data, $htmloutput = true, $uppercase = false, $return = false)\n    {\n        // Init\n        $hexi = '';\n        $ascii = '';\n        $dump = $htmloutput ? '<pre>' : '';\n        $offset = 0;\n        $len = mb_strlen($data, 'ASCII');\n\n        // Upper or lower case hexidecimal\n        $hexFormat = $uppercase ? 'X' : 'x';\n\n        // Iterate string\n        for ($i = $j = 0; $i < $len; $i++) {\n            // Convert to hexidecimal\n            // We must use concatenation here because the $hexFormat value\n            // is needed for sprintf() to parse the format\n            $hexi .= sprintf('%02' .  $hexFormat . ' ', ord($data[$i]));\n\n            // Replace non-viewable bytes with '.'\n            if (ord($data[$i]) >= 32) {\n                $ascii .= $htmloutput ? htmlentities($data[$i]) : $data[$i];\n            } else {\n                $ascii .= '.';\n            }\n\n            // Add extra column spacing\n            if ($j === 7) {\n                $hexi .= ' ';\n                $ascii .= ' ';\n            }\n\n            // Add row\n            if (++$j === 16 || $i === $len - 1) {\n                // Join the hexi / ascii output\n                // We must use concatenation here because the $hexFormat value\n                // is needed for sprintf() to parse the format\n                $dump .= sprintf('%04' . $hexFormat . '  %-49s  %s', $offset, $hexi, $ascii);\n\n                // Reset vars\n                $hexi = $ascii = '';\n                $offset += 16;\n                $j = 0;\n\n                // Add newline\n                if ($i !== $len - 1) {\n                    $dump .= PHP_EOL;\n                }\n            }\n        }\n\n        // Finish dump\n        $dump .= $htmloutput ? '</pre>' : '';\n        $dump .= PHP_EOL;\n\n        if ($return) {\n            return $dump;\n        }\n\n        echo $dump;\n    }", "label": 2}
{"code": "def iter_and_close(file_like, block_size):\n    \"\"\"Yield file contents by block then close the file.\"\"\"\n    while 1:\n        try:\n            block = file_like.read(block_size)\n            if block:\n                yield block\n            else:\n                raise StopIteration\n        except StopIteration:\n            file_like.close()\n            return", "label": 1}
{"code": "def from_dict(cls, cls_dict, fallback_xsi_type=None):\n        \"\"\"Parse the dictionary and return an Entity instance.\n\n        This will attempt to extract type information from the input\n        dictionary and pass it to entity_class to resolve the correct class\n        for the type.\n\n        Args:\n            cls_dict: A dictionary representation of an Entity object.\n            fallback_xsi_type: An xsi_type to use for string input, which\n            doesn't have properties\n\n        Returns:\n            An Entity instance.\n        \"\"\"\n        if not cls_dict:\n            return None\n        \n        if isinstance(cls_dict, six.string_types):\n            if not getattr(cls, \"_convert_strings\", False):\n                return cls_dict\n\n        try:\n            typekey = cls.dictkey(cls_dict)\n        except TypeError:\n            typekey = fallback_xsi_type\n        klass   = cls.entity_class(typekey)\n        return klass.from_dict(cls_dict)", "label": 1}
{"code": "func (r *Registry) getEntityParent(item mo.Entity, kind string) mo.Entity {\n\tfor {\n\t\tparent := item.Entity().Parent\n\n\t\titem = r.Get(*parent).(mo.Entity)\n\n\t\tif item.Reference().Type == kind {\n\t\t\treturn item\n\t\t}\n\t}\n}", "label": 5}
{"code": "def stop(cls):\n        \"\"\"Change back the normal stdout after the end\"\"\"\n        if any(cls.streams):\n            sys.stdout = cls.streams.pop(-1)\n        else:\n            sys.stdout = sys.__stdout__", "label": 1}
{"code": "def find_vagrantfile(search_path, filenames=nil)\n      filenames ||= [\"Vagrantfile\", \"vagrantfile\"]\n      filenames.each do |vagrantfile|\n        current_path = search_path.join(vagrantfile)\n        return current_path if current_path.file?\n      end\n\n      nil\n    end", "label": 4}
{"code": "function read(filePath, options){\n\treturn new Promise((resolve, reject) => {\n\t\tfs.readFile(filePath, options, (error, data) => {\n\t\t\terror\n\t\t\t\t? reject(error)\n\t\t\t\t: resolve(data.toString());\n\t\t});\n\t});\n}", "label": 3}
{"code": "public function unlink($path)\n    {\n        $client = $this->openPath($path);\n        $object = $this->bucket->object($this->file);\n\n        try {\n            $object->delete();\n            return true;\n        } catch (ServiceException $e) {\n            return false;\n        }\n    }", "label": 2}
{"code": "def _ensure_patient_group_is_ok(patient_object, patient_name=None):\n    \"\"\"\n    Ensure that the provided entries for the patient groups is formatted properly.\n\n    :param set|dict patient_object: The values passed to the samples patient group\n    :param str patient_name: Optional name for the set\n    :raises ParameterError: If required entry doesnt exist\n    \"\"\"\n    from protect.addons.common import TCGAToGTEx\n    assert isinstance(patient_object, (set, dict)), '%s,%s' % (patient_object, patient_name)\n    # set(dict) = set of keys of the dict\n    test_set = set(patient_object)\n    if 'tumor_type' not in patient_object:\n        raise ParameterError(('The patient entry for sample %s ' % patient_name) +\n                             'does not contain a Tumor type.')\n    elif patient_object['tumor_type'] not in TCGAToGTEx:\n        raise ParameterError(('The patient entry for sample %s ' % patient_name) +\n                             'does contains an invalid Tumor type. Please use one of the '\n                             'valid TCGA tumor types.')\n    if {'tumor_dna_fastq_1', 'normal_dna_fastq_1', 'tumor_rna_fastq_1'}.issubset(test_set):\n        # Best case scenario, we get all fastqs\n        pass\n    else:\n        # We have less than 3 fastqs so we have to have a haplotype.\n        if 'hla_haplotype_files' not in test_set:\n            raise ParameterError(('The patient entry for sample %s ' % patient_name) +\n                                 'does not contain a hla_haplotype_files entry.\\nCannot haplotype '\n                                 'patient if all the input sequence files are not fastqs.')\n        # Either we have a fastq and/or bam for the tumor and normal, or we need to be given a vcf\n        if (({re.search('tumor_dna_((bam)|(fastq_1)).*', x) for x in test_set} == {None} or\n                {re.search('normal_dna_((bam)|(fastq_1)).*', x) for x in test_set} == {None}) and\n                ('mutation_vcf' not in test_set and 'fusion_bedpe' not in test_set)):\n            raise ParameterError(('The patient entry for sample %s ' % patient_name) +\n                                 'does not contain a mutation_vcf or fusion_bedpe entry. If both '\n                                 'tumor and normal DNA sequences (fastqs or bam) are not provided, '\n                                 'a pre-computed vcf and/or bedpe must be provided.')\n        # We have to be given a tumor rna fastq or bam unless we are processing ONLY fusions\n        if {re.search('tumor_rna_((bam)|(fastq_1)).*', x) for x in test_set} == {None}:\n            if 'mutation_vcf' not in test_set and 'fusion_bedpe' in test_set:\n                # The only case where it is ok to not have the genome mapped rna.\n                pass\n            else:\n                raise ParameterError(('The patient entry for sample %s ' % patient_name) +\n                                     'does not contain a tumor rna sequence data entry. We require '\n                                     'either tumor_rna_fastq_1 or tumor_rna_bam.')\n        # If we are given an RNA bam then it needs to have a corresponding transcriptome bam unless\n        # we have also been provided expression values.\n        if 'tumor_rna_bam' in test_set and 'tumor_rna_transcriptome_bam' not in test_set:\n            if 'expression_files' not in test_set:\n                raise ParameterError(('The patient entry for sample %s ' % patient_name +\n                                      'was provided a tumor rna bam with sequences mapped to the '\n                                      'genome but was not provided a matching rna bam for the '\n                                      'transcriptome or a tar containing expression values. '\n                                      'We require either a matching transcriptome bam to estimate'\n                                      'expression, or the precomputed expression values.'))", "label": 1}
{"code": "function updatePackageID () {\n  return new Promise((resolve) => {\n    const oldPackageID = oldInfo.packageID\n    const newPackageID = newInfo.packageID\n    const androidPath = newInfo.androidPathToModule\n    console.log(`Changing package ID from \"${oldPackageID}\" to \"${newPackageID}\"...`)\n\n    replaceInFiles(RegExp(`(?=([ \"'])).${oldPackageID}(?=[;\"'])`), `$1${newPackageID}`, [\n      'android/app/BUCK',\n      'android/app/build.gradle',\n      'android/app/src/main/AndroidManifest.xml',\n      `${androidPath}/MainActivity.java`,\n      `${androidPath}/MainApplication.java`,\n    ])\n\n    console.log('Package ID is updated.\\n')\n    resolve()\n  })\n}", "label": 3}
{"code": "public static base_responses enable(nitro_service client, nspbr resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tnspbr enableresources[] = new nspbr[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tenableresources[i] = new nspbr();\n\t\t\t\tenableresources[i].name = resources[i].name;\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, enableresources,\"enable\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def commit(list=nil, async=false)\n      if !list.nil? && !list.is_a?(TopicPartitionList)\n        raise TypeError.new(\"list has to be nil or a TopicPartitionList\")\n      end\n      tpl = if list\n              list.to_native_tpl\n            else\n              nil\n            end\n      response = Rdkafka::Bindings.rd_kafka_commit(@native_kafka, tpl, async)\n      if response != 0\n        raise Rdkafka::RdkafkaError.new(response)\n      end\n    end", "label": 4}
{"code": "func (p *ProcessStorage) WriteIdentity(name string, id Identity) error {\n\tres := IdentityV2{\n\t\tResourceHeader: services.ResourceHeader{\n\t\t\tKind:    services.KindIdentity,\n\t\t\tVersion: services.V2,\n\t\t\tMetadata: services.Metadata{\n\t\t\t\tName: name,\n\t\t\t},\n\t\t},\n\t\tSpec: IdentitySpecV2{\n\t\t\tKey:        id.KeyBytes,\n\t\t\tSSHCert:    id.CertBytes,\n\t\t\tTLSCert:    id.TLSCertBytes,\n\t\t\tTLSCACerts: id.TLSCACertsBytes,\n\t\t\tSSHCACerts: id.SSHCACertBytes,\n\t\t},\n\t}\n\tif err := res.CheckAndSetDefaults(); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tvalue, err := json.Marshal(res)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\titem := backend.Item{\n\t\tKey:   backend.Key(idsPrefix, strings.ToLower(id.ID.Role.String()), name),\n\t\tValue: value,\n\t}\n\t_, err = p.Put(context.TODO(), item)\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "def fill_in_empty_cells(cells, row_number, last_col, use_simple_rows_format)\n      new_cells = Hash.new\n\n      unless cells.empty?\n        last_col = last_col.gsub(row_number, '')\n\n        (\"A\"..last_col).to_a.each do |column|\n          id = use_simple_rows_format ? \"#{column}\" : \"#{column}#{row_number}\"\n          new_cells[id] = cells[id]\n        end\n      end\n\n      new_cells\n    end", "label": 4}
{"code": "function prepareElementRoot() {\n\n        P.$root.\n\n            on({\n\n                // For iOS8.\n                keydown: handleKeydownEvent,\n\n                // When something within the root is focused, stop from bubbling\n                // to the doc and remove the \u201cfocused\u201d state from the root.\n                focusin: function( event ) {\n                    P.$root.removeClass( CLASSES.focused )\n                    event.stopPropagation()\n                },\n\n                // When something within the root holder is clicked, stop it\n                // from bubbling to the doc.\n                'mousedown click': function( event ) {\n\n                    var target = event.target\n\n                    // Make sure the target isn\u2019t the root holder so it can bubble up.\n                    if ( target != P.$root.children()[ 0 ] ) {\n\n                        event.stopPropagation()\n\n                        // * For mousedown events, cancel the default action in order to\n                        //   prevent cases where focus is shifted onto external elements\n                        //   when using things like jQuery mobile or MagnificPopup (ref: #249 & #120).\n                        //   Also, for Firefox, don\u2019t prevent action on the `option` element.\n                        if ( event.type == 'mousedown' && !$( target ).is( 'input, select, textarea, button, option' )) {\n\n                            event.preventDefault()\n\n                            // Re-focus onto the root so that users can click away\n                            // from elements focused within the picker.\n                            P.$root[0].focus()\n                        }\n                    }\n                }\n            }).\n\n            // Add/remove the \u201ctarget\u201d class on focus and blur.\n            on({\n                focus: function() {\n                    $ELEMENT.addClass( CLASSES.target )\n                },\n                blur: function() {\n                    $ELEMENT.removeClass( CLASSES.target )\n                }\n            }).\n\n            // Open the picker and adjust the root \u201cfocused\u201d state\n            on( 'focus.toOpen', handleFocusToOpenEvent ).\n\n            // If there\u2019s a click on an actionable element, carry out the actions.\n            on( 'click', '[data-pick], [data-nav], [data-clear], [data-close]', function() {\n\n                var $target = $( this ),\n                    targetData = $target.data(),\n                    targetDisabled = $target.hasClass( CLASSES.navDisabled ) || $target.hasClass( CLASSES.disabled ),\n\n                    // * For IE, non-focusable elements can be active elements as well\n                    //   (http://stackoverflow.com/a/2684561).\n                    activeElement = getActiveElement()\n                    activeElement = activeElement && ( activeElement.type || activeElement.href )\n\n                // If it\u2019s disabled or nothing inside is actively focused, re-focus the element.\n                if ( targetDisabled || activeElement && !$.contains( P.$root[0], activeElement ) ) {\n                    P.$root[0].focus()\n                }\n\n                // If something is superficially changed, update the `highlight` based on the `nav`.\n                if ( !targetDisabled && targetData.nav ) {\n                    P.set( 'highlight', P.component.item.highlight, { nav: targetData.nav } )\n                }\n\n                // If something is picked, set `select` then close with focus.\n                else if ( !targetDisabled && 'pick' in targetData ) {\n                    P.set( 'select', targetData.pick )\n                }\n\n                // If a \u201cclear\u201d button is pressed, empty the values and close with focus.\n                else if ( targetData.clear ) {\n                    P.clear().close( true )\n                }\n\n                else if ( targetData.close ) {\n                    P.close( true )\n                }\n\n            }) //P.$root\n\n        aria( P.$root[0], 'hidden', true )\n    }", "label": 3}
{"code": "async function extractTypedef(config) {\n  const {\n    source,\n    destination,\n    writable,\n  } = config\n  try {\n    const s = createReadStream(source)\n    const ts = createRegexTransformStream(typedefRe)\n    const ps = new Properties()\n    const readable = new PassThrough()\n    const xml = new XML()\n\n    await writeOnce(readable, '<types>\\n')\n\n    s.pipe(ts).pipe(ps).pipe(xml).pipe(readable, { end: false })\n\n    const p = whichStream({\n      readable,\n      source,\n      writable,\n      destination,\n    })\n\n    await new Promise((r, j) => {\n      s.on('error', e => { LOG('Error in Read'); j(e) })\n      ts.on('error', e => { LOG('Error in Transform'); j(e) })\n      ps.on('error', e => { LOG('Error in RegexTransform'); j(e) })\n      xml.on('error', e => { LOG('Error in XML'); j(e) })\n      readable.on('error', e => { LOG('Error in Stream'); j(e) })\n      xml.on('end', r)\n    })\n\n    await new Promise(r => readable.end('</types>\\n', r))\n    await p\n  } catch (err) {\n    catcher(err)\n  }\n}", "label": 3}
{"code": "def wait_for_logs_matching(self, matcher, timeout=10, encoding='utf-8',\n                               **logs_kwargs):\n        \"\"\"\n        Wait for logs matching the given matcher.\n        \"\"\"\n        wait_for_logs_matching(\n            self.inner(), matcher, timeout=timeout, encoding=encoding,\n            **logs_kwargs)", "label": 1}
{"code": "func DialWithDeadline(network string, addr string, config *ssh.ClientConfig) (*ssh.Client, error) {\n\tconn, err := net.DialTimeout(network, addr, config.Timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewClientConnWithDeadline(conn, addr, config)\n}", "label": 5}
{"code": "def canonical_path(path)\n      if Gem.win_platform?\n        unless File.exist?(path)\n          raise PDK::CLI::FatalError, _(\"Cannot resolve a full path to '%{path}', as it does not currently exist.\") % { path: path }\n        end\n        PDK::Util::Windows::File.get_long_pathname(path)\n      else\n        File.expand_path(path)\n      end\n    end", "label": 4}
{"code": "public static cmppolicylabel get(nitro_service service, String labelname) throws Exception{\n\t\tcmppolicylabel obj = new cmppolicylabel();\n\t\tobj.set_labelname(labelname);\n\t\tcmppolicylabel response = (cmppolicylabel) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static function serialize($filename, $instance, $force = false)\n    {\n        if ($filename == '') {\n            throw new \\danog\\MadelineProto\\Exception('Empty filename');\n        }\n        if ($instance->API->asyncInitPromise) {\n            return $instance->call(static function () use ($filename, $instance, $force) {\n                yield $instance->API->asyncInitPromise;\n                $instance->API->asyncInitPromise = null;\n                return self::serialize($filename, $instance, $force);\n            });\n        }\n        if (isset($instance->API->setdem) && $instance->API->setdem) {\n            $instance->API->setdem = false;\n            $instance->API->__construct($instance->API->settings);\n        }\n        if ($instance->API === null && !$instance->getting_api_id) {\n            return false;\n        }\n        $instance->serialized = time();\n        $realpaths = self::realpaths($filename);\n        if (!file_exists($realpaths['lockfile'])) {\n            touch($realpaths['lockfile']);\n            clearstatcache();\n        }\n        $realpaths['lockfile'] = fopen($realpaths['lockfile'], 'w');\n        \\danog\\MadelineProto\\Logger::log('Waiting for exclusive lock of serialization lockfile...');\n        flock($realpaths['lockfile'], LOCK_EX);\n        \\danog\\MadelineProto\\Logger::log('Lock acquired, serializing');\n\n        try {\n            if (!$instance->getting_api_id) {\n                $update_closure = $instance->API->settings['updates']['callback'];\n                if ($instance->API->settings['updates']['callback'] instanceof \\Closure) {\n                    $instance->API->settings['updates']['callback'] = [$instance->API, 'noop'];\n                }\n                $logger_closure = $instance->API->settings['logger']['logger_param'];\n                if ($instance->API->settings['logger']['logger_param'] instanceof \\Closure) {\n                    $instance->API->settings['logger']['logger_param'] = [$instance->API, 'noop'];\n                }\n            }\n            $wrote = file_put_contents($realpaths['tempfile'], serialize($instance));\n            rename($realpaths['tempfile'], $realpaths['file']);\n        } finally {\n            if (!$instance->getting_api_id) {\n                $instance->API->settings['updates']['callback'] = $update_closure;\n                $instance->API->settings['logger']['logger_param'] = $logger_closure;\n            }\n            flock($realpaths['lockfile'], LOCK_UN);\n            fclose($realpaths['lockfile']);\n        }\n\n        return $wrote;\n    }", "label": 2}
{"code": "function storeOfflineLogin(credentials, serverOptions, loginResponse) {\n    return cipher.encryptJson(credentials['password'], loginResponse).then(function (value) {\n        localStorage().setItem(computeLocalStorageKey(serverOptions), JSON.stringify(value));\n        return loginResponse;\n    });\n}", "label": 3}
{"code": "function (state, char) {\n                gpf.interfaces.ignoreParameter(state);\n                gpf.interfaces.ignoreParameter(char);\n                gpf.Error.abstract();\n                // return -1;\n            }", "label": 3}
{"code": "def purge_queue():\n    \"\"\"Purge indexing queue.\"\"\"\n    def action(queue):\n        queue.purge()\n        click.secho('Indexing queue has been purged.', fg='green')\n        return queue\n    return action", "label": 1}
{"code": "def not_found(res, path)\n      path = ::Rack::Utils.escape_html(path)\n      res.status = 404\n      res.write \"<html><head></head><body><h1>File Not Found</h1><p>#{path}</p></body></html>\"\n      res.finish\n    end", "label": 4}
{"code": "def body\n      if raw_post = get_header(\"RAW_POST_DATA\")\n        raw_post = raw_post.dup.force_encoding(Encoding::BINARY)\n        StringIO.new(raw_post)\n      else\n        body_stream\n      end\n    end", "label": 4}
{"code": "public function setExampleCount($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::INT32);\n        $this->example_count = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public DescriptorRepository readDescriptorRepository(InputStream inst)\r\n    {\r\n        try\r\n        {\r\n            RepositoryPersistor persistor = new RepositoryPersistor();\r\n            return persistor.readDescriptorRepository(inst);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new MetadataException(\"Can not read repository \" + inst, e);\r\n        }\r\n    }", "label": 0}
{"code": "function adaptInputValidator(legacyValidator) {\n  return function adaptedInputValidator(inputValue, extraParams) {\n    return legacyValidator.call(this, inputValue, extraParams).then(function () {\n      return undefined;\n    }, function (validationMessage) {\n      return validationMessage;\n    });\n  };\n}", "label": 3}
{"code": "def state_push(self):\n        \"\"\"\n        Push the state of all generators\n        \"\"\"\n        super(Composite,self).state_push()\n        for gen in self.generators:\n            gen.state_push()", "label": 1}
{"code": "def bulk_edit(self, _fields, ids=None, filter=None, type=None, all=False): # pylint: disable=redefined-builtin\n        \"\"\"Bulk edit a set of packages.\n\n        :param _fields: :class:`packages.Package <packages.Package>` object\n        :param ids: (optional) Int list of package IDs.\n        :param filter: (optional) String list of filters.\n        :param type: (optional) `union` or `inter` as string.\n        :param all: (optional) Apply to all if bool `True`.\n        \"\"\"\n        schema = PackageSchema(exclude=('id', 'created', 'updated', 'test_count', 'agent_id', 'result_id'))\n        _fields = self.service.encode(schema, _fields, skip_none=True)\n        return self.service.bulk_edit(self.base, self.RESOURCE,\n                                      _fields, ids=ids, filter=filter, type=type, all=all)", "label": 1}
{"code": "func entitiesFieldRemove(field types.CustomFieldDef) {\n\tentities := Map.All(field.ManagedObjectType)\n\tfor _, e := range entities {\n\t\tentity := e.Entity()\n\t\tMap.WithLock(entity, func() {\n\t\t\taFields := entity.AvailableField\n\t\t\tfor i, aField := range aFields {\n\t\t\t\tif aField.Key == field.Key {\n\t\t\t\t\tentity.AvailableField = append(aFields[:i], aFields[i+1:]...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalues := e.Entity().Value\n\t\t\tfor i, value := range values {\n\t\t\t\tif value.(*types.CustomFieldStringValue).Key == field.Key {\n\t\t\t\t\tentity.Value = append(values[:i], values[i+1:]...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcValues := e.Entity().CustomValue\n\t\t\tfor i, cValue := range cValues {\n\t\t\t\tif cValue.(*types.CustomFieldStringValue).Key == field.Key {\n\t\t\t\t\tentity.CustomValue = append(cValues[:i], cValues[i+1:]...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}", "label": 5}
{"code": "func ExpectAlreadyExists(c *check.C, err error) {\n\tc.Assert(trace.IsAlreadyExists(err), check.Equals, true, check.Commentf(\"expected AlreadyExists, got %T %v at %v\", trace.Unwrap(err), err, string(debug.Stack())))\n}", "label": 5}
{"code": "func (m *MockIndex) Slice(arg0 []int, arg1 []byte) [3]int {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Slice\", arg0, arg1)\n\tret0, _ := ret[0].([3]int)\n\treturn ret0\n}", "label": 5}
{"code": "function checkSavedData(dbName, objStore, data) {\n    const keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n    const value = keyValueContainer ? data.value : data;\n    const objStoreMeta = objStoresMeta.get(dbName).get(objStore.name);\n    let key = keyValueContainer ? data.key : undefined;\n\n    const keyPath = objStore.keyPath || objStoreMeta.keyPath;\n    const autoIncrement = objStore.autoIncrement || objStoreMeta.autoIncrement;\n\n    if (keyPath === null) {\n        if (!autoIncrement && key === undefined) {\n            key = uuid();\n        }\n    } else {\n        if (typeof data !== 'object') {\n            return false;\n        }\n\n        // TODO: support dot-separated and array keyPaths\n        if (!autoIncrement && data[keyPath] === undefined) {\n            data[keyPath] = uuid();\n        }\n    }\n\n    return key ? [value, key] : [value];\n}", "label": 3}
{"code": "func InitOSContext() func() {\n\truntime.LockOSThread()\n\tif err := ns.SetNamespace(); err != nil {\n\t\tlogrus.Error(err)\n\t}\n\treturn runtime.UnlockOSThread\n}", "label": 5}
{"code": "public function setFieldTransformations($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\FieldTransformation::class);\n        $this->field_transformations = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_responses delete(nitro_service client, nsip6 resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tnsip6 deleteresources[] = new nsip6[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tdeleteresources[i] = new nsip6();\n\t\t\t\tdeleteresources[i].ipv6address = resources[i].ipv6address;\n\t\t\t\tdeleteresources[i].td = resources[i].td;\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def async_producer(delivery_interval: 0, delivery_threshold: 0, max_queue_size: 1000, max_retries: -1, retry_backoff: 0, **options)\n      sync_producer = producer(**options)\n\n      AsyncProducer.new(\n        sync_producer: sync_producer,\n        delivery_interval: delivery_interval,\n        delivery_threshold: delivery_threshold,\n        max_queue_size: max_queue_size,\n        max_retries: max_retries,\n        retry_backoff: retry_backoff,\n        instrumenter: @instrumenter,\n        logger: @logger,\n      )\n    end", "label": 4}
{"code": "public void afterMaterialization(IndirectionHandler handler, Object materializedObject)\r\n    {\r\n        try\r\n        {\r\n            Identity oid = handler.getIdentity();\r\n            if (log.isDebugEnabled())\r\n            log.debug(\"deferred registration: \" + oid);\r\n            if(!isOpen())\r\n            {\r\n                log.error(\"Proxy object materialization outside of a running tx, obj=\" + oid);\r\n                try{throw new Exception(\"Proxy object materialization outside of a running tx, obj=\" + oid);}catch(Exception e)\r\n                {\r\n                e.printStackTrace();\r\n                }\r\n            }\r\n            ClassDescriptor cld = getBroker().getClassDescriptor(materializedObject.getClass());\r\n            RuntimeObject rt = new RuntimeObject(materializedObject, oid, cld, false, false);\r\n            lockAndRegister(rt, Transaction.READ, isImplicitLocking(), getRegistrationList());\r\n        }\r\n        catch (Throwable t)\r\n        {\r\n            log.error(\"Register materialized object with this tx failed\", t);\r\n            throw new LockNotGrantedException(t.getMessage());\r\n        }\r\n        unregisterFromIndirectionHandler(handler);\r\n    }", "label": 0}
{"code": "func newRPCClient(c *Client) (*RPCClient, error) {\n\t// Connect to the client\n\tconn, err := net.Dial(c.address.Network(), c.address.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif tcpConn, ok := conn.(*net.TCPConn); ok {\n\t\t// Make sure to set keep alive so that the connection doesn't die\n\t\ttcpConn.SetKeepAlive(true)\n\t}\n\n\tif c.config.TLSConfig != nil {\n\t\tconn = tls.Client(conn, c.config.TLSConfig)\n\t}\n\n\t// Create the actual RPC client\n\tresult, err := NewRPCClient(conn, c.config.Plugins)\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\t// Begin the stream syncing so that stdin, out, err work properly\n\terr = result.SyncStreams(\n\t\tc.config.SyncStdout,\n\t\tc.config.SyncStderr)\n\tif err != nil {\n\t\tresult.Close()\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}", "label": 5}
{"code": "public function route(string $name, array $parameters = [], bool $absolute = true): self\n    {\n        $this->route = route($name, $parameters, $absolute);\n\n        $this->active([$this->route, $this->route.'/*']);\n\n        return $this;\n    }", "label": 2}
{"code": "function() {\n      if (this.xhr) {\n        this.xhr.abort();\n      } else if (this.config) {\n        this.config.complete.call(this, this.xhr, 'abort');\n      }\n\n      // Cleanup leftover state.\n      if (this.xhr) {\n        this.xhr = undefined;\n        delete this.xhr;\n      }\n      if (this.config) {\n        this.config = undefined;\n        delete this.config;\n      }\n\n      return this;\n    }", "label": 3}
{"code": "public static List<String> asListLinesIgnore(String content, Pattern ignorePattern) {\n    List<String> retorno = new ArrayList<String>();\n    content = content.replace(CARRIAGE_RETURN, RETURN);\n    content = content.replace(RETURN, CARRIAGE_RETURN);\n    for (String str : content.split(CARRIAGE_RETURN)) {\n      if (!ignorePattern.matcher(str).matches()) {\n        retorno.add(str);\n      }\n    }\n    return retorno;\n  }", "label": 0}
{"code": "private int getBeliefCount() {\n        Integer count = (Integer)introspector.getBeliefBase(ListenerMockAgent.this).get(Definitions.RECEIVED_MESSAGE_COUNT);\n        if (count == null) count = 0; // Just in case, not really sure if this is necessary.\n        return count;\n    }", "label": 0}
{"code": "func assertionsToTraitMap(assertionInfo saml2.AssertionInfo) map[string][]string {\n\ttraits := make(map[string][]string)\n\n\tfor _, assr := range assertionInfo.Values {\n\t\tvar vals []string\n\t\tfor _, value := range assr.Values {\n\t\t\tvals = append(vals, value.Value)\n\t\t}\n\t\ttraits[assr.Name] = vals\n\t}\n\n\treturn traits\n}", "label": 5}
{"code": "def previous_occurrences(num, from)\n      from = TimeUtil.match_zone(from, start_time) or raise ArgumentError, \"Time required, got #{from.inspect}\"\n      return [] if from <= start_time\n      a = enumerate_occurrences(start_time, from - 1).to_a\n      a.size > num ? a[-1*num,a.size] : a\n    end", "label": 4}
{"code": "function() {\n    // First deal only with doc-comments\n    doc_comments = _.filter(docs, function(d) {\n      return d[\"type\"] == \"doc_comment\";\n    });\n\n    // Detect code in each docset.  Sometimes a docset has already\n    // been detected as part of detecting some previous docset (like\n    // Class detecting all of its configs) - in such case, skip.\n    _.each(doc_comments, function(docset) {\n      code = docset[\"code\"];\n      \n      if ( !(code && code[\"tagname\"]) )\n        docset[\"code\"] = detect(code);\n      else\n        docset[\"code\"] = \"\";\n    });\n\n    // Return all doc-comments + other comments for which related\n    // code was detected.\n    return _.filter(docs, function(d) {\n      return d[\"type\"] == \"doc_comment\" || d[\"code\"] && d[\"code\"][\"tagname\"];\n    });\n  }", "label": 3}
{"code": "def normalized_authority\n      return nil unless self.authority\n      @normalized_authority ||= begin\n        authority = String.new\n        if self.normalized_userinfo != nil\n          authority << \"#{self.normalized_userinfo}@\"\n        end\n        authority << self.normalized_host\n        if self.normalized_port != nil\n          authority << \":#{self.normalized_port}\"\n        end\n        authority\n      end\n      # All normalized values should be UTF-8\n      if @normalized_authority\n        @normalized_authority.force_encoding(Encoding::UTF_8)\n      end\n      @normalized_authority\n    end", "label": 4}
{"code": "function addSentinels(container, className, stickySelector = STICKY_SELECTOR) {\n  return Array.from(container.querySelectorAll(stickySelector)).map((stickyElement) => {\n    const sentinel = document.createElement('div');\n    const stickyParent = stickyElement.parentElement;\n\n    // Apply styles to the sticky element\n\n    stickyElement.style.cssText = `\n      position: -webkit-sticky;\n      position: sticky;\n    `;\n\n    // Apply default sentinel styles\n\n    sentinel.classList.add(ClassName.SENTINEL, className);\n\n    Object.assign(sentinel.style,{\n      left: 0,\n      position: 'absolute',\n      right: 0,\n      visibility: 'hidden',\n    });\n\n    switch (className) {\n      case ClassName.SENTINEL_TOP: {\n        stickyParent.insertBefore(sentinel, stickyElement);\n\n        // Apply styles specific to the top sentinel\n\n        Object.assign(\n          sentinel.style,\n          getSentinelPosition(stickyElement, sentinel, className),\n          { position: 'relative' },\n        );\n\n        break;\n      }\n\n      case ClassName.SENTINEL_BOTTOM: {\n        stickyParent.appendChild(sentinel);\n\n        // Apply styles specific to the bottom sentinel\n\n        Object.assign(sentinel.style, getSentinelPosition(stickyElement, sentinel, className));\n\n        break;\n      }\n    }\n\n    return sentinel;\n  });\n}", "label": 3}
{"code": "def send_file(resource, env)\n      file     = ::Rack::File.new nil\n      path     = resource.file_descriptor[:full_path]\n      if !file.respond_to?(:path=)\n        request  = ::Rack::Request.new(env)\n        response = file.serving(request, path)\n      else\n        file.path = path\n        response = file.serving(env)\n      end\n      status = response[0]\n      response[1]['Content-Encoding'] = 'gzip' if %w[.svgz .gz].include?(resource.ext)\n      # Do not set Content-Type if status is 1xx, 204, 205 or 304, otherwise\n      # Rack will throw an error (500)\n      if !(100..199).cover?(status) && ![204, 205, 304].include?(status)\n        response[1]['Content-Type'] = resource.content_type || (resource.binary? ? 'application/octet-stream' : 'text/plain')\n      end\n\n      halt response\n    end", "label": 4}
{"code": "def bitbucket_pr_from_env(env)\n      branch_name = env[\"BITBUCKET_BRANCH_NAME\"]\n      repo_slug   = env[\"BITBUCKET_REPO_SLUG\"]\n      begin\n        Danger::RequestSources::BitbucketCloudAPI.new(repo_slug, nil, branch_name, env).pull_request_id\n      rescue\n        raise \"Failed to find a pull request for branch \\\"#{branch_name}\\\" on Bitbucket.\"\n      end\n    end", "label": 4}
{"code": "public static base_response restart(nitro_service client) throws Exception {\n\t\tdbsmonitors restartresource = new dbsmonitors();\n\t\treturn restartresource.perform_operation(client,\"restart\");\n\t}", "label": 0}
{"code": "public static function detect($index = 0)\n    {\n        $context = new Context();\n        $backtrace = debug_backtrace();\n        $position = $backtrace[$index];\n        if (isset($position['file'])) {\n            $context->filename = $position['file'];\n        }\n        if (isset($position['line'])) {\n            $context->line = $position['line'];\n        }\n        $caller = isset($backtrace[$index + 1]) ? $backtrace[$index + 1] : null;\n        if (isset($caller['function'])) {\n            $context->method = $caller['function'];\n            if (isset($caller['type']) && $caller['type'] === '::') {\n                $context->static = true;\n            }\n        }\n        if (isset($caller['class'])) {\n            $fqn = explode('\\\\', $caller['class']);\n            $context->class = array_pop($fqn);\n            if (count($fqn)) {\n                $context->namespace = implode('\\\\', $fqn);\n            }\n        }\n\n        // @todo extract namespaces and use statements\n        return $context;\n    }", "label": 2}
{"code": "func (s *Session) Put(item mo.Reference) mo.Reference {\n\tref := item.Reference()\n\tif ref.Value == \"\" {\n\t\tref.Value = fmt.Sprintf(\"session[%s]%s\", s.Key, uuid.New())\n\t}\n\ts.Registry.setReference(item, ref)\n\treturn s.Registry.Put(item)\n}", "label": 5}
{"code": "func (cli *NetworkCli) CmdServiceUnpublish(chain string, args ...string) error {\n\tcmd := cli.Subcmd(chain, \"unpublish\", \"SERVICE[.NETWORK]\", \"Removes a service\", false)\n\tforce := cmd.Bool([]string{\"f\", \"-force\"}, false, \"force unpublish service\")\n\tcmd.Require(flag.Exact, 1)\n\terr := cmd.ParseFlags(args, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsn, nn := parseServiceName(cmd.Arg(0))\n\tserviceID, err := lookupServiceID(cli, nn, sn)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsd := serviceDelete{Name: sn, Force: *force}\n\t_, _, err = readBody(cli.call(\"DELETE\", \"/services/\"+serviceID, sd, nil))\n\n\treturn err\n}", "label": 5}
{"code": "func updateDBVersion(tx *sql.Tx, version int) error {\n\t// ql doesn't have an INSERT OR UPDATE function so\n\t// it's faster to remove and reinsert the row\n\t_, err := tx.Exec(\"DELETE FROM version\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = tx.Exec(\"INSERT INTO version VALUES ($1)\", version)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function(ids) {\n            this.remove(_.difference(this.trackedIds, ids));\n            parentInstance.registerIds(ids, ownerKey);\n            this.trackedIds = ids;\n          }", "label": 3}
{"code": "def open(filename, connection=None):\n    \"\"\"Edits or Adds a filename ensuring the file is in perforce and editable\n\n    :param filename: File to check out\n    :type filename: str\n    :param connection: Connection object to use\n    :type connection: :py:class:`Connection`\n    \"\"\"\n    c = connection or connect()\n    res = c.ls(filename)\n    if res and res[0].revision:\n        res[0].edit()\n    else:\n        c.add(filename)", "label": 1}
{"code": "def enabled_ad_hoc_hooks(hook_context)\n      @hash[hook_context.hook_class_name].keys.\n        reject { |hook_name| hook_name == 'ALL' }.\n        select { |hook_name| ad_hoc_hook?(hook_context, hook_name) }.\n        select { |hook_name| hook_enabled?(hook_context, hook_name) }\n    end", "label": 4}
{"code": "public static base_responses update(nitro_service client, dbdbprofile resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tdbdbprofile updateresources[] = new dbdbprofile[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new dbdbprofile();\n\t\t\t\tupdateresources[i].name = resources[i].name;\n\t\t\t\tupdateresources[i].interpretquery = resources[i].interpretquery;\n\t\t\t\tupdateresources[i].stickiness = resources[i].stickiness;\n\t\t\t\tupdateresources[i].kcdaccount = resources[i].kcdaccount;\n\t\t\t\tupdateresources[i].conmultiplex = resources[i].conmultiplex;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def bulk_copy(self, ids):\n        \"\"\"Bulk copy a set of configs.\n\n        :param ids: Int list of config IDs.\n        :return: :class:`configs.Config <configs.Config>` list\n        \"\"\"\n        schema = self.GET_SCHEMA\n        return self.service.bulk_copy(self.base, self.RESOURCE, ids, schema)", "label": 1}
{"code": "def better_result(base_result, result = nil)\n      base_result ||= {}\n      return base_result unless result\n\n      return result unless base_result.values.find { |e| e[:possible].any? }\n\n      return result if result.values.find { |e| e[:valid].any? }\n\n      base_result\n    end", "label": 4}
{"code": "public function analyzeEntitySentiment($content, array $options = [])\n    {\n        return new Annotation(\n            $this->connection->analyzeEntitySentiment(\n                $this->formatRequest($content, $options)\n            )\n        );\n    }", "label": 2}
{"code": "public function SendNotificationChannelVerificationCode(\\Google\\Cloud\\Monitoring\\V3\\SendNotificationChannelVerificationCodeRequest $argument,\n      $metadata = [], $options = []) {\n        return $this->_simpleRequest('/google.monitoring.v3.NotificationChannelService/SendNotificationChannelVerificationCode',\n        $argument,\n        ['\\Google\\Protobuf\\GPBEmpty', 'decode'],\n        $metadata, $options);\n    }", "label": 2}
{"code": "def _line_2_pair(line):\n    '''Return bash variable declaration as name-value pair.\n\n    Name as lower case str. Value itself only without surrounding '\"' (if any).\n\n    For example, _line_2_pair('NAME=\"Ubuntu\"') will return ('name', 'Ubuntu')\n    '''\n    key, val = line.split('=')\n    return key.lower(), val.strip('\"')", "label": 1}
{"code": "def extract_text(element, prefix=\"\", restore_whitespace = true)\n      quotes = {\n        :rdquo => '\"',\n        :ldquo => '\"',\n        :lsquo => \"'\",\n        :rsquo => \"'\"\n      }\n      # If anything goes amiss here, e.g. unknown type, then nil will be\n      # returned and we'll just not catch that part of the text, which seems\n      # like a sensible failure mode.\n      lines = element.children.map { |e|\n        if e.type == :text\n          e.value\n        elsif [:strong, :em, :p, :codespan].include?(e.type)\n          extract_text(e, prefix, restore_whitespace).join(\"\\n\")\n        elsif e.type == :smart_quote\n          quotes[e.value]\n        end\n      }.join.split(\"\\n\")\n      # Text blocks have whitespace stripped, so we need to add it back in at\n      # the beginning. Because this might be in something like a blockquote,\n      # we optionally strip off a prefix given to the function.\n      if restore_whitespace\n        lines[0] = element_line(element).sub(prefix, \"\")\n      end\n      lines\n    end", "label": 4}
{"code": "def pivot(self, a, b, Keep=None, NullVals=None, order = None, prefix='_'):\n        \"\"\"\n        Pivot with `a` as the row axis and `b` values as the column axis.\n\n        Method wraps::\n\n                tabular.spreadsheet.pivot(X, a, b, Keep)\n\n        \"\"\"\n        [data,coloring] = spreadsheet.pivot(X=self, a=a, b=b, Keep=Keep, \n                          NullVals=NullVals, order=order, prefix=prefix)\n        data = data.view(tabarray)\n        data.coloring = coloring\n        return data", "label": 1}
{"code": "def env_or_default(var, default=None):\n    \"\"\"Get environment variable or provide default.\n\n    Args:\n        var (str): environment variable to search for\n        default (optional(str)): default to return\n    \"\"\"\n    if var in os.environ:\n        return os.environ[var]\n    return default", "label": 1}
{"code": "function gen(spark, fn) {\n    crypto.randomBytes(8, function generated(err, buff) {\n      if (err) return fn(err);\n\n      fn(undefined, buff.toString('hex'));\n    });\n  }", "label": 3}
{"code": "function bootWebWorker({ Worker }) {\n  const webWorker = Object.assign(\n    new Worker(\"pubcontrol-browser-demo.webworker.js\"),\n    {\n      onmessage: event => {\n        console.debug(\"Message received from worker\", event.data.type, event);\n      }\n    }\n  );\n  webWorker.postMessage({\n    type: \"Hello\",\n    from: \"browser\",\n    content: \"Hello worker. I booted you out here in pubcontrol-browser-demo.\"\n  });\n  const url = new URL(global.location.href);\n  const epcp = {\n    uri: url.searchParams.get(\"epcp.uri\"),\n    defaultChannel: url.searchParams.get(\"epcp.defaultChannel\")\n  };\n  if (![epcp.uri, epcp.defaultChannel].every(Boolean)) {\n    console.warn(\n      \"Missing one of ?epcp.uri or ?epcp.defaultChannel query params.\"\n    );\n  }\n  webWorker.postMessage({\n    type: \"EPCPConfiguration\",\n    ...epcp\n  });\n}", "label": 3}
{"code": "def xrb_address_to_public_key(address):\n    \"\"\"\n    Convert an xrb address to public key in bytes\n\n    >>> xrb_address_to_public_key('xrb_1e3i81r51e3i81r51e3i81r51e3i'\\\n                                  '81r51e3i81r51e3i81r51e3imxssakuq')\n    b'00000000000000000000000000000000'\n\n    :param address: xrb address\n    :type address: bytes\n\n    :return: public key in bytes\n    :rtype: bytes\n\n    :raises ValueError:\n    \"\"\"\n\n    address = bytearray(address, 'ascii')\n\n    if not address.startswith(b'xrb_'):\n        raise ValueError('address does not start with xrb_: %s' % address)\n\n    if len(address) != 64:\n        raise ValueError('address must be 64 chars long: %s' % address)\n\n    address = bytes(address)\n    key_b32xrb = b'1111' + address[4:56]\n    key_bytes = b32xrb_decode(key_b32xrb)[3:]\n    checksum = address[56:]\n\n    if b32xrb_encode(address_checksum(key_bytes)) != checksum:\n        raise ValueError('invalid address, invalid checksum: %s' % address)\n\n    return key_bytes", "label": 1}
{"code": "func (c *Manager) FilterLibraryItem(ctx context.Context, libraryItemID string, filter FilterRequest) (FilterResponse, error) {\n\turl := internal.URL(c, internal.VCenterOVFLibraryItem).WithID(libraryItemID).WithAction(\"filter\")\n\tvar res FilterResponse\n\treturn res, c.Do(ctx, url.Request(http.MethodPost, filter), &res)\n}", "label": 5}
{"code": "def parse_value xpath\n      node = parser_xml.xpath(xpath)\n      return nil if node.empty?\n      node.text.strip\n    end", "label": 4}
{"code": "def searchAccession(acc):\n    \"\"\"\n    attempt to use NCBI Entrez to get\n    BioSample ID\n    \"\"\"\n    # try genbank file\n    # genome database\n    out, error = entrez('genome', acc)\n    for line in out.splitlines():\n        line = line.decode('ascii').strip()\n        if 'Assembly_Accession' in line or 'BioSample' in line:\n            newAcc = line.split('>')[1].split('<')[0].split('.')[0].split(',')[0]\n            if len(newAcc) > 0:\n                return (True, acc, newAcc)\n    # nucleotide database\n    out, error = entrez('nucleotide', acc)\n    for line in out.splitlines():\n        line = line.decode('ascii').strip()\n        if 'Assembly_Accession' in line or 'BioSample' in line:\n            newAcc = line.split('>')[1].split('<')[0].split('.')[0].split(',')[0]\n            if len(newAcc) > 0:\n                return (True, acc, newAcc)\n    # assembly database\n    out, error = entrez('assembly', acc)\n    for line in out.splitlines():\n        line = line.decode('ascii').strip()\n        if 'Assembly_Accession' in line or 'BioSample' in line:\n            newAcc = line.split('>')[1].split('<')[0].split('.')[0].split(',')[0]\n            if len(newAcc) > 0:\n                return (True, acc, newAcc)\n    for error in error.splitlines():\n        error = error.decode('ascii').strip()\n        if '500 Can' in error:\n            return (False, acc, 'no network')\n    return (False, acc, 'efetch failed')", "label": 1}
{"code": "function _gpfDefineClassImport(InstanceBuilder) {\n        var entityDefinition = _gpfDefineEntitiesFindByConstructor(InstanceBuilder);\n        if (entityDefinition) {\n            return entityDefinition;\n        }\n        return _gpfDefineClassImportFrom(InstanceBuilder, _gpfDefineClassImportGetDefinition(InstanceBuilder));\n    }", "label": 3}
{"code": "def associate_tagged_prs(tags, prs, total)\n      @fetcher.fetch_tag_shas_async(tags)\n\n      i = 0\n      prs.reject do |pr|\n        found = false\n        # XXX Wish I could use merge_commit_sha, but gcg doesn't currently\n        # fetch that. See\n        # https://developer.github.com/v3/pulls/#get-a-single-pull-request vs.\n        # https://developer.github.com/v3/pulls/#list-pull-requests\n        if pr[\"events\"] && (event = pr[\"events\"].find { |e| e[\"event\"] == \"merged\" })\n          # Iterate tags.reverse (oldest to newest) to find first tag of each PR.\n          if (oldest_tag = tags.reverse.find { |tag| tag[\"shas_in_tag\"].include?(event[\"commit_id\"]) })\n            pr[\"first_occurring_tag\"] = oldest_tag[\"name\"]\n            found = true\n            i += 1\n            print(\"Associating PRs with tags: #{i}/#{total}\\r\") if @options[:verbose]\n          end\n        else\n          # Either there were no events or no merged event. Github's api can be\n          # weird like that apparently. Check for a rebased comment before erroring.\n          no_events_pr = associate_rebase_comment_prs(tags, [pr], total)\n          raise StandardError, \"No merge sha found for PR #{pr['number']} via the GitHub API\" unless no_events_pr.empty?\n\n          found = true\n          i += 1\n          print(\"Associating PRs with tags: #{i}/#{total}\\r\") if @options[:verbose]\n        end\n        found\n      end\n    end", "label": 4}
{"code": "private void distributedProcessFinish(ResponseBuilder rb,\n      ComponentFields mtasFields) throws IOException {\n    // rewrite\n\n    Object mtasResponseRaw;\n    if ((mtasResponseRaw = rb.rsp.getValues().get(\"mtas\")) != null\n        && mtasResponseRaw instanceof NamedList) {\n      NamedList<Object> mtasResponse = (NamedList<Object>) mtasResponseRaw;\n      Object mtasResponseTermvectorRaw;\n      if ((mtasResponseTermvectorRaw = mtasResponse.get(NAME)) != null\n          && mtasResponseTermvectorRaw instanceof ArrayList) {\n        MtasSolrResultUtil.rewrite(\n            (ArrayList<Object>) mtasResponseTermvectorRaw, searchComponent);\n      }\n    }\n  }", "label": 0}
{"code": "func (args Arguments) Is(objects ...interface{}) bool {\n\tfor i, obj := range args {\n\t\tif obj != objects[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "label": 5}
{"code": "func NewServer(kind, name, addr, namespace string) *services.ServerV2 {\n\treturn &services.ServerV2{\n\t\tKind:    kind,\n\t\tVersion: services.V2,\n\t\tMetadata: services.Metadata{\n\t\t\tName:      name,\n\t\t\tNamespace: namespace,\n\t\t},\n\t\tSpec: services.ServerSpecV2{\n\t\t\tAddr:       addr,\n\t\t\tPublicAddr: addr,\n\t\t},\n\t}\n}", "label": 5}
{"code": "function(apiClient) {\n    this.apiClient = apiClient || ApiClient.instance;\n\n\n\n    /**\n     * Finds a code\n     * Finds a code\n     * @param {String} codeId Id of the code\n     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Code}\n     */\n    this.findCode = function(codeId) {\n      var postBody = null;\n\n      // verify the required parameter 'codeId' is set\n      if (codeId == undefined || codeId == null) {\n        throw \"Missing the required parameter 'codeId' when calling findCode\";\n      }\n\n\n      var pathParams = {\n        'codeId': codeId\n      };\n      var queryParams = {\n      };\n      var headerParams = {\n      };\n      var formParams = {\n      };\n\n      var authNames = ['basicAuth'];\n      var contentTypes = ['application/json;charset=utf-8'];\n      var accepts = ['application/json;charset=utf-8'];\n      var returnType = Code;\n\n      return this.apiClient.callApi(\n        '/codes/{codeId}', 'GET',\n        pathParams, queryParams, headerParams, formParams, postBody,\n        authNames, contentTypes, accepts, returnType\n      );\n    }\n\n\n    /**\n     * Lists codes\n     * Lists codes\n     * @param {Object} opts Optional parameters\n     * @param {Array.<String>} opts.types Filter results by types\n     * @param {String} opts.search Search codes by free-text query\n     * @param {String} opts.sortBy define order (NATURAL or SCORE). Default is SCORE\n     * @param {String} opts.sortDir ASC or DESC. Default is ASC\n     * @param {Integer} opts.firstResult First result\n     * @param {Integer} opts.maxResults Max results\n     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Code>}\n     */\n    this.listCodes = function(opts) {\n      opts = opts || {};\n      var postBody = null;\n\n\n      var pathParams = {\n      };\n      var queryParams = {\n        'types': this.apiClient.buildCollectionParam(opts['types'], 'csv'),\n        'search': opts['search'],\n        'sortBy': opts['sortBy'],\n        'sortDir': opts['sortDir'],\n        'firstResult': opts['firstResult'],\n        'maxResults': opts['maxResults']\n      };\n      var headerParams = {\n      };\n      var formParams = {\n      };\n\n      var authNames = ['basicAuth'];\n      var contentTypes = ['application/json;charset=utf-8'];\n      var accepts = ['application/json;charset=utf-8'];\n      var returnType = [Code];\n\n      return this.apiClient.callApi(\n        '/codes', 'GET',\n        pathParams, queryParams, headerParams, formParams, postBody,\n        authNames, contentTypes, accepts, returnType\n      );\n    }\n  }", "label": 3}
{"code": "func (c *Client) GetSAMLConnector(id string, withSecrets bool) (services.SAMLConnector, error) {\n\tif id == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing connector id\")\n\t}\n\tout, err := c.Get(c.Endpoint(\"saml\", \"connectors\", id),\n\t\turl.Values{\"with_secrets\": []string{fmt.Sprintf(\"%t\", withSecrets)}})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn services.GetSAMLConnectorMarshaler().UnmarshalSAMLConnector(out.Bytes(), services.SkipValidation())\n}", "label": 5}
{"code": "public function findWhereIn($field, array $values, $columns = ['*'])\n    {\n        $this->applyCriteria();\n        $this->applyScope();\n        $model = $this->model->whereIn($field, $values)->get($columns);\n        $this->resetModel();\n\n        return $this->parserResult($model);\n    }", "label": 2}
{"code": "public function executeAsyncScript($script, array $arguments = [])\n    {\n        $params = [\n            'script' => $script,\n            'args' => $this->prepareScriptArguments($arguments),\n        ];\n\n        return $this->execute(\n            DriverCommand::EXECUTE_ASYNC_SCRIPT,\n            $params\n        );\n    }", "label": 2}
{"code": "def _update_property(tree_to_update, xpath_root, xpaths, values):\n    \"\"\"\n    Default update operation for a single parser property. If xpaths contains one xpath,\n    then one element per value will be inserted at that location in the tree_to_update;\n    otherwise, the number of values must match the number of xpaths.\n    \"\"\"\n\n    # Inner function to update a specific XPATH with the values provided\n\n    def update_element(elem, idx, root, path, vals):\n        \"\"\" Internal helper function to encapsulate single item update \"\"\"\n\n        has_root = bool(root and len(path) > len(root) and path.startswith(root))\n        path, attr = get_xpath_tuple(path)  # 'path/@attr' to ('path', 'attr')\n\n        if attr:\n            removed = [get_element(elem, path)]\n            remove_element_attributes(removed[0], attr)\n        elif not has_root:\n            removed = wrap_value(remove_element(elem, path))\n        else:\n            path = get_xpath_branch(root, path)\n            removed = [] if idx != 0 else [remove_element(e, path, True) for e in get_elements(elem, root)]\n\n        if not vals:\n            return removed\n\n        items = []\n\n        for i, val in enumerate(wrap_value(vals)):\n            elem_to_update = elem\n\n            if has_root:\n                elem_to_update = insert_element(elem, (i + idx), root)\n\n            val = val.decode('utf-8') if not isinstance(val, string_types) else val\n            if not attr:\n                items.append(insert_element(elem_to_update, i, path, val))\n            elif path:\n                items.append(insert_element(elem_to_update, i, path, **{attr: val}))\n            else:\n                set_element_attributes(elem_to_update, **{attr: val})\n                items.append(elem_to_update)\n\n        return items\n\n    # Code to update each of the XPATHs with each of the values\n\n    xpaths = reduce_value(xpaths)\n    values = filter_empty(values)\n\n    if isinstance(xpaths, string_types):\n        return update_element(tree_to_update, 0, xpath_root, xpaths, values)\n    else:\n        each = []\n\n        for index, xpath in enumerate(xpaths):\n            value = values[index] if values else None\n            each.extend(update_element(tree_to_update, index, xpath_root, xpath, value))\n\n        return each", "label": 1}
{"code": "function () {\n    // Create and attach our main view\n    this.mainView = new MainView({\n      model: this.me,\n      el: document.body\n    });\n\n    // this kicks off our backbutton tracking (browser history)\n    // and will cause the first matching handler in the router\n    // to fire.\n    this.router.history.start({\n      root: '/',\n      pushState: true\n    });\n  }", "label": 3}
{"code": "public function setJavascriptEnabled($enabled)\n    {\n        $browser = $this->getBrowserName();\n        if ($browser && $browser !== WebDriverBrowserType::HTMLUNIT) {\n            throw new Exception(\n                'isJavascriptEnabled() is a htmlunit-only option. ' .\n                'See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities#read-write-capabilities.'\n            );\n        }\n\n        $this->set(WebDriverCapabilityType::JAVASCRIPT_ENABLED, $enabled);\n\n        return $this;\n    }", "label": 2}
{"code": "func (l *LoadBalancer) trackConnection(backend NetAddr, conn net.Conn) int64 {\n\tl.Lock()\n\tdefer l.Unlock()\n\tl.connID += 1\n\ttracker, ok := l.connections[backend]\n\tif !ok {\n\t\ttracker = make(map[int64]net.Conn)\n\t\tl.connections[backend] = tracker\n\t}\n\ttracker[l.connID] = conn\n\treturn l.connID\n}", "label": 5}
{"code": "def extract(uri, processor=nil)\n      match_data = self.match(uri, processor)\n      return (match_data ? match_data.mapping : nil)\n    end", "label": 4}
{"code": "func (a *ArgType) hascolumn(fields []*Field, name string) bool {\n\tfor _, f := range fields {\n\t\tif f.Col.ColumnName == name {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "label": 5}
{"code": "def conforms(self, json: str, name: str = \"\", verbose: bool=False) -> ValidationResult:\n        \"\"\" Determine whether json conforms with the JSG specification\n\n        :param json: JSON string, URI to JSON or file name with JSON\n        :param name: Test name for ValidationResult -- printed in dx if present\n        :param verbose: True means print the response\n        :return: pass/fail + fail reason\n        \"\"\"\n        json = self._to_string(json) if not self.is_json(json) else json\n        try:\n            self.json_obj = loads(json, self.module)\n        except ValueError as v:\n            return ValidationResult(False, str(v), name, None)\n        logfile = StringIO()\n        logger = Logger(cast(TextIO, logfile))      # cast because of bug in ide\n        if not is_valid(self.json_obj, logger):\n            return ValidationResult(False, logfile.getvalue().strip('\\n'), name, None)\n        return ValidationResult(True, \"\", name, type(self.json_obj).__name__)", "label": 1}
{"code": "func extractMetricValue(aggregations *core.AggregationValue, aggName core.AggregationType) *types.MetricValue {\n\tif inputVal, ok := aggregations.Aggregations[aggName]; ok {\n\t\treturn exportMetricValue(&inputVal)\n\t} else {\n\t\treturn nil\n\t}\n}", "label": 5}
{"code": "func (s *sequence) toByteArray() ([]byte, error) {\n\tvar bb []byte\n\n\tp := s\n\tfor p != nil {\n\t\tb := make([]byte, 12)\n\t\tbinary.BigEndian.PutUint32(b[0:], p.block)\n\t\tbinary.BigEndian.PutUint64(b[4:], p.count)\n\t\tbb = append(bb, b...)\n\t\tp = p.next\n\t}\n\n\treturn bb, nil\n}", "label": 5}
{"code": "def action(name, opts=nil)\n      @triggers.fire_triggers(name, :before, @name.to_s, :action)\n\n      @logger.info(\"Calling action: #{name} on provider #{@provider}\")\n\n      opts ||= {}\n\n      # Determine whether we lock or not\n      lock = true\n      lock = opts.delete(:lock) if opts.key?(:lock)\n\n      # Extra env keys are the remaining opts\n      extra_env = opts.dup\n      # An environment is required for triggers to function properly. This is\n      # passed in specifically for the `#Action::Warden` class triggers. We call it\n      # `:trigger_env` instead of `env` in case it collides with an existing environment\n      extra_env[:trigger_env] = @env\n\n      check_cwd # Warns the UI if the machine was last used on a different dir\n\n      # Create a deterministic ID for this machine\n      vf = nil\n      vf = @env.vagrantfile_name[0] if @env.vagrantfile_name\n      id = Digest::MD5.hexdigest(\n        \"#{@env.root_path}#{vf}#{@env.local_data_path}#{@name}\")\n\n      # We only lock if we're not executing an SSH action. In the future\n      # we will want to do more fine-grained unlocking in actions themselves\n      # but for a 1.6.2 release this will work.\n      locker = Proc.new { |*args, &block| block.call }\n      locker = @env.method(:lock) if lock && !name.to_s.start_with?(\"ssh\")\n\n      # Lock this machine for the duration of this action\n      return_env = locker.call(\"machine-action-#{id}\") do\n        # Get the callable from the provider.\n        callable = @provider.action(name)\n\n        # If this action doesn't exist on the provider, then an exception\n        # must be raised.\n        if callable.nil?\n          raise Errors::UnimplementedProviderAction,\n            action: name,\n            provider: @provider.to_s\n        end\n\n        # Call the action\n        ui.machine(\"action\", name.to_s, \"start\")\n        action_result = action_raw(name, callable, extra_env)\n        ui.machine(\"action\", name.to_s, \"end\")\n        action_result\n      end\n\n      @triggers.fire_triggers(name, :after, @name.to_s, :action)\n      # preserve returning environment after machine action runs\n      return return_env\n    rescue Errors::EnvironmentLockedError\n      raise Errors::MachineActionLockedError,\n        action: name,\n        name: @name\n    end", "label": 4}
{"code": "public static function shutdownHandler()\n    {\n        if ($err = error_get_last()) {\n            switch ($err['type']) {\n                case E_ERROR:\n                case E_PARSE:\n                case E_COMPILE_ERROR:\n                case E_CORE_ERROR:\n                    $service = self::$psrLogger\n                        ->getMetadataProvider()\n                        ->serviceId();\n                    $version = self::$psrLogger\n                        ->getMetadataProvider()\n                        ->versionId();\n                    $message = sprintf(\n                        '%s: %s in %s on line %d',\n                        self::getErrorPrefix($err['type']),\n                        $err['message'],\n                        $err['file'],\n                        $err['line']\n                    );\n                    $context = [\n                        'context' => [\n                            'reportLocation' => [\n                                'filePath' => $err['file'],\n                                'lineNumber' => $err['line'],\n                                'functionName' =>\n                                    self::getFunctionNameForReport(),\n                            ]\n                        ],\n                        'serviceContext' => [\n                            'service' => $service,\n                            'version' => $version\n                        ]\n                    ];\n                    if (self::$psrLogger) {\n                        self::$psrLogger->log(\n                            self::getErrorLevelString($err['type']),\n                            $message,\n                            $context\n                        );\n                    }\n                    break;\n            }\n        }\n    }", "label": 2}
{"code": "public static function refreshed(self $condition)\n    {\n        return new static(\n            function (WebDriver $driver) use ($condition) {\n                try {\n                    return call_user_func($condition->getApply(), $driver);\n                } catch (StaleElementReferenceException $e) {\n                    return null;\n                }\n            }\n        );\n    }", "label": 2}
{"code": "public function setRequestMetadata($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\RequestMetadata::class);\n        $this->request_metadata = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function extractLiteralFromInstalled(stats, element) {\n    if (element.length === 0) return stats;\n    let value = \"\";\n    if (validLiteral(element[0])) {\n        value = element[0].value;\n        // let array = value.split('$');\n        // if (array.length == 0) {\n        //     stats.setPackageName(value);\n        // } else {\n        //     stats.setPackageName(array[0]);\n        //     stats.setPackageVersion(array[1]);\n        // }\n        stats.setPackageName(value);\n    }\n    if (validLiteral(element[1])) {\n        value = element[1].value;\n        stats.setFileName(value);\n    }\n    if (validLiteral(element[2])) {\n        value = element[2].value;\n        stats.setVersion(value);\n    }\n    return stats;\n}", "label": 3}
{"code": "function message(worker, task) {\n    var callback = worker.queue[task.id]\n      , err;\n\n    // Rebuild the Error object so we can pass it to our callbacks\n    if (task.err) {\n      err = new Error(task.err.message);\n      err.stack = task.err.stack;\n    }\n\n    // Kill the whole fucking system, we are in a fucked up state and should die\n    // badly, so just throw something and have the process.uncaughtException\n    // handle it.\n    if (!callback) {\n      if (err) console.error(err);\n      console.error(task);\n      throw new Error('Unable to process message from worker, can\\'t locate the callback!');\n    }\n\n    callback(err, task);\n    delete worker.queue[task.id];\n  }", "label": 3}
{"code": "func (nDB *NetworkDB) RemoveKey(key []byte) {\n\tlogrus.Debugf(\"Remove Key %.5s\", hex.EncodeToString(key))\n\tnDB.Lock()\n\tdefer nDB.Unlock()\n\tfor i, dbKey := range nDB.config.Keys {\n\t\tif bytes.Equal(key, dbKey) {\n\t\t\tnDB.config.Keys = append(nDB.config.Keys[:i], nDB.config.Keys[i+1:]...)\n\t\t\tif nDB.keyring != nil {\n\t\t\t\tnDB.keyring.RemoveKey(dbKey)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n}", "label": 5}
{"code": "public static appflowcollector get(nitro_service service, String name) throws Exception{\n\t\tappflowcollector obj = new appflowcollector();\n\t\tobj.set_name(name);\n\t\tappflowcollector response = (appflowcollector) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function _moveToPrevChar(&$contentctr, &$charctr, $content)\n\t{\n\t\t$lastchar = false;\n\t\t$charctr--;\n\t\twhile ($charctr < 0) { // go back to previous $content[]\n\t\t\t$contentctr--;\n\t\t\tif ($contentctr < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($this->usingCoreFont) {\n\t\t\t\t$charctr = strlen($content[$contentctr]) - 1;\n\t\t\t} else {\n\t\t\t\t$charctr = mb_strlen($content[$contentctr], $this->mb_enc) - 1;\n\t\t\t}\n\t\t}\n\t\tif ($this->usingCoreFont) {\n\t\t\t$lastchar = $content[$contentctr][$charctr];\n\t\t} else {\n\t\t\t$lastchar = mb_substr($content[$contentctr], $charctr, 1, $this->mb_enc);\n\t\t}\n\t\treturn $lastchar;\n\t}", "label": 2}
{"code": "public static float calcDet(Vector3 a ,Vector3 b, Vector3 c) {\n\t\treturn (a.x*(b.y-c.y)) - (a.y*(b.x-c.x)) + (b.x*c.y-b.y*c.x);\n\t}", "label": 0}
{"code": "public function sendBroadcastImage($targets, $path, $storeURLmedia = false, $fsize = 0, $fhash = '', $caption = '')\n    {\n        if (!is_array($targets)) {\n            $targets = [$targets];\n        }\n        // Return message ID. Make pull request for this.\n        return  $this->sendMessageImage($targets, $path, $storeURLmedia, $fsize, $fhash, $caption);\n    }", "label": 2}
{"code": "function (point, i) {\n            var series = point.series,\n              args = arguments,\n              fn = typeof i === 'number' ?\n                  // Insert the value in the given position\n                function (key) {\n                    var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n                    series[key + 'Data'][i] = val;\n                } :\n                  // Apply the method specified in i with the following arguments as arguments\n                function (key) {\n                    Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n                };\n\n            each(series.parallelArrays, fn);\n        }", "label": 3}
{"code": "def remove_label(label)\n      unless label.valid?\n        errors.add(:label, \"is not valid.\")\n        return Trello.logger.warn \"Label is not valid.\" unless label.valid?\n      end\n      client.delete(\"/cards/#{id}/idLabels/#{label.id}\")\n    end", "label": 4}
{"code": "protected Map<String, List<MtasParserObject>> createCurrentList() {\n    Map<String, List<MtasParserObject>> currentList = new HashMap<>();\n    currentList.put(MAPPING_TYPE_RELATION, new ArrayList<MtasParserObject>());\n    currentList.put(MAPPING_TYPE_RELATION_ANNOTATION,\n        new ArrayList<MtasParserObject>());\n    currentList.put(MAPPING_TYPE_REF, new ArrayList<MtasParserObject>());\n    currentList.put(MAPPING_TYPE_GROUP, new ArrayList<MtasParserObject>());\n    currentList.put(MAPPING_TYPE_GROUP_ANNOTATION,\n        new ArrayList<MtasParserObject>());\n    currentList.put(MAPPING_TYPE_WORD, new ArrayList<MtasParserObject>());\n    currentList.put(MAPPING_TYPE_WORD_ANNOTATION,\n        new ArrayList<MtasParserObject>());\n    return currentList;\n  }", "label": 0}
{"code": "def invisible_recaptcha_tags(options = {})\n      options = {callback: 'invisibleRecaptchaSubmit', ui: :button}.merge options\n      text = options.delete(:text)\n      html, tag_attributes = Recaptcha::ClientHelper.recaptcha_components(options)\n      html << recaptcha_default_callback(options) if recaptcha_default_callback_required?(options)\n      case options[:ui]\n      when :button\n        html << %(<button type=\"submit\" #{tag_attributes}>#{text}</button>\\n)\n      when :invisible\n        html << %(<div data-size=\"invisible\" #{tag_attributes}></div>\\n)\n      when :input\n        html << %(<input type=\"submit\" #{tag_attributes} value=\"#{text}\"/>\\n)\n      else\n        raise(RecaptchaError, \"ReCAPTCHA ui `#{options[:ui]}` is not valid.\")\n      end\n      html.respond_to?(:html_safe) ? html.html_safe : html\n    end", "label": 4}
{"code": "async function setPreferredMcpTimezone(accessToken, timezone) {\n    let tz = getValidTimezoneOrThrow(timezone);\n\n    return mcpCustomizr.putSettings(accessToken, {\n        timezone: tz,\n    });\n}", "label": 3}
{"code": "def _discover_mac(self):\n        \"\"\" Discovers MAC address of device.\n\n        Discovery is done by sending a UDP broadcast.\n        All configured devices reply. The response contains\n        the MAC address in both needed formats.\n\n        Discovery of multiple switches must be done synchronously.\n\n        :returns: Tuple of MAC address and reversed MAC address.\n        \"\"\"\n        mac = None\n        mac_reversed = None\n        cmd = MAGIC + DISCOVERY\n        resp = self._udp_transact(cmd, self._discovery_resp,\n                                  broadcast=True,\n                                  timeout=DISCOVERY_TIMEOUT)\n        if resp:\n            (mac, mac_reversed) = resp\n        if mac is None:\n            raise S20Exception(\"Couldn't discover {}\".format(self.host))\n        return (mac, mac_reversed)", "label": 1}
{"code": "def enabled_builtin_hooks(hook_context)\n      @hash[hook_context.hook_class_name].keys.\n        reject { |hook_name| hook_name == 'ALL' }.\n        select { |hook_name| built_in_hook?(hook_context, hook_name) }.\n        select { |hook_name| hook_enabled?(hook_context, hook_name) }\n    end", "label": 4}
{"code": "function _createNewToken() {\n    var token = uuid.v4(),\n        newTokenObj = {\n            _id: crypto.createHash(token, config.crypto.secret_passphrase),\n            uid: this.userInfo._id.toString(),\n            created: new Date().toISOString(),\n            type: 'facebook'\n        };\n\n    return db.tokens.insert(newTokenObj).then(function() { return token; });\n}", "label": 3}
{"code": "func (s *Service) Handle(pattern string, handler http.Handler) {\n\ts.ServeMux.Handle(pattern, handler)\n\t// Not ideal, but avoids having to add yet another registration mechanism\n\t// so we can optionally use vapi/simulator internally.\n\tif m, ok := handler.(tagManager); ok {\n\t\ts.sdk[vim25.Path].tagManager = m\n\t}\n}", "label": 5}
{"code": "function _gpfCompatibilityInstallMethods(typeName, description) {\n        var on = description.on;\n        _gpfInstallCompatibleMethods(on, description.methods);\n        _gpfInstallCompatibleStatics(on, description.statics);\n    }", "label": 3}
{"code": "function _send(sync, messages, metaConnect, extraPath) {\n        // We must be sure that the messages have a clientId.\n        // This is not guaranteed since the handshake may take time to return\n        // (and hence the clientId is not known yet) and the application\n        // may create other messages.\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var messageId = message.id;\n\n            if (_clientId) {\n                message.clientId = _clientId;\n            }\n\n            message = _applyOutgoingExtensions(message);\n            if (message !== undefined && message !== null) {\n                // Extensions may have modified the message id, but we need to own it.\n                message.id = messageId;\n                messages[i] = message;\n            } else {\n                delete _callbacks[messageId];\n                messages.splice(i--, 1);\n            }\n        }\n\n        if (messages.length === 0) {\n            return;\n        }\n\n        var url = _cometd.getURL();\n        if (_config.appendMessageTypeToURL) {\n            // If url does not end with '/', then append it\n            if (!url.match(/\\/$/)) {\n                url = url + '/';\n            }\n            if (extraPath) {\n                url = url + extraPath;\n            }\n        }\n\n        var envelope = {\n            url: url,\n            sync: sync,\n            messages: messages,\n            onSuccess: function(rcvdMessages) {\n                try {\n                    _handleMessages.call(_cometd, rcvdMessages);\n                } catch (x) {\n                    _cometd._info('Exception during handling of messages', x);\n                }\n            },\n            onFailure: function(conduit, messages, failure) {\n                try {\n                    var transport = _cometd.getTransport();\n                    failure.connectionType = transport ? transport.getType() : \"unknown\";\n                    _handleFailure.call(_cometd, conduit, messages, failure);\n                } catch (x) {\n                    _cometd._info('Exception during handling of failure', x);\n                }\n            }\n        };\n        _cometd._debug('Send', envelope);\n        _transport.send(envelope, metaConnect);\n    }", "label": 3}
{"code": "private function wrapUploads($files): array\n    {\n        if (empty($files)) {\n            return [];\n        }\n\n        $result = [];\n        foreach ($files as $index => $f) {\n            if (!isset($f['name'])) {\n                $result[$index] = $this->wrapUploads($f);\n                continue;\n            }\n\n            if (UPLOAD_ERR_OK === $f['error']) {\n                $stream = $this->streamFactory->createStreamFromFile($f['tmpName']);\n            } else {\n                $stream = $this->streamFactory->createStream();\n            }\n\n            $result[$index] = $this->uploadsFactory->createUploadedFile(\n                $stream,\n                $f['size'],\n                $f['error'],\n                $f['name'],\n                $f['mime']\n            );\n        }\n\n        return $result;\n    }", "label": 2}
{"code": "public function setMissing($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Datastore\\V1\\EntityResult::class);\n        $this->missing = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def state_delta(self, selector='all',\n        power=None, duration=1.0, infrared=None, hue=None,\n        saturation=None, brightness=None, kelvin=None):\n        \"\"\"Given a state delta, apply the modifications to lights' state\n        over a given period of time.\n\n        selector: required String\n            The selector to limit which lights are controlled.\n\n        power: String\n            The power state you want to set on the selector. on or off\n\n        duration: Double\n            How long in seconds you want the power action to take.\n            Range: 0.0 \u2013 3155760000.0 (100 years)\n\n        infrared: Double\n            The maximum brightness of the infrared channel.\n\n        hue: Double\n            Rotate the hue by this angle in degrees.\n\n        saturation: Double\n            Change the saturation by this additive amount; the resulting\n            saturation is clipped to [0, 1].\n\n        brightness: Double\n            Change the brightness by this additive amount; the resulting\n            brightness is clipped to [0, 1].\n\n        kelvin: Double\n            Change the kelvin by this additive amount; the resulting kelvin is\n            clipped to [2500, 9000].\n        \"\"\"\n\n        argument_tuples = [\n            (\"power\", power),\n            (\"duration\", duration),\n            (\"infrared\", infrared),\n            (\"hue\", hue),\n            (\"saturation\", saturation),\n            (\"brightness\", brightness),\n            (\"kelvin\", kelvin)\n        ]\n\n        return self.client.perform_request(\n            method='post', endpoint='lights/{}/state/delta',\n            endpoint_args=[selector], argument_tuples=argument_tuples)", "label": 1}
{"code": "public static base_responses link(nitro_service client, sslcertkey resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tsslcertkey linkresources[] = new sslcertkey[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tlinkresources[i] = new sslcertkey();\n\t\t\t\tlinkresources[i].certkey = resources[i].certkey;\n\t\t\t\tlinkresources[i].linkcertkeyname = resources[i].linkcertkeyname;\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, linkresources,\"link\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function process(data) {\n  var companyIdentifierCode = data.substr(2,2);\n  companyIdentifierCode += data.substr(0,2);\n\n  var companyName = companyIdentifierCodes.companyNames[companyIdentifierCode];\n  if(typeof companyName === 'undefined') {\n    companyName = 'Unknown';\n  }\n\n  // NOTE: this is for legacy compatibility\n  var advertiserData = {\n    manufacturerSpecificData: {\n      companyName : companyName,\n      companyIdentifierCode: companyIdentifierCode,\n      data: data.substr(4)\n    }\n  };\n\n  // Handle the unique case of AltBeacon\n  if(altbeacon.isAltBeacon(advertiserData)) {\n    altbeacon.process(advertiserData);\n    return advertiserData.manufacturerSpecificData;\n  }\n\n  // Interpret the manufacturer specific data, if possible\n  // Kindly respect ascending order of company identifier codes \n  switch(companyIdentifierCode) {\n    case '004c':\n      apple.process(advertiserData);\n      return advertiserData.manufacturerSpecificData;\n    case '00f9':\n      sticknfind.process(advertiserData);\n      return advertiserData.manufacturerSpecificData;\n    case '015d':\n      estimote.process(advertiserData);\n      return advertiserData.manufacturerSpecificData;\n    case '0274':\n      motsai.process(advertiserData);\n      return advertiserData.manufacturerSpecificData;\n    case '0583':\n      codebluecommunications.process(advertiserData);\n      return advertiserData.manufacturerSpecificData;\n    default:\n      return advertiserData.manufacturerSpecificData;\n  }\n}", "label": 3}
{"code": "func (s *cScreen) mapStyle(style Style) uint16 {\n\tf, b, a := style.Decompose()\n\tfa := s.oscreen.attrs & 0xf\n\tba := (s.oscreen.attrs) >> 4 & 0xf\n\tif f != ColorDefault {\n\t\tfa = mapColor2RGB(f)\n\t}\n\tif b != ColorDefault {\n\t\tba = mapColor2RGB(b)\n\t}\n\tvar attr uint16\n\t// We simulate reverse by doing the color swap ourselves.\n\t// Apparently windows cannot really do this except in DBCS\n\t// views.\n\tif a&AttrReverse != 0 {\n\t\tattr = ba\n\t\tattr |= (fa << 4)\n\t} else {\n\t\tattr = fa\n\t\tattr |= (ba << 4)\n\t}\n\tif a&AttrBold != 0 {\n\t\tattr |= 0x8\n\t}\n\tif a&AttrDim != 0 {\n\t\tattr &^= 0x8\n\t}\n\tif a&AttrUnderline != 0 {\n\t\t// Best effort -- doesn't seem to work though.\n\t\tattr |= 0x8000\n\t}\n\t// Blink is unsupported\n\treturn attr\n}", "label": 5}
{"code": "function getPath (path, name, profiles, label) {\n  const profilesStr = buildProfilesString(profiles)\n\n  return (path.endsWith('/') ? path : path + '/') +\n        encodeURIComponent(name) + '/' +\n        encodeURIComponent(profilesStr) +\n        (label ? '/' + encodeURIComponent(label) : '')\n}", "label": 3}
{"code": "def allow_role(role):\n    \"\"\"Allow a role identified by an email address.\"\"\"\n    def processor(action, argument):\n        db.session.add(\n            ActionRoles.allow(action, argument=argument, role_id=role.id)\n        )\n    return processor", "label": 1}
{"code": "public static RgbaColor fromRgb(String rgb) {\n        if (rgb.length() == 0) return getDefaultColor();\n\n        String[] parts = getRgbParts(rgb).split(\",\");\n        if (parts.length == 3) {\n            return new RgbaColor(parseInt(parts[0]),\n                                 parseInt(parts[1]),\n                                 parseInt(parts[2]));\n        }\n        else {\n            return getDefaultColor();\n        }\n    }", "label": 0}
{"code": "def request_response(method, req, marshal, unmarshal,\n                         deadline: nil,\n                         return_op: false,\n                         parent: nil,\n                         credentials: nil,\n                         metadata: {})\n      c = new_active_call(method, marshal, unmarshal,\n                          deadline: deadline,\n                          parent: parent,\n                          credentials: credentials)\n      interception_context = @interceptors.build_context\n      intercept_args = {\n        method: method,\n        request: req,\n        call: c.interceptable,\n        metadata: metadata\n      }\n      if return_op\n        # return the operation view of the active_call; define #execute as a\n        # new method for this instance that invokes #request_response.\n        c.merge_metadata_to_send(metadata)\n        op = c.operation\n        op.define_singleton_method(:execute) do\n          interception_context.intercept!(:request_response, intercept_args) do\n            c.request_response(req, metadata: metadata)\n          end\n        end\n        op\n      else\n        interception_context.intercept!(:request_response, intercept_args) do\n          c.request_response(req, metadata: metadata)\n        end\n      end\n    end", "label": 4}
{"code": "def standardize(definition)\n      case definition\n      when String\n        # Expands simple string from: logs => logs:*\n        definition = \"#{definition}:*\" unless definition.include?(':')\n        @policy[:statement] << {\n          action: [definition],\n          effect: \"Allow\",\n          resource: \"*\",\n        }\n      when Hash\n        definition = definition.stringify_keys\n        if definition.key?(\"Version\") # special case where we replace the policy entirely\n          @policy = definition\n        else\n          @policy[:statement] << definition\n        end\n      end\n    end", "label": 4}
{"code": "public function insertOrUpdateBatch($table, array $dataSet)\n    {\n        $this->enqueue(Operation::OP_INSERT_OR_UPDATE, $table, $dataSet);\n\n        return $this;\n    }", "label": 2}
{"code": "def _find_file(f):\n        \"\"\"Find a config file if possible.\"\"\"\n        if os.path.isabs(f):\n            return f\n        else:\n            for d in Config._dirs:\n                _f = os.path.join(d, f)\n                if os.path.isfile(_f):\n                    return _f\n            raise FiggypyError(\n                \"could not find configuration file {} in dirs {}\"\n                .format(f, Config._dirs)\n            )", "label": 1}
{"code": "private String searchForPersistentSubType(XClass type)\r\n    {\r\n        ArrayList queue = new ArrayList();\r\n        XClass    subType;\r\n\r\n        queue.add(type);\r\n        while (!queue.isEmpty())\r\n        {\r\n            subType = (XClass)queue.get(0);\r\n            queue.remove(0);\r\n            if (_model.hasClass(subType.getQualifiedName()))\r\n            {\r\n                return subType.getQualifiedName();\r\n            }\r\n            addDirectSubTypes(subType, queue);\r\n        }\r\n        return null;\r\n    }", "label": 0}
{"code": "def drop(options = {})\n      operation = { :dropDatabase => 1 }\n      client.send(:with_session, options) do |session|\n        Operation::DropDatabase.new({\n          selector: operation,\n          db_name: name,\n          write_concern: write_concern,\n          session: session\n        }).execute(next_primary)\n      end\n    end", "label": 4}
{"code": "func unregisterHandler(handlerIndex int) {\n\thandlerMu.Lock()\n\tdefer handlerMu.Unlock()\n\n\tdelete(handlers, handlerIndex)\n}", "label": 5}
{"code": "def process(name)\n      self.ext = File.extname(name)\n      self.basename = name[0..-ext.length - 1].gsub(%r!\\.*\\z!, \"\")\n    end", "label": 4}
{"code": "def make_pattern(self, pattern, listsep=','):\n        \"\"\"Make pattern for a data type with the specified cardinality.\n\n        .. code-block:: python\n\n            yes_no_pattern = r\"yes|no\"\n            many_yes_no = Cardinality.one_or_more.make_pattern(yes_no_pattern)\n\n        :param pattern:  Regular expression for type (as string).\n        :param listsep:  List separator for multiple items (as string, optional)\n        :return: Regular expression pattern for type with cardinality.\n        \"\"\"\n        if self is Cardinality.one:\n            return pattern\n        elif self is Cardinality.zero_or_one:\n            return self.schema % pattern\n        else:\n            return self.schema % (pattern, listsep, pattern)", "label": 1}
{"code": "func (tl TypeLoader) Escape(typ EscType, s string) string {\n\tif e, ok := tl.Esc[typ]; ok && e != nil {\n\t\treturn e(s)\n\t}\n\n\treturn `\"` + s + `\"`\n}", "label": 5}
{"code": "function(updateEventConfiguration) {\n      var validStringConfig = _.isString(updateEventConfiguration);\n      var validObjectConfig = _.isObject(updateEventConfiguration) && _.keys(updateEventConfiguration).length > 0;\n      if (!validStringConfig && !validObjectConfig) {\n        throw new Error('Not a valid updateEvent configuration.  Update events need to either be strings or objects with a single property: ' + JSON.stringify(updateEventConfiguration));\n      }\n    }", "label": 3}
{"code": "function ( formatString, itemObject ) {\n            var calendar = this\n            return calendar.formats.toArray( formatString ).map( function( label ) {\n                return _.trigger( calendar.formats[ label ], calendar, [ 0, itemObject ] ) || label.replace( /^!/, '' )\n            }).join( '' )\n        }", "label": 3}
{"code": "function getResponseItems (response) {\n  const header = response.Hlavicka.attributes\n  const body = response.Potvrzeni.attributes\n  return {\n    uuid: header.uuid_zpravy,\n    bkp: header.bkp,\n    date: new Date(header.dat_prij),\n    test: body.test === 'true',\n    fik: body.fik,\n    warnings: getWarnings(response.Varovani)\n  }\n}", "label": 3}
{"code": "public function setJobBenefits($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::ENUM, \\Google\\Cloud\\Talent\\V4beta1\\JobBenefit::class);\n        $this->job_benefits = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function validatorRadio(fieldValue, fieldDefinition, previousFieldValues, cb) {\n      if (typeof(fieldValue) !== \"string\") {\n        return cb(new Error(\"Expected submission to be string but got \" + typeof(fieldValue)));\n      }\n\n      //Check value exists in the field definition\n      if (!fieldDefinition.fieldOptions.definition.options) {\n        return cb(new Error(\"No options exist for field \" + fieldDefinition.name));\n      }\n\n      async.some(fieldDefinition.fieldOptions.definition.options, function(dropdownOption, cb) {\n        //check if fieldValue and the label need to be escaped\n        isSafeString(fieldValue) ? null : fieldValue = _.escape(fieldValue);\n        isSafeString(dropdownOption.label) ? null : dropdownOption.label = _.escape(dropdownOption.label);\n        return cb(dropdownOption.label === fieldValue);\n      }, function(found) {\n        if (!found) {\n          return cb(new Error(\"Invalid option specified: \" + fieldValue));\n        } else {\n          return cb();\n        }\n      });\n    }", "label": 3}
{"code": "def circle(origin_x, origin_y, perim_x, perim_y)\n      primitive 'circle ' + format('%g,%g %g,%g', origin_x, origin_y, perim_x, perim_y)\n    end", "label": 4}
{"code": "public long indexOf(final String element) {\n        return doWithJedis(new JedisCallable<Long>() {\n            @Override\n            public Long call(Jedis jedis) {\n                return doIndexOf(jedis, element);\n            }\n        });\n    }", "label": 0}
{"code": "public function addFilter($callback, $name = null)\n    {\n        $tuple = $this->createFilterTuple(func_get_args());\n\n        $this->filters[] = $tuple;\n\n        $this->handleChangedParameters();\n\n        return $this;\n    }", "label": 2}
{"code": "private void updateMax(MtasRBTreeNode n, MtasRBTreeNode c) {\n    if (c != null) {\n      if (n.max < c.max) {\n        n.max = c.max;\n      }\n    }\n  }", "label": 0}
{"code": "public static appflowpolicy_appflowpolicylabel_binding[] get(nitro_service service, String name) throws Exception{\n\t\tappflowpolicy_appflowpolicylabel_binding obj = new appflowpolicy_appflowpolicylabel_binding();\n\t\tobj.set_name(name);\n\t\tappflowpolicy_appflowpolicylabel_binding response[] = (appflowpolicy_appflowpolicylabel_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function areTermsMatching (buyerTerms, sellerTerms) {\n\n  if (buyerTerms.maxPrice >= sellerTerms.minPrice &&\n      buyerTerms.maxLock >= sellerTerms.minLock &&\n      buyerTerms.minNumberOfSellers <= sellerTerms.maxNumberOfSellers &&\n      buyerTerms.maxContractFeePerKb >= sellerTerms.minContractFeePerKb\n  ) {\n    return true\n  } else {\n    return false\n  }\n}", "label": 3}
{"code": "def add(host, add_options=nil)\n      address = Address.new(host, options)\n      if !addresses.include?(address)\n        server = Server.new(address, self, @monitoring, event_listeners, options.merge(\n          monitor: false))\n        @update_lock.synchronize { @servers.push(server) }\n        if add_options.nil? || add_options[:monitor] != false\n          server.start_monitoring\n        end\n        server\n      end\n    end", "label": 4}
{"code": "function createBuffersFromArrays(gl, arrays) {\n    var buffers = { };\n    Object.keys(arrays).forEach(function(key) {\n      var type = key === \"indices\" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n      var array = makeTypedArray(arrays[key], name);\n      buffers[key] = createBufferFromTypedArray(gl, array, type);\n    });\n\n    // hrm\n    if (arrays.indices) {\n      buffers.numElements = arrays.indices.length;\n    } else if (arrays.position) {\n      buffers.numElements = arrays.position.length / 3;\n    }\n\n    return buffers;\n  }", "label": 3}
{"code": "def bowtie(sam, btd, f, r, u, opt, no_shrink, threads):\n    \"\"\"\n    generate bowtie2 command\n    \"\"\"\n    bt2 = 'bowtie2 -x %s -p %s ' % (btd, threads)\n    if f is not False:\n        bt2 += '-1 %s -2 %s ' % (f, r)\n    if u is not False:\n        bt2 += '-U %s ' % (u)\n    bt2 += opt\n    if no_shrink is False:\n        if f is False:\n            bt2 += ' | shrinksam -u -k %s-shrunk.sam ' % (sam)\n        else:\n            bt2 += ' | shrinksam -k %s-shrunk.sam ' % (sam)\n    else:\n        bt2 += ' > %s.sam' % (sam)\n    return bt2", "label": 1}
{"code": "def diff_from(ts = nil, version: nil, time: nil)\n      Deprecations.show_ts_deprecation_for(\"#diff_from\") if ts\n      time ||= ts\n      time = parse_time(time) if time\n      changes = log_data.diff_from(time: time, version: version).tap do |v|\n        deserialize_changes!(v)\n      end\n\n      changes.delete_if { |k, _v| deleted_column?(k) }\n\n      { \"id\" => id, \"changes\" => changes }\n    end", "label": 4}
{"code": "function getArrayOfHoles(length) {\n  var holyLen = HOLY_ARRAY.length;\n  if (length > holyLen) {\n    HOLY_ARRAY.length = length;\n    for (var i = holyLen; i < length; ++i) {\n      HOLY_ARRAY[i] = ARRAY_HOLE_INDEX;\n    }\n  }\n\n  return HOLY_ARRAY.slice(0, length);\n}", "label": 3}
{"code": "def DAVIDgetGeneAttribute(x,df,refCol=\"ensembl_gene_id\",fieldTOretrieve=\"gene_name\"):\n    \"\"\"\n    Returns a list of gene names for given gene ids.\n\n    :param x: a string with the list of IDs separated by ', '\n    :param df: a dataframe with the reference column and a the column to retrieve\n    :param refCol: the header of the column containing the identifiers\n    :param fieldTOretrieve: the field to retrieve from parsedGTF eg. 'gene_name'\n\n    :returns: list of fieldTOretrieve separeted by ', ' in the same order as the given in x\n    \"\"\"\n    \n    l=x.split(\", \")\n    l=[ s.upper() for s in l ]\n    tmpdf=pd.DataFrame({refCol:l},index=range(len(l)))\n    df_fix=df[[refCol,fieldTOretrieve]].drop_duplicates()\n    df_fix[refCol]=df_fix[refCol].apply(lambda x: x.upper())\n    ids=pd.merge(tmpdf,df_fix,how=\"left\",on=[refCol])\n    ids=ids[fieldTOretrieve].tolist()\n    ids=[ str(s) for s in ids ]\n    ids=\", \".join(ids)\n    return ids", "label": 1}
{"code": "def mime_type(type, value)\n      type = \".#{type}\" unless type.to_s[0] == '.'\n      ::Rack::Mime::MIME_TYPES[type] = value\n    end", "label": 4}
{"code": "def join(self, ToMerge, keycols=None, nullvals=None, \n             renamer=None, returnrenaming=False, selfname=None, Names=None):\n        \"\"\"\n        Wrapper for spreadsheet.join, but handles coloring attributes.\n\n        The `selfname` argument allows naming of `self` to be used if `ToMerge` \n        is a dictionary.\n\n        **See also:** :func:`tabular.spreadsheet.join`, :func:`tab_join`\n        \"\"\"\n\n        if isinstance(ToMerge,np.ndarray):\n            ToMerge = [ToMerge]\n\n        if isinstance(ToMerge,dict):\n            assert selfname not in ToMerge.keys(), \\\n             ('Can\\'t use \"', selfname + '\" for name of one of the things to '  \n              'merge, since it is the same name as the self object.')\n            if selfname == None:\n                try:\n                    selfname = self.name\n                except AttributeError:\n                    selfname = 'self'\n            ToMerge.update({selfname:self})\n        else:\n            ToMerge = [self] + ToMerge\n\n        return tab_join(ToMerge, keycols=keycols, nullvals=nullvals, \n                   renamer=renamer, returnrenaming=returnrenaming, Names=Names)", "label": 1}
{"code": "def lounge_upgrade(self, email, password, release_id):\n        \"\"\"Download & install an upgrade from the CDRouter Support Lounge\n        using your Support Lounge email & password. Please note that any\n        running tests will be stopped.\n\n        :param email: CDRouter Support Lounge email as a string.\n        :param password: CDRouter Support Lounge password as a string.\n        :param release_id: Release ID as an int.\n        :return: :class:`system.Upgrade <system.Upgrade>` object\n        :rtype: system.Upgrade\n        \"\"\"\n        schema = UpgradeSchema()\n        resp = self.service.post(self.base+'lounge/upgrade/',\n                                 json={'email': email, 'password': password, 'release': {'id': int(release_id)}})\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "def any_of(value, *args):\n    \"\"\" At least one of the items in value should match \"\"\"\n\n    if len(args):\n        value = (value,) + args\n\n    return ExpectationAny(value)", "label": 1}
{"code": "function error(err) {\n    if (!(err instanceof Error)) return err\n    return {\n        code: err.code,\n        message: err.message,\n        details: err.detail,\n        stack: err.stack || ''\n    }\n}", "label": 3}
{"code": "protected function signString($privateKey, $data, $forceOpenssl = false)\n    {\n        $signature = '';\n\n        if (class_exists(RSA::class) && !$forceOpenssl) {\n            $rsa = new RSA;\n            $rsa->loadKey($privateKey);\n            $rsa->setSignatureMode(RSA::SIGNATURE_PKCS1);\n            $rsa->setHash('sha256');\n\n            $signature = $rsa->sign($data);\n        } elseif (extension_loaded('openssl')) {\n            openssl_sign($data, $signature, $privateKey, 'sha256WithRSAEncryption');\n        } else {\n            // @codeCoverageIgnoreStart\n            throw new \\RuntimeException('OpenSSL is not installed.');\n        }\n        // @codeCoverageIgnoreEnd\n\n        return $signature;\n    }", "label": 2}
{"code": "def mouse(table, day=None):\r\n    \"\"\"Handler for showing mouse statistics for specified type and day.\"\"\"\r\n    where = ((\"day\", day),) if day else ()\r\n    events = db.fetch(table, where=where, order=\"day\")\r\n    for e in events: e[\"dt\"] = datetime.datetime.fromtimestamp(e[\"stamp\"])\r\n    stats, positions, events = stats_mouse(events, table)\r\n    days, input = db.fetch(\"counts\", order=\"day\", type=table), \"mouse\"\r\n    return bottle.template(\"heatmap.tpl\", locals(), conf=conf)", "label": 1}
{"code": "def approve_subscription(data):\n    \"\"\"\n    Function to approve a SNS subscription with Amazon\n\n    We don't do a ton of verification here, past making sure that the endpoint\n    we're told to go to to verify the subscription is on the correct host\n    \"\"\"\n    url = data['SubscribeURL']\n\n    domain = urlparse(url).netloc\n    pattern = getattr(\n        settings,\n        'BOUNCY_SUBSCRIBE_DOMAIN_REGEX',\n        r\"sns.[a-z0-9\\-]+.amazonaws.com$\"\n    )\n    if not re.search(pattern, domain):\n        logger.error('Invalid Subscription Domain %s', url)\n        return HttpResponseBadRequest('Improper Subscription Domain')\n\n    try:\n        result = urlopen(url).read()\n        logger.info('Subscription Request Sent %s', url)\n    except urllib.HTTPError as error:\n        result = error.read()\n        logger.warning('HTTP Error Creating Subscription %s', str(result))\n\n    signals.subscription.send(\n        sender='bouncy_approve_subscription',\n        result=result,\n        notification=data\n    )\n\n    # Return a 200 Status Code\n    return HttpResponse(six.u(result))", "label": 1}
{"code": "func (c *CertChecker) Authenticate(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {\n\terr := validate(key)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tperms, err := c.CertChecker.Authenticate(conn, key)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn perms, nil\n}", "label": 5}
{"code": "public static base_response unset(nitro_service client, systemcollectionparam resource, String[] args) throws Exception{\n\t\tsystemcollectionparam unsetresource = new systemcollectionparam();\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "func OptionKVProviderURL(url string) Option {\n\treturn func(c *Config) {\n\t\tlogrus.Debugf(\"Option OptionKVProviderURL: %s\", url)\n\t\tif _, ok := c.Scopes[datastore.GlobalScope]; !ok {\n\t\t\tc.Scopes[datastore.GlobalScope] = &datastore.ScopeCfg{}\n\t\t}\n\t\tc.Scopes[datastore.GlobalScope].Client.Address = strings.TrimSpace(url)\n\t}\n}", "label": 5}
{"code": "function define(path, factoryOrObject, options) {\n        /*\n        $_mod.def('/baz$3.0.0/lib/index', function(require, exports, module, __filename, __dirname) {\n            // module source code goes here\n        });\n        */\n\n        var globals = options && options.globals;\n\n        definitions[path] = factoryOrObject;\n\n        if (globals) {\n            var target = win || global;\n            for (var i=0;i<globals.length; i++) {\n                var globalVarName = globals[i];\n                var globalModule = loadedGlobalsByRealPath[path] = requireModule(path);\n                target[globalVarName] = globalModule.exports;\n            }\n        }\n    }", "label": 3}
{"code": "public function setListFindingsResults($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\SecurityCenter\\V1\\ListFindingsResponse\\ListFindingsResult::class);\n        $this->list_findings_results = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def diff_config(ctx, second_host, mode):\n    \"\"\" Config comparison between two devices.\n\n    @param ctx: The click context paramter, for receiving the object dictionary\n              | being manipulated by other previous functions. Needed by any\n              | function with the @click.pass_context decorator.\n    @type ctx: click.Context\n    @param second_host: The IP/hostname of the second device to pull from\n    @type second_host: str\n    @param mode: The mode in which we are retrieving the config ('set' or\n               | 'stanza')\n    @type mode: str\n\n    @returns: None. Functions part of click relating to the command group\n            | 'main' do not return anything. Click handles passing context\n            | between the functions and maintaing command order and chaining.\n    \"\"\"\n    mp_pool = multiprocessing.Pool(multiprocessing.cpu_count() * 2)\n    for ip in ctx.obj['hosts']:\n        mp_pool.apply_async(wrap.open_connection, args=(ip,\n                            ctx.obj['conn']['username'],\n                            ctx.obj['conn']['password'],\n                            wrap.diff_config, [second_host, mode],\n                            ctx.obj['out'],\n                            ctx.obj['conn']['connect_timeout'],\n                            ctx.obj['conn']['session_timeout'],\n                            ctx.obj['conn']['port']), callback=write_out)\n    mp_pool.close()\n    mp_pool.join()", "label": 1}
{"code": "public static appfwprofile_stats[] get(nitro_service service) throws Exception{\n\t\tappfwprofile_stats obj = new appfwprofile_stats();\n\t\tappfwprofile_stats[] response = (appfwprofile_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function checkOverwrite(array $entities, $allowOverwrite = false)\n    {\n        $this->validateBatch($entities, EntityInterface::class);\n\n        foreach ($entities as $entity) {\n            if (!$entity->populatedByService() && !$allowOverwrite) {\n                throw new \\InvalidArgumentException(sprintf(\n                    'Given entity cannot be saved because it may overwrite an '.\n                    'existing record. When updating manually created entities, '.\n                    'please set the options `$allowOverwrite` flag to `true`. '.\n                    'Invalid entity key was %s',\n                    (string) $entity->key()\n                ));\n            }\n        }\n    }", "label": 2}
{"code": "public static function prefix(string $path = ''): string\n    {\n        $prefix = config('platform.prefix');\n\n        return Str::start($prefix.$path, '/');\n    }", "label": 2}
{"code": "private function partitionOptions(array $options)\n    {\n        $options['partitionOptions'] = array_filter([\n            'partitionSizeBytes' => $this->pluck('partitionSizeBytes', $options, false),\n            'maxPartitions' => $this->pluck('maxPartitions', $options, false)\n        ]);\n\n        return $options;\n    }", "label": 2}
{"code": "private Object getAttributeRecursively(Object feature, String name) throws LayerException {\n\t\tif (feature == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Split up properties: the first and the rest.\n\t\tString[] properties = name.split(SEPARATOR_REGEXP, 2);\n\t\tObject tempFeature;\n\n\t\t// If the first property is the identifier:\n\t\tif (properties[0].equals(getFeatureInfo().getIdentifier().getName())) {\n\t\t\ttempFeature = getId(feature);\n\t\t} else {\n\t\t\tEntity entity = entityMapper.asEntity(feature);\n\t\t\tHibernateEntity child = (HibernateEntity) entity.getChild(properties[0]);\n\t\t\ttempFeature = child == null ? null : child.getObject();\n\t\t}\n\n\t\t// Detect if the first property is a collection (one-to-many):\n\t\tif (tempFeature instanceof Collection<?>) {\n\t\t\tCollection<?> features = (Collection<?>) tempFeature;\n\t\t\tObject[] values = new Object[features.size()];\n\t\t\tint count = 0;\n\t\t\tfor (Object value : features) {\n\t\t\t\tif (properties.length == 1) {\n\t\t\t\t\tvalues[count++] = value;\n\t\t\t\t} else {\n\t\t\t\t\tvalues[count++] = getAttributeRecursively(value, properties[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn values;\n\t\t} else { // Else first property is not a collection (one-to-many):\n\t\t\tif (properties.length == 1 || tempFeature == null) {\n\t\t\t\treturn tempFeature;\n\t\t\t} else {\n\t\t\t\treturn getAttributeRecursively(tempFeature, properties[1]);\n\t\t\t}\n\t\t}\n\t}", "label": 0}
{"code": "def entry_name(options = {})\n      default = options[:count] == 1 ? model_name.human : model_name.human.pluralize\n      model_name.human(options.reverse_merge(default: default))\n    end", "label": 4}
{"code": "public static snmpalarm get(nitro_service service, String trapname) throws Exception{\n\t\tsnmpalarm obj = new snmpalarm();\n\t\tobj.set_trapname(trapname);\n\t\tsnmpalarm response = (snmpalarm) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def used_args(self):\n        \"\"\"Return args already used in the\n        command line\n\n        rtype: command.Arg generator\n        \"\"\"\n        # get all arguments values from the command line\n        values = []\n        for idx, c in enumerate(self.words[1:]):\n            if c.startswith('-'):\n                continue\n            option_str = self.words[1:][idx - 1]\n            option = self.get_option(option_str)\n            if option is None or not option.need_value:\n                values.append((c, c == self.document.get_word_before_cursor(WORD=True)))\n        logger.debug(\"Found args values %s\" % values)\n        # consume values\n        for arg in self.cmd.args.values():\n            if not values:\n                raise StopIteration\n            if arg.is_multiple:\n                values = []\n                yield arg\n            elif type(arg.nargs) is int:\n                for _ in range(arg.nargs):\n                    value = values.pop(0)\n                    # not the current argument\n                    if value[1] is False:\n                        yield arg\n                    if not values:\n                        raise StopIteration", "label": 1}
{"code": "func (l *Handler) Download(ctx context.Context, sessionID session.ID, writer io.WriterAt) error {\n\tpath := l.path(sessionID)\n\t_, err := os.Stat(filepath.Dir(path))\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn trace.ConvertSystemError(err)\n\t}\n\tdefer f.Close()\n\t_, err = io.Copy(writer.(io.Writer), f)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    }", "label": 3}
{"code": "func (tc *TeleportClient) getProxySSHPrincipal() string {\n\tproxyPrincipal := tc.Config.HostLogin\n\tif tc.DefaultPrincipal != \"\" {\n\t\tproxyPrincipal = tc.DefaultPrincipal\n\t}\n\t// see if we already have a signed key in the cache, we'll use that instead\n\tif !tc.Config.SkipLocalAuth && tc.LocalAgent() != nil {\n\t\tsigners, err := tc.LocalAgent().Signers()\n\t\tif err != nil || len(signers) == 0 {\n\t\t\treturn proxyPrincipal\n\t\t}\n\t\tcert, ok := signers[0].PublicKey().(*ssh.Certificate)\n\t\tif ok && len(cert.ValidPrincipals) > 0 {\n\t\t\treturn cert.ValidPrincipals[0]\n\t\t}\n\t}\n\treturn proxyPrincipal\n}", "label": 5}
{"code": "function(idsResult) {\n      if (_.isEmpty(idsResult) && _.isEmpty(this.data.privateCollection.getTrackedIds())) {\n        return { skipObjectRetrieval: true, forceFetchedEvent: true };\n      } else {\n        return idsResult;\n      }\n    }", "label": 3}
{"code": "def path=(new_path)\n      if new_path && !new_path.respond_to?(:to_str)\n        raise TypeError, \"Can't convert #{new_path.class} into String.\"\n      end\n      @path = (new_path || EMPTY_STR).to_str\n      if !@path.empty? && @path[0..0] != SLASH && host != nil\n        @path = \"/#{@path}\"\n      end\n\n      # Reset dependent values\n      remove_instance_variable(:@normalized_path) if defined?(@normalized_path)\n      remove_composite_values\n\n      # Ensure we haven't created an invalid URI\n      validate()\n    end", "label": 4}
{"code": "public String get() {\n\t\tsynchronized (LOCK) {\n\t\t\tif (!initialised) {\n\t\t\t\t// generate the random number\n\t\t\t\tRandom rnd = new Random();\t// @todo need a different seed, this is now time based and I\n\t\t\t\t// would prefer something different, like an object address\n\t\t\t\t// get the random number, instead of getting an integer and converting that to base64 later,\n\t\t\t\t// we get a string and narrow that down to base64, use the top 6 bits of the characters\n\t\t\t\t// as they are more random than the bottom ones...\n\t\t\t\trnd.nextBytes(value);\t\t// get some random characters\n\t\t\t\tvalue[3] = BASE64[((value[3] >> 2) & BITS_6)]; // NOSONAR\n\t\t\t\tvalue[4] = BASE64[((value[4] >> 2) & BITS_6)]; // NOSONAR\n\t\t\t\tvalue[5] = BASE64[((value[5] >> 2) & BITS_6)]; // NOSONAR\n\t\t\t\tvalue[6] = BASE64[((value[6] >> 2) & BITS_6)]; // NOSONAR\n\t\t\t\tvalue[7] = BASE64[((value[7] >> 2) & BITS_6)]; // NOSONAR\n\n\t\t\t\t// complete the time part in the HIGH value of the token\n\t\t\t\t// this also sets the initial low value\n\t\t\t\tcompleteToken(rnd);\n\n\t\t\t\tinitialised = true;\n\t\t\t}\n\n\t\t\t// fill in LOW value in id\n\t\t\tint l = low;\n\t\t\tvalue[0] = BASE64[(l & BITS_6)];\n\t\t\tl >>= SHIFT_6;\n\t\t\tvalue[1] = BASE64[(l & BITS_6)];\n\t\t\tl >>= SHIFT_6;\n\t\t\tvalue[2] = BASE64[(l & BITS_6)];\n\n\t\t\tString res = new String(value);\n\n\t\t\t// increment LOW\n\t\t\tlow++;\n\t\t\tif (low == LOW_MAX) {\n\t\t\t\tlow = 0;\n\t\t\t}\n\t\t\tif (low == lowLast) {\n\t\t\t\ttime = System.currentTimeMillis();\n\t\t\t\tcompleteToken();\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\t}", "label": 0}
{"code": "func (s *PresenceService) UpsertNodes(namespace string, servers []services.Server) error {\n\tbatch, ok := s.Backend.(backend.Batch)\n\tif !ok {\n\t\treturn trace.BadParameter(\"backend does not support batch interface\")\n\t}\n\tif namespace == \"\" {\n\t\treturn trace.BadParameter(\"missing node namespace\")\n\t}\n\n\tstart := time.Now()\n\n\titems := make([]backend.Item, len(servers))\n\tfor i, server := range servers {\n\t\tvalue, err := services.GetServerMarshaler().MarshalServer(server)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\n\t\titems[i] = backend.Item{\n\t\t\tKey:     backend.Key(nodesPrefix, server.GetNamespace(), server.GetName()),\n\t\t\tValue:   value,\n\t\t\tExpires: server.Expiry(),\n\t\t\tID:      server.GetResourceID(),\n\t\t}\n\t}\n\n\terr := batch.PutRange(context.TODO(), items)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\ts.log.Debugf(\"UpsertNodes(%v) in %v\", len(servers), time.Now().Sub(start))\n\n\treturn nil\n}", "label": 5}
{"code": "public void loadDefault() {\r\n    try {\r\n      load( new BufferedReader(new StringReader(\r\n        DefaultTeXHyphenData.hyphenData) ) );\r\n    } catch(IOException e) {\r\n      // shouldn't happen\r\n      throw new RuntimeException(e);\r\n    }\r\n  }", "label": 0}
{"code": "protected Collection provideStateManagers(Collection pojos)\r\n    {\r\n    \tPersistenceCapable pc;\r\n    \tint [] fieldNums;\r\n    \tIterator iter = pojos.iterator();\r\n    \tCollection result = new ArrayList();\r\n    \t\r\n    \twhile (iter.hasNext())\r\n    \t{\r\n    \t\t// obtain a StateManager\r\n    \t\tpc = (PersistenceCapable) iter.next();\r\n    \t\tIdentity oid = new Identity(pc, broker);\r\n    \t\tStateManagerInternal smi = pmi.getStateManager(oid, pc.getClass()); \r\n    \t\t\r\n    \t\t// fetch attributes into StateManager\r\n\t\t\tJDOClass jdoClass = Helper.getJDOClass(pc.getClass());\r\n\t\t\tfieldNums = jdoClass.getManagedFieldNumbers();\r\n\r\n\t\t\tFieldManager fm = new OjbFieldManager(pc, broker);\r\n\t\t\tsmi.replaceFields(fieldNums, fm);\r\n\t\t\tsmi.retrieve();\r\n\t\t\t\r\n\t\t\t// get JDO PersistencecCapable instance from SM and add it to result collection\r\n\t\t\tObject instance = smi.getObject();\r\n\t\t\tresult.add(instance);\r\n    \t}\r\n    \treturn result;   \r\n\t}", "label": 0}
{"code": "public HalfEdge getEdge(int i) {\n        HalfEdge he = he0;\n        while (i > 0) {\n            he = he.next;\n            i--;\n        }\n        while (i < 0) {\n            he = he.prev;\n            i++;\n        }\n        return he;\n    }", "label": 0}
{"code": "private function castToType(string $value, string $type)\n    {\n        $casts = [\n            'integer' => 'intval',\n            'number' => 'floatval',\n            'float' => 'floatval',\n            'boolean' => 'boolval',\n        ];\n\n        // First, we handle booleans. We can't use a regular cast,\n        //because PHP considers string 'false' as true.\n        if ($value == 'false' && $type == 'boolean') {\n            return false;\n        }\n\n        if (isset($casts[$type])) {\n            return $casts[$type]($value);\n        }\n\n        return $value;\n    }", "label": 2}
{"code": "function addFeatures() {\n        const features = {};\n        for (const spec in filters.specs) {\n            features[parseResults.specs.specTable[spec].feature] = true;\n        }\n        filters.features = features;\n    }", "label": 3}
{"code": "function create(connections, dataTarget, cb) {\n  async.waterfall([\n    function validateParams(cb) {\n      validate(dataTarget).hasno(CONSTANTS.DATA_TARGET_ID, function(err) {\n        if (err) {\n          return cb(buildErrorResponse({error: new Error(\"Data Target ID Should Not Be Included When Creating A Data Target\"), code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS}));\n        }\n      });\n\n      cb(undefined, dataTarget);\n    },\n    function createDataTarget(dataTargetJSON, cb) {\n      dataTargetJSON = sanitiseJSON(dataTargetJSON);\n\n      var DataTarget = models.get(connections.mongooseConnection, models.MODELNAMES.DATA_TARGET);\n      var newDataTarget = new DataTarget(dataTargetJSON);\n\n      newDataTarget.save(function(err) {\n        if (err) {\n          return cb(buildErrorResponse({\n            error: err,\n            userDetail: \"Invalid Data Target Creation Data.\",\n            systemDetail: err.errors,\n            code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS\n          }));\n        }\n\n        return cb(undefined, newDataTarget.toJSON());\n      });\n\n    }\n  ], cb);\n}", "label": 3}
{"code": "@Nonnull\n\tprivate static Properties findDefaultProperties() {\n\t\tfinal InputStream in = SourceCodeFormatter.class.getClassLoader().getResourceAsStream(DEFAULT_PROPERTIES_PATH);\n\t\tfinal Properties p = new Properties();\n\t\ttry {\n\t\t\tp.load(in);\n\t\t} catch (final IOException e) {\n\t\t\tthrow new RuntimeException(String.format(\"Can not load resource %s\", DEFAULT_PROPERTIES_PATH));\n\t\t}\n\t\treturn p;\n\t}", "label": 0}
{"code": "function(index, obj) {\n\t\t\tvar lang = this.lang;\n\t\t\tvar lindex = index.toLowerCase();\n\n\t\t\tif(typeof obj == \"object\") {\n\t\t\t\tlang = obj;\n\t\t\t}\n\n\t\t\tif(lang && lang[lindex]) {\n\t\t\t\treturn lang[lindex];\n\t\t\t}\n\n\t\t\treturn index;\n\t\t}", "label": 3}
{"code": "def all\n      results = []\n\n      with_collection_lock do\n        @logger.debug(\"Finding all boxes in: #{@directory}\")\n        @directory.children(true).each do |child|\n          # Ignore non-directories, since files are not interesting to\n          # us in our folder structure.\n          next if !child.directory?\n\n          box_name = undir_name(child.basename.to_s)\n\n          # Otherwise, traverse the subdirectories and see what versions\n          # we have.\n          child.children(true).each do |versiondir|\n            next if !versiondir.directory?\n            next if versiondir.basename.to_s.start_with?(\".\")\n\n            version = versiondir.basename.to_s\n\n            versiondir.children(true).each do |provider|\n              # Ensure version of box is correct before continuing\n              if !Gem::Version.correct?(version)\n                ui = Vagrant::UI::Prefixed.new(Vagrant::UI::Colored.new, \"vagrant\")\n                ui.warn(I18n.t(\"vagrant.box_version_malformed\",\n                              version: version, box_name: box_name))\n                @logger.debug(\"Invalid version #{version} for box #{box_name}\")\n                next\n              end\n\n              # Verify this is a potentially valid box. If it looks\n              # correct enough then include it.\n              if provider.directory? && provider.join(\"metadata.json\").file?\n                provider_name = provider.basename.to_s.to_sym\n                @logger.debug(\"Box: #{box_name} (#{provider_name}, #{version})\")\n                results << [box_name, version, provider_name]\n              else\n                @logger.debug(\"Invalid box #{box_name}, ignoring: #{provider}\")\n              end\n            end\n          end\n        end\n      end\n      # Sort the list to group like providers and properly ordered versions\n      results.sort_by! do |box_result|\n        [box_result[0], box_result[2], Gem::Version.new(box_result[1])]\n      end\n      results\n    end", "label": 4}
{"code": "public static base_response add(nitro_service client, sslcertkey resource) throws Exception {\n\t\tsslcertkey addresource = new sslcertkey();\n\t\taddresource.certkey = resource.certkey;\n\t\taddresource.cert = resource.cert;\n\t\taddresource.key = resource.key;\n\t\taddresource.password = resource.password;\n\t\taddresource.fipskey = resource.fipskey;\n\t\taddresource.inform = resource.inform;\n\t\taddresource.passplain = resource.passplain;\n\t\taddresource.expirymonitor = resource.expirymonitor;\n\t\taddresource.notificationperiod = resource.notificationperiod;\n\t\taddresource.bundle = resource.bundle;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def interaction_method(self, kind, x):\n        ''' Checks whether the error is an InteractionRequired error\n        that implements the method with the given name, and JSON-unmarshals the\n        method-specific data into x by calling its from_dict method\n        with the deserialized JSON object.\n        @param kind The interaction method kind (string).\n        @param x A class with a class method from_dict that returns a new\n        instance of the interaction info for the given kind.\n        @return The result of x.from_dict.\n        '''\n        if self.info is None or self.code != ERR_INTERACTION_REQUIRED:\n            raise InteractionError(\n                'not an interaction-required error (code {})'.format(\n                    self.code)\n            )\n        entry = self.info.interaction_methods.get(kind)\n        if entry is None:\n            raise InteractionMethodNotFound(\n                'interaction method {} not found'.format(kind)\n            )\n        return x.from_dict(entry)", "label": 1}
{"code": "public void promoteModule(final String moduleId) {\n        final DbModule module = getModule(moduleId);\n\n        for (final String gavc : DataUtils.getAllArtifacts(module)) {\n            final DbArtifact artifact = repositoryHandler.getArtifact(gavc);\n            artifact.setPromoted(true);\n            repositoryHandler.store(artifact);\n        }\n\n        repositoryHandler.promoteModule(module);\n    }", "label": 0}
{"code": "def create_sentence_list(text_string):\n    '''\n    Splits text_string into a list of sentences based on NLTK's english.pickle tokenizer, and\n    returns said list as type list of str.\n\n    Keyword argument:\n\n    - text_string: string instance\n\n    Exceptions raised:\n\n    - InputError: occurs should a non-string argument be passed\n    '''\n    if text_string is None or text_string == \"\":\n        return []\n    elif isinstance(text_string, str):\n        return SENTENCE_TOKENIZER.tokenize(text_string)\n    else:\n        raise InputError(\"non-string passed as argument for create_sentence_list\")", "label": 1}
{"code": "def clear_all_expired()\n      t = Time.now\n      return if t < @next_expiration && ! @cache.any? {|name, _| @cache_expiration_service.expired?(name.to_sym) }\n      to_expire = @cache.select { |name, entry| entry.expires < t || @cache_expiration_service.expired?(name.to_sym) }\n      to_expire.each do |name, entry|\n        Puppet.debug {\"Evicting cache entry for environment '#{name}'\"}\n        @cache_expiration_service.evicted(name)\n        clear(name)\n        @expirations.delete(entry.expires)\n        Puppet.settings.clear_environment_settings(name)\n      end\n      @next_expiration = @expirations.first || END_OF_TIME\n    end", "label": 4}
{"code": "protected Connection newConnectionFromDataSource(JdbcConnectionDescriptor jcd)\r\n            throws LookupException\r\n    {\r\n        Connection retval = null;\r\n        // use JNDI lookup\r\n        DataSource ds = jcd.getDataSource();\r\n\r\n        if (ds == null)\r\n        {\r\n            // [tomdz] Would it suffice to store the datasources only at the JCDs ?\r\n            //         Only possible problem would be serialization of the JCD because\r\n            //         the data source object in the JCD does not 'survive' this\r\n            ds = (DataSource) dataSourceCache.get(jcd.getDatasourceName());\r\n        }\r\n        try\r\n        {\r\n            if (ds == null)\r\n            {\r\n                /**\r\n                 * this synchronization block won't be a big deal as we only look up\r\n                 * new datasources not found in the map.\r\n                 */\r\n                synchronized (dataSourceCache)\r\n                {\r\n                    InitialContext ic = new InitialContext();\r\n                    ds = (DataSource) ic.lookup(jcd.getDatasourceName());\r\n                    /**\r\n                     * cache the datasource lookup.\r\n                     */\r\n                    dataSourceCache.put(jcd.getDatasourceName(), ds);\r\n                }\r\n            }\r\n            if (jcd.getUserName() == null)\r\n            {\r\n                retval = ds.getConnection();\r\n            }\r\n            else\r\n            {\r\n                retval = ds.getConnection(jcd.getUserName(), jcd.getPassWord());\r\n            }\r\n        }\r\n        catch (SQLException sqlEx)\r\n        {\r\n            log.error(\"SQLException thrown while trying to get Connection from Datasource (\" +\r\n                    jcd.getDatasourceName() + \")\", sqlEx);\r\n            throw new LookupException(\"SQLException thrown while trying to get Connection from Datasource (\" +\r\n                    jcd.getDatasourceName() + \")\", sqlEx);\r\n        }\r\n        catch (NamingException namingEx)\r\n        {\r\n            log.error(\"Naming Exception while looking up DataSource (\" + jcd.getDatasourceName() + \")\", namingEx);\r\n            throw new LookupException(\"Naming Exception while looking up DataSource (\" + jcd.getDatasourceName() +\r\n                    \")\", namingEx);\r\n        }\r\n        // initialize connection\r\n        initializeJdbcConnection(retval, jcd);\r\n        if(log.isDebugEnabled()) log.debug(\"Create new connection using DataSource: \"+retval);\r\n        return retval;\r\n    }", "label": 0}
{"code": "function (what, oldProps, propName, val) {\n\t\tObject.defineProperty(what, propName, {value: val, configurable: true, enumerable: true, writable: true});\n\t}", "label": 3}
{"code": "func PrivateKeyFingerprint(keyBytes []byte) (string, error) {\n\tsigner, err := ssh.ParsePrivateKey(keyBytes)\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn Fingerprint(signer.PublicKey()), nil\n}", "label": 5}
{"code": "public function getTemporaryIdTableName() : string\n    {\n        $schema = $this->getSchemaName() === null\n            ? ''\n            : $this->getSchemaName() . '_';\n\n        // replace dots with underscores because PostgreSQL creates temporary tables in a special schema\n        return $schema . $this->getTableName() . '_id_tmp';\n    }", "label": 2}
{"code": "def option(*args, &block)\n      switches, description = Runner.separate_switches_from_description(*args)\n      proc = block || option_proc(switches)\n      @options << {\n        args: args,\n        proc: proc,\n        switches: switches,\n        description: description,\n      }\n    end", "label": 4}
{"code": "def get_cached_parent_for_taxon(self, child_taxon):\n        \"\"\"If the taxa are being cached, this call will create a the lineage \"spike\" for taxon child_taxon\n\n        Expecting child_taxon to have a non-empty _taxonomic_lineage with response dicts that can create\n            an ancestral TaxonWrapper.\n        \"\"\"\n        if self._ott_id2taxon is None:\n            resp = child_taxon._taxonomic_lineage[0]\n            tl = child_taxon._taxonomic_lineage[1:]\n            assert 'taxonomic_lineage' not in resp\n            resp['taxonomic_lineage'] = tl\n            return TaxonWrapper(taxonomy=child_taxon.taxonomy,\n                                taxomachine_wrapper=self._wr,\n                                prop_dict=resp)  # TODO recursive (indirectly)\n        else:\n            anc = []\n            prev = None\n            for resp in reversed(child_taxon._taxonomic_lineage):\n                ott_id = resp['ot:ottId']\n                curr = self._ott_id2taxon.get(ott_id)\n                if curr is None:\n                    assert 'taxonomic_lineage' not in resp\n                    assert 'parent' not in resp\n                    resp['parent'] = prev\n                    resp['taxonomic_lineage'] = anc\n                    curr = TaxonWrapper(taxonomy=child_taxon.taxonomy,\n                                        taxomachine_wrapper=self._wr,\n                                        prop_dict=resp)\n                elif curr._parent is None and prev is not None:\n                    curr._parent = prev\n                prev = curr\n                anc.insert(0, curr)\n            return prev", "label": 1}
{"code": "func (g *GLogger) Infof(format string, args ...interface{}) {\n\t// GRPC is very verbose, so this is intentionally\n\t// pushes info level statements as Teleport's debug level ones\n\tg.Entry.Debugf(format, args...)\n}", "label": 5}
{"code": "func (p PortBinding) HostAddr() (net.Addr, error) {\n\tswitch p.Proto {\n\tcase UDP:\n\t\treturn &net.UDPAddr{IP: p.HostIP, Port: int(p.HostPort)}, nil\n\tcase TCP:\n\t\treturn &net.TCPAddr{IP: p.HostIP, Port: int(p.HostPort)}, nil\n\tcase SCTP:\n\t\treturn &sctp.SCTPAddr{IP: []net.IP{p.HostIP}, Port: int(p.HostPort)}, nil\n\tdefault:\n\t\treturn nil, ErrInvalidProtocolBinding(p.Proto.String())\n\t}\n}", "label": 5}
{"code": "def sort_args_by_position(*args)\n      args.flatten.compact.sort_by do |arg|\n        pos = arg.source_range.end_pos\n        [pos.line, pos.offset]\n      end\n    end", "label": 4}
{"code": "def monthdays2calendar(cls, year, month):\n        \"\"\" Return a list of the weeks in the month month of the year as full weeks.\n        Weeks are lists of seven tuples of day numbers and weekday numbers. \"\"\"\n        weeks = []\n        week = []\n        for day in NepCal.itermonthdays2(year, month):\n            week.append(day)\n            if len(week) == 7:\n                weeks.append(week)\n                week = []\n        if len(week) > 0:\n            weeks.append(week)\n        return weeks", "label": 1}
{"code": "def template_subst(template, subs, delims=('<', '>')):\n    \"\"\" Perform substitution of content into tagged string.\n\n    For substitutions into template input files for external computational\n    packages, no checks for valid syntax are performed.\n\n    Each key in `subs` corresponds to a delimited\n    substitution tag to be replaced in `template` by the entire text of the\n    value of that key. For example, the dict ``{\"ABC\": \"text\"}`` would\n    convert ``The <ABC> is working`` to  ``The text is working``, using the\n    default delimiters of '<' and '>'. Substitutions are performed in\n    iteration order from `subs`; recursive substitution\n    as the tag parsing proceeds is thus\n    feasible if an :class:`~collections.OrderedDict` is used and substitution\n    key/value pairs are added in the proper order.\n\n    Start and end delimiters for the tags are modified by `delims`. For\n    example, to substitute a tag of the form **{\\|TAG\\|}**, the tuple\n    ``(\"{|\",\"|}\")`` should be passed to `subs_delims`.  Any elements in\n    `delims` past the second are ignored. No checking is\n    performed for whether the delimiters are \"sensible\" or not.\n\n    Parameters\n    ----------\n    template\n        |str| --\n        Template containing tags delimited by `subs_delims`,\n        with tag names and substitution contents provided in `subs`\n\n    subs\n        |dict| of |str| --\n        Each item's key and value are the tag name and corresponding content to\n        be substituted into the provided template.\n\n    delims\n        iterable of |str| --\n        Iterable containing the 'open' and 'close' strings used to mark tags\n        in the template, which are drawn from elements zero and one,\n        respectively. Any elements beyond these are ignored.\n\n    Returns\n    -------\n    subst_text\n        |str| --\n        String generated from the parsed template, with all tag\n        substitutions performed.\n\n    \"\"\"\n\n    # Store the template into the working variable\n    subst_text = template\n\n    # Iterate over subs and perform the .replace() calls\n    for (k,v) in subs.items():\n        subst_text = subst_text.replace(\n                delims[0] + k + delims[1], v)\n    ## next tup\n\n    # Return the result\n    return subst_text", "label": 1}
{"code": "public function setProductSearchParams($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Vision\\V1\\ProductSearchParams::class);\n        $this->product_search_params = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function validateRouteDefinition(routeDef) {\n  var expectedKeys = ['route', 'type', 'module', 'path'];\n  var expectedTypes = ['static', 'module'];\n  var expectedTypeMap = {\n    'static': 'path',\n    'module': 'module'\n  };\n\n  var keys = Object.keys(routeDef);\n  var EXPECTED_NUMBER_OF_PROPERTIES = 3;\n  //Handle warnings first;\n  if (routeDef.route && routeDef.route.substr(0, 1) !== '/') {\n    log.warn('Route path does not start with a slash:', routeDef.route);\n  }\n\n  if(keys.length !== EXPECTED_NUMBER_OF_PROPERTIES) {\n    throw new Error('Route definition does not contain all required properties');\n  }\n\n  _.map(keys, function compareAgainstExpected(key) {\n    if (expectedKeys.indexOf(key) === -1) {\n      throw new Error('Unexpected property found in route definition.  Please check the spelling');\n    }\n  });\n\n  if (expectedTypes.indexOf(routeDef.type) === -1) {\n    throw new Error('Unknown type of route.  Please check your configuration');\n  }\n\n  if (keys.indexOf(expectedTypeMap[routeDef.type]) === -1) {\n    throw new Error('Route type ' + routeDef.type + ' requires ' + expectedTypeMap[routeDef.type] + ' to be defined');\n  }\n\n  return true;\n}", "label": 3}
{"code": "public static function namespaceClassname(string $classCandidate, array $namespacesToTry, callable $determineMatch): ?string\n    {\n        if ($determineMatch($classCandidate)) {\n            return $classCandidate;\n        }\n\n        // Stop if the class is found or we are out of namespaces to try\n        while (! empty($namespacesToTry)) {\n            // Pop off the first namespace and try it\n            $className = array_shift($namespacesToTry).'\\\\'.$classCandidate;\n\n            if ($determineMatch($className)) {\n                return $className;\n            }\n        }\n\n        return null;\n    }", "label": 2}
{"code": "def build_diagonals(self):\r\n    \"\"\"\r\n    Builds the diagonals for the coefficient array\r\n    \"\"\"\r\n\r\n    ##########################################################\r\n    # INCORPORATE BOUNDARY CONDITIONS INTO COEFFICIENT ARRAY #\r\n    ##########################################################\r\n\r\n    # Roll to keep the proper coefficients at the proper places in the\r\n    # arrays: Python will naturally just do vertical shifts instead of \r\n    # diagonal shifts, so this takes into account the horizontal compoent \r\n    # to ensure that boundary values are at the right place.\r\n    self.l2 = np.roll(self.l2, -2)\r\n    self.l1 = np.roll(self.l1, -1)\r\n    self.r1 = np.roll(self.r1, 1)\r\n    self.r2 = np.roll(self.r2, 2)\r\n\r\n    # Then assemble these rows: this is where the periodic boundary condition \r\n    # can matter.\r\n    if self.coeff_matrix is not None:\r\n      pass\r\n    elif self.BC_E == 'Periodic' and self.BC_W == 'Periodic':\r\n      # In this case, the boundary-condition-related stacking has already \r\n      # happened inside b.c.-handling function. This is because periodic\r\n      # boundary conditions require extra diagonals to exist on the edges of \r\n      # the solution array\r\n      pass\r\n    else:\r\n      self.diags = np.vstack((self.l2,self.l1,self.c0,self.r1,self.r2))\r\n      self.offsets = np.array([-2,-1,0,1,2])\r\n\r\n    # Everybody now (including periodic b.c. cases)\r\n    self.coeff_matrix = spdiags(self.diags, self.offsets, self.nx, self.nx, format='csr')", "label": 1}
{"code": "public static systemsession get(nitro_service service, Long sid) throws Exception{\n\t\tsystemsession obj = new systemsession();\n\t\tobj.set_sid(sid);\n\t\tsystemsession response = (systemsession) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public void addColumnNotNull(String column)\r\n    {\r\n\t\t// PAW\r\n\t\t// SelectionCriteria c = ValueCriteria.buildNotNullCriteria(column, getAlias());\r\n\t\tSelectionCriteria c = ValueCriteria.buildNotNullCriteria(column, getUserAlias(column));\r\n        c.setTranslateAttribute(false);\r\n        addSelectionCriteria(c);\r\n    }", "label": 0}
{"code": "func (m HostCertificateManager) ReplaceCACertificatesAndCRLs(ctx context.Context, caCert []string, caCrl []string) error {\n\treq := types.ReplaceCACertificatesAndCRLs{\n\t\tThis:   m.Reference(),\n\t\tCaCert: caCert,\n\t\tCaCrl:  caCrl,\n\t}\n\n\t_, err := methods.ReplaceCACertificatesAndCRLs(ctx, m.Client(), &req)\n\treturn err\n}", "label": 5}
{"code": "public void readFrom(IIMReader reader, int recover) throws IOException, InvalidDataSetException {\r\n\t\tfinal boolean doLog = log != null;\r\n\t\tfor (;;) {\r\n\t\t\ttry {\r\n\t\t\t\tDataSet ds = reader.read();\r\n\t\t\t\tif (ds == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (doLog) {\r\n\t\t\t\t\tlog.debug(\"Read data set \" + ds);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tDataSetInfo info = ds.getInfo();\r\n\t\t\t\tSerializer s = info.getSerializer();\r\n\t\t\t\tif (s != null) {\r\n\t\t\t\t\tif (info.getDataSetNumber() == IIM.DS(1, 90)) {\r\n\t\t\t\t\t\tsetCharacterSet((String) s.deserialize(ds.getData(), activeSerializationContext));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdataSets.add(ds);\r\n\r\n\t\t\t\tif (stopAfter9_10 && info.getDataSetNumber() == IIM.DS(9, 10))\r\n\t\t\t\t\tbreak;\r\n\t\t\t} catch (IIMFormatException e) {\r\n\t\t\t\tif (recoverFromIIMFormat && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (UnsupportedDataSetException e) {\r\n\t\t\t\tif (recoverFromUnsupportedDataSet && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (InvalidDataSetException e) {\r\n\t\t\t\tif (recoverFromInvalidDataSet && recover-- > 0) {\r\n\t\t\t\t\tboolean r = reader.recover();\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.debug(r ? \"Recoved from \" + e : \"Failed to recover from \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!r)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tif (recover-- > 0 && !dataSets.isEmpty()) {\r\n\t\t\t\t\tif (doLog) {\r\n\t\t\t\t\t\tlog.error(\"IOException while reading, however some data sets where recovered, \" + e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}", "label": 0}
{"code": "protected function authenticate()\n  {\n      $keys = KeyStream::GenerateKeys(base64_decode($this->password), $this->parent->getChallengeData());\n      $this->inputKey = new KeyStream($keys[2], $keys[3]);\n      $this->outputKey = new KeyStream($keys[0], $keys[1]);\n      $array = \"\\0\\0\\0\\0\".$this->phoneNumber.$this->parent->getChallengeData().''.time().'000'.hex2bin('00').'000'.hex2bin('00')\n       .Constants::OS_VERSION.hex2bin('00').Constants::MANUFACTURER.hex2bin('00').Constants::DEVICE.hex2bin('00').Constants::BUILD_VERSION;\n      $response = $this->outputKey->EncodeMessage($array, 0, 4, strlen($array) - 4);\n      $this->parent->setOutputKey($this->outputKey);\n\n      return $response;\n  }", "label": 2}
{"code": "public T peek() {\r\n    if (nextToken == null) {\r\n      nextToken = getNext();\r\n    }\r\n    if (nextToken == null) {\r\n      throw new NoSuchElementException();\r\n    }\r\n    return nextToken;\r\n  }", "label": 0}
{"code": "def when_enabled(timeout = nil)\n      msg = '#when_enabled'\n      repl_msg = 'wait_until(&:enabled?)'\n      Watir.logger.deprecate msg, repl_msg, ids: [:when_enabled]\n\n      timeout ||= Watir.default_timeout\n      message = \"waiting for #{selector_string} to become enabled\"\n\n      if block_given?\n        Wait.until(timeout, message) { enabled? }\n        yield self\n      else\n        WhenEnabledDecorator.new(self, timeout, message)\n      end\n    end", "label": 4}
{"code": "function(value, attr, minLength, model) {\n        if (!_.isString(value) || value.length < minLength) {\n          return this.format(getMessageKey(this.msgKey, defaultMessages.minLength), this.formatLabel(attr, model), minLength);\n        }\n      }", "label": 3}
{"code": "def xml_values(target)\n      lazy_load_strings\n      @lazy_load_strings.select { |_key, value| value.downcase.include? target.downcase }\n    end", "label": 4}
{"code": "public static java.sql.Date newDate() {\n        return new java.sql.Date((System.currentTimeMillis() / DAY_MILLIS) * DAY_MILLIS);\n    }", "label": 0}
{"code": "def create_cache_dir(sha)\n      file_dir = File.join(@cache_dir, sha)\n      @cache_dir_mutex.with_read_lock do\n        # mkdir_p doesn't error if the file exists\n        FileUtils.mkdir_p(file_dir, mode: 0o750)\n        FileUtils.touch(file_dir)\n      end\n      file_dir\n    end", "label": 4}
{"code": "def with_replaced_national_prefix(phone, data)\n      return phone unless data[Core::NATIONAL_PREFIX_TRANSFORM_RULE]\n      pattern = cr(\"^(?:#{data[Core::NATIONAL_PREFIX_FOR_PARSING]})\")\n      match = phone.match pattern\n      if match && match.captures.compact.size > 0\n        phone.gsub(pattern, data[Core::NATIONAL_PREFIX_TRANSFORM_RULE])\n      else\n        phone\n      end\n    end", "label": 4}
{"code": "public static gslbservice get(nitro_service service, String servicename) throws Exception{\n\t\tgslbservice obj = new gslbservice();\n\t\tobj.set_servicename(servicename);\n\t\tgslbservice response = (gslbservice) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function setSink($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Logging\\V2\\LogSink::class);\n        $this->sink = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def _load_meta_cache(self):\n        \"\"\" Try to load metadata from file. \"\"\"\n        try:\n            if self._should_invalidate_cache():\n                os.remove(self._cache_filename)\n            else:\n                with open(self._cache_filename, 'rb') as f:\n                    self._document_meta = compat.pickle.load(f)\n        except (OSError, IOError, compat.pickle.PickleError,\n                ImportError, AttributeError):\n            pass", "label": 1}
{"code": "protected function callMatchingMessages()\n    {\n        $matchingMessages = $this->conversationManager->getMatchingMessages($this->getMessages(), $this->middleware,\n            $this->getConversationAnswer(), $this->getDriver());\n\n        foreach ($matchingMessages as $matchingMessage) {\n            $this->command = $matchingMessage->getCommand();\n            $callback = $this->command->getCallback();\n\n            $callback = $this->getCallable($callback);\n\n            // Set the message first, so it's available for middlewares\n            $this->message = $matchingMessage->getMessage();\n\n            $commandMiddleware = Collection::make($this->command->getMiddleware())->filter(function ($middleware) {\n                return $middleware instanceof Heard;\n            })->toArray();\n\n            $this->message = $this->middleware->applyMiddleware('heard', $matchingMessage->getMessage(),\n                $commandMiddleware);\n\n            $parameterNames = $this->compileParameterNames($this->command->getPattern());\n\n            $parameters = $matchingMessage->getMatches();\n            if (\\count($parameterNames) !== \\count($parameters)) {\n                $parameters = array_merge(\n                //First, all named parameters (eg. function ($a, $b, $c))\n                    array_filter(\n                        $parameters,\n                        '\\is_string',\n                        ARRAY_FILTER_USE_KEY\n                    ),\n                    //Then, all other unsorted parameters (regex non named results)\n                    array_filter(\n                        $parameters,\n                        '\\is_integer',\n                        ARRAY_FILTER_USE_KEY\n                    )\n                );\n            }\n\n            $this->matches = $parameters;\n            array_unshift($parameters, $this);\n\n            $parameters = $this->conversationManager->addDataParameters($this->message, $parameters);\n\n            if (call_user_func_array($callback, $parameters)) {\n                return;\n            }\n        }\n\n        if (empty($matchingMessages) && empty($this->getBotMessages()) && ! \\is_null($this->fallbackMessage)) {\n            $this->callFallbackMessage();\n        }\n    }", "label": 2}
{"code": "private function revertIndexColumn($mDataSupport)\n    {\n        if ($this->columnDef['index']) {\n            $index = $mDataSupport ? config('datatables.index_column', 'DT_RowIndex') : 0;\n            $start = (int) $this->request->input('start');\n            $this->collection->transform(function ($data) use ($index, &$start) {\n                $data[$index] = ++$start;\n\n                return $data;\n            });\n        }\n    }", "label": 2}
{"code": "public static base_response add(nitro_service client, nsappflowcollector resource) throws Exception {\n\t\tnsappflowcollector addresource = new nsappflowcollector();\n\t\taddresource.name = resource.name;\n\t\taddresource.ipaddress = resource.ipaddress;\n\t\taddresource.port = resource.port;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "func (l *Lease) Progress(ctx context.Context, percent int32) error {\n\treq := types.HttpNfcLeaseProgress{\n\t\tThis:    l.Reference(),\n\t\tPercent: percent,\n\t}\n\n\t_, err := methods.HttpNfcLeaseProgress(ctx, l.c, &req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "private byte[] createErrorImage(int width, int height, Exception e) throws IOException {\n\t\tString error = e.getMessage();\n\t\tif (null == error) {\n\t\t\tWriter result = new StringWriter();\n\t\t\tPrintWriter printWriter = new PrintWriter(result);\n\t\t\te.printStackTrace(printWriter);\n\t\t\terror = result.toString();\n\t\t}\n\n\t\tBufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);\n\t\tGraphics2D g = (Graphics2D) image.getGraphics();\n\n\t\tg.setColor(Color.RED);\n\t\tg.drawString(error, ERROR_MESSAGE_X, height / 2);\n\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tImageIO.write(image, \"PNG\", out);\n\t\tout.flush();\n\t\tbyte[] result = out.toByteArray();\n\t\tout.close();\n\n\t\treturn result;\n\t}", "label": 0}
{"code": "private function getCollectionReference(\n        ConnectionInterface $connection,\n        ValueMapper $mapper,\n        $projectId,\n        $database,\n        $name\n    ) {\n        if ($this->isRelative($name)) {\n            $name = $this->fullName($projectId, $database, $name);\n        }\n\n        if (!$this->isCollection($name)) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Given path `%s` is not a valid collection path.',\n                $name\n            ));\n        }\n\n        return new CollectionReference($connection, $mapper, $name);\n    }", "label": 2}
{"code": "public Object[] getForeignKeyValues(Object obj, ClassDescriptor mif)\r\n            throws PersistenceBrokerException\r\n    {\r\n        FieldDescriptor[] fks = getForeignKeyFieldDescriptors(mif);\r\n        // materialize object only if FK fields are declared\r\n        if(fks.length > 0) obj = ProxyHelper.getRealObject(obj);\r\n        Object[] result = new Object[fks.length];\r\n        for (int i = 0; i < result.length; i++)\r\n        {\r\n            FieldDescriptor fmd = fks[i];\r\n            PersistentField f = fmd.getPersistentField();\r\n\r\n            // BRJ: do NOT convert.\r\n            // conversion is done when binding the sql-statement\r\n            //\r\n            // FieldConversion fc = fmd.getFieldConversion();\r\n            // Object val = fc.javaToSql(f.get(obj));\r\n\r\n            result[i] = f.get(obj);\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "func (s *APIServer) getAuthServers(auth ClientI, w http.ResponseWriter, r *http.Request, p httprouter.Params, version string) (interface{}, error) {\n\tservers, err := auth.GetAuthServers()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn marshalServers(servers, version)\n}", "label": 5}
{"code": "public function setCard($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\Intent_Message_Card::class);\n        $this->writeOneof(4, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def version(self):\n        '''\n        Returns Weed-FS master version\n\n        :rtype: string\n        '''\n        url = \"http://{master_addr}:{master_port}/dir/status\".format(\n            master_addr=self.master_addr,\n            master_port=self.master_port)\n        data = self.conn.get_data(url)\n        response_data = json.loads(data)\n        return response_data.get(\"Version\")", "label": 1}
{"code": "def verify_counter(self, signature, counter):\n        \"\"\" Verifies that counter value is greater than previous signature\"\"\" \n\n        devices = self.__get_u2f_devices()\n\n        for device in devices:\n            # Searching for specific keyhandle\n            if device['keyHandle'] == signature['keyHandle']:\n                if counter > device['counter']:\n                    \n                    # Updating counter record\n                    device['counter'] = counter\n                    self.__save_u2f_devices(devices)\n                    \n                    return True\n                else:\n                    return False", "label": 1}
{"code": "def create(parameter_names, parameter_types, return_type):\n        \"\"\"Returns a signature object ensuring order of parameter names and types.\n\n        :param parameter_names: A list of ordered parameter names\n        :type parameter_names: list[str]\n        :param parameter_types: A dictionary of parameter names to types\n        :type parameter_types: dict[str, type]\n        :param return_type: The type the function returns\n        :type return_type: type\n        :rtype: MethodSignature\n        \"\"\"\n        ordered_pairs = [(name, parameter_types[name]) for name in parameter_names]\n        return MethodSignature(ordered_pairs, return_type)", "label": 1}
{"code": "public void addProfile(Object key, DescriptorRepository repository)\r\n    {\r\n        if (metadataProfiles.contains(key))\r\n        {\r\n            throw new MetadataException(\"Duplicate profile key. Key '\" + key + \"' already exists.\");\r\n        }\r\n        metadataProfiles.put(key, repository);\r\n    }", "label": 0}
{"code": "func (s *AccessService) DeleteAllRoles() error {\n\treturn s.DeleteRange(context.TODO(), backend.Key(rolesPrefix), backend.RangeEnd(backend.Key(rolesPrefix)))\n}", "label": 5}
{"code": "func NetworkRange(network *net.IPNet) (net.IP, net.IP) {\n\tif network == nil {\n\t\treturn nil, nil\n\t}\n\n\tfirstIP := network.IP.Mask(network.Mask)\n\tlastIP := types.GetIPCopy(firstIP)\n\tfor i := 0; i < len(firstIP); i++ {\n\t\tlastIP[i] = firstIP[i] | ^network.Mask[i]\n\t}\n\n\tif network.IP.To4() != nil {\n\t\tfirstIP = firstIP.To4()\n\t\tlastIP = lastIP.To4()\n\t}\n\n\treturn firstIP, lastIP\n}", "label": 5}
{"code": "public function update(array $metadata, array $options = [])\n    {\n        $options += $metadata;\n        $options += $this->info($options);\n\n        return $this->info = $this->connection->updateSink($options + [\n            'sinkName' => $this->formattedName\n        ]);\n    }", "label": 2}
{"code": "def from_locus_read(cls, locus_read, n_ref):\n        \"\"\"\n        Given a single LocusRead object, return either an AlleleRead or None\n\n        Parameters\n        ----------\n        locus_read : LocusRead\n            Read which overlaps a variant locus but doesn't necessarily contain the\n            alternate nucleotides\n\n        n_ref : int\n            Number of reference positions we are expecting to be modified or\n            deleted (for insertions this should be 0)\n        \"\"\"\n        sequence = locus_read.sequence\n        reference_positions = locus_read.reference_positions\n\n        # positions of the nucleotides before and after the variant within\n        # the read sequence\n        read_pos_before = locus_read.base0_read_position_before_variant\n        read_pos_after = locus_read.base0_read_position_after_variant\n\n        # positions of the nucleotides before and after the variant on the\n        # reference genome\n        ref_pos_before = reference_positions[read_pos_before]\n\n        if ref_pos_before is None:\n            logger.warn(\n                \"Missing reference pos for nucleotide before variant on read: %s\",\n                locus_read)\n            return None\n\n        ref_pos_after = reference_positions[read_pos_after]\n\n        if ref_pos_after is None:\n            logger.warn(\n                \"Missing reference pos for nucleotide after variant on read: %s\",\n                locus_read)\n            return None\n\n        if n_ref == 0:\n            if ref_pos_after - ref_pos_before != 1:\n                # if the number of nucleotides skipped isn't the same\n                # as the number of reference nucleotides in the variant then\n                # don't use this read\n                logger.debug(\n                    \"Positions before (%d) and after (%d) variant should be adjacent on read %s\",\n                    ref_pos_before,\n                    ref_pos_after,\n                    locus_read)\n                return None\n\n            # insertions require a sequence of non-aligned bases\n            # followed by the subsequence reference position\n            ref_positions_for_inserted = reference_positions[\n                read_pos_before + 1:read_pos_after]\n            if any(insert_pos is not None for insert_pos in ref_positions_for_inserted):\n                # all these inserted nucleotides should *not* align to the\n                # reference\n                logger.debug(\n                    \"Skipping read, inserted nucleotides shouldn't map to reference\")\n                return None\n        else:\n            # substitutions and deletions\n            if ref_pos_after - ref_pos_before != n_ref + 1:\n                # if the number of nucleotides skipped isn't the same\n                # as the number of reference nucleotides in the variant then\n                # don't use this read\n                logger.debug(\n                    (\"Positions before (%d) and after (%d) variant should be \"\n                     \"adjacent on read %s\"),\n                    ref_pos_before,\n                    ref_pos_after,\n                    locus_read)\n                return None\n\n        nucleotides_at_variant_locus = sequence[read_pos_before + 1:read_pos_after]\n\n        prefix = sequence[:read_pos_before + 1]\n        suffix = sequence[read_pos_after:]\n\n        prefix, suffix = convert_from_bytes_if_necessary(prefix, suffix)\n        prefix, suffix = trim_N_nucleotides(prefix, suffix)\n\n        return cls(\n            prefix,\n            nucleotides_at_variant_locus,\n            suffix,\n            name=locus_read.name)", "label": 1}
{"code": "function get(values, index, initiatedOnce, rtn) {\n        /**\n         * add the named mixin and all un-added dependencies to the return array\n         * @param the mixin name\n         */\n        function addTo(name) {\n            var indexName = name,\n                match = name.match(/^([^\\(]*)\\s*\\(([^\\)]*)\\)\\s*/),\n                params = match && match[2];\n            name = match && match[1] || name;\n\n            if (!index[indexName]) {\n                if (params) {\n                    // there can be no function calls here because of the regex match\n                    /*jshint evil: true */\n                    params = eval('[' + params + ']');\n                }\n                var mixin = _mixins[name],\n                    checkAgain = false,\n                    skip = false;\n\n                if (mixin) {\n                    if (typeof mixin === 'function') {\n                        if (_initiatedOnce[name]) {\n                            if (!initiatedOnce[name]) {\n                                initiatedOnce[name] = [];\n                                // add the placeholder so the mixin ends up in the right place\n                                // we will replace all names with the appropriate mixins at the end\n                                // (so we have all of the appropriate arguments)\n                                mixin = name;\n                            } else {\n                                // but we only want to add it a single time\n                                skip = true;\n                            }\n                            if (params) {\n                                initiatedOnce[name].push(params);\n                            }\n                        } else {\n                            mixin = mixin.apply(this, params || []);\n                            checkAgain = true;\n                        }\n                    } else if (params) {\n                        throw new Error('the mixin \"' + name + '\" does not support parameters');\n                    }\n                    get(_dependsOn[name], index, initiatedOnce, rtn);\n                    get(_dependsInjected[name], index, initiatedOnce, rtn);\n\n                    index[indexName] = true;\n                    if (checkAgain) {\n                        get([mixin], index, initiatedOnce, rtn);\n                    } else if (!skip) {\n                        checkForInlineMixins(mixin, rtn);\n                        rtn.push(mixin);\n                    }\n\n                } else {\n                    throw new Error('invalid mixin \"' + name + '\"');\n                }\n            }\n        }\n\n        // if the mixin has a \"mixins\" attribute, clone and add those dependencies first\n        function checkForInlineMixins(mixin, rtn) {\n            if (mixin.mixins) {\n                get(mixin.mixins, index, initiatedOnce, rtn);\n            }\n        }\n\n        function handleMixin(mixin) {\n            if (mixin) {\n                if (Array.isArray(mixin)) {\n                    // flatten it out\n                    get(mixin, index, initiatedOnce, rtn);\n                } else if (typeof mixin === 'string') {\n                    // add the named mixin and all of it's dependencies\n                    addTo(mixin);\n                } else {\n                    checkForInlineMixins(mixin, rtn);\n\n                    // just add the mixin normally\n                    rtn.push(mixin);\n                }\n            }\n        }\n\n        if (Array.isArray(values)) {\n            for (var i = 0; i < values.length; i++) {\n                handleMixin(values[i]);\n            }\n        } else {\n            handleMixin(values);\n        }\n    }", "label": 3}
{"code": "def authorize(self, ctx, identity, ops):\n        '''Implements Authorizer.authorize by calling identity.allow to\n        determine whether the identity is a member of the ACLs associated with\n        the given operations.\n        '''\n        if len(ops) == 0:\n            # Anyone is allowed to do nothing.\n            return [], []\n        allowed = [False] * len(ops)\n        has_allow = isinstance(identity, ACLIdentity)\n        for i, op in enumerate(ops):\n            acl = self._get_acl(ctx, op)\n            if has_allow:\n                allowed[i] = identity.allow(ctx, acl)\n            else:\n                allowed[i] = self._allow_public and EVERYONE in acl\n        return allowed, []", "label": 1}
{"code": "public static Trajectory combineTrajectory(Trajectory a, Trajectory b){\n\t\tif(a.getDimension()!=b.getDimension()){\n\t\t\tthrow new IllegalArgumentException(\"Combination not possible: The trajectorys does not have the same dimension\");\n\t\t}\n\t\tif(a.size()!=b.size()){\n\t\t\tthrow new IllegalArgumentException(\"Combination not possible: The trajectorys does not \"\n\t\t\t\t\t+ \"have the same number of steps a=\"+a.size() + \" b=\"+b.size());\n\t\t}\n\t\tTrajectory c = new Trajectory(a.getDimension());\n\t\t\n\t\tfor(int i = 0 ; i < a.size(); i++){\n\t\t\tPoint3d pos = new Point3d(a.get(i).x+b.get(i).x, \n\t\t\t\t\ta.get(i).y+b.get(i).y, \n\t\t\t\t\ta.get(i).z+b.get(i).z);\n\t\t\tc.add(pos);\n\t\t}\n\t\t\n\t\treturn c;\n\t}", "label": 0}
{"code": "def pertotal(table, option):\n    \"\"\"\n    calculate percent of total\n    \"\"\"\n    if option == 'table':\n        total = sum([i for line in table for i in line])\n    t = []\n    for row in table:\n        t_row = []\n        if option != 'table':\n            total = sum(row)\n        for i in row:\n            if total == 0:\n                t_row.append(0)\n            else:\n                t_row.append(i/total*100)\n        t.append(t_row)\n    return t", "label": 1}
{"code": "public static cachepolicy_stats get(nitro_service service, String policyname) throws Exception{\n\t\tcachepolicy_stats obj = new cachepolicy_stats();\n\t\tobj.set_policyname(policyname);\n\t\tcachepolicy_stats response = (cachepolicy_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (t *Text) SetStyle(style tcell.Style) {\n\tt.style = style\n\tfor i := 0; i < len(t.text); i++ {\n\t\tif t.widths[i] != 0 {\n\t\t\tt.styles[i] = t.style\n\t\t}\n\t}\n\tt.PostEventWidgetContent(t)\n}", "label": 5}
{"code": "public function totalCount()\n    {\n        if ($this->skipTotalRecords) {\n            return true;\n        }\n\n        return $this->totalRecords ? $this->totalRecords : $this->count();\n    }", "label": 2}
{"code": "def launch_one_at_a_time(language, locale, device_type, launch_arguments)\n      prepare_for_launch([device_type], language, locale, launch_arguments)\n\n      add_media([device_type], :photo, launcher_config.add_photos) if launcher_config.add_photos\n      add_media([device_type], :video, launcher_config.add_videos) if launcher_config.add_videos\n\n      open_simulator_for_device(device_type)\n\n      command = TestCommandGeneratorXcode8.generate(device_type: device_type, language: language, locale: locale)\n\n      if locale\n        UI.header(\"#{device_type} - #{language} (#{locale})\")\n      else\n        UI.header(\"#{device_type} - #{language}\")\n      end\n\n      execute(command: command, language: language, locale: locale, device_type: device_type, launch_args: launch_arguments)\n\n      raw_output = File.read(TestCommandGeneratorXcode8.xcodebuild_log_path(device_type: device_type, language: language, locale: locale))\n\n      dir_name = locale || language\n\n      return Collector.fetch_screenshots(raw_output, dir_name, device_type, launch_arguments.first)\n    end", "label": 4}
{"code": "function getTokenValuesFromUrl(pattern, url) {\n    var tokenValues = {},\n        urlSegments = url.split('/');\n\n    pattern.split('/').forEach(function (segment, idx) {\n\n        // this has this form {stuff}, so let's dig\n        var beginIdx = segment.indexOf('{');\n        var endIdx = segment.indexOf('}');\n        var endLen = segment.length - endIdx - 1;\n        var urlSegment = urlSegments[idx];\n\n        if (beginIdx > -1) {\n\n            // peel off the { and } at the ends\n            segment = segment.substring(beginIdx + 1, endIdx);\n\n            var pieces = segment.split(':');\n            if (pieces.length === 2 && pieces[1] === urlPathPatternSymbol ) {\n                var vals = [urlSegment.substring(beginIdx, urlSegment.length - endLen)];\n                for ( var i = idx + 1, len = urlSegments.length; i < len; i++ ) {\n                    vals.push(urlSegments[i]);\n                }\n                tokenValues[pieces[0]] = vals.join('%20'); // join any remaining segments with a space\n            }\n            else if (pieces.length === 2 || pieces.length === 1) {\n                tokenValues[pieces[0]] = urlSegment.substring(beginIdx, urlSegment.length - endLen);\n            }\n        } // else no token to grab\n    });\n\n    return tokenValues;\n}", "label": 3}
{"code": "def connect(request, _unused_call)\n      logger.debug(\"RPC Connect: #{request.inspect}\")\n\n      socket = build_socket(env: rack_env(request))\n\n      connection = factory.call(socket)\n\n      connection.handle_open\n\n      if socket.closed?\n        AnyCable::ConnectionResponse.new(status: AnyCable::Status::FAILURE)\n      else\n        AnyCable::ConnectionResponse.new(\n          status: AnyCable::Status::SUCCESS,\n          identifiers: connection.identifiers_json,\n          transmissions: socket.transmissions\n        )\n      end\n    rescue StandardError => exp\n      notify_exception(exp, :connect, request)\n\n      AnyCable::ConnectionResponse.new(\n        status: AnyCable::Status::ERROR,\n        error_msg: exp.message\n      )\n    end", "label": 4}
{"code": "func (c *Manager) FindLibraryItems(\n\tctx context.Context, search FindItem) ([]string, error) {\n\n\turl := internal.URL(c, internal.LibraryItemPath).WithAction(\"find\")\n\tspec := struct {\n\t\tSpec FindItem `json:\"spec\"`\n\t}{search}\n\tvar res []string\n\treturn res, c.Do(ctx, url.Request(http.MethodPost, spec), &res)\n}", "label": 5}
{"code": "public function isProtected()\n    {\n        if (isset($this->middleware['api.auth']) || in_array('api.auth', $this->middleware)) {\n            if ($this->controller && isset($this->middleware['api.auth'])) {\n                return $this->optionsApplyToControllerMethod($this->middleware['api.auth']);\n            }\n\n            return true;\n        }\n\n        return false;\n    }", "label": 2}
{"code": "func Key(label string) (key string) {\n\tif kv := strings.SplitN(label, \"=\", 2); len(kv) > 0 {\n\t\tkey = kv[0]\n\t}\n\treturn\n}", "label": 5}
{"code": "function getPascalCase(filePath) {\n    var camelCase = getCamelCase(filePath);\n    return camelCase.substring(0, 1).toUpperCase() + camelCase.substring(1);\n}", "label": 3}
{"code": "func PgProcParams(db XODB, schema string, proc string) ([]*ProcParam, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`UNNEST(STRING_TO_ARRAY(oidvectortypes(p.proargtypes), ', ')) ` + // ::varchar AS param_type\n\t\t`FROM pg_proc p ` +\n\t\t`JOIN ONLY pg_namespace n ON p.pronamespace = n.oid ` +\n\t\t`WHERE n.nspname = $1 AND p.proname = $2`\n\n\t// run query\n\tXOLog(sqlstr, schema, proc)\n\tq, err := db.Query(sqlstr, schema, proc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer q.Close()\n\n\t// load results\n\tres := []*ProcParam{}\n\tfor q.Next() {\n\t\tpp := ProcParam{}\n\n\t\t// scan\n\t\terr = q.Scan(&pp.ParamType)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres = append(res, &pp)\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "func (cn *connection) updatePiecePriority(piece pieceIndex) bool {\n\ttpp := cn.t.piecePriority(piece)\n\tif !cn.PeerHasPiece(piece) {\n\t\ttpp = PiecePriorityNone\n\t}\n\tif tpp == PiecePriorityNone {\n\t\treturn cn.stopRequestingPiece(piece)\n\t}\n\tprio := cn.getPieceInclination()[piece]\n\tswitch cn.t.requestStrategy {\n\tcase 1:\n\t\tswitch tpp {\n\t\tcase PiecePriorityNormal:\n\t\tcase PiecePriorityReadahead:\n\t\t\tprio -= int(cn.t.numPieces())\n\t\tcase PiecePriorityNext, PiecePriorityNow:\n\t\t\tprio -= 2 * int(cn.t.numPieces())\n\t\tdefault:\n\t\t\tpanic(tpp)\n\t\t}\n\t\tprio += int(piece / 3)\n\tdefault:\n\t}\n\treturn cn.pieceRequestOrder.Set(bitmap.BitIndex(piece), prio) || cn.shouldRequestWithoutBias()\n}", "label": 5}
{"code": "def match?(path)\n      path = ::Rack::Utils.unescape_path path\n      return false unless ::Rack::Utils.valid_path? path\n      path = ::Rack::Utils.clean_path_info path\n\n      paths = [path, \"#{path}#{ext}\", \"#{path}/#{@index}#{ext}\"]\n\n      if match = paths.detect { |p|\n        path = File.join(@root, p.b)\n        begin\n          File.file?(path) && File.readable?(path)\n        rescue SystemCallError\n          false\n        end\n      }\n        return ::Rack::Utils.escape_path(match).b\n      end\n    end", "label": 4}
{"code": "public static base_response delete(nitro_service client, String viewname) throws Exception {\n\t\tdnsview deleteresource = new dnsview();\n\t\tdeleteresource.viewname = viewname;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "def userinfo\n      current_user = self.user\n      current_password = self.password\n      (current_user || current_password) && @userinfo ||= begin\n        if current_user && current_password\n          \"#{current_user}:#{current_password}\"\n        elsif current_user && !current_password\n          \"#{current_user}\"\n        end\n      end\n    end", "label": 4}
{"code": "function GraphProgress(graph, graphDescription) {\n        assert.object(graph, 'graph');\n        assert.string(graphDescription, 'graphDescription');\n\n        this.graph = graph;\n        this.data = {\n            graphId: graph.instanceId,\n            nodeId: graph.node,\n            graphName: graph.name || 'Not available',\n            status: graph._status,\n            progress: {\n                description: graphDescription || 'Not available',\n            }\n        };\n        this._calculateGraphProgress();\n    }", "label": 3}
{"code": "def get_duration(self, matrix_name):\n        \"\"\"\n        Get duration for a concrete matrix.\n\n        Args:\n            matrix_name (str): name of the Matrix.\n\n        Returns:\n            float: duration of concrete matrix in seconds.\n        \"\"\"\n        duration = 0.0\n        if matrix_name in self.data:\n            duration = sum([stage.duration() for stage in self.data[matrix_name]])\n        return duration", "label": 1}
{"code": "public function getIndexForNumber($discussionId, $number, User $actor = null)\n    {\n        $query = Discussion::find($discussionId)\n            ->posts()\n            ->whereVisibleTo($actor)\n            ->where('created_at', '<', function ($query) use ($discussionId, $number) {\n                $query->select('created_at')\n                      ->from('posts')\n                      ->where('discussion_id', $discussionId)\n                      ->whereNotNull('number')\n                      ->take(1)\n\n                      // We don't add $number as a binding because for some\n                      // reason doing so makes the bindings go out of order.\n                      ->orderByRaw('ABS(CAST(number AS SIGNED) - '.(int) $number.')');\n            });\n\n        return $query->count();\n    }", "label": 2}
{"code": "public function setUpdate($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\V1beta1\\Document::class);\n        $this->writeOneof(1, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "private function triggerError($errors, $flags = null)\n    {\n        // This is triggered with things like file_exists()\n        if ($flags & STREAM_URL_STAT_QUIET) {\n            return $flags & STREAM_URL_STAT_LINK\n                // This is triggered for things like is_link()\n                ? $this->formatUrlStat(false)\n                : false;\n        }\n\n        // This is triggered when doing things like lstat() or stat()\n        trigger_error(implode(\"\\n\", (array) $errors), E_USER_WARNING);\n\n        return false;\n    }", "label": 2}
{"code": "func (*TeleportTunnelMarshaler) MarshalReverseTunnel(rt ReverseTunnel, opts ...MarshalOption) ([]byte, error) {\n\tcfg, err := collectOptions(opts)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttype tunv1 interface {\n\t\tV1() *ReverseTunnelV1\n\t}\n\ttype tunv2 interface {\n\t\tV2() *ReverseTunnelV2\n\t}\n\tversion := cfg.GetVersion()\n\tswitch version {\n\tcase V1:\n\t\tv, ok := rt.(tunv1)\n\t\tif !ok {\n\t\t\treturn nil, trace.BadParameter(\"don't know how to marshal %v\", V1)\n\t\t}\n\t\treturn json.Marshal(v.V1())\n\tcase V2:\n\t\tv, ok := rt.(tunv2)\n\t\tif !ok {\n\t\t\treturn nil, trace.BadParameter(\"don't know how to marshal %v\", V2)\n\t\t}\n\t\tv2 := v.V2()\n\t\tif !cfg.PreserveResourceID {\n\t\t\t// avoid modifying the original object\n\t\t\t// to prevent unexpected data races\n\t\t\tcopy := *v2\n\t\t\tcopy.SetResourceID(0)\n\t\t\tv2 = &copy\n\t\t}\n\t\treturn utils.FastMarshal(v2)\n\tdefault:\n\t\treturn nil, trace.BadParameter(\"version %v is not supported\", version)\n\t}\n}", "label": 5}
{"code": "public function setProgressBytes($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\Admin\\V1\\Progress::class);\n        $this->progress_bytes = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func It(text string, body interface{}, timeout ...float64) bool {\n\tglobalSuite.PushItNode(text, body, types.FlagTypeNone, codelocation.New(1), parseTimeout(timeout...))\n\treturn true\n}", "label": 5}
{"code": "function(err, req, res) {\n\n  console.log('handle error:');\n  console.dir(err);\n\n  // uri error\n  if (err instanceof URIError) {\n    return res.status(404).render('errors/404');\n  }\n\n  logger.error(req.method + ' ' + getURL(req) + ' : ' + err);\n  logger.error(err.stack);\n\n  if (!res._headerSent) {\n    // show error\n    if (config.showerrstack) {\n      //\n      const stacktrace = [\n        '<h1>', req.originalUrl, '</h1>',\n        '<pre>', err.stack, '</pre>'\n      ].join('');\n      res.status(500).send(stacktrace);\n    } else {\n      res.status(500).render('errors/500');\n    }\n  }\n\n  if (config.mailcrashto) {\n    mailer.send('crash', {\n      to:       config.mailcrashto,\n      subject:  [ config.appname, 'Crash:', err ].join(' '),\n      body:     formatMessage(req, err)\n    })\n  }\n}", "label": 3}
{"code": "def build_uri(base_uri, rest_path)\n      if server.options[:single_org]\n        # Strip off /organizations/chef if we are in single org mode\n        if rest_path[0..1] != [ \"organizations\", server.options[:single_org] ]\n          raise \"Unexpected URL #{rest_path[0..1]} passed to build_uri in single org mode\"\n        end\n\n        return self.class.build_uri(base_uri, rest_path[2..-1])\n      end\n\n      self.class.build_uri(base_uri, rest_path)\n    end", "label": 4}
{"code": "function (patternFolder, files, cb) {\n    var file, patterns = [];\n    files.forEach(function readPattern(pattern) {\n      file = {filename: pattern};\n      file.content = grunt.file.read(patternFolder + '/' + file.filename);\n      patterns.push(file);\n    });\n\n    // call the outputPatterns function that generates\n    // the html for every pattern\n    outputPatterns(patternFolder, patterns, cb);\n  }", "label": 3}
{"code": "func (r *Registry) FileManager() *FileManager {\n\treturn r.Get(r.content().FileManager.Reference()).(*FileManager)\n}", "label": 5}
{"code": "public static function parse($uri)\n    {\n        if (stripos($uri, 'unix://') === 0) {\n            // parse_url() can parse unix:/path/to/sock so we do not need the\n            // unix:///path/to/sock hack, we will support it anyway until 2.0.\n            $uri = str_ireplace('unix://', 'unix:', $uri);\n        }\n\n        if (!$parsed = parse_url($uri)) {\n            throw new \\InvalidArgumentException(\"Invalid parameters URI: $uri\");\n        }\n\n        if (\n            isset($parsed['host'])\n            && false !== strpos($parsed['host'], '[')\n            && false !== strpos($parsed['host'], ']')\n        ) {\n            $parsed['host'] = substr($parsed['host'], 1, -1);\n        }\n\n        if (isset($parsed['query'])) {\n            parse_str($parsed['query'], $queryarray);\n            unset($parsed['query']);\n\n            $parsed = array_merge($parsed, $queryarray);\n        }\n\n        if (stripos($uri, 'redis') === 0) {\n            if (isset($parsed['pass'])) {\n                $parsed['password'] = $parsed['pass'];\n                unset($parsed['pass']);\n            }\n\n            if (isset($parsed['path']) && preg_match('/^\\/(\\d+)(\\/.*)?/', $parsed['path'], $path)) {\n                $parsed['database'] = $path[1];\n\n                if (isset($path[2])) {\n                    $parsed['path'] = $path[2];\n                } else {\n                    unset($parsed['path']);\n                }\n            }\n        }\n\n        return $parsed;\n    }", "label": 2}
{"code": "protected function registerOrchid(): self\n    {\n        $this->publishes([\n            realpath(PLATFORM_PATH.'/install-stubs/routes/') => base_path('routes'),\n            realpath(PLATFORM_PATH.'/install-stubs/Orchid/') => app_path('Orchid'),\n        ], 'orchid-stubs');\n\n        return $this;\n    }", "label": 2}
{"code": "def fetch(self, request, callback=None, raise_error=True, **kwargs):\n        \"\"\"Executes a request by AsyncHTTPClient,\n        asynchronously returning an `tornado.HTTPResponse`.\n\n           The ``raise_error=False`` argument currently suppresses\n           *all* errors, encapsulating them in `HTTPResponse` objects\n           following the tornado http-client standard\n        \"\"\"\n        # accepts request as string then convert it to HTTPRequest\n        if isinstance(request, str):\n            request = HTTPRequest(request, **kwargs)\n\n        try:\n            # The first request calls tornado-client ignoring the\n            # possible exception, in case of 401 response,\n            # renews the access token and replay it\n            response = yield self._authorized_fetch(request,\n                                                    callback,\n                                                    raise_error=False,\n                                                    **kwargs)\n\n            if response.code == BAD_TOKEN:\n                yield self._token_manager.reset_token()\n            elif response.error and raise_error:\n                raise response.error\n            else:\n                raise gen.Return(response)\n\n            # The request with renewed token\n            response = yield self._authorized_fetch(request,\n                                                    callback,\n                                                    raise_error=raise_error,\n                                                    **kwargs)\n            raise gen.Return(response)\n\n        except TokenError as err:\n            yield self._token_manager.reset_token()\n            raise err", "label": 1}
{"code": "public function getCookies()\n    {\n        $cookieArrays = $this->executor->execute(DriverCommand::GET_ALL_COOKIES);\n        $cookies = [];\n\n        foreach ($cookieArrays as $cookieArray) {\n            $cookies[] = Cookie::createFromArray($cookieArray);\n        }\n\n        return $cookies;\n    }", "label": 2}
{"code": "func SetOutputMode(mode OutputMode) OutputMode {\n\tif screen.Colors() < 256 {\n\t\tmode = OutputNormal\n\t}\n\tswitch mode {\n\tcase OutputCurrent:\n\t\treturn outMode\n\tcase OutputNormal, Output256, Output216, OutputGrayscale:\n\t\toutMode = mode\n\t\treturn mode\n\tdefault:\n\t\treturn outMode\n\t}\n}", "label": 5}
{"code": "func (m *Manager) CreateDescriptor(ctx context.Context, obj mo.Reference, cdp types.OvfCreateDescriptorParams) (*types.OvfCreateDescriptorResult, error) {\n\treq := types.CreateDescriptor{\n\t\tThis: m.Reference(),\n\t\tObj:  obj.Reference(),\n\t\tCdp:  cdp,\n\t}\n\n\tres, err := methods.CreateDescriptor(ctx, m.c, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &res.Returnval, nil\n}", "label": 5}
{"code": "def print_genome_matrix(hits, fastas, id2desc, file_name):\n    \"\"\"\n    optimize later? slow ...\n    should combine with calculate_threshold module\n    \"\"\"\n    out = open(file_name, 'w')\n    fastas = sorted(fastas)\n    print('## percent identity between genomes', file=out)\n    print('# - \\t %s' % ('\\t'.join(fastas)), file=out)\n    for fasta in fastas:\n        line = [fasta]\n        for other in fastas:\n            if other == fasta:\n                average = '-'\n            else:\n                average = numpy.average([hits[fasta][other][i][3] for i in hits[fasta][other]])\n            line.append(str(average))\n        print('\\t'.join(line), file=out)\n    print('', file=out)\n    print('## percent of orfs that are orthologous between genomes', file=out)\n    print('# - \\t %s' % ('\\t'.join(fastas)), file=out)\n    for fasta in fastas:\n        line = [fasta]\n        for other in fastas:\n            if other == fasta:\n                percent = '-'\n            else:\n                orthologs = float(len(hits[fasta][other]))\n                orfs = float(len([i for i in id2desc if id2desc[i][0] == fasta]))\n                percent = float(orthologs / orfs) * 100\n            line.append(str(percent))\n        print('\\t'.join(line), file=out)", "label": 1}
{"code": "public function setKeyValue($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Datastore\\V1\\Key::class);\n        $this->writeOneof(5, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "protected function getSelectColumnSQL($field, ClassMetadata $class, $alias = 'r')\n    {\n        $property    = $class->getProperty($field);\n        $columnAlias = $this->getSQLColumnAlias();\n        $sql         = sprintf(\n            '%s.%s',\n            $this->getSQLTableAlias($property->getTableName(), ($alias === 'r' ? '' : $alias)),\n            $this->platform->quoteIdentifier($property->getColumnName())\n        );\n\n        $this->currentPersisterContext->rsm->addFieldResult($alias, $columnAlias, $field, $class->getClassName());\n\n        return $property->getType()->convertToPHPValueSQL($sql, $this->platform) . ' AS ' . $columnAlias;\n    }", "label": 2}
{"code": "public void removeDropPasteWorker(DropPasteWorkerInterface worker)\r\n    {\r\n        this.dropPasteWorkerSet.remove(worker);\r\n        java.util.Iterator it = this.dropPasteWorkerSet.iterator();\r\n        int newDefaultActions = 0;\r\n        while (it.hasNext())\r\n            newDefaultActions |= ((DropPasteWorkerInterface)it.next()).getAcceptableActions(defaultDropTarget.getComponent());\r\n        defaultDropTarget.setDefaultActions(newDefaultActions);\r\n    }", "label": 0}
{"code": "public Identity refreshIdentity()\r\n    {\r\n        Identity oldOid = getIdentity();\r\n        this.oid = getBroker().serviceIdentity().buildIdentity(myObj);\r\n        return oldOid;\r\n    }", "label": 0}
{"code": "public function snapshot(DocumentReference $document, array $options = [])\n    {\n        return $this->createSnapshot($this->connection, $this->valueMapper, $document, [\n            'transaction' => $this->transaction,\n        ] + $options);\n    }", "label": 2}
{"code": "public static gslbsite_stats get(nitro_service service, String sitename) throws Exception{\n\t\tgslbsite_stats obj = new gslbsite_stats();\n\t\tobj.set_sitename(sitename);\n\t\tgslbsite_stats response = (gslbsite_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def add_to_guardfile\n      klass = plugin_class # call here to avoid failing later\n\n      require_relative \"guardfile/evaluator\"\n      # TODO: move this to Generator?\n      options = Guard.state.session.evaluator_options\n      evaluator = Guardfile::Evaluator.new(options)\n      begin\n        evaluator.evaluate\n      rescue Guard::Guardfile::Evaluator::NoPluginsError\n      end\n\n      if evaluator.guardfile_include?(name)\n        UI.info \"Guardfile already includes #{ name } guard\"\n      else\n        content = File.read(\"Guardfile\")\n        File.open(\"Guardfile\", \"wb\") do |f|\n          f.puts(content)\n          f.puts(\"\")\n          f.puts(klass.template(plugin_location))\n        end\n\n        UI.info INFO_ADDED_GUARD_TO_GUARDFILE % name\n      end\n    end", "label": 4}
{"code": "public function rename($username)\n    {\n        if ($username !== $this->username) {\n            $oldUsername = $this->username;\n            $this->username = $username;\n\n            $this->raise(new Renamed($this, $oldUsername));\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "async def open(self) -> '_BaseAgent':\n        \"\"\"\n        Context manager entry; open wallet.\n        For use when keeping agent open across multiple calls.\n\n        :return: current object\n        \"\"\"\n\n        LOGGER.debug('_BaseAgent.open >>>')\n\n        # Do not open pool independently: let relying party decide when to go on-line and off-line\n        await self.wallet.open()\n\n        LOGGER.debug('_BaseAgent.open <<<')\n        return self", "label": 1}
{"code": "protected void associateBatched(Collection owners, Collection children)\r\n    {\r\n        CollectionDescriptor cds = getCollectionDescriptor();\r\n        PersistentField field = cds.getPersistentField();\r\n        PersistenceBroker pb = getBroker();\r\n        Class ownerTopLevelClass = pb.getTopLevelClass(getOwnerClassDescriptor().getClassOfObject());\r\n        Class collectionClass = cds.getCollectionClass(); // this collection type will be used:\r\n        HashMap ownerIdsToLists = new HashMap(owners.size());\r\n\r\n        IdentityFactory identityFactory = pb.serviceIdentity();\r\n        // initialize the owner list map\r\n        for (Iterator it = owners.iterator(); it.hasNext();)\r\n        {\r\n            Object owner = it.next();\r\n            ownerIdsToLists.put(identityFactory.buildIdentity(getOwnerClassDescriptor(), owner), new ArrayList());\r\n        }\r\n\r\n        // build the children lists for the owners\r\n        for (Iterator it = children.iterator(); it.hasNext();)\r\n        {\r\n            Object child = it.next();\r\n            // BRJ: use cld for real class, relatedObject could be Proxy\r\n            ClassDescriptor cld = getDescriptorRepository().getDescriptorFor(ProxyHelper.getRealClass(child));\r\n\r\n            Object[] fkValues = cds.getForeignKeyValues(child, cld);\r\n            Identity ownerId = identityFactory.buildIdentity(null, ownerTopLevelClass, fkValues);\r\n            List list = (List) ownerIdsToLists.get(ownerId);\r\n            if (list != null)\r\n            {\r\n                list.add(child);\r\n            }\r\n        }\r\n\r\n        // connect children list to owners\r\n        for (Iterator it = owners.iterator(); it.hasNext();)\r\n        {\r\n            Object result;\r\n            Object owner = it.next();\r\n            Identity ownerId = identityFactory.buildIdentity(owner);\r\n            List list = (List) ownerIdsToLists.get(ownerId);\r\n\r\n            if ((collectionClass == null) && field.getType().isArray())\r\n            {\r\n                int length = list.size();\r\n                Class itemtype = field.getType().getComponentType();\r\n                result = Array.newInstance(itemtype, length);\r\n                for (int j = 0; j < length; j++)\r\n                {\r\n                    Array.set(result, j, list.get(j));\r\n                }\r\n            }\r\n            else\r\n            {\r\n                ManageableCollection col = createCollection(cds, collectionClass);\r\n                for (Iterator it2 = list.iterator(); it2.hasNext();)\r\n                {\r\n                    col.ojbAdd(it2.next());\r\n                }\r\n                result = col;\r\n            }\r\n\r\n            Object value = field.get(owner);\r\n            if ((value instanceof CollectionProxyDefaultImpl) && (result instanceof Collection))\r\n            {\r\n                ((CollectionProxyDefaultImpl) value).setData((Collection) result);\r\n            }\r\n            else\r\n            {\r\n                field.set(owner, result);\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "func (m *DatastoreFileManager) DeleteFile(ctx context.Context, name string) error {\n\tp := m.Path(name)\n\n\ttask, err := m.FileManager.DeleteDatastoreFile(ctx, p.String(), m.Datacenter)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn m.wait(ctx, task)\n}", "label": 5}
{"code": "public function update(array $subscription, array $options = [])\n    {\n        return $this->info = $this->connection->updateSubscription([\n            'name' => $this->name\n        ] + $options + $subscription);\n    }", "label": 2}
{"code": "public void drawGeometry(Geometry geometry, SymbolInfo symbol, Color fillColor, Color strokeColor, float lineWidth,\n\t\t\tfloat[] dashArray, Rectangle clipRect) {\n\t\ttemplate.saveState();\n\t\t// clipping code\n\t\tif (clipRect != null) {\n\t\t\ttemplate.rectangle(clipRect.getLeft() + origX, clipRect.getBottom() + origY, clipRect.getWidth(), clipRect\n\t\t\t\t\t.getHeight());\n\t\t\ttemplate.clip();\n\t\t\ttemplate.newPath();\n\t\t}\n\t\tsetStroke(strokeColor, lineWidth, dashArray);\n\t\tsetFill(fillColor);\n\t\tdrawGeometry(geometry, symbol);\n\t\ttemplate.restoreState();\n\t}", "label": 0}
{"code": "def vanity? number\n      country, _, national = partial_split number\n      country.vanity? national\n    end", "label": 4}
{"code": "def rename_column(old, nu)\n      col = @origin.columns[old.to_s]\n\n      definition = col[:type]\n      definition += ' NOT NULL' unless col[:is_nullable]\n      definition += \" DEFAULT #{@connection.quote(col[:column_default])}\" if col[:column_default]\n\n      ddl('alter table `%s` change column `%s` `%s` %s' % [@name, old, nu, definition])\n      @renames[old.to_s] = nu.to_s\n    end", "label": 4}
{"code": "def add_form_widget_attr(field, attr_name, attr_value, replace=0):\n    \"\"\"\n    Adds widget attributes to a bound form field.\n\n    This is helpful if you would like to add a certain class to all your forms\n    (i.e. `form-control` to all form fields when you are using Bootstrap)::\n\n        {% load libs_tags %}\n        {% for field in form.fields %}\n            {% add_form_widget_attr field 'class' 'form-control' as field_ %}\n            {{ field_ }}\n        {% endfor %}\n\n    The tag will check if the attr already exists and only append your value.\n    If you would like to replace existing attrs, set `replace=1`::\n\n        {% add_form_widget_attr field 'class' 'form-control' replace=1 as\n          field_ %}\n\n\n    \"\"\"\n    if not replace:\n        attr = field.field.widget.attrs.get(attr_name, '')\n        attr += force_text(attr_value)\n        field.field.widget.attrs[attr_name] = attr\n        return field\n    else:\n        field.field.widget.attrs[attr_name] = attr_value\n        return field", "label": 1}
{"code": "protected function decrypt($encryptedData)\n    {\n        try {\n            if ($this->encryptionKey instanceof Key) {\n                return Crypto::decrypt($encryptedData, $this->encryptionKey);\n            }\n\n            return Crypto::decryptWithPassword($encryptedData, $this->encryptionKey);\n        } catch (Exception $e) {\n            throw new LogicException($e->getMessage(), null, $e);\n        }\n    }", "label": 2}
{"code": "protected function decrypt(\n        $cipherText,\n        MaterialsProvider $provider,\n        MetadataEnvelope $envelope,\n        array $cipherOptions = []\n    ) {\n        $cipherOptions['Iv'] = base64_decode(\n            $envelope[MetadataEnvelope::IV_HEADER]\n        );\n\n        $cipherOptions['TagLength'] =\n            $envelope[MetadataEnvelope::CRYPTO_TAG_LENGTH_HEADER] / 8;\n\n        $cek = $provider->decryptCek(\n            base64_decode(\n                $envelope[MetadataEnvelope::CONTENT_KEY_V2_HEADER]\n            ),\n            json_decode(\n                $envelope[MetadataEnvelope::MATERIALS_DESCRIPTION_HEADER],\n                true\n            )\n        );\n        $cipherOptions['KeySize'] = strlen($cek) * 8;\n        $cipherOptions['Cipher'] = $this->getCipherFromAesName(\n            $envelope[MetadataEnvelope::CONTENT_CRYPTO_SCHEME_HEADER]\n        );\n\n        $decryptionSteam = $this->getDecryptingStream(\n            $cipherText,\n            $cek,\n            $cipherOptions\n        );\n        unset($cek);\n\n        return $decryptionSteam;\n    }", "label": 2}
{"code": "public function setProperty($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Datastore\\V1\\PropertyReference::class);\n        $this->property = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function BriToPbn(opts) {\n    if (!(this instanceof BriToPbn)) return new BriToPbn(opts);\n\n    opts = opts || {};\n    this.needDirectives = true;\n    this.boardNumber = opts.boardNumber || 1;\n\n    stream.Transform.call(this, opts);\n}", "label": 3}
{"code": "function getAutomaticTypeDirectiveNames(options, host) {\n        // Use explicit type list from tsconfig.json\n        if (options.types) {\n            return options.types;\n        }\n        // Walk the primary type lookup locations\n        var result = [];\n        if (host.directoryExists && host.getDirectories) {\n            var typeRoots = getEffectiveTypeRoots(options, host);\n            if (typeRoots) {\n                for (var _i = 0, typeRoots_1 = typeRoots; _i < typeRoots_1.length; _i++) {\n                    var root = typeRoots_1[_i];\n                    if (host.directoryExists(root)) {\n                        for (var _a = 0, _b = host.getDirectories(root); _a < _b.length; _a++) {\n                            var typeDirectivePath = _b[_a];\n                            var normalized = ts.normalizePath(typeDirectivePath);\n                            var packageJsonPath = ts.pathToPackageJson(ts.combinePaths(root, normalized));\n                            // tslint:disable-next-line:no-null-keyword\n                            var isNotNeededPackage = host.fileExists(packageJsonPath) && ts.readJson(packageJsonPath, host).typings === null;\n                            if (!isNotNeededPackage) {\n                                // Return just the type directive names\n                                result.push(ts.getBaseFileName(normalized));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }", "label": 3}
{"code": "function updateDataSourceEntry(params, dataSourceData, callback) {\n  var dataToUpdate = dataSourceData.data;\n  var dataSourceDocument = dataSourceData.document;\n\n  logger.debug(\"updateDataSourceEntry \", params, dataSourceData);\n\n  //If there is no cache entry, create a new one to validate.\n  var cacheElement = dataSourceDocument.cache[0];\n\n  if (!cacheElement) {\n    dataSourceDocument.cache.push({});\n  }\n\n  cacheElement = dataSourceDocument.cache[0];\n\n  //Assigning the last attempt to update the data source\n  cacheElement.updateTimestamp = params.currentTime;\n\n  var existingData = cacheElement.data;\n  var existingHash = cacheElement.dataHash;\n\n  logger.debug(\"updateDataSourceEntry \", {dataToUpdate: dataToUpdate, cacheElement: cacheElement, existingData: existingData, existingHash: existingHash});\n\n  if (dataSourceData.dataError || dataSourceData.error) {\n    cacheElement.currentStatus = {\n      status: \"error\",\n      error: dataSourceData.dataError || dataSourceData.error\n    };\n  } else if (dataSourceData.dataHash !== cacheElement.dataHash) {\n    //If the hashes are different, need to update the data set and hash\n    cacheElement.data = dataToUpdate;\n    cacheElement.dataHash = dataSourceData.dataHash;\n    dataSourceData.dataChanged = true;\n  }\n\n  logger.debug(\"updateDataSourceEntry \", {cacheElementBeforeValidation: cacheElement});\n\n  async.waterfall([\n    function validateDataPassed(cb) {\n      //Validating That the Data That Was Passed is correct.\n      dataSourceDocument.save(function(err) {\n        if (err) {\n          logger.warn(\"Error Validating Data Source \", {error: err});\n          //Not Valid, don't try to save it, mark it as an error state\n          dataSourceData.error = buildErrorResponse({\n            error: err,\n            userDetail: \"Invalid Data For Cache Update.\",\n            systemDetail: err.message,\n            code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS\n          });\n\n          //If there is a validation error, save it with the exiting data set Data Source for viewing later.\n          cacheElement.data = existingData ? existingData : [];\n          cacheElement.dataHash = existingHash;\n          cacheElement.currentStatus = {\n            status: \"error\",\n            error: dataSourceData.error\n          };\n        }\n\n        if (!dataSourceData.error && !dataSourceData.dataError) {\n          //marking the status as ok.\n          cacheElement.currentStatus = {\n            status: \"ok\",\n            error: null\n          };\n          //Resetting the backOffIndex as it is a valid Data Source update.\n          cacheElement.backOffIndex = 0;\n          cacheElement.markModified('currentStatus');\n        } else {\n          //The data source encountered an error. Increment the backOffIndex.\n          cacheElement.backOffIndex = cacheElement.backOffIndex ? cacheElement.backOffIndex + 1 : 1;\n        }\n\n        //Mark The Submission As Refreshed\n        cacheElement.lastRefreshed = params.currentTime;\n\n        logger.debug(\"updateDataSourceEntry \", {cacheElementAfterValidate: cacheElement});\n\n        cb();\n      });\n    },\n    async.apply(saveAuditLogEntryAndUpdateDataSource, _.extend({\n      cacheElement: cacheElement,\n      dataSourceDocument: dataSourceDocument,\n      dataSourceData: dataSourceData\n    }, params))\n  ], callback);\n}", "label": 3}
{"code": "func (tc *TeleportClient) accessPoint(clt auth.AccessPoint, proxyHostPort string, clusterName string) (auth.AccessPoint, error) {\n\t// If no caching policy was set or on Windows (where Teleport does not\n\t// support file locking at the moment), return direct access to the access\n\t// point.\n\tif tc.CachePolicy == nil || runtime.GOOS == teleport.WindowsOS {\n\t\tlog.Debugf(\"not using caching access point\")\n\t\treturn clt, nil\n\t}\n\treturn clt, nil\n}", "label": 5}
{"code": "def parse_unixtime(value)\n      unless value.is_a?(String) || value.is_a?(Numeric)\n        raise TimeParseError, \"value must be a string or a number: #{value}(value.class)\"\n      end\n\n      if @cache1_key == value\n        return @cache1_time\n      elsif @cache2_key == value\n        return @cache2_time\n      end\n\n      begin\n        time = Fluent::EventTime.new(value.to_i)\n      rescue => e\n        raise TimeParseError, \"invalid time format: value = #{value}, error_class = #{e.class.name}, error = #{e.message}\"\n      end\n      @cache1_key = @cache2_key\n      @cache1_time = @cache2_time\n      @cache2_key = value\n      @cache2_time = time\n      time\n    end", "label": 4}
{"code": "def upgrade_v1_1_v1_5\n      with_collection_lock do\n        temp_dir = Pathname.new(Dir.mktmpdir(TEMP_PREFIX, @temp_root))\n\n        @directory.children(true).each do |boxdir|\n          # Ignore all non-directories because they can't be boxes\n          next if !boxdir.directory?\n\n          box_name = boxdir.basename.to_s\n\n          # If it is a v1 box, then we need to upgrade it first\n          if v1_box?(boxdir)\n            upgrade_dir = v1_upgrade(boxdir)\n            FileUtils.mv(upgrade_dir, boxdir.join(\"virtualbox\"))\n          end\n\n          # Create the directory for this box\n          new_box_dir = temp_dir.join(dir_name(box_name), \"0\")\n          new_box_dir.mkpath\n\n          # Go through each provider and move it\n          boxdir.children(true).each do |providerdir|\n            FileUtils.cp_r(providerdir, new_box_dir.join(providerdir.basename))\n          end\n        end\n\n        # Move the folder into place\n        @directory.rmtree\n        FileUtils.mv(temp_dir.to_s, @directory.to_s)\n      end\n    end", "label": 4}
{"code": "func (p *PointType) Transform(x, y float64) PointType {\n\treturn PointType{p.X + x, p.Y + y}\n}", "label": 5}
{"code": "def keys_with_ttl(pattern = SCAN_PATTERN, count = DEFAULT_COUNT)\n      hash = {}\n      redis do |conn|\n        conn.scan_each(match: prefix(pattern), count: count).each do |key|\n          hash[key] = conn.ttl(key)\n        end\n      end\n      hash\n    end", "label": 4}
{"code": "def describe(self):\n        \"\"\"Describes the method.\n\n        :return: Description\n        :rtype: dict[str, object]\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"params\": self.params,\n            \"returns\": self.returns,\n            \"description\": self.description,\n        }", "label": 1}
{"code": "public static base_response delete(nitro_service client, String selectorname) throws Exception {\n\t\tcacheselector deleteresource = new cacheselector();\n\t\tdeleteresource.selectorname = selectorname;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "public static base_response add(nitro_service client, nsacl6 resource) throws Exception {\n\t\tnsacl6 addresource = new nsacl6();\n\t\taddresource.acl6name = resource.acl6name;\n\t\taddresource.acl6action = resource.acl6action;\n\t\taddresource.td = resource.td;\n\t\taddresource.srcipv6 = resource.srcipv6;\n\t\taddresource.srcipop = resource.srcipop;\n\t\taddresource.srcipv6val = resource.srcipv6val;\n\t\taddresource.srcport = resource.srcport;\n\t\taddresource.srcportop = resource.srcportop;\n\t\taddresource.srcportval = resource.srcportval;\n\t\taddresource.destipv6 = resource.destipv6;\n\t\taddresource.destipop = resource.destipop;\n\t\taddresource.destipv6val = resource.destipv6val;\n\t\taddresource.destport = resource.destport;\n\t\taddresource.destportop = resource.destportop;\n\t\taddresource.destportval = resource.destportval;\n\t\taddresource.ttl = resource.ttl;\n\t\taddresource.srcmac = resource.srcmac;\n\t\taddresource.protocol = resource.protocol;\n\t\taddresource.protocolnumber = resource.protocolnumber;\n\t\taddresource.vlan = resource.vlan;\n\t\taddresource.Interface = resource.Interface;\n\t\taddresource.established = resource.established;\n\t\taddresource.icmptype = resource.icmptype;\n\t\taddresource.icmpcode = resource.icmpcode;\n\t\taddresource.priority = resource.priority;\n\t\taddresource.state = resource.state;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def insert(self, index, value):\n        \"\"\"Insert an item at a given position.\"\"\"\n        return super(Collection, self).insert(\n            index, self._ensure_value_is_valid(value))", "label": 1}
{"code": "func (t *terminal) Wait() (*ExecResult, error) {\n\terr := t.cmd.Wait()\n\tif err != nil {\n\t\tif exitErr, ok := err.(*exec.ExitError); ok {\n\t\t\tstatus := exitErr.Sys().(syscall.WaitStatus)\n\t\t\treturn &ExecResult{Code: status.ExitStatus(), Command: t.cmd.Path}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tstatus, ok := t.cmd.ProcessState.Sys().(syscall.WaitStatus)\n\tif !ok {\n\t\treturn nil, trace.Errorf(\"unknown exit status: %T(%v)\", t.cmd.ProcessState.Sys(), t.cmd.ProcessState.Sys())\n\t}\n\n\treturn &ExecResult{\n\t\tCode:    status.ExitStatus(),\n\t\tCommand: t.cmd.Path,\n\t}, nil\n}", "label": 5}
{"code": "def process_exception(self, request, exception):\n        \"\"\"\n        Add user details.\n        \"\"\"\n        if request.user and hasattr(request.user, 'email'):\n            request.META['USER'] = request.user.email", "label": 1}
{"code": "function resolveApp(baseAliasOrNameOrApp, options) {\n    if (options === void 0) { options = {}; }\n    // defaults on arguments given\n    var url;\n    if (!baseAliasOrNameOrApp) {\n        url = options.application || init.initOptions.application;\n    }\n    else if (_.isString(baseAliasOrNameOrApp)) {\n        url = baseAliasOrNameOrApp;\n    }\n    else {\n        url = baseAliasOrNameOrApp.baseAlias || baseAliasOrNameOrApp.name;\n    }\n    // application must not include the leading slash for resolveUrl to do the job\n    url = url.replace(/\\/?(.*)/, '$1');\n    // resolve local path against application\n    return resolveUrl('.', _.defaults({\n        application: url\n    }, options));\n}", "label": 3}
{"code": "func GetClusterConfigSchema(extensionSchema string) string {\n\tvar clusterConfigSchema string\n\tif clusterConfigSchema == \"\" {\n\t\tclusterConfigSchema = fmt.Sprintf(ClusterConfigSpecSchemaTemplate, \"\")\n\t} else {\n\t\tclusterConfigSchema = fmt.Sprintf(ClusterConfigSpecSchemaTemplate, \",\"+extensionSchema)\n\t}\n\treturn fmt.Sprintf(V2SchemaTemplate, MetadataSchema, clusterConfigSchema, DefaultDefinitions)\n}", "label": 5}
{"code": "function Logger () {\n  const levels = [\n    'fatal', // 1\n    'error', // 2\n    'warn', // 3\n    'info', // 4\n    'debug' // 5\n  ];\n  let verbosity = 3;\n\n  levels.forEach((level, idx) => {\n    this[level] = (...params) => {\n      if (idx + 1 <= verbosity) console.log(...params); // eslint-disable-line\n    };\n  });\n\n  this.setLevel = (_) => {\n    verbosity = _;\n  };\n\n  return this;\n}", "label": 3}
{"code": "def invalidate(self, context, sid):\n\t\t\"\"\"Immediately expire a session from the backing store.\"\"\"\n\t\t\n\t\tresult = self._Document.get_collection().delete_one({'_id': sid})\n\t\t\n\t\treturn result.deleted_count == 1", "label": 1}
{"code": "def collect_program_info(self, fname):\n        \"\"\"\n        gets details on the program, size, date, list of functions\n        and produces a Markdown file for documentation\n        \"\"\"\n        md = '#AIKIF Technical details\\n'\n        md += 'Autogenerated list of programs with comments and progress\\n'\n        md += '\\nFilename | Comment | Date | Size\\n'\n        md += '--- | --- | --- | ---\\n'\n        for i in self.lstPrograms:\n            md += self.get_file_info_line(i, ' | ')\n        \n        # save the details an Markdown file \n        with open(fname, 'w') as f:\n            f.write(md)", "label": 1}
{"code": "public static base_response add(nitro_service client, vpnclientlessaccesspolicy resource) throws Exception {\n\t\tvpnclientlessaccesspolicy addresource = new vpnclientlessaccesspolicy();\n\t\taddresource.name = resource.name;\n\t\taddresource.rule = resource.rule;\n\t\taddresource.profilename = resource.profilename;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def de_rep(fastas, append_index, return_original = False):\n    \"\"\"\n    de-replicate fastas based on sequence names\n    \"\"\"\n    ids = []\n    for fasta in fastas:\n        for seq in parse_fasta(fasta):\n            header = seq[0].split('>')[1].split()\n            id = header[0]\n            if id not in ids:\n                ids.append(id)\n                if return_original is True:\n                    yield [header, seq]\n                else:\n                    yield seq\n            elif append_index == True:\n                new, ids = append_index_id(id, ids) \n                if return_original is True:\n                    yield [header, ['>%s %s' % (new, ' '.join(header[1::])), seq[1]]]\n                else:\n                    yield ['>%s %s' % (new, ' '.join(header[1::])), seq[1]]", "label": 1}
{"code": "def edit(*args)\n      arguments(args, required: [:user, :repo, :branch]) do\n        permit VALID_PROTECTION_PARAM_NAMES\n      end\n\n      put_request(\"/repos/#{arguments.user}/#{arguments.repo}/branches/#{arguments.branch}/protection\", arguments.params)\n    end", "label": 4}
{"code": "def param(name, type = nil, **opts, &block)\n      add_definition(false, name, type, block, opts)\n    end", "label": 4}
{"code": "public static Chart getTrajectoryChart(String title, Trajectory t){\n\t\tif(t.getDimension()==2){\n\t\t \tdouble[] xData = new double[t.size()];\n\t\t    double[] yData = new double[t.size()];\n\t\t    for(int i = 0; i < t.size(); i++){\n\t\t    \txData[i] = t.get(i).x;\n\t\t    \tyData[i] = t.get(i).y;\n\t\t    \t\n\t\t    }\n\t\t    // Create Chart\n\t\t    Chart chart = QuickChart.getChart(title, \"X\", \"Y\", \"y(x)\", xData, yData);\n\t\n\t\t    return chart;\n\t\t    //Show it\n\t\t //   SwingWrapper swr = new SwingWrapper(chart);\n\t\t  //  swr.displayChart();\n\t\t} \n\t\treturn null;\n\t}", "label": 0}
{"code": "public static base_response update(nitro_service client, sslfips resource) throws Exception {\n\t\tsslfips updateresource = new sslfips();\n\t\tupdateresource.inithsm = resource.inithsm;\n\t\tupdateresource.sopassword = resource.sopassword;\n\t\tupdateresource.oldsopassword = resource.oldsopassword;\n\t\tupdateresource.userpassword = resource.userpassword;\n\t\tupdateresource.hsmlabel = resource.hsmlabel;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function addMethod(func, name) {\n    var newMethods = methods.MethodDictionary.concat(\n      _methods,\n      func,\n      name\n    );\n\n    if (_Entity) {\n      _loadEntityMethod(func, name);\n    }\n\n    _methods = newMethods;\n  }", "label": 3}
{"code": "def model_length(gene, domain):\n    \"\"\"\n    get length of model\n    \"\"\"\n    if gene == '16S':\n        domain2max = {'E_coli_K12': int(1538), 'bacteria': int(1689), 'archaea': int(1563), 'eukarya': int(2652)}\n        return domain2max[domain]\n    elif gene == '23S':\n        domain2max = {'E_coli_K12': int(2903), 'bacteria': int(3146), 'archaea': int(3774), 'eukarya': int(9079)}\n        return domain2max[domain]\n    else:\n        print(sys.stderr, '# length unknown for gene: %s, domain: %s' % (gene, domain))\n        exit()", "label": 1}
{"code": "public static base_response add(nitro_service client, appfwconfidfield resource) throws Exception {\n\t\tappfwconfidfield addresource = new appfwconfidfield();\n\t\taddresource.fieldname = resource.fieldname;\n\t\taddresource.url = resource.url;\n\t\taddresource.isregex = resource.isregex;\n\t\taddresource.comment = resource.comment;\n\t\taddresource.state = resource.state;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public function setPartitionId($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Datastore\\V1\\PartitionId::class);\n        $this->partition_id = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_response update(nitro_service client, bridgetable resource) throws Exception {\n\t\tbridgetable updateresource = new bridgetable();\n\t\tupdateresource.bridgeage = resource.bridgeage;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function (err, manifest) {\n            if (err) {\n                // Error generating SRI hashes\n                grunt.log.error(\"Error loading resource: \" + err);\n                return done(false);\n            }\n\n            return saveJson(\n                options,\n                manifest,\n                writeLog(fileCount, done)\n            );\n        }", "label": 3}
{"code": "function minRunLength(n) {\n  let r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= (n & 1);\n    n >>= 1;\n  }\n\n  return n + r;\n}", "label": 3}
{"code": "private static function get_doc_comment( $reflection ) {\n\t\t$doc_comment = $reflection->getDocComment();\n\n\t\tif ( false !== $doc_comment || ! ( ini_get( 'opcache.enable_cli' ) && ! ini_get( 'opcache.save_comments' ) ) ) {\n\t\t\t// Either have doc comment, or no doc comment and save comments enabled - standard situation.\n\t\t\tif ( ! getenv( 'WP_CLI_TEST_GET_DOC_COMMENT' ) ) {\n\t\t\t\treturn $doc_comment;\n\t\t\t}\n\t\t}\n\n\t\t$filename = $reflection->getFileName();\n\n\t\tif ( isset( self::$file_contents[ $filename ] ) ) {\n\t\t\t$contents = self::$file_contents[ $filename ];\n\t\t} elseif ( is_readable( $filename ) ) {\n\t\t\t$contents = file_get_contents( $filename );\n\t\t\tif ( is_string( $contents ) && '' !== $contents ) {\n\t\t\t\t$contents                         = explode( \"\\n\", $contents );\n\t\t\t\tself::$file_contents[ $filename ] = $contents;\n\t\t\t}\n\t\t}\n\n\t\tif ( ! empty( $contents ) ) {\n\t\t\treturn self::extract_last_doc_comment( implode( \"\\n\", array_slice( $contents, 0, $reflection->getStartLine() ) ) );\n\t\t}\n\n\t\t\\WP_CLI::debug( \"Could not read contents for filename '{$filename}'.\", 'commandfactory' );\n\t\treturn null;\n\t}", "label": 2}
{"code": "def typed_value_for(key, value)\n      fields.key?(key) ? fields[key].mongoize(value) : value.mongoize\n    end", "label": 4}
{"code": "function normalizeIds(ids) {\n    if (_.isArray(ids)) {\n      // remove any nesting of arrays - it is assumed that the resulting ids will be simple string or number values.\n      ids = _.flatten(ids);\n      // remove any duplicate ids.\n      return _.uniq(ids);\n    } else if (_.isString(ids) || _.isNumber(ids)) {\n      // individual id - convert to array for consistency.\n      return [ids];\n    } else if (ids && ids.skipObjectRetrieval) {\n      return ids;\n    }\n  }", "label": 3}
{"code": "function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }", "label": 3}
{"code": "public static base_response delete(nitro_service client, String aliasname) throws Exception {\n\t\tdnscnamerec deleteresource = new dnscnamerec();\n\t\tdeleteresource.aliasname = aliasname;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "func CollectOptions(opts ...SuiteOption) SuiteOptions {\n\tvar suiteOpts SuiteOptions\n\tfor _, o := range opts {\n\t\to(&suiteOpts)\n\t}\n\treturn suiteOpts\n}", "label": 5}
{"code": "func NotBlank(fl validator.FieldLevel) bool {\n\tfield := fl.Field()\n\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\treturn len(strings.TrimSpace(field.String())) > 0\n\tcase reflect.Chan, reflect.Map, reflect.Slice, reflect.Array:\n\t\treturn field.Len() > 0\n\tcase reflect.Ptr, reflect.Interface, reflect.Func:\n\t\treturn !field.IsNil()\n\tdefault:\n\t\treturn field.IsValid() && field.Interface() != reflect.Zero(field.Type()).Interface()\n\t}\n}", "label": 5}
{"code": "def cms_snippet_render(identifier, cms_site = @cms_site)\n      cms_site ||= cms_site_detect\n      snippet = cms_site&.snippets&.find_by_identifier(identifier)\n      return \"\" unless snippet\n      r = ComfortableMexicanSofa::Content::Renderer.new(snippet)\n      render inline: r.render(r.nodes(r.tokenize(snippet.content)))\n    end", "label": 4}
{"code": "func (f *Fpdf) point(x, y float64) {\n\tf.outf(\"%.2f %.2f m\", x*f.k, (f.h-y)*f.k)\n}", "label": 5}
{"code": "def get_verbose(obj, field_name=\"\"):\n    \"\"\"\n    Returns the verbose name of an object's field.\n\n    :param obj: A model instance.\n    :param field_name: The requested field value in string format.\n\n    \"\"\"\n    if hasattr(obj, \"_meta\") and hasattr(obj._meta, \"get_field_by_name\"):\n        try:\n            return obj._meta.get_field(field_name).verbose_name\n        except FieldDoesNotExist:\n            pass\n    return \"\"", "label": 1}
{"code": "protected boolean cannotInstantiate(Class<?> actionClass) {\n\t\treturn actionClass.isAnnotation() || actionClass.isInterface() || actionClass.isEnum()\n\t\t\t\t|| (actionClass.getModifiers() & Modifier.ABSTRACT) != 0 || actionClass.isAnonymousClass();\n\t}", "label": 0}
{"code": "def parse_heading(heading)\n      captures = { \"version\" => nil, \"url\" => nil, \"date\" => nil }\n\n      @heading_structures.each do |regexp|\n        matches = Regexp.new(regexp).match(heading)\n        if matches\n          captures.merge!(Hash[matches.names.zip(matches.captures)])\n          break\n        end\n      end\n\n      captures\n    end", "label": 4}
{"code": "def block_anyfilter(parser, token):\n    \"\"\"\n    Turn any template filter into a blocktag.\n\n    Usage::\n\n    {% load libs_tags %}\n    {% block_anyfilter django.template.defaultfilters.truncatewords_html 15 %}\n        // Something complex that generates html output\n    {% endblockanyfilter %}\n\n    \"\"\"\n    bits = token.contents.split()\n    nodelist = parser.parse(('endblockanyfilter',))\n    parser.delete_first_token()\n    return BlockAnyFilterNode(nodelist, bits[1], *bits[2:])", "label": 1}
{"code": "function listenPushNotification(callback) {\n    if (callback === void 0) { callback = defaultPushCallback; }\n    if (resolveRegistrationEventResponse) {\n        diag.debug.assert(!!rejectRegistrationEventResponse);\n        resolveRegistrationEventResponse(undefined);\n        resolveRegistrationEventResponse = undefined;\n        rejectRegistrationEventResponse = undefined;\n    }\n    if (callback) {\n        // perform registration\n        promiseRegistrationEventResponse = device.ready.then(function (info) {\n            var pushInitOptions = init.initOptions.push;\n            var pushPlatform = info.platform.id;\n            if (pushPlatform === 'windowsphone') {\n                pushPlatform = 'windows';\n            }\n            if (!pushInitOptions || !pushPlatform || !(pushPlatform in pushInitOptions)) {\n                // no push configuration for current platform\n                promiseRegistrationEventResponse = Q.resolve(undefined);\n                return promiseRegistrationEventResponse;\n            }\n            // init or reinit push\n            var pushStatic = global['PushNotification'];\n            var pushImpl = pushStatic.init(pushInitOptions);\n            if (pushPlugin !== pushImpl) {\n                if (pushPlugin) {\n                    // turn off existing event handlers (in reverse order of registration)\n                    pushPlugin.off('notification', onPushNotificationNotification);\n                    pushPlugin.off('registration', onPushNotificationRegistration);\n                    pushPlugin.off('error', onPushNotificationError);\n                }\n                // set up new registration results\n                promiseRegistrationEventResponse = Q.Promise(function (resolve, reject) {\n                    resolveRegistrationEventResponse = resolve;\n                    rejectRegistrationEventResponse = reject;\n                });\n                // activation of new implementation\n                pushCallback = callback;\n                pushPlugin = pushImpl;\n                // turn on event handlers (in order of relevance)\n                pushPlugin.on('error', onPushNotificationError);\n                pushPlugin.on('registration', onPushNotificationRegistration);\n                pushPlugin.on('notification', onPushNotificationNotification);\n            }\n            return promiseRegistrationEventResponse;\n        });\n    }\n    else if (pushPlugin) {\n        // perform unregistration\n        promiseRegistrationEventResponse = Q.Promise(function (resolve, reject) {\n            try {\n                pushPlugin.unregister(resolve, reject);\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    else {\n        // nothing to unregister\n        promiseRegistrationEventResponse = Q.resolve(undefined);\n    }\n    return promiseRegistrationEventResponse;\n}", "label": 3}
{"code": "def add_txn_num!(command)\n      command.tap do |c|\n        c[:txnNumber] = BSON::Int64.new(@server_session.txn_num) if in_transaction?\n      end\n    end", "label": 4}
{"code": "public void setPromoted(final boolean promoted) {\n        this.promoted = promoted;\n\n        for (final Artifact artifact : artifacts) {\n            artifact.setPromoted(promoted);\n        }\n\n        for (final Module suModule : submodules) {\n            suModule.setPromoted(promoted);\n        }\n    }", "label": 0}
{"code": "def numDomtblout(domtblout, numHits, evalueT, bitT, sort):\n    \"\"\"\n    parse hmm domain table output\n    this version is faster but does not work unless the table is sorted\n    \"\"\"\n    if sort is True:\n        for hit in numDomtblout_sort(domtblout, numHits, evalueT, bitT):\n            yield hit\n        return\n    header = ['#target name', 'target accession', 'tlen',\n              'query name', 'query accession', 'qlen',\n              'full E-value', 'full score', 'full bias',\n              'domain #', '# domains',\n              'domain c-Evalue', 'domain i-Evalue', 'domain score', 'domain bias',\n              'hmm from', 'hmm to', 'seq from', 'seq to', 'env from', 'env to',\n              'acc', 'target description']\n    yield header\n    prev, hits = None, []\n    for line in domtblout:\n        if line.startswith('#'):\n            continue\n        # parse line and get description\n        line = line.strip().split()\n        desc = ' '.join(line[18:])\n        line = line[0:18]\n        line.append(desc)\n        # create ID based on query name and domain number\n        ID = line[0] + line[9]\n        # domain c-Evalue and domain score thresholds\n        line[11], line[13] = float(line[11]), float(line[13])\n        evalue, bitscore = line[11], line[13]\n        line[11], line[13] = evalue, bitscore\n        if ID != prev:\n            if len(hits) > 0:\n                for hit in top_hits(hits, numHits, 13, True):\n                    yield hit\n            hits = []\n        if evalueT == False and bitT == False:\n            hits.append(line)\n        elif evalue <= evalueT and bitT == False:\n            hits.append(line)\n        elif evalue <= evalueT and bit >= bitT:\n            hits.append(line)\n        elif evalueT == False and bit >= bitT:\n            hits.append(line)\n        prev = ID\n    for hit in top_hits(hits, numHits, 13, True):\n        yield hit", "label": 1}
{"code": "def update_conf(conf)\n      @protocol = conf[:transport]\n\n      t_conf = conf[:transports][transport.to_sym] || {}\n      # Override url methods\n      @user = t_conf['user']\n      @password = t_conf['password']\n      @port = t_conf['port']\n      @host = t_conf['host']\n\n      # Preserve everything in options so we can easily create copies of a Target.\n      @options = t_conf.merge(@options)\n\n      self\n    end", "label": 4}
{"code": "function echo(command) {\n        return command.getUser()\n            .then((user) => {\n                const content = (command.parent.text || '').split('\\n').map((line) => `> ${line}`);\n                content.unshift(`@${user.username} said:`);\n                command.reply(content.join('\\n'));\n            });\n    }", "label": 3}
{"code": "def subscribe(topic_or_regex, default_offset: nil, start_from_beginning: true, max_bytes_per_partition: 1048576)\n      default_offset ||= start_from_beginning ? :earliest : :latest\n\n      if topic_or_regex.is_a?(Regexp)\n        cluster_topics.select { |topic| topic =~ topic_or_regex }.each do |topic|\n          subscribe_to_topic(topic, default_offset, start_from_beginning, max_bytes_per_partition)\n        end\n      else\n        subscribe_to_topic(topic_or_regex, default_offset, start_from_beginning, max_bytes_per_partition)\n      end\n\n      nil\n    end", "label": 4}
{"code": "public function getNewNotificationCount()\n    {\n        return $this->getUnreadNotifications()->filter(function ($notification) {\n            return $notification->created_at > $this->read_notifications_at ?: 0;\n        })->count();\n    }", "label": 2}
{"code": "def name_to_cell(name)\n      col_index, row_index = *Axlsx::name_to_indices(name)\n      r = rows[row_index]\n      r[col_index] if r\n    end", "label": 4}
{"code": "def iter_format_modules(lang):\n    \"\"\"\n    Does the heavy lifting of finding format modules.\n\n    \"\"\"\n    if check_for_language(lang):\n        format_locations = []\n        for path in CUSTOM_FORMAT_MODULE_PATHS:\n            format_locations.append(path + '.%s')\n        format_locations.append('django.conf.locale.%s')\n        locale = to_locale(lang)\n        locales = [locale]\n        if '_' in locale:\n            locales.append(locale.split('_')[0])\n        for location in format_locations:\n            for loc in locales:\n                try:\n                    yield import_module('.formats', location % loc)\n                except ImportError:\n                    pass", "label": 1}
{"code": "public static base_response add(nitro_service client, dnssuffix resource) throws Exception {\n\t\tdnssuffix addresource = new dnssuffix();\n\t\taddresource.Dnssuffix = resource.Dnssuffix;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "function find(deleted, file) {\n    var meta = bundle[file].meta\n      , match = files.some(function some (file) {\n          return file === meta.location || ~meta.location.indexOf(file)\n            || (meta.compiler && ~meta.compiler.imported.join(',').indexOf(file));\n        });\n\n    if (!match) return;\n\n    // If we check previous for deleted files, don't read content.\n    if (!deleted) {\n      self.hold(meta.location); // Temporary freeze of the event loop.\n      self.package.bundle[file].meta.content = fs.readFileSync(meta.location, 'utf8');\n    }\n\n    // Add the file extension to the extensions list so we can create\n    // a dedicated rebuild.\n    extensions.push(meta.output);\n    changes.push(file);\n  }", "label": 3}
{"code": "public function sendReceipt($node, $type = 'read', $participant = null, $callId = null)\n    {\n        $messageHash = [];\n        if ($type == 'read') {\n            $messageHash['type'] = $type;\n        }\n        if ($participant != null) {\n            $messageHash['participant'] = $participant;\n        }\n        $messageHash['to'] = $node->getAttribute('from');\n        $messageHash['id'] = $node->getAttribute('id');\n        $messageHash['t'] = $node->getAttribute('t');\n\n        if ($callId != null) {\n            $offerNode = new ProtocolNode('offer', ['call-id' => $callId], null, null);\n            $messageNode = new ProtocolNode('receipt', $messageHash, [$offerNode], null);\n        } else {\n            $messageNode = new ProtocolNode('receipt', $messageHash, null, null);\n        }\n        $this->sendNode($messageNode);\n        $this->eventManager()->fire('onSendMessageReceived',\n            [\n                $this->phoneNumber,\n                $node->getAttribute('id'),\n                $node->getAttribute('from'),\n                $type,\n            ]);\n    }", "label": 2}
{"code": "func Warn(format string, values ...interface{}) {\n\tfmt.Fprintf(os.Stderr, fmt.Sprintf(\"%s%c\", format, '\\n'), values...)\n}", "label": 5}
{"code": "def webhooks\n      webhooks = JSON.parse(API::Server.webhooks(@bot.token, @id))\n      webhooks.map { |webhook| Webhook.new(webhook, @bot) }\n    end", "label": 4}
{"code": "public function setInspectTemplates($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\InspectTemplate::class);\n        $this->inspect_templates = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def shorten(self, long_url, custom_ending=None, is_secret=False):\n        \"\"\"\n        Creates a short url if valid\n\n        :param str long_url: The url to shorten.\n        :param custom_ending: The custom url to create if available.\n        :type custom_ending: str or None\n        :param bool is_secret: if not public, it's secret\n        :return: a short link\n        :rtype: str\n        \"\"\"\n        params = {\n            'url': long_url,\n            'is_secret': 'true' if is_secret else 'false',\n            'custom_ending': custom_ending\n        }\n        data, r = self._make_request(self.api_shorten_endpoint, params)\n        if r.status_code == 400:\n            if custom_ending is not None:\n                raise exceptions.CustomEndingUnavailable(custom_ending)\n            raise exceptions.BadApiRequest\n        elif r.status_code == 403:\n            raise exceptions.QuotaExceededError\n        action = data.get('action')\n        short_url = data.get('result')\n        if action == 'shorten' and short_url is not None:\n            return short_url\n        raise exceptions.DebugTempWarning", "label": 1}
{"code": "func IsBuiltinLocalDriver(networkType string) bool {\n\tif \"l2bridge\" == networkType || \"l2tunnel\" == networkType || \"nat\" == networkType || \"ics\" == networkType || \"transparent\" == networkType {\n\t\treturn true\n\t}\n\n\treturn false\n}", "label": 5}
{"code": "func isCIDRv4(fl FieldLevel) bool {\n\n\tip, _, err := net.ParseCIDR(fl.Field().String())\n\n\treturn err == nil && ip.To4() != nil\n}", "label": 5}
{"code": "private function validate_alias_type( $aliases, $alias, $assoc_args, $grouping ) {\n\n\t\t$alias_data = $aliases[ $alias ];\n\n\t\t$group_aliases_match = preg_grep( '/^@(\\w+)/i', $alias_data );\n\t\t$arg_match           = preg_grep( '/^set-(\\w+)/i', array_keys( $assoc_args ) );\n\n\t\tif ( ! empty( $group_aliases_match ) && ! empty( $arg_match ) ) {\n\t\t\tWP_CLI::error( 'Trying to update group alias with invalid arguments.' );\n\t\t} elseif ( empty( $group_aliases_match ) && ! empty( $grouping ) ) {\n\t\t\tWP_CLI::error( 'Trying to update simple alias with invalid --grouping argument.' );\n\t\t}\n\t}", "label": 2}
{"code": "function () {\n        var i = 0;\n        var len = 0;\n        var actionData = null;\n\n        if (!(this.constructor.periodicActions instanceof Array)) {\n            return;\n        }\n\n        len = this.constructor.periodicActions.length;\n\n        for (; i < len; i += 1) {\n            actionData = this.constructor.periodicActions[i];\n            this.startPeriodicAction(actionData.uuid, actionData.action, actionData.params, actionData.interval);\n        }\n    }", "label": 3}
{"code": "def distinct(l):\n    \"\"\"\n    Return a list where the duplicates have been removed.\n\n    Args:\n        l (list): the list to filter.\n\n    Returns:\n        list: the same list without duplicates.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return (_ for _ in l if not (_ in seen or seen_add(_)))", "label": 1}
{"code": "def handle_debug(self, environ, start_response, traceback_id):\n        \"\"\"Handles the debug endpoint for inspecting previous errors.\n\n        :param environ: The environment which is passed into the wsgi application\n        :type environ: dict[str, object]\n        :param start_response: The start_response function of the wsgi application\n        :type start_response: (str, list[(str, str)]) -> NoneType\n        :param traceback_id: The id of the traceback to inspect\n        :type traceback_id: int\n\n        .. versionadded:: 0.1.0\n        \"\"\"\n        if traceback_id not in self.app.registry.tracebacks:\n            abort(404)\n        self._copy_over_traceback(traceback_id)\n        traceback = self.tracebacks[traceback_id]\n        rendered = traceback.render_full(evalex=self.evalex, secret=self.secret)\n        response = Response(rendered.encode('utf-8', 'replace'),\n                            headers=[('Content-Type', 'text/html; charset=utf-8'),\n                                     ('X-XSS-Protection', '0')])\n        return response(environ, start_response)", "label": 1}
{"code": "@SuppressWarnings(\"unchecked\")\r\n  // This is not good code, but what's there to be done? TODO\r\n  public static <T> T sample(Counter<T> c, Random rand) {\r\n    Iterable<T> objects;\r\n    Set<T> keySet = c.keySet();\r\n    objects = c.keySet();\r\n    if (rand == null) {\r\n      rand = new Random();\r\n    } else { // TODO: Seems like there should be a way to directly check if T is\r\n             // comparable\r\n      if (!keySet.isEmpty() && keySet.iterator().next() instanceof Comparable) {\r\n        List l = new ArrayList<T>(keySet);\r\n        Collections.sort(l);\r\n        objects = l;\r\n      } else {\r\n        throw new RuntimeException(\"Results won't be stable since Counters keys are comparable.\");\r\n      }\r\n    }\r\n    double r = rand.nextDouble() * c.totalCount();\r\n    double total = 0.0;\r\n\r\n    for (T t : objects) { // arbitrary ordering\r\n      total += c.getCount(t);\r\n      if (total >= r)\r\n        return t;\r\n    }\r\n    // only chance of reaching here is if c isn't properly normalized, or if\r\n    // double math makes total<1.0\r\n    return c.keySet().iterator().next();\r\n  }", "label": 0}
{"code": "func (a *HistoricalApi) availableNodeMetrics(request *restful.Request, response *restful.Response) {\n\tkey := core.HistoricalKey{\n\t\tObjectType: core.MetricSetTypeNode,\n\t\tNodeName:   request.PathParameter(\"node-name\"),\n\t}\n\ta.processMetricNamesRequest(key, response)\n}", "label": 5}
{"code": "public function setSources($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\SecurityCenter\\V1\\Source::class);\n        $this->sources = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function define(JSFile, utils) {\n  return class JSXFile extends JSFile {\n    /**\n     * Parse 'content' for dependency references\n     * @param {String} content\n     * @returns {Array}\n     */\n    parseDependencyReferences(content) {\n      const references = super.parseDependencyReferences(content);\n\n      references[0].push({ context: \"require('react')\", match: 'react', id: 'react' });\n\n      return references;\n    }\n\n    /**\n     * Transpile file contents\n     * @param {Object} buildOptions\n     *  - {Boolean} batch\n     *  - {Boolean} bootstrap\n     *  - {Boolean} boilerplate\n     *  - {Boolean} browser\n     *  - {Boolean} bundle\n     *  - {Boolean} compress\n     *  - {Boolean} helpers\n     *  - {Array} ignoredFiles\n     *  - {Boolean} import\n     *  - {Boolean} watchOnly\n     * @param {Function} fn(err)\n     */\n    transpile(buildOptions, fn) {\n      super.transpile(buildOptions, (err) => {\n        if (err) return fn && fn();\n        this.prependContent(\"var React = $m['react'].exports;\");\n        fn();\n      });\n    }\n  };\n}", "label": 3}
{"code": "public static <E> void removeKeys(Counter<E> counter, Collection<E> removeKeysCollection) {\r\n\r\n    for (E key : removeKeysCollection)\r\n      counter.remove(key);\r\n  }", "label": 0}
{"code": "function computeRateBetweenSubunitAmounts(fromCurrency, fromAmount, toCurrency, toAmount) {\n  /*\n   * If currencies are equal, rate is 1\n   */\n  if (fromCurrency === toCurrency) {\n    return 1;\n  }\n\n  /*\n   * If toAmount is 0, we don't want to divide by zero.\n   * In this case, return NaN\n   */\n  if (toAmount === 0) {\n    return NaN;\n  }\n\n  /*\n   * Convert both amounts to main units\n   */\n  const fromAmountMainUnit = fromSmallestSubunit(fromAmount, fromCurrency);\n  const toAmountMainUnit = fromSmallestSubunit(toAmount, toCurrency);\n\n  /*\n   * Compute and return rate\n   */\n  return fromAmountMainUnit / toAmountMainUnit;\n}", "label": 3}
{"code": "function provideName(obj, token){\n    if(!isString(token)) {\n      throw new Error('Must provide string as name of module');\n    }\n    di.annotate(obj, new di.Provide(token));\n  }", "label": 3}
{"code": "func (s *MockStore) Put(key string, value []byte, options *store.WriteOptions) error {\n\tmData := s.db[key]\n\tif mData == nil {\n\t\tmData = &MockData{value, 0}\n\t}\n\tmData.Index = mData.Index + 1\n\ts.db[key] = mData\n\treturn nil\n}", "label": 5}
{"code": "function (item, state) {\n                state.count = 0;\n                state.sub = {};\n                item.reset(state.sub);\n            }", "label": 3}
{"code": "def *(other)\n      if Scalar === other || Duration === other\n        Duration.new(value * other.value, parts.map { |type, number| [type, number * other.value] })\n      elsif Numeric === other\n        Duration.new(value * other, parts.map { |type, number| [type, number * other] })\n      else\n        raise_type_error(other)\n      end\n    end", "label": 4}
{"code": "function findPrim(columns,field) {\n\n    var primary_keys = columns.filter(function (r) {return r.Key === 'PRI';});\n\n    //for multiple primary keys, just take the first\n    if(primary_keys.length > 0) {\n        return primary_keys[0].Field;\n    }\n\n    //If the provided field is a string, we might have a chance\n    if(typeof field === \"string\") {\n        if(checkIfFieldsExist(field,columns)) {\n            return escape(field);\n        }\n    }\n\n    //FALLBACK\n    return \"id\";\n}", "label": 3}
{"code": "function buildErrorResponse(params) {\n  params = params || {};\n  params.error = params.error || {};\n  var ERROR_CODES = models.CONSTANTS.ERROR_CODES;\n\n  if (params.error.userDetail) {\n    return params.error;\n  }\n\n  if (params.error) {\n    var message = params.error.message || \"\";\n    //If the message is about validation, the return a validation http response\n    if (message.indexOf(\"validation\") > -1) {\n      params.code = params.code || ERROR_CODES.FH_FORMS_INVALID_PARAMETERS;\n    }\n  }\n\n  //Mongoose Validation Failed\n  if (params.error && params.error.errors) {\n    var fieldKey = _.keys(params.error.errors)[0];\n    params.userDetail = params.userDetail || params.error.errors[fieldKey].message;\n    params.code = params.code || ERROR_CODES.FH_FORMS_INVALID_PARAMETERS;\n  }\n\n  var userDetail = params.userDetail || params.error.userDetail || params.error.message || \"An Unexpected Error Occurred\";\n  var systemDetail = params.systemDetail || params.error.systemDetail || params.error.stack || \"\";\n  var code = params.code || ERROR_CODES.FH_FORMS_UNEXPECTED_ERROR;\n\n  return {\n    userDetail: userDetail,\n    systemDetail: systemDetail,\n    code: code\n  };\n}", "label": 3}
{"code": "def get(cls, user_id, client_id):\n        \"\"\"Get RemoteAccount object for user.\n\n        :param user_id: User id\n        :param client_id: Client id.\n        :returns: A :class:`invenio_oauthclient.models.RemoteAccount` instance.\n        \"\"\"\n        return cls.query.filter_by(\n            user_id=user_id,\n            client_id=client_id,\n        ).first()", "label": 1}
{"code": "def delete_all(mailbox='INBOX')\n      mailbox ||= 'INBOX'\n      mailbox = Net::IMAP.encode_utf7(mailbox)\n\n      start do |imap|\n        imap.select(mailbox)\n        imap.uid_search(['ALL']).each do |uid|\n          imap.uid_store(uid, \"+FLAGS\", [Net::IMAP::DELETED])\n        end\n        imap.expunge\n      end\n    end", "label": 4}
{"code": "private function processParameterMappings($paramMappings)\n    {\n        $sqlParams = [];\n        $types     = [];\n\n        foreach ($this->parameters as $parameter) {\n            $key   = $parameter->getName();\n            $value = $parameter->getValue();\n            $rsm   = $this->getResultSetMapping();\n\n            if (! isset($paramMappings[$key])) {\n                throw QueryException::unknownParameter($key);\n            }\n\n            if (isset($rsm->metadataParameterMapping[$key]) && $value instanceof ClassMetadata) {\n                $value = $value->getMetadataValue($rsm->metadataParameterMapping[$key]);\n            }\n\n            if (isset($rsm->discriminatorParameters[$key]) && $value instanceof ClassMetadata) {\n                $value = array_keys(HierarchyDiscriminatorResolver::resolveDiscriminatorsForClass($value, $this->em));\n            }\n\n            $value = $this->processParameterValue($value);\n            $type  = $parameter->getValue() === $value\n                ? $parameter->getType()\n                : ParameterTypeInferer::inferType($value);\n\n            foreach ($paramMappings[$key] as $position) {\n                $types[$position] = $type;\n            }\n\n            $sqlPositions      = $paramMappings[$key];\n            $sqlPositionsCount = count($sqlPositions);\n\n            // optimized multi value sql positions away for now,\n            // they are not allowed in DQL anyways.\n            $value      = [$value];\n            $countValue = count($value);\n\n            for ($i = 0, $l = $sqlPositionsCount; $i < $l; $i++) {\n                $sqlParams[$sqlPositions[$i]] = $value[($i % $countValue)];\n            }\n        }\n\n        if (count($sqlParams) !== count($types)) {\n            throw QueryException::parameterTypeMismatch();\n        }\n\n        if ($sqlParams) {\n            ksort($sqlParams);\n            $sqlParams = array_values($sqlParams);\n\n            ksort($types);\n            $types = array_values($types);\n        }\n\n        return [$sqlParams, $types];\n    }", "label": 2}
{"code": "def permit!\n      each_pair do |key, value|\n        Array.wrap(value).flatten.each do |v|\n          v.permit! if v.respond_to? :permit!\n        end\n      end\n\n      @permitted = true\n      self\n    end", "label": 4}
{"code": "def create(self):\n        \"\"\"\n        Subscribes at the server.\n        \"\"\"\n        self.logger.debug('Create subscription on server...')\n\n        if not self.connection.connected:\n            self.state = 'connection_pending'\n            return\n\n        data = {\n            'command': 'subscribe',\n            'identifier': self._identifier_string()\n        }\n\n        self.connection.send(data)\n        self.state = 'pending'", "label": 1}
{"code": "func (s *Service) RegisterHandler(name string, handler Handler) {\n\ts.handlers[name] = handler\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, route6 resource) throws Exception {\n\t\troute6 addresource = new route6();\n\t\taddresource.network = resource.network;\n\t\taddresource.gateway = resource.gateway;\n\t\taddresource.vlan = resource.vlan;\n\t\taddresource.weight = resource.weight;\n\t\taddresource.distance = resource.distance;\n\t\taddresource.cost = resource.cost;\n\t\taddresource.advertise = resource.advertise;\n\t\taddresource.msr = resource.msr;\n\t\taddresource.monitor = resource.monitor;\n\t\taddresource.td = resource.td;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public function rejectCall($to, $id, $callId)\n    {\n        $rejectNode = new ProtocolNode('reject',\n            [\n              'call-id' => $callId,\n            ], null, null);\n\n        $callNode = new ProtocolNode('call',\n            [\n              'id' => $id,\n              'to' => $this->getJID($to),\n            ], [$rejectNode], null);\n\n        $this->sendNode($callNode);\n    }", "label": 2}
{"code": "def move_to_list(list)\n      list_number = list.is_a?(String) ? list : list.id\n      unless list_id == list_number\n        client.put(\"/cards/#{id}/idList\", {\n          value: list_number\n        })\n      end\n    end", "label": 4}
{"code": "function getRuleLink(ruleId) {\n\tlet ruleLink = `http://eslint.org/docs/rules/${ruleId}`;\n\n\tif (_.startsWith(ruleId, 'angular')) {\n\t\truleId = ruleId.replace('angular/', '');\n\t\truleLink = `https://github.com/Gillespie59/eslint-plugin-angular/blob/master/docs/${ruleId}.md`;\n\t} else if (_.startsWith(ruleId, 'lodash')) {\n\t\truleId = ruleId.replace('lodash/', '');\n\t\truleLink = `https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/${ruleId}.md`;\n\t}\n\treturn ruleLink;\n}", "label": 3}
{"code": "public function isEmpty()\n    {\n        return $this->years === 0 &&\n            $this->months === 0 &&\n            $this->dayz === 0 &&\n            !$this->days &&\n            $this->hours === 0 &&\n            $this->minutes === 0 &&\n            $this->seconds === 0 &&\n            $this->microseconds === 0;\n    }", "label": 2}
{"code": "def filter_by_symbol(args)\n      return args unless worker_method_defined?(unique_args_method)\n\n      worker_class.send(unique_args_method, args)\n    rescue ArgumentError => ex\n      log_fatal(ex)\n      args\n    end", "label": 4}
{"code": "def invites\n      invites = JSON.parse(API::Server.invites(@bot.token, @id))\n      invites.map { |invite| Invite.new(invite, @bot) }\n    end", "label": 4}
{"code": "@SuppressWarnings(\"rawtypes\")\n\tpublic void setReplicationClassLoader(Fqn regionFqn, ClassLoader classLoader) {\n\t\tif (!isLocalMode()) {\n\t\t\tfinal Region region = jBossCache.getRegion(regionFqn, true);\n\t\t\tregion.registerContextClassLoader(classLoader);\n\t\t\tif (!region.isActive() && jBossCache.getCacheStatus() == CacheStatus.STARTED) {\n\t\t\t\tregion.activate();\n\t\t\t}\t\t\t\n\t\t}\n\t}", "label": 0}
{"code": "def send_request(request)\n      api_name = Protocol.api_name(request.api_key)\n\n      # Default notification payload.\n      notification = {\n        broker_host: @host,\n        api: api_name,\n        request_size: 0,\n        response_size: 0,\n      }\n\n      raise IdleConnection if idle?\n\n      @logger.push_tags(api_name)\n      @instrumenter.instrument(\"request.connection\", notification) do\n        open unless open?\n\n        @correlation_id += 1\n\n        @logger.debug \"Sending #{api_name} API request #{@correlation_id} to #{to_s}\"\n\n        write_request(request, notification)\n\n        response_class = request.response_class\n        response = wait_for_response(response_class, notification) unless response_class.nil?\n\n        @last_request = Time.now\n\n        response\n      end\n    rescue SystemCallError, EOFError, IOError => e\n      close\n\n      raise ConnectionError, \"Connection error #{e.class}: #{e}\"\n    ensure\n      @logger.pop_tags\n    end", "label": 4}
{"code": "public static nsfeature get(nitro_service service) throws Exception{\n\t\tnsfeature obj = new nsfeature();\n\t\tnsfeature[] response = (nsfeature[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "private function searchPrefixes($path)\n    {\n        $dirname = dirname($path);\n        $directoryParts = explode(DIRECTORY_SEPARATOR, $dirname);\n        $directories = [];\n        while ($directoryParts) {\n            $directories[] = implode(DIRECTORY_SEPARATOR, $directoryParts);\n            array_shift($directoryParts);\n        }\n        return $directories;\n    }", "label": 2}
{"code": "func (i *TeleInstance) AddUser(username string, mappings []string) *User {\n\tlog.Infof(\"teleInstance.AddUser(%v) mapped to %v\", username, mappings)\n\tif mappings == nil {\n\t\tmappings = make([]string, 0)\n\t}\n\tuser := &User{\n\t\tUsername:      username,\n\t\tAllowedLogins: mappings,\n\t}\n\ti.Secrets.Users[username] = user\n\treturn user\n}", "label": 5}
{"code": "public Class getRealClass(Object objectOrProxy)\r\n    {\r\n        IndirectionHandler handler;\r\n\r\n        if(isNormalOjbProxy(objectOrProxy))\r\n        {\r\n            String msg;\r\n\r\n            try\r\n            {\r\n                handler = getIndirectionHandler(objectOrProxy);\r\n                /*\r\n                 arminw:\r\n                 think we should return the real class\r\n                 */\r\n                // return handler.getIdentity().getObjectsTopLevelClass();\r\n                return handler.getIdentity().getObjectsRealClass();\r\n            }\r\n            catch(ClassCastException e)\r\n            {\r\n                // shouldn't happen but still ...\r\n                msg = \"The InvocationHandler for the provided Proxy was not an instance of \" + IndirectionHandler.class.getName();\r\n                log.error(msg);\r\n                throw new PersistenceBrokerException(msg, e);\r\n            }\r\n            catch(IllegalArgumentException e)\r\n            {\r\n                msg = \"Could not retrieve real object for given Proxy: \" + objectOrProxy;\r\n                log.error(msg);\r\n                throw new PersistenceBrokerException(msg, e);\r\n            }\r\n        }\r\n        else if(isVirtualOjbProxy(objectOrProxy))\r\n        {\r\n            handler = VirtualProxy.getIndirectionHandler((VirtualProxy) objectOrProxy);\r\n            /*\r\n             arminw:\r\n             think we should return the real class\r\n             */\r\n            // return handler.getIdentity().getObjectsTopLevelClass();\r\n            return handler.getIdentity().getObjectsRealClass();\r\n        }\r\n        else\r\n        {\r\n            return objectOrProxy.getClass();\r\n        }\r\n    }", "label": 0}
{"code": "public void reverse() {\r\n\t// overridden for performance only.\r\n\tdouble tmp;\r\n\tint limit=size/2;\r\n\tint j=size-1;\r\n\r\n\tdouble[] theElements = elements;\r\n\tfor (int i=0; i<limit;) { //swap\r\n\t\ttmp=theElements[i];\r\n\t\ttheElements[i++]=theElements[j];\r\n\t\ttheElements[j--]=tmp;\r\n\t}\r\n}", "label": 0}
{"code": "function detect_class_members_from_array(cls, ast) {\n  cls[\"members\"] = [];\n  return _.each(ast[\"elements\"], function(el) {\n    detect_method_or_property(cls, key_value(el), el, el);\n  });\n}", "label": 3}
{"code": "func (p *Panel) SetStatus(w Widget) {\n\tindex := 0\n\tif p.title != nil {\n\t\tindex++\n\t}\n\tif p.menu != nil {\n\t\tindex++\n\t}\n\tif p.content != nil {\n\t\tindex++\n\t}\n\tif p.status != nil {\n\t\tp.RemoveWidget(p.status)\n\t}\n\tp.InsertWidget(index, w, 0.0)\n\tp.status = w\n}", "label": 5}
{"code": "def list_pages(location_id, opts = {})\n      data, _status_code, _headers = list_pages_with_http_info(location_id, opts)\n      return data\n    end", "label": 4}
{"code": "function serializeBody ({ decamelizeBody=true, headers, body }) {\n  if (!body || !isJSONRequest(headers)) return\n  const transformedBody = decamelizeBody ? decamelizeKeys(body) : body\n  return {\n    body: JSON.stringify(transformedBody)\n  }\n}", "label": 3}
{"code": "private function addCommonParams($generation, array $params, array $options)\n    {\n        if ($options['responseType']) {\n            $params['response-content-type'] = $options['responseType'];\n        }\n\n        if ($options['responseDisposition']) {\n            $params['response-content-disposition'] = $options['responseDisposition'];\n        } elseif ($options['saveAsName']) {\n            $params['response-content-disposition'] = 'attachment; filename='\n                . '\"' . $options['saveAsName'] . '\"';\n        }\n\n        if ($generation) {\n            $params['generation'] = $generation;\n        }\n\n        return $params;\n    }", "label": 2}
{"code": "def run_cmd(input)\n      safely do\n        command = command_list.match(input)\n        return command.new(self, input).execute if command\n\n        puts safe_inspect(multiple_thread_eval(input))\n      end\n    end", "label": 4}
{"code": "def editor_field_tag(name, value, options = {})\n      options[:toolbar] ||= \"basic\"\n      options[:lines] ||= 10\n\n      content_tag(:div, class: \"editor\") do\n        template = \"\"\n        template += label_tag(name, options[:label]) if options[:label] != false\n        template += hidden_field_tag(name, value, options)\n        template += content_tag(:div, nil, class: \"editor-container\", data: {\n                                  toolbar: options[:toolbar]\n                                }, style: \"height: #{options[:lines]}rem\")\n        template.html_safe\n      end\n    end", "label": 4}
{"code": "func (ctrl *Controller) RecordCallWithMethodType(receiver interface{}, method string, methodType reflect.Type, args ...interface{}) *Call {\n\tctrl.T.Helper()\n\n\tcall := newCall(ctrl.T, receiver, method, methodType, args...)\n\n\tctrl.mu.Lock()\n\tdefer ctrl.mu.Unlock()\n\tctrl.expectedCalls.Add(call)\n\n\treturn call\n}", "label": 5}
{"code": "def load(file = '.cookies')\n      YAML.safe_load(IO.read(file), [::Symbol, ::Time]).each do |c|\n        add(c.delete(:name), c.delete(:value), c)\n      end\n    end", "label": 4}
{"code": "def explicit_content_filter=(filter_level)\n      filter_level = FILTER_LEVELS[filter_level] if filter_level.is_a?(Symbol)\n\n      update_server_data(explicit_content_filter: filter_level)\n    end", "label": 4}
{"code": "function Model(name, table) {\n    this.model = this;\n\n    if(!name || typeof name !== \"string\"){\n        throw new Error(\"Attempting to instantiate a model without a valid name. Create models using the Cassanova.model API.\");\n    }\n\n    if(!table){\n        throw new Error(\"Attempting to instantiate a model, \" + name + \", without a valid table. Create models using the Cassanova.model API.\");\n    }\n\n    this.name = name;\n    this.table = table;\n}", "label": 3}
{"code": "func (v *validate) ReportError(field interface{}, fieldName, structFieldName, tag, param string) {\n\n\tfv, kind, _ := v.extractTypeInternal(reflect.ValueOf(field), false)\n\n\tif len(structFieldName) == 0 {\n\t\tstructFieldName = fieldName\n\t}\n\n\tv.str1 = string(append(v.ns, fieldName...))\n\n\tif v.v.hasTagNameFunc || fieldName != structFieldName {\n\t\tv.str2 = string(append(v.actualNs, structFieldName...))\n\t} else {\n\t\tv.str2 = v.str1\n\t}\n\n\tif kind == reflect.Invalid {\n\n\t\tv.errs = append(v.errs,\n\t\t\t&fieldError{\n\t\t\t\tv:              v.v,\n\t\t\t\ttag:            tag,\n\t\t\t\tactualTag:      tag,\n\t\t\t\tns:             v.str1,\n\t\t\t\tstructNs:       v.str2,\n\t\t\t\tfieldLen:       uint8(len(fieldName)),\n\t\t\t\tstructfieldLen: uint8(len(structFieldName)),\n\t\t\t\tparam:          param,\n\t\t\t\tkind:           kind,\n\t\t\t},\n\t\t)\n\t\treturn\n\t}\n\n\tv.errs = append(v.errs,\n\t\t&fieldError{\n\t\t\tv:              v.v,\n\t\t\ttag:            tag,\n\t\t\tactualTag:      tag,\n\t\t\tns:             v.str1,\n\t\t\tstructNs:       v.str2,\n\t\t\tfieldLen:       uint8(len(fieldName)),\n\t\t\tstructfieldLen: uint8(len(structFieldName)),\n\t\t\tvalue:          fv.Interface(),\n\t\t\tparam:          param,\n\t\t\tkind:           kind,\n\t\t\ttyp:            fv.Type(),\n\t\t},\n\t)\n}", "label": 5}
{"code": "@PostConstruct\n\tprotected void postConstruct() throws GeomajasException {\n\t\tif (null == baseTmsUrl) {\n\t\t\tthrow new GeomajasException(ExceptionCode.PARAMETER_MISSING, \"baseTmsUrl\");\n\t\t}\n\n\t\t// Make sure we have a base URL we can work with:\n\t\tif ((baseTmsUrl.startsWith(\"http://\") || baseTmsUrl.startsWith(\"https://\")) && !baseTmsUrl.endsWith(\"/\")) {\n\t\t\tbaseTmsUrl += \"/\";\n\t\t}\n\n\t\t// Make sure there is a correct RasterLayerInfo object:\n\t\tif (layerInfo == null || layerInfo == UNUSABLE_LAYER_INFO) {\n\t\t\ttry {\n\t\t\t\ttileMap = configurationService.getCapabilities(this);\n\t\t\t\tversion = tileMap.getVersion();\n\t\t\t\textension = tileMap.getTileFormat().getExtension();\n\t\t\t\tlayerInfo = configurationService.asLayerInfo(tileMap);\n\t\t\t\tusable = true;\n\t\t\t} catch (TmsLayerException e) {\n\t\t\t\t// a layer needs an info object to keep the DtoConfigurationPostProcessor happy !\n\t\t\t\tlayerInfo = UNUSABLE_LAYER_INFO;\n\t\t\t\tusable = false;\n\t\t\t\tlog.warn(\"The layer could not be correctly initialized: \" + getId(), e);\n\t\t\t}\n\t\t} else if (extension == null) {\n\t\t\tthrow new GeomajasException(ExceptionCode.PARAMETER_MISSING, \"extension\");\n\t\t}\n\n\t\tif (layerInfo != null) {\n\t\t\t// Finally prepare some often needed values:\n\t\t\tstate = new TileServiceState(geoService, layerInfo);\n\t\t\t// when proxying the real url will be resolved later on, just use a simple one for now\n\t\t\tboolean proxying = useCache || useProxy || null != authentication;\n\t\t\tif (tileMap != null && !proxying) {\n\t\t\t\turlBuilder = new TileMapUrlBuilder(tileMap);\n\t\t\t} else {\n\t\t\t\turlBuilder = new SimpleTmsUrlBuilder(extension);\n\t\t\t}\n\t\t}\n\t}", "label": 0}
{"code": "private void writeAllEnvelopes(boolean reuse)\r\n    {\r\n        // perform remove of m:n indirection table entries first\r\n        performM2NUnlinkEntries();\r\n\r\n        Iterator iter;\r\n        // using clone to avoid ConcurentModificationException\r\n        iter = ((List) mvOrderOfIds.clone()).iterator();\r\n        while(iter.hasNext())\r\n        {\r\n            ObjectEnvelope mod = (ObjectEnvelope) mhtObjectEnvelopes.get(iter.next());\r\n            boolean insert = false;\r\n            if(needsCommit)\r\n            {\r\n                insert = mod.needsInsert();\r\n                mod.getModificationState().commit(mod);\r\n                if(reuse && insert)\r\n                {\r\n                    getTransaction().doSingleLock(mod.getClassDescriptor(), mod.getObject(), mod.getIdentity(), Transaction.WRITE);\r\n                }\r\n            }\r\n            /*\r\n            arminw: important to call this cleanup method for each registered\r\n            ObjectEnvelope, because this method will e.g. remove proxy listener\r\n            objects for registered objects.\r\n            */\r\n            mod.cleanup(reuse, insert);\r\n        }\r\n        // add m:n indirection table entries\r\n        performM2NLinkEntries();\r\n    }", "label": 0}
{"code": "async function validateDirPath (dirPath) {\n  try {\n    const stats = await fs.lstat(dirPath);\n    if (!stats.isDirectory()) {\n      throw userError([\n        'Source path must be a directory',\n        ''\n      ]);\n    }\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      throw userError([\n        'No files or directories found at ' + dirPath,\n        ''\n      ]);\n    }\n\n    throw error;\n  }\n}", "label": 3}
{"code": "func (a *AuthServer) buildSAMLRoles(connector services.SAMLConnector, assertionInfo saml2.AssertionInfo) ([]string, error) {\n\troles := connector.MapAttributes(assertionInfo)\n\tif len(roles) == 0 {\n\t\treturn nil, trace.AccessDenied(\"unable to map attributes to role for connector: %v\", connector.GetName())\n\t}\n\n\treturn roles, nil\n}", "label": 5}
{"code": "def _do_post(self, url, **kwargs):\n        \"\"\"\n        Convenient method for POST requests\n        Returns http request status value from a POST request\n        \"\"\"\n        #TODO:\n        # Add error handling. Check for HTTP status here would be much more conveinent than in each calling method\n        scaleioapi_post_headers = {'Content-type':'application/json','Version':'1.0'}\n        try:\n            response = self._session.post(url, headers=scaleioapi_post_headers, **kwargs)\n            self.conn.logger.debug('_do_post() - HTTP response: %s', response.text)\n            if response.status_code == requests.codes.ok:\n                self.conn.logger.debug('_do_post() - HTTP response OK, data: %s', response.text)                \n                return response\n            else:\n                self.conn.logger.error('_do_post() - HTTP response error: %s', response.status_code)\n                self.conn.logger.error('_do_post() - HTTP response error, data: %s', response.text)                \n                raise RuntimeError(\"_do_post() - HTTP response error\" + response.status_code)\n        except Exception as e:\n            self.conn.logger.error(\"_do_post() - Unhandled Error Occurred: %s\" % str(e)) \n            raise RuntimeError(\"_do_post() - Communication error with ScaleIO gateway\")\n        return response", "label": 1}
{"code": "public function sendSetGroupSubject($gjid, $subject)\n    {\n        $child = new ProtocolNode('subject', null, null, $subject);\n        $node = new ProtocolNode('iq',\n            [\n                'id'    => $this->createIqId(),\n                'type'  => 'set',\n                'to'    => $this->getJID($gjid),\n                'xmlns' => 'w:g2',\n            ], [$child], null);\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "def update_iap_family!(app_id: nil, family_id: nil, data: nil)\n      with_tunes_retry do\n        r = request(:put) do |req|\n          req.url(\"ra/apps/#{app_id}/iaps/family/#{family_id}/\")\n          req.body = data.to_json\n          req.headers['Content-Type'] = 'application/json'\n        end\n        handle_itc_response(r.body)\n      end\n    end", "label": 4}
{"code": "public static <GROUP extends Serializable> ExecutorConfig<GROUP> basicGroupable() {\n        return new ExecutorConfig<GROUP>()\n                    .withTaskIdAdapter((TaskIdAdapter<Groupable<GROUP>, GROUP, ?>) new DefaultGroupableTaskIdAdapter<GROUP>());\n    }", "label": 0}
{"code": "def show_actions(email, role):\n    \"\"\"Show all assigned actions.\"\"\"\n    if email:\n        actions = ActionUsers.query.join(ActionUsers.user).filter(\n            User.email.in_(email)\n        ).all()\n        for action in actions:\n            click.secho('user:{0}:{1}:{2}:{3}'.format(\n                action.user.email,\n                action.action,\n                '' if action.argument is None else action.argument,\n                'deny' if action.exclude else 'allow',\n            ), fg='red' if action.exclude else 'green')\n\n    if role:\n        actions = ActionRoles.query.filter(\n            Role.name.in_(role)\n        ).join(ActionRoles.role).all()\n        for action in actions:\n            click.secho('role:{0}:{1}:{2}:{3}'.format(\n                action.role.name,\n                action.action,\n                '' if action.argument is None else action.argument,\n                'deny' if action.exclude else 'allow',\n            ), fg='red' if action.exclude else 'green')", "label": 1}
{"code": "func (c *SessionContext) ExtendWebSession() (services.WebSession, error) {\n\tsess, err := c.clt.ExtendWebSession(c.user, c.sess.GetName())\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn sess, nil\n}", "label": 5}
{"code": "def load(file)\n      if file.nil? || !File.exist?(file)\n        raise \"Can't open #{file}.\"\n      end\n      loader = ReVIEW::YAMLLoader.new\n      merge_config(@config.deep_merge(loader.load_file(file)))\n    end", "label": 4}
{"code": "def parse_sasl_params(sasl_params)\n      # Symbilize keys in a hash\n      if sasl_params.kind_of?(Hash)\n        return sasl_params.inject({}) do |memo,(k,v)|\n          memo[k.to_sym] = v;\n          memo\n        end\n      end\n      return nil\n    end", "label": 4}
{"code": "func (fe *fieldError) Field() string {\n\n\treturn fe.ns[len(fe.ns)-int(fe.fieldLen):]\n\t// // return fe.field\n\t// fld := fe.ns[len(fe.ns)-int(fe.fieldLen):]\n\n\t// log.Println(\"FLD:\", fld)\n\n\t// if len(fld) > 0 && fld[:1] == \".\" {\n\t// \treturn fld[1:]\n\t// }\n\n\t// return fld\n}", "label": 5}
{"code": "public static <E> Counter<E> asCounter(Collection<E> c) {\r\n    Counter<E> count = new ClassicCounter<E>();\r\n    for (E elem : c) {\r\n      count.incrementCount(elem);\r\n    }\r\n    return count;\r\n  }", "label": 0}
{"code": "func (c *RPCClient) Ping() error {\n\tvar empty struct{}\n\treturn c.control.Call(\"Control.Ping\", true, &empty)\n}", "label": 5}
{"code": "def save_rst(self, fd):\n        \"\"\" Save a reStructuredText representation of the case.\n        \"\"\"\n        from pylon.io import ReSTWriter\n        ReSTWriter(self).write(fd)", "label": 1}
{"code": "public function rc4($key, $text)\n\t{\n\t\tif ($this->lastRc4Key != $key) {\n\t\t\t$k = str_repeat($key, 256 / strlen($key) + 1);\n\t\t\t$rc4 = range(0, 255);\n\t\t\t$j = 0;\n\t\t\tfor ($i = 0; $i < 256; $i++) {\n\t\t\t\t$t = $rc4[$i];\n\t\t\t\t$j = ($j + $t + ord($k[$i])) % 256;\n\t\t\t\t$rc4[$i] = $rc4[$j];\n\t\t\t\t$rc4[$j] = $t;\n\t\t\t}\n\t\t\t$this->lastRc4Key = $key;\n\t\t\t$this->lastRc4KeyC = $rc4;\n\t\t} else {\n\t\t\t$rc4 = $this->lastRc4KeyC;\n\t\t}\n\n\t\t$len = strlen($text);\n\t\t$a = 0;\n\t\t$b = 0;\n\t\t$out = '';\n\t\tfor ($i = 0; $i < $len; $i++) {\n\t\t\t$a = ($a + 1) % 256;\n\t\t\t$t = $rc4[$a];\n\t\t\t$b = ($b + $t) % 256;\n\t\t\t$rc4[$a] = $rc4[$b];\n\t\t\t$rc4[$b] = $t;\n\t\t\t$k = $rc4[($rc4[$a] + $rc4[$b]) % 256];\n\t\t\t$out .= chr(ord($text[$i]) ^ $k);\n\t\t}\n\n\t\treturn $out;\n\t}", "label": 2}
{"code": "public static appfwprofile_excluderescontenttype_binding[] get(nitro_service service, String name) throws Exception{\n\t\tappfwprofile_excluderescontenttype_binding obj = new appfwprofile_excluderescontenttype_binding();\n\t\tobj.set_name(name);\n\t\tappfwprofile_excluderescontenttype_binding response[] = (appfwprofile_excluderescontenttype_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function processOne() {\n        var item = array.pop();\n        fn(item, function(result, err) {\n            if (array.length > 0) \n                processOne();\n            else\n                callback(result, err);\n        });\n    }", "label": 3}
{"code": "function indexEntry(entry) {\n    if (entry.year) entry.year = parseInt(entry.year.toString().split(\"-\")[0]); // first year for series\n    var n = helpers.simplifyName(entry);\n    if (!meta[n]) meta[n] = [];\n    meta[n].push(entry);\n    byImdb[entry.imdb_id] = entry;\n}", "label": 3}
{"code": "def copy_files_to_folder(src, dest, xtn='*.txt'):\n\t\"\"\"\n\tcopies all the files from src to dest folder\n\t\"\"\" \n\t\n\ttry:\n\t\tall_files = glob.glob(os.path.join(src,xtn))\n\t\tfor f in all_files:\n\t\t\tcopy_file(f, dest)\n\texcept Exception as ex:\n\t\tprint('ERROR copy_files_to_folder - ' + str(ex))", "label": 1}
{"code": "def normalize national_number\n      clean! national_number\n      normalized = @codes.reduce national_number do |number, code|\n        result = code.normalize number\n        break result if result\n        number\n      end\n      normalized\n    end", "label": 4}
{"code": "def custom_writer(key, value, convert = true) #:nodoc:\n      key_as_symbol = (key = convert_key(key)).to_sym\n\n      log_built_in_message(key_as_symbol) if log_collision?(key_as_symbol)\n      regular_writer(key, convert ? convert_value(value) : value)\n    end", "label": 4}
{"code": "function (err) {\n\t\t\tvar i;\n\n\t\t\t// If the extended option is off, just return cloudpaths\n\t\t\tif (!options.extended) {\n\t\t\t\ti = aObjects.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\taObjects[i] = aObjects[i].cloudpath;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcb(err, err ? undefined : aObjects);\n\t\t}", "label": 3}
{"code": "public function getTags(): array\n    {\n        $typeTag = $this->implode([\n            'graphql',\n            strtolower($this->fieldValue->getParentName()),\n            $this->fieldKey,\n        ]);\n\n        $fieldTag = $this->implode([\n            'graphql',\n            strtolower($this->fieldValue->getParentName()),\n            $this->fieldKey,\n            $this->resolveInfo->fieldName,\n        ]);\n\n        return [$typeTag, $fieldTag];\n    }", "label": 2}
{"code": "function getCleanUrl (url) {\n  try {\n    const parsed = new URL(url)\n    return parsed.pathname || url\n  } catch (err) {\n    return url\n  }\n}", "label": 3}
{"code": "public void initDB() throws PlatformException\r\n    {\r\n        if (_initScripts.isEmpty())\r\n        {\r\n            createInitScripts();\r\n        }\r\n\r\n        Project       project   = new Project();\r\n        TorqueSQLTask sqlTask   = new TorqueSQLTask(); \r\n        File          outputDir = null;\r\n        \r\n        try\r\n        {\r\n            outputDir = new File(getWorkDir(), \"sql\");\r\n\r\n            outputDir.mkdir();\r\n            writeCompressedTexts(outputDir, _initScripts);\r\n\r\n            project.setBasedir(outputDir.getAbsolutePath());\r\n\r\n            // executing the generated sql, but this time with a torque task \r\n            TorqueSQLExec         sqlExec = new TorqueSQLExec();\r\n            TorqueSQLExec.OnError onError = new TorqueSQLExec.OnError();\r\n\r\n            sqlExec.setProject(project);\r\n            onError.setValue(\"continue\");\r\n            sqlExec.setAutocommit(true);\r\n            sqlExec.setDriver(_jcd.getDriver());\r\n            sqlExec.setOnerror(onError);\r\n            sqlExec.setUserid(_jcd.getUserName());\r\n            sqlExec.setPassword(_jcd.getPassWord() == null ? \"\" : _jcd.getPassWord());\r\n            sqlExec.setUrl(getDBManipulationUrl());\r\n            sqlExec.setSrcDir(outputDir.getAbsolutePath());\r\n            sqlExec.setSqlDbMap(SQL_DB_MAP_NAME);\r\n            sqlExec.execute();\r\n            \r\n            deleteDir(outputDir);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            // clean-up\r\n            if (outputDir != null)\r\n            {\r\n                deleteDir(outputDir);\r\n            }\r\n            throw new PlatformException(ex);\r\n        }\r\n    }", "label": 0}
{"code": "def set_action_cache(self, action_key, data):\n        \"\"\"Store action needs and excludes.\n\n        .. note:: The action is saved only if a cache system is defined.\n\n        :param action_key: The unique action name.\n        :param data: The action to be saved.\n        \"\"\"\n        if self.cache:\n            self.cache.set(\n                self.app.config['ACCESS_ACTION_CACHE_PREFIX'] +\n                action_key, data\n            )", "label": 1}
{"code": "def get_cantera_composition_string(self, species_conversion=None):\n        \"\"\"Get the composition in a string format suitable for input to Cantera.\n\n        Returns a formatted string no matter the type of composition. As such, this method\n        is not recommended for end users; instead, prefer the `get_cantera_mole_fraction`\n        or `get_cantera_mass_fraction` methods.\n\n        Arguments:\n            species_conversion (`dict`, optional): Mapping of species identifier to a\n                species name. This argument should be supplied when the name of the\n                species in the ChemKED YAML file does not match the name of the same\n                species in a chemical kinetic mechanism. The species identifier (the key\n                of the mapping) can be the name, InChI, or SMILES provided in the ChemKED\n                file, while the value associated with a key should be the desired name in\n                the Cantera format output string.\n\n        Returns:\n            `str`: String in the ``SPEC:AMT, SPEC:AMT`` format\n\n        Raises:\n            `ValueError`: If the composition type of the `DataPoint` is not one of\n                ``'mass fraction'``, ``'mole fraction'``, or ``'mole percent'``\n        \"\"\"\n        if self.composition_type in ['mole fraction', 'mass fraction']:\n            factor = 1.0\n        elif self.composition_type == 'mole percent':\n            factor = 100.0\n        else:\n            raise ValueError('Unknown composition type: {}'.format(self.composition_type))\n\n        if species_conversion is None:\n            comps = ['{!s}:{:.4e}'.format(c.species_name,\n                     c.amount.magnitude/factor) for c in self.composition.values()]\n        else:\n            comps = []\n            for c in self.composition.values():\n                amount = c.amount.magnitude/factor\n                idents = [getattr(c, s, False) for s in ['species_name', 'InChI', 'SMILES']]\n                present = [i in species_conversion for i in idents]\n                if not any(present):\n                    comps.append('{!s}:{:.4e}'.format(c.species_name, amount))\n                else:\n                    if len([i for i in present if i]) > 1:\n                        raise ValueError('More than one conversion present for species {}'.format(\n                                         c.species_name))\n\n                    ident = idents[present.index(True)]\n                    species_replacement_name = species_conversion.pop(ident)\n                    comps.append('{!s}:{:.4e}'.format(species_replacement_name, amount))\n\n            if len(species_conversion) > 0:\n                raise ValueError('Unknown species in conversion: {}'.format(species_conversion))\n\n        return ', '.join(comps)", "label": 1}
{"code": "def _solve(self, x0, A, l, u, xmin, xmax):\n        \"\"\" Solves using the Interior Point OPTimizer.\n        \"\"\"\n        # Indexes of constrained lines.\n        il = [i for i,ln in enumerate(self._ln) if 0.0 < ln.rate_a < 1e10]\n        nl2 = len(il)\n\n        neqnln = 2 * self._nb # no. of non-linear equality constraints\n        niqnln = 2 * len(il)  # no. of lines with constraints\n\n        user_data = {\"A\": A, \"neqnln\": neqnln, \"niqnln\": niqnln}\n\n        self._f(x0)\n        Jdata = self._dg(x0, False, user_data)\n#        Hdata = self._h(x0, ones(neqnln + niqnln), None, False, user_data)\n\n        lmbda = {\"eqnonlin\": ones(neqnln),\n                 \"ineqnonlin\": ones(niqnln)}\n        H = tril(self._hessfcn(x0, lmbda), format=\"coo\")\n        self._Hrow, self._Hcol = H.row, H.col\n\n        n = len(x0) # the number of variables\n        xl = xmin\n        xu = xmax\n        gl = r_[zeros(2 * self._nb), -Inf * ones(2 * nl2), l]\n        gu = r_[zeros(2 * self._nb),       zeros(2 * nl2), u]\n        m = len(gl) # the number of constraints\n        nnzj = len(Jdata) # the number of nonzeros in Jacobian matrix\n        nnzh = 0#len(H.data) # the number of non-zeros in Hessian matrix\n\n        f_fcn, df_fcn, g_fcn, dg_fcn, h_fcn = \\\n            self._f, self._df, self._g, self._dg, self._h\n\n        nlp = pyipopt.create(n, xl, xu, m, gl, gu, nnzj, nnzh,\n                             f_fcn, df_fcn, g_fcn, dg_fcn)#, h_fcn)\n\n#        print dir(nlp)\n#        nlp.str_option(\"print_options_documentation\", \"yes\")\n#        nlp.int_option(\"max_iter\", 10)\n\n#        x, zl, zu, obj = nlp.solve(x0)\n        success = nlp.solve(x0, user_data)\n        nlp.close()", "label": 1}
{"code": "public static snmpcommunity[] get(nitro_service service, String communityname[]) throws Exception{\n\t\tif (communityname !=null && communityname.length>0) {\n\t\t\tsnmpcommunity response[] = new snmpcommunity[communityname.length];\n\t\t\tsnmpcommunity obj[] = new snmpcommunity[communityname.length];\n\t\t\tfor (int i=0;i<communityname.length;i++) {\n\t\t\t\tobj[i] = new snmpcommunity();\n\t\t\t\tobj[i].set_communityname(communityname[i]);\n\t\t\t\tresponse[i] = (snmpcommunity) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "def resolution(path)\n      return FastImage.size(path) if content_type(path).start_with?(\"image\")\n      return video_resolution(path) if content_type(path).start_with?(\"video\")\n      raise \"Cannot find resolution of file #{path}\"\n    end", "label": 4}
{"code": "func main() {\n\tflag.Parse()\n\n\tin := toolbox.NewBackdoorChannelIn()\n\tout := toolbox.NewBackdoorChannelOut()\n\n\tservice := toolbox.NewService(in, out)\n\n\tif os.Getuid() == 0 {\n\t\tservice.Power.Halt.Handler = toolbox.Halt\n\t\tservice.Power.Reboot.Handler = toolbox.Reboot\n\t}\n\n\terr := service.Start()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// handle the signals and gracefully shutdown the service\n\tsig := make(chan os.Signal, 1)\n\tsignal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\tlog.Printf(\"signal %s received\", <-sig)\n\t\tservice.Stop()\n\t}()\n\n\tservice.Wait()\n}", "label": 5}
{"code": "public function handleStartRequest(StartRequest $startRequest): void\n    {\n        $this->requestStart = Carbon::now();\n        $this->requestStartPrecise = $this->getTime();\n    }", "label": 2}
{"code": "function(captions) {\n        var SRT_BODY = [],\n            counter = 1;\n        captions.forEach(function(caption) {\n            if (caption.text.length > 0 && validateText(caption.text)) {\n                SRT_BODY.push(counter);\n                SRT_BODY.push(module.exports.formatTime(caption.startTimeMicro) + ' --> ' + module.exports.formatTime(caption.endTimeMicro));\n                SRT_BODY.push(module.exports.renderMacros(macros.fixItalics(macros.cleanMacros(caption.text))) + '\\n');\n                counter++;\n            }\n        });\n        return SRT_BODY.join('\\n');\n    }", "label": 3}
{"code": "function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }", "label": 3}
{"code": "def get_methods fqns, scope: :instance, visibility: [:public], deep: true\n      cached = cache.get_methods(fqns, scope, visibility, deep)\n      return cached.clone unless cached.nil?\n      result = []\n      skip = []\n      if fqns == ''\n        # @todo Implement domains\n        # domains.each do |domain|\n        #   type = ComplexType.parse(domain).first\n        #   result.concat inner_get_methods(type.name, type.scope, [:public], deep, skip)\n        # end\n        result.concat inner_get_methods(fqns, :class, visibility, deep, skip)\n        result.concat inner_get_methods(fqns, :instance, visibility, deep, skip)\n        result.concat inner_get_methods('Kernel', :instance, visibility, deep, skip)\n      else\n        result.concat inner_get_methods(fqns, scope, visibility, deep, skip)\n      end\n      # live = live_map.get_methods(fqns, '', scope.to_s, visibility.include?(:private))\n      # unless live.empty?\n      #   exist = result.map(&:name)\n      #   result.concat live.reject{|p| exist.include?(p.name)}\n      # end\n      resolved = resolve_method_aliases(result)\n      cache.set_methods(fqns, scope, visibility, deep, resolved)\n      resolved\n    end", "label": 4}
{"code": "def handle_observation_criteria\n      exp = @entry.at_xpath('./cda:measureObservationDefinition/cda:value/cda:expression/@value',\n                            HQMF2::Document::NAMESPACES)\n      # Measure Observations criteria rely on computed expressions. If it doesn't have one,\n      #  then it is likely formatted improperly.\n      fail 'Measure Observations criteria is missing computed expression(s) ' if exp.nil?\n      parts = exp.to_s.split('-')\n      dc = parse_parts_to_dc(parts)\n      @doc.add_data_criteria(dc)\n      # Update reference_ids with any newly referenced data criteria\n      dc.children_criteria.each { |cc| @doc.add_reference_id(cc) } unless dc.children_criteria.nil?\n      dc\n    end", "label": 4}
{"code": "public static function invalidRequest($parameter, $hint = null, Throwable $previous = null)\n    {\n        $errorMessage = 'The request is missing a required parameter, includes an invalid parameter value, ' .\n            'includes a parameter more than once, or is otherwise malformed.';\n        $hint = ($hint === null) ? sprintf('Check the `%s` parameter', $parameter) : $hint;\n\n        return new static($errorMessage, 3, 'invalid_request', 400, $hint, null, $previous);\n    }", "label": 2}
{"code": "public static void addIndex(DBCollection collection, String field, boolean asc, boolean background) {\n        int dir = (asc) ? 1 : -1;\n        collection.createIndex(new BasicDBObject(field, dir), new BasicDBObject(\"background\", background));\n    }", "label": 0}
{"code": "def share_of_standby(df, resolution='24h', time_window=None):\n    \"\"\"\n    Compute the share of the standby power in the total consumption.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame or pandas.Series\n        Power (typically electricity, can be anything)\n    resolution : str, default='d'\n        Resolution of the computation.  Data will be resampled to this resolution (as mean) before computation\n        of the minimum.\n        String that can be parsed by the pandas resample function, example ='h', '15min', '6h'\n    time_window : tuple with start-hour and end-hour, default=None\n        Specify the start-time and end-time for the analysis.\n        Only data within this time window will be considered.\n        Both times have to be specified as string ('01:00', '06:30') or as datetime.time() objects\n\n    Returns\n    -------\n    fraction : float between 0-1 with the share of the standby consumption\n    \"\"\"\n\n    p_sb = standby(df, resolution, time_window)\n    df = df.resample(resolution).mean()\n    p_tot = df.sum()\n    p_standby = p_sb.sum()\n    share_standby = p_standby / p_tot\n    res = share_standby.iloc[0]\n    return res", "label": 1}
{"code": "func Init(dc driverapi.DriverCallback, config map[string]interface{}) error {\n\tc := driverapi.Capability{\n\t\tDataScope:         datastore.LocalScope,\n\t\tConnectivityScope: datastore.GlobalScope,\n\t}\n\td := &driver{\n\t\tnetworks: networkTable{},\n\t}\n\td.initStore(config)\n\n\treturn dc.RegisterDriver(ipvlanType, d, c)\n}", "label": 5}
{"code": "public function setLabelDetectionConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\VideoIntelligence\\V1beta2\\LabelDetectionConfig::class);\n        $this->label_detection_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func endpointThumbprint(endpoint *types.LookupServiceRegistrationEndpoint) string {\n\tif len(endpoint.SslTrust) == 0 {\n\t\treturn \"\"\n\t}\n\tenc := endpoint.SslTrust[0]\n\n\tb, err := base64.StdEncoding.DecodeString(enc)\n\tif err != nil {\n\t\tlog.Printf(\"base64.Decode(%q): %s\", enc, err)\n\t\treturn \"\"\n\t}\n\n\tcert, err := x509.ParseCertificate(b)\n\tif err != nil {\n\t\tlog.Printf(\"x509.ParseCertificate(%q): %s\", enc, err)\n\t\treturn \"\"\n\t}\n\n\treturn soap.ThumbprintSHA1(cert)\n}", "label": 5}
{"code": "function extractCTXLabel(test, limit) {\n\t\tlimit = typeof limit === 'undefined' ? strimLimit : limit;\n\t\tvar label;\n\t\tif (test.label) {\n\t\t\tlabel = style.accent(test.label);\n\t\t}\n\t\tif (!label) {\n\t\t\tlabel = style.accent('<no label>') + ' ' + valueStrim(test.value, limit);\n\t\t}\n\t\treturn label;\n\t}", "label": 3}
{"code": "public static base_responses flush(nitro_service client, cacheobject resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tcacheobject flushresources[] = new cacheobject[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tflushresources[i] = new cacheobject();\n\t\t\t\tflushresources[i].locator = resources[i].locator;\n\t\t\t\tflushresources[i].url = resources[i].url;\n\t\t\t\tflushresources[i].host = resources[i].host;\n\t\t\t\tflushresources[i].port = resources[i].port;\n\t\t\t\tflushresources[i].groupname = resources[i].groupname;\n\t\t\t\tflushresources[i].httpmethod = resources[i].httpmethod;\n\t\t\t\tflushresources[i].force = resources[i].force;\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, flushresources,\"flush\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def save_template\n      path = \"/tmp/ufo/#{@stack_name}/stack.yml\"\n      FileUtils.mkdir_p(File.dirname(path))\n      IO.write(path, template_body)\n      puts \"Generated template saved at: #{path}\"\n\n      path = \"/tmp/ufo/#{@stack_name}/parameters.yml\"\n      IO.write(path, JSON.pretty_generate(parameters))\n      puts \"Generated parameters saved at: #{path}\"\n    end", "label": 4}
{"code": "def merge(target)\n      start, stop = if target.is_a?(String)\n                      [self.r, target]\n                    elsif(target.is_a?(Cell))\n                      Axlsx.sort_cells([self, target]).map { |c| c.r }\n                    end\n      self.row.worksheet.merge_cells \"#{start}:#{stop}\" unless stop.nil?\n    end", "label": 4}
{"code": "function RequestStream(requestStream, options) {\n\tvar self = this;\n\tif(!options) options = {};\n\tif(options.allowedStatusCodes === undefined) {\n\t\toptions.allowedStatusCodes = [200, 201, 202, 203, 204, 205, 206];\n\t}\n\tif(options.readErrorResponse === undefined) {\n\t\toptions.readErrorResponse = true;\n\t}\n\tClassicDuplex.call(this, requestStream, options);\n\tthis._readErrorResponse = !!options.readErrorResponse;\n\tthis._allowedStatusCodes = options.allowedStatusCodes;\n\n\trequestStream.on('response', function(response) {\n\t\tself._currentResponse = response;\n\t\tself.emit('response', response);\n\t\tif(Array.isArray(self._allowedStatusCodes)) {\n\t\t\tvar statusCode = ''+response.statusCode;\n\t\t\tvar statusCodeIsAllowed = false;\n\t\t\tfor(var i = 0; i < self._allowedStatusCodes.length; i++) {\n\t\t\t\tif(''+self._allowedStatusCodes[i] === statusCode) {\n\t\t\t\t\tstatusCodeIsAllowed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!statusCodeIsAllowed) {\n\t\t\t\tself._handleErrorInResponse(response, new Error('Received error status code: ' + statusCode));\n\t\t\t}\n\t\t}\n\t});\n\tif(requestStream.method === 'GET') {\n\t\tthis._compoundWritable.end();\n\t}\n}", "label": 3}
{"code": "def initial_variant_sequences_from_reads(\n        variant_reads,\n        max_nucleotides_before_variant=None,\n        max_nucleotides_after_variant=None):\n    \"\"\"\n    Get all unique sequences from reads spanning a variant locus. This will\n    include partial sequences due to reads starting in the middle of the\n    sequence around around a variant.\n    \"\"\"\n    unique_sequence_groups = group_unique_sequences(\n        variant_reads,\n        max_prefix_size=max_nucleotides_before_variant,\n        max_suffix_size=max_nucleotides_after_variant)\n\n    return [\n        VariantSequence(\n            prefix=prefix,\n            alt=alt,\n            suffix=suffix,\n            reads=reads)\n        for ((prefix, alt, suffix), reads)\n        in unique_sequence_groups.items()\n    ]", "label": 1}
{"code": "protected synchronized void doClose()\r\n    {\r\n        try\r\n        {\r\n            LockManager lm = getImplementation().getLockManager();\r\n            Enumeration en = objectEnvelopeTable.elements();\r\n            while (en.hasMoreElements())\r\n            {\r\n                ObjectEnvelope oe = (ObjectEnvelope) en.nextElement();\r\n                lm.releaseLock(this, oe.getIdentity(), oe.getObject());\r\n            }\r\n\r\n            //remove locks for objects which haven't been materialized yet\r\n            for (Iterator it = unmaterializedLocks.iterator(); it.hasNext();)\r\n            {\r\n                lm.releaseLock(this, it.next());\r\n            }\r\n\r\n            // this tx is no longer interested in materialization callbacks\r\n            unRegisterFromAllIndirectionHandlers();\r\n            unRegisterFromAllCollectionProxies();\r\n        }\r\n        finally\r\n        {\r\n            /**\r\n             * MBAIRD: Be nice and close the table to release all refs\r\n             */\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"Close Transaction and release current PB \" + broker + \" on tx \" + this);\r\n            // remove current thread from LocalTxManager\r\n            // to avoid problems for succeeding calls of the same thread\r\n            implementation.getTxManager().deregisterTx(this);\r\n            // now cleanup and prepare for reuse\r\n            refresh();\r\n        }\r\n    }", "label": 0}
{"code": "def documents\n      @documents ||= collections.reduce(Set.new) do |docs, (_, collection)|\n        docs + collection.docs + collection.files\n      end.to_a\n    end", "label": 4}
{"code": "def vec_angle(vec1, vec2):\n    \"\"\" Angle between two R-dimensional vectors.\n\n    Angle calculated as:\n\n    .. math::\n\n        \\\\arccos\\\\left[\n        \\\\frac{\\\\mathsf{vec1}\\cdot\\\\mathsf{vec2}}\n        {\\\\left\\\\|\\\\mathsf{vec1}\\\\right\\\\|\n            \\\\left\\\\|\\\\mathsf{vec2}\\\\right\\\\|}\n        \\\\right]\n\n    Parameters\n    ----------\n    vec1\n        length-R |npfloat_| --\n        First vector\n\n    vec2\n        length-R |npfloat_| --\n        Second vector\n\n    Returns\n    -------\n    angle\n        |npfloat_| --\n        Angle between the two vectors in degrees\n\n    \"\"\"\n\n    # Imports\n    import numpy as np\n    from scipy import linalg as spla\n    from ..const import PRM\n\n    # Check shape and equal length\n    if len(vec1.shape) != 1:\n        raise ValueError(\"'vec1' is not a vector\")\n    ## end if\n    if len(vec2.shape) != 1:\n        raise ValueError(\"'vec2' is not a vector\")\n    ## end if\n    if vec1.shape[0] != vec2.shape[0]:\n        raise ValueError(\"Vector lengths are not equal\")\n    ## end if\n\n    # Check magnitudes\n    if spla.norm(vec1) < PRM.ZERO_VEC_TOL:\n        raise ValueError(\"'vec1' norm is too small\")\n    ## end if\n    if spla.norm(vec2) < PRM.ZERO_VEC_TOL:\n        raise ValueError(\"'vec2' norm is too small\")\n    ## end if\n\n    # Calculate the angle and return. Do in multiple steps to test for\n    #  possible >1 or <-1 values from numerical precision errors.\n    dotp = np.dot(vec1, vec2) / spla.norm(vec1) / spla.norm(vec2)\n\n    if dotp > 1:\n        angle = 0. # pragma: no cover\n    elif dotp < -1:\n        angle = 180. # pragma: no cover\n    else:\n        angle = np.degrees(np.arccos(dotp))\n    ## end if\n\n    return angle", "label": 1}
{"code": "public boolean load()\r\n    {\r\n    \t_load();\r\n    \tjava.util.Iterator it = this.alChildren.iterator();\r\n    \twhile (it.hasNext())\r\n    \t{\r\n    \t\tObject o = it.next();\r\n    \t\tif (o instanceof OjbMetaTreeNode) ((OjbMetaTreeNode)o).load();\r\n    \t}\r\n    \treturn true;\r\n    }", "label": 0}
{"code": "public static authenticationvserver_binding get(nitro_service service, String name) throws Exception{\n\t\tauthenticationvserver_binding obj = new authenticationvserver_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationvserver_binding response = (authenticationvserver_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function getAvatarUrlAttribute(string $value = null)\n    {\n        if ($value && strpos($value, '://') === false) {\n            return app(UrlGenerator::class)->to('forum')->path('assets/avatars/'.$value);\n        }\n\n        return $value;\n    }", "label": 2}
{"code": "public function addScopes(array $scopes): self\n    {\n        $this->scopes = array_merge($this->scopes, $scopes);\n\n        return $this;\n    }", "label": 2}
{"code": "public function pressKey($key)\n    {\n        $this->executor->execute(DriverCommand::SEND_KEYS_TO_ACTIVE_ELEMENT, [\n            'value' => [(string) $key],\n        ]);\n\n        return $this;\n    }", "label": 2}
{"code": "public static function toXml($data): string\n    {\n        if (!is_array($data) || count($data) <= 0) {\n            throw new InvalidArgumentException('Convert To Xml Error! Invalid Array!');\n        }\n\n        $xml = '<xml>';\n        foreach ($data as $key => $val) {\n            $xml .= is_numeric($val) ? '<'.$key.'>'.$val.'</'.$key.'>' :\n                                       '<'.$key.'><![CDATA['.$val.']]></'.$key.'>';\n        }\n        $xml .= '</xml>';\n\n        return $xml;\n    }", "label": 2}
{"code": "function getCompletionEntryDisplayNameForSymbol(symbol, target, performCharacterChecks, location) {\n            var displayName = ts.getDeclaredName(program.getTypeChecker(), symbol, location);\n            if (displayName) {\n                var firstCharCode = displayName.charCodeAt(0);\n                // First check of the displayName is not external module; if it is an external module, it is not valid entry\n                if ((symbol.flags & 1920 /* Namespace */) && (firstCharCode === 39 /* singleQuote */ || firstCharCode === 34 /* doubleQuote */)) {\n                    // If the symbol is external module, don't show it in the completion list\n                    // (i.e declare module \"http\" { const x; } | // <= request completion here, \"http\" should not be there)\n                    return undefined;\n                }\n            }\n            return getCompletionEntryDisplayName(displayName, target, performCharacterChecks);\n        }", "label": 3}
{"code": "func makeIgnoredLabels(labels []string) map[string]string {\n\tignoredLabels := make(map[string]string)\n\tfor _, s := range labels {\n\t\tignoredLabels[s] = \"\"\n\t}\n\treturn ignoredLabels\n}", "label": 5}
{"code": "public function setFieldsOfStudy($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->fields_of_study = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public DbLicense getLicense(final String name) {\n        final DbLicense license = repoHandler.getLicense(name);\n\n        if (license == null) {\n            throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND)\n                    .entity(\"License \" + name + \" does not exist.\").build());\n        }\n\n        return license;\n    }", "label": 0}
{"code": "func ParsePortBindingPolicies(policies []json.RawMessage) ([]types.PortBinding, error) {\n\tvar bindings []types.PortBinding\n\thcsPolicy := &hcsshim.NatPolicy{}\n\n\tfor _, elem := range policies {\n\n\t\tif err := json.Unmarshal([]byte(elem), &hcsPolicy); err != nil || hcsPolicy.Type != \"NAT\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tbinding := types.PortBinding{\n\t\t\tHostPort:    hcsPolicy.ExternalPort,\n\t\t\tHostPortEnd: hcsPolicy.ExternalPort,\n\t\t\tPort:        hcsPolicy.InternalPort,\n\t\t\tProto:       types.ParseProtocol(hcsPolicy.Protocol),\n\t\t\tHostIP:      net.IPv4(0, 0, 0, 0),\n\t\t}\n\n\t\tbindings = append(bindings, binding)\n\t}\n\n\treturn bindings, nil\n}", "label": 5}
{"code": "function newChecklist(Class) {\n  if (Class) {\n    var _keys, _complete, _Class$META_KEY$CHECK, _mutatorMap;\n\n    // $FlowFixMe\n    Class[_GQLBase.META_KEY][CHECKLIST] = (_Class$META_KEY$CHECK = {}, (0, _defineProperty2.default)(_Class$META_KEY$CHECK, CHECK_SCHEMA, false), (0, _defineProperty2.default)(_Class$META_KEY$CHECK, CHECK_RESOLVERS, false), (0, _defineProperty2.default)(_Class$META_KEY$CHECK, CHECK_API_DOCS, false), _keys = \"keys\", _mutatorMap = {}, _mutatorMap[_keys] = _mutatorMap[_keys] || {}, _mutatorMap[_keys].get = function () {\n      return [CHECK_SCHEMA, CHECK_RESOLVERS, CHECK_API_DOCS];\n    }, _complete = \"complete\", _mutatorMap[_complete] = _mutatorMap[_complete] || {}, _mutatorMap[_complete].get = function () {\n      var _this = this;\n\n      return this.keys.reduce(function (p, c, i, a) {\n        if (!p || !_this[c]) {\n          return false;\n        }\n      }, true);\n    }, (0, _defineEnumerableProperties2.default)(_Class$META_KEY$CHECK, _mutatorMap), _Class$META_KEY$CHECK);\n  } else {\n    throw new Error((0, _neTagFns.customDedent)({\n      dropLowest: true\n    })(_templateObject()));\n  }\n}", "label": 3}
{"code": "def delete_all\n      if Runtime.version >= '2.0'\n        plugins = Chewy.client.nodes.info(plugins: true)['nodes'].values.map { |item| item['plugins'] }.flatten\n        raise PluginMissing, 'install delete-by-query plugin' unless plugins.find { |item| item['name'] == 'delete-by-query' }\n      end\n\n      request = chain { criteria.update_options simple: true }.send(:_request)\n\n      ActiveSupport::Notifications.instrument 'delete_query.chewy',\n        request: request, indexes: _indexes, types: _types,\n        index: _indexes.one? ? _indexes.first : _indexes,\n        type: _types.one? ? _types.first : _types do\n          if Runtime.version >= '2.0'\n            path = Elasticsearch::API::Utils.__pathify(\n              Elasticsearch::API::Utils.__listify(request[:index]),\n              Elasticsearch::API::Utils.__listify(request[:type]),\n              '/_query'\n            )\n            Chewy.client.perform_request(Elasticsearch::API::HTTP_DELETE, path, {}, request[:body]).body\n          else\n            Chewy.client.delete_by_query(request)\n          end\n        end\n    end", "label": 4}
{"code": "public static File ensureDir(File tgtDir) throws Exception {\r\n    if (tgtDir.exists()) {\r\n      if (tgtDir.isDirectory()) return tgtDir;\r\n      else\r\n        throw new Exception(\"Could not create directory \"+tgtDir.getAbsolutePath()+\", as a file already exists at that path.\");\r\n    } else {\r\n      tgtDir.mkdirs();\r\n      return tgtDir;\r\n    }\r\n  }", "label": 0}
{"code": "def fetch_pull_request_url(repo_slug, build_number, token)\n      build_json = fetch_build(repo_slug, build_number, token)\n      pull_requests = build_json[:pull_requests]\n      return nil unless pull_requests.first\n      pull_requests.first[:url]\n    end", "label": 4}
{"code": "def printArchive(fileName):\n    \"\"\" Prints content of combine archive\n\n    :param fileName: path of archive\n    :return: None\n    \"\"\"\n    archive = CombineArchive()\n    if archive.initializeFromArchive(fileName) is None:\n        print(\"Invalid Combine Archive\")\n        return None\n\n    print('*'*80)\n    print('Print archive:', fileName)\n    print('*' * 80)\n    printMetaDataFor(archive, \".\")\n    print(\"Num Entries: {0}\".format(archive.getNumEntries()))\n\n    for i in range(archive.getNumEntries()):\n        entry = archive.getEntry(i)\n        print(\" {0}: location: {1} format: {2}\".format(i, entry.getLocation(), entry.getFormat()))\n        printMetaDataFor(archive, entry.getLocation())\n\n        for j in range(entry.getNumCrossRefs()):\n            print(\"  {0}: crossRef location {1}\".format(j, entry.getCrossRef(j).getLocation()))\n\n        # the entry could now be extracted via\n        # archive.extractEntry(entry.getLocation(), <filename or folder>)\n\n        # or used as string\n        # content = archive.extractEntryToString(entry.getLocation());\n\n    archive.cleanUp()", "label": 1}
{"code": "public static function castToArray($param)\n    {\n        if ($param instanceof \\stdClass) {\n            $param = (array) $param;\n\n            return $param;\n        }\n\n        if ($param instanceof Arrayable) {\n            return $param->toArray();\n        }\n\n        return $param;\n    }", "label": 2}
{"code": "def [](url)\n      interpret case\n        when store.respond_to?(:[])\n          store[key_for(url)]\n        when store.respond_to?(:get)\n          store.get key_for(url)\n        when store.respond_to?(:read)\n          store.read key_for(url)\n      end\n    end", "label": 4}
{"code": "def ask_editor(input = nil, preferred_editor = nil)\n      editor = available_editor preferred_editor\n      program = Commander::Runner.instance.program(:name).downcase rescue 'commander'\n      tmpfile = Tempfile.new program\n      begin\n        tmpfile.write input if input\n        tmpfile.close\n        system(\"#{editor} #{tmpfile.path.shellescape}\") ? IO.read(tmpfile.path) : nil\n      ensure\n        tmpfile.unlink\n      end\n    end", "label": 4}
{"code": "def run_strelka_full(job, tumor_bam, normal_bam, univ_options, strelka_options):\n    \"\"\"\n    Run strelka on the DNA bams.\n\n    :param dict tumor_bam: Dict of bam and bai for tumor DNA-Seq\n    :param dict normal_bam: Dict of bam and bai for normal DNA-Seq\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict strelka_options: Options specific to strelka\n    :return: Dict of fsIDs snv and indel prediction files\n             output_dict:\n                 |-'snvs': fsID\n                 +-'indels': fsID\n    :rtype: dict\n    \"\"\"\n    work_dir = os.getcwd()\n    input_files = {\n        'tumor.bam': tumor_bam['tumor_dna_fix_pg_sorted.bam'],\n        'tumor.bam.bai': tumor_bam['tumor_dna_fix_pg_sorted.bam.bai'],\n        'normal.bam': normal_bam['normal_dna_fix_pg_sorted.bam'],\n        'normal.bam.bai': normal_bam['normal_dna_fix_pg_sorted.bam.bai'],\n        'genome.fa.tar.gz': strelka_options['genome_fasta'],\n        'genome.fa.fai.tar.gz': strelka_options['genome_fai'],\n        'config.ini.tar.gz': strelka_options['config_file']\n    }\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n\n    for key in ('genome.fa', 'genome.fa.fai', 'config.ini'):\n        input_files[key] = untargz(input_files[key + '.tar.gz'], work_dir)\n    input_files = {key: docker_path(path) for key, path in input_files.items()}\n\n    parameters = [input_files['config.ini'],\n                  input_files['tumor.bam'],\n                  input_files['normal.bam'],\n                  input_files['genome.fa'],\n                  str(job.cores)\n                  ]\n    docker_call(tool='strelka', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], tool_version=strelka_options['version'])\n    output_dict = {}\n    for mutation_type in ['snvs', 'indels']:\n        output_dict[mutation_type] = job.fileStore.writeGlobalFile(os.path.join(\n            work_dir, 'strelka_out', 'results', 'passed.somatic.' + mutation_type + '.vcf'))\n    job.fileStore.logToMaster('Ran strelka on %s successfully' % univ_options['patient'])\n    return output_dict", "label": 1}
{"code": "public function setGraph($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dataproc\\V1beta2\\WorkflowGraph::class);\n        $this->graph = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def RattributesBM(dataset,database,host=rbiomart_host):\n    \"\"\"\n    Lists BioMart attributes through a RPY2 connection.\n\n    :param dataset: a dataset listed in RdatasetsBM()\n    :param database: a database listed in RdatabasesBM()\n    :param host: address of the host server, default='www.ensembl.org'\n\n    :returns: nothing\n\n    \"\"\"\n    biomaRt = importr(\"biomaRt\")\n    ensemblMart=biomaRt.useMart(database, host=rbiomart_host)\n    ensembl=biomaRt.useDataset(dataset, mart=ensemblMart)\n    print(biomaRt.listAttributes(ensembl))", "label": 1}
{"code": "public function collection($collectionId)\n    {\n        return new CollectionReference(\n            $this->connection,\n            $this->valueMapper,\n            $this->childPath($this->name, $collectionId)\n        );\n    }", "label": 2}
{"code": "public static base_responses update(nitro_service client, Interface resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tInterface updateresources[] = new Interface[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new Interface();\n\t\t\t\tupdateresources[i].id = resources[i].id;\n\t\t\t\tupdateresources[i].speed = resources[i].speed;\n\t\t\t\tupdateresources[i].duplex = resources[i].duplex;\n\t\t\t\tupdateresources[i].flowctl = resources[i].flowctl;\n\t\t\t\tupdateresources[i].autoneg = resources[i].autoneg;\n\t\t\t\tupdateresources[i].hamonitor = resources[i].hamonitor;\n\t\t\t\tupdateresources[i].tagall = resources[i].tagall;\n\t\t\t\tupdateresources[i].trunk = resources[i].trunk;\n\t\t\t\tupdateresources[i].lacpmode = resources[i].lacpmode;\n\t\t\t\tupdateresources[i].lacpkey = resources[i].lacpkey;\n\t\t\t\tupdateresources[i].lagtype = resources[i].lagtype;\n\t\t\t\tupdateresources[i].lacppriority = resources[i].lacppriority;\n\t\t\t\tupdateresources[i].lacptimeout = resources[i].lacptimeout;\n\t\t\t\tupdateresources[i].ifalias = resources[i].ifalias;\n\t\t\t\tupdateresources[i].throughput = resources[i].throughput;\n\t\t\t\tupdateresources[i].bandwidthhigh = resources[i].bandwidthhigh;\n\t\t\t\tupdateresources[i].bandwidthnormal = resources[i].bandwidthnormal;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def github(github_token, path=\"/v1/auth/github/login\")\n      payload = {token: github_token}\n      json = client.post(path, JSON.fast_generate(payload))\n      secret = Secret.decode(json)\n      client.token = secret.auth.client_token\n      return secret\n    end", "label": 4}
{"code": "func (mr *MockEmbeddedMockRecorder) EmbeddedMethod() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"EmbeddedMethod\", reflect.TypeOf((*MockEmbedded)(nil).EmbeddedMethod))\n}", "label": 5}
{"code": "def rollup_messages\n      [].tap do |messages|\n        messages << message if message.present?\n        children&.pluck(:message)&.uniq&.each do |child_message|\n          messages << child_message if child_message.present?\n        end\n      end\n    end", "label": 4}
{"code": "protected function autoDetectTimeZone($object, $originalObject = null)\n    {\n        /** @var CarbonTimeZone $timezone */\n        $timezone = CarbonTimeZone::instance($object);\n        if ($timezone && is_int($originalObject ?: $object)) {\n            $timezone = $timezone->toRegionTimeZone($this);\n        }\n\n        return $timezone;\n    }", "label": 2}
{"code": "function sortByProp(prop, list) {\n  const get = R.is(Array, prop) ? R.path : R.prop;\n  return R.sort((elA, elB) => {\n    const a = get(prop, elA);\n    const b = get(prop, elB);\n    return sortObjects(a, b);\n  }, list);\n}", "label": 3}
{"code": "function($el, options) {\n      options = options || {};\n      var view = this;\n      if (!this.isAttachedToParent()) {\n        this.__pendingAttachInfo = {\n          $el: $el,\n          options: options\n        };\n        return this.render().done(function() {\n          if (!view.__attachedCallbackInvoked && view.isAttached()) {\n            view.__invokeAttached();\n          }\n          view.__isAttachedToParent = true;\n        });\n      }\n      return $.Deferred().resolve().promise();\n    }", "label": 3}
{"code": "def extractDate(self, inp):\n        \"\"\"Returns the first date found in the input string, or None if not\n        found.\"\"\"\n        dates = self.extractDates(inp)\n        for date in dates:\n            return date\n        return None", "label": 1}
{"code": "private function _getXAdvancePos($pos)\n\t{\n\t\t// NB Not all fonts have all marks specified in GlyphClassMarks\n\t\t// If the current glyph is not a base (but a mark) then ignore this, and apply to the current position\n\t\tif (strpos($this->GlyphClassMarks, $this->OTLdata[$pos]['hex']) !== false) {\n\t\t\treturn $pos;\n\t\t}\n\n\t\twhile (isset($this->OTLdata[$pos + 1]['hex']) && strpos($this->GlyphClassMarks, $this->OTLdata[$pos + 1]['hex']) !== false) {\n\t\t\t$pos++;\n\t\t}\n\t\treturn $pos;\n\t}", "label": 2}
{"code": "function once(events, callback, context)\n  {\n    return onListeners( this, events, callback, context, EventNode.Types.Once );\n  }", "label": 3}
{"code": "@ViewChanged\n\tpublic synchronized void onViewChangeEvent(ViewChangedEvent event) {\n\t\t\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"onViewChangeEvent : pre[\" + event.isPre() + \"] : event local address[\" + event.getCache().getLocalAddress() + \"]\");\n\t\t}\n\t\t\n\t\tfinal List<Address> oldView = currentView;\n\t\tcurrentView = new ArrayList<Address>(event.getNewView().getMembers());\n\t\tfinal Address localAddress = getLocalAddress();\n\t\t\n\t\t//just a precaution, it can be null!\n\t\tif (oldView != null) {\n\t\t\tfinal Cache jbossCache = mobicentsCache.getJBossCache();\n\t\t\tfinal Configuration config = jbossCache.getConfiguration();\t\t\n\n\t\t\tfinal boolean isBuddyReplicationEnabled = config.getBuddyReplicationConfig() != null && config.getBuddyReplicationConfig().isEnabled();\n\t\t\t// recover stuff from lost members\n\t\t\tRunnable runnable = new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfor (Address oldMember : oldView) {\n\t\t\t\t\t\tif (!currentView.contains(oldMember)) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"onViewChangeEvent : processing lost member \" + oldMember);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (FailOverListener localListener : failOverListeners) {\n\t\t\t\t\t\t\t\tClientLocalListenerElector localListenerElector = localListener.getElector();\n\t\t\t\t\t\t\t\tif (localListenerElector != null && !isBuddyReplicationEnabled) {\n\t\t\t\t\t\t\t\t\t// going to use the local listener elector instead, which gives results based on data\n\t\t\t\t\t\t\t\t\tperformTakeOver(localListener,oldMember,localAddress, true, isBuddyReplicationEnabled);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tList<Address> electionView = getElectionView(oldMember);\n\t\t\t\t\t\t\t\t\tif(electionView!=null && elector.elect(electionView).equals(localAddress))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tperformTakeOver(localListener, oldMember, localAddress, false, isBuddyReplicationEnabled);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tcleanAfterTakeOver(localListener, oldMember);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tThread t = new Thread(runnable);\n\t\t\tt.start();\n\t\t}\n\t\t\n\t}", "label": 0}
{"code": "function PbfSplicer(options) {\n  // tag which will be auto-removed and auto-injected. Usually 'name'\n  this.nameTag = options.nameTag;\n  // tag that contains JSON initially, and which works as a prefix for multiple values\n  this.multiTag = options.multiTag;\n\n  // If options.namePicker is given, this class converts multiple language tags into one\n  // Otherwise, it assumes that a single name_ tag exists with JSON content, and it will replace\n  // it with multiple tags \"name_en\", \"name_fr\", ... depending on the JSON language codes\n  this.namePicker = options.namePicker;\n\n  // Flag to make requested_name (local_name) form\n  this.combineName = options.combineName;\n}", "label": 3}
{"code": "def parse_rRNA(insertion, seq, gff):\n    \"\"\"\n    parse rRNA to gff format\n    \"\"\"\n    offset = insertion['offset']\n    strand = insertion['strand']\n    for rRNA in parse_masked(seq, 0)[0]:\n        rRNA = ''.join(rRNA)\n        Start = seq[1].find(rRNA) + 1\n        End = Start + len(rRNA) - 1\n        if strand == '-':\n            Start, End = End - 2, Start - 2\n        pos = (abs(Start + offset) - 1, abs(End + offset) - 1)\n        Start, End = min(pos), max(pos)\n        source = insertion['source']\n        annot = '%s rRNA' % (source.split('from', 1)[0])\n        gff['#seqname'].append(insertion['ID'])\n        gff['source'].append(source)\n        gff['feature'].append('rRNA')\n        gff['start'].append(Start)\n        gff['end'].append(End)\n        gff['score'].append('.')\n        gff['strand'].append(strand)\n        gff['frame'].append('.')\n        gff['attribute'].append('Name=%s' % (annot))\n    return gff", "label": 1}
{"code": "def calculate_columns(sequence):\n    \"\"\"\n    Find all row names and the maximum column widths.\n\n    Args:\n        columns (dict): the keys are the column name and the value the max length.\n\n    Returns:\n        dict: column names (key) and widths (value).\n    \"\"\"\n    columns = {}\n\n    for row in sequence:\n        for key in row.keys():\n            if key not in columns:\n                columns[key] = len(key)\n\n            value_length = len(str(row[key]))\n            if value_length > columns[key]:\n                columns[key] = value_length\n\n    return columns", "label": 1}
{"code": "func CreateUserAndRole(clt clt, username string, allowedLogins []string) (services.User, services.Role, error) {\n\tuser, err := services.NewUser(username)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\trole := services.RoleForUser(user)\n\trole.SetLogins(services.Allow, []string{user.GetName()})\n\terr = clt.UpsertRole(role)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\tuser.AddRole(role.GetName())\n\terr = clt.UpsertUser(user)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\treturn user, role, nil\n}", "label": 5}
{"code": "def add_dynamic_field_factory(name, type, options = {}, &block)\n      stored, more_like_this = options[:stored], options[:more_like_this]\n      field_factory = FieldFactory::Dynamic.new(name, type, options, &block)\n      @dynamic_field_factories[field_factory.signature] = field_factory\n      @dynamic_field_factories_cache[field_factory.name] = field_factory\n      if stored\n        @stored_field_factories_cache[field_factory.name] << field_factory\n      end\n      if more_like_this\n        @more_like_this_field_factories_cache[field_factory.name] << field_factory\n      end\n    end", "label": 4}
{"code": "def _parse_ignores(self):\n        \"\"\" Parse the ignores setting from the pylintrc file if available. \"\"\"\n\n        error_message = (\n            colorama.Fore.RED\n            + \"{} does not appear to be a valid pylintrc file\".format(self.rcfile)\n            + colorama.Fore.RESET\n        )\n\n        if not os.path.isfile(self.rcfile):\n            if not self._is_using_default_rcfile():\n                print(error_message)\n                sys.exit(1)\n            else:\n                return\n\n        config = configparser.ConfigParser()\n        try:\n            config.read(self.rcfile)\n        except configparser.MissingSectionHeaderError:\n            print(error_message)\n            sys.exit(1)\n\n        if config.has_section(\"MASTER\") and config.get(\"MASTER\", \"ignore\"):\n            self.ignore_folders += config.get(\"MASTER\", \"ignore\").split(\",\")", "label": 1}
{"code": "public function setInterleave($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\V2\\RowFilter_Interleave::class);\n        $this->writeOneof(2, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def find_trees(self, query_dict=None, exact=False, verbose=False, wrap_response=False, **kwargs):\n        \"\"\"Query on tree properties. See documentation for _OTIWrapper class.\"\"\"\n        if self.use_v1:\n            uri = '{p}/singlePropertySearchForTrees'.format(p=self.query_prefix)\n        else:\n            uri = '{p}/find_trees'.format(p=self.query_prefix)\n        resp = self._do_query(uri,\n                              query_dict=query_dict,\n                              exact=exact,\n                              verbose=verbose,\n                              valid_keys=self.tree_search_term_set,\n                              kwargs=kwargs)\n        if wrap_response:\n            return TreeRefList(resp)\n        return resp", "label": 1}
{"code": "public function setProductSets($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\ProductSet::class);\n        $this->product_sets = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "private ClassTypeSignature getClassTypeSignature(\r\n\t\t\tParameterizedType parameterizedType) {\r\n\t\tClass<?> rawType = (Class<?>) parameterizedType.getRawType();\r\n\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\r\n\t\tTypeArgSignature[] typeArgSignatures = new TypeArgSignature[typeArguments.length];\r\n\t\tfor (int i = 0; i < typeArguments.length; i++) {\r\n\t\t\ttypeArgSignatures[i] = getTypeArgSignature(typeArguments[i]);\r\n\t\t}\r\n\r\n\t\tString binaryName = rawType.isMemberClass() ? rawType.getSimpleName()\r\n\t\t\t\t: rawType.getName();\r\n\t\tClassTypeSignature ownerTypeSignature = parameterizedType\r\n\t\t\t\t.getOwnerType() == null ? null\r\n\t\t\t\t: (ClassTypeSignature) getFullTypeSignature(parameterizedType\r\n\t\t\t\t\t\t.getOwnerType());\r\n\t\tClassTypeSignature classTypeSignature = new ClassTypeSignature(\r\n\t\t\t\tbinaryName, typeArgSignatures, ownerTypeSignature);\r\n\t\treturn classTypeSignature;\r\n\t}", "label": 0}
{"code": "def pass_community(f):\n    \"\"\"Decorator to pass community.\"\"\"\n    @wraps(f)\n    def inner(community_id, *args, **kwargs):\n        c = Community.get(community_id)\n        if c is None:\n            abort(404)\n        return f(c, *args, **kwargs)\n    return inner", "label": 1}
{"code": "function _gpfRequireWrapGpf(context, name) {\n        return _gpfRequirePlugWrapper(_gpfRequireAllocateWrapper(), _gpfRequireAllocate(context, { base: _gpfPathParent(name) }));\n    }", "label": 3}
{"code": "def describe_contents(self):\n        \"\"\" describes various contents of data table \"\"\"\n        print('======================================================================')\n        print(self)\n        print('Table  = ',  str(len(self.header)) + ' cols x ' + str(len(self.arr)) + ' rows')\n        print('HEADER = ', self.get_header())\n        print('arr    = ', self.arr[0:2])", "label": 1}
{"code": "def data\n      unless @data\n        @data = {}\n        @path.find do |descendant|\n          if Puppet::ModuleTool.artifact?(descendant)\n            Find.prune\n          elsif descendant.file?\n            path = descendant.relative_path_from(@path)\n            @data[path.to_s] = checksum(descendant)\n          end\n        end\n      end\n      return @data\n    end", "label": 4}
{"code": "public function validator()\n    {\n\n        if (isset($this->rules) && !is_null($this->rules) && is_array($this->rules) && !empty($this->rules)) {\n            if (class_exists('Prettus\\Validator\\LaravelValidator')) {\n                $validator = app('Prettus\\Validator\\LaravelValidator');\n                if ($validator instanceof ValidatorInterface) {\n                    $validator->setRules($this->rules);\n\n                    return $validator;\n                }\n            } else {\n                throw new Exception(trans('repository::packages.prettus_laravel_validation_required'));\n            }\n        }\n\n        return null;\n    }", "label": 2}
{"code": "def generate_account(seed=None, index=0):\n    \"\"\"\n    Generates an adhoc account and keypair\n\n    >>> account = generate_account(seed=unhexlify('0'*64))\n    {'address': u'xrb_3i1aq1cchnmbn9x5rsbap8b15akfh7wj7pwskuzi7ahz8oq6cobd99d4r3b7',\n     'private_key_bytes': '\\x9f\\x0eDLi\\xf7zI\\xbd\\x0b\\xe8\\x9d\\xb9,8\\xfeq>\\tc\\x16\\\\\\xca\\x12\\xfa\\xf5q-vW\\x12\\x0f',\n     'private_key_hex': '9f0e444c69f77a49bd0be89db92c38fe713e0963165cca12faf5712d7657120f',\n     'public_key_bytes': '\\xc0\\x08\\xb8\\x14\\xa7\\xd2i\\xa1\\xfa<e(\\xb1\\x92\\x01\\xa2Myy\\x12\\xdb\\x99\\x96\\xff\\x02\\xa1\\xff5nEU+',\n     'public_key_hex': 'c008b814a7d269a1fa3c6528b19201a24d797912db9996ff02a1ff356e45552b'}\n\n    :param seed: the seed in bytes to use to generate the account, if not\n                 provided one is generated randomly\n    :type seed: bytes\n\n    :param index: the index offset for deterministic account generation\n    :type index: int\n\n    :return: dict containing the account address and pub/priv keys in hex/bytes\n    :rtype: dict\n    \"\"\"\n\n    if not seed:\n        seed = unhexlify(''.join(random.choice('0123456789ABCDEF') for i in range(64)))\n\n    pair = keypair_from_seed(seed, index=index)\n    result = {\n        'address': public_key_to_xrb_address(pair['public']),\n        'private_key_bytes': pair['private'],\n        'public_key_bytes': pair['public'],\n    }\n    result['private_key_hex'] = hexlify(pair['private'])\n    result['public_key_hex'] = hexlify(pair['public'])\n\n    return result", "label": 1}
{"code": "function bootstrap(item, prop, path) {\n  if ( (path.split('node_modules').length > 2) || (path.slice(-4) == 'emit') || (item == require('util') && (prop=='format')) ) return;\n  if (!item.hasOwnProperty(prop) || Object.getOwnPropertyDescriptor(item, prop).get) return;\n  var original = item[prop];\n  if (allFuncs.indexOf(original) !== -1) return;\n  allFuncs.push(original);\n  if (item[prop] instanceof Function) {\n    infect(item, prop, path);\n    if (item[prop].prototype) {\n      bootstrap(item[prop], 'prototype', path+'.prototype');\n    }\n    for (var i in original) {\n      if (!original.hasOwnProperty(i) || Object.getOwnPropertyDescriptor(original, i).get) return;\n      item[prop][i] = original[i];\n    }\n  }\n  if (item[prop] instanceof Object) {\n    for (var i in item[prop]) {\n      bootstrap(item[prop], i, path+'.'+i);\n    }\n  }\n  return item;\n}", "label": 3}
{"code": "def flush_cache(self):\n        '''\n        Use a cache to save state changes to avoid opening a session for every change.\n        The cache will be flushed at the end of the simulation, and when history is accessed.\n        '''\n        logger.debug('Flushing cache {}'.format(self.db_path))\n        with self.db:\n            for rec in self._tups:\n                self.db.execute(\"replace into history(agent_id, t_step, key, value) values (?, ?, ?, ?)\", (rec.agent_id, rec.t_step, rec.key, rec.value))\n        self._tups = list()", "label": 1}
{"code": "def deep_find_providers_for(attributes)\n      plugins = []\n      attributes.each do |attribute|\n        attrs = select_subtree(@map, attribute)\n\n        unless attrs\n          attrs = select_closest_subtree(@map, attribute)\n\n          unless attrs\n            raise Ohai::Exceptions::AttributeNotFound, \"No such attribute: \\'#{attribute}\\'\"\n          end\n        end\n\n        collect_plugins_in(attrs, plugins)\n      end\n\n      plugins.uniq\n    end", "label": 4}
{"code": "public static License createLicense(final String name, final String longName, final String comments, final String regexp, final String url){\n\t\tfinal License license = new License();\n\n\t\tlicense.setName(name);\n\t\tlicense.setLongName(longName);\n\t\tlicense.setComments(comments);\n\t\tlicense.setRegexp(regexp);\n\t\tlicense.setUrl(url);\n\n\t\treturn license;\n\t}", "label": 0}
{"code": "public function setAspect($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Language\\V1\\PartOfSpeech_Aspect::class);\n        $this->aspect = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function isImage(headers){\n    var regexImage = /image\\//i;\n    var contentType = headers ?  headers['content-type'] : '';\n    return regexImage.test(contentType);\n}", "label": 3}
{"code": "protected function setTitleAttribute($title)\n    {\n        $this->attributes['title'] = $title;\n        $this->slug = Str::slug($title);\n    }", "label": 2}
{"code": "public function setProvider($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Container\\V1\\NetworkPolicy_Provider::class);\n        $this->provider = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def run_radia(job, bams, univ_options, radia_options, chrom):\n    \"\"\"\n    This module will run radia on the RNA and DNA bams\n\n    ARGUMENTS\n    1. bams: Dict of bams and their indexes\n        bams\n         |- 'tumor_rna': <JSid>\n         |- 'tumor_rnai': <JSid>\n         |- 'tumor_dna': <JSid>\n         |- 'tumor_dnai': <JSid>\n         |- 'normal_dna': <JSid>\n         +- 'normal_dnai': <JSid>\n    2. univ_options: Dict of universal arguments used by almost all tools\n         univ_options\n                +- 'dockerhub': <dockerhub to use>\n    3. radia_options: Dict of parameters specific to radia\n         radia_options\n              |- 'dbsnp_vcf': <JSid for dnsnp vcf file>\n              +- 'genome': <JSid for genome fasta file>\n    4. chrom: String containing chromosome name with chr appended\n\n    RETURN VALUES\n    1. Dict of filtered radia output vcf and logfile (Nested return)\n        |- 'radia_filtered_CHROM.vcf': <JSid>\n        +- 'radia_filtered_CHROM_radia.log': <JSid>\n    \"\"\"\n    job.fileStore.logToMaster('Running radia on %s:%s' %(univ_options['patient'], chrom))\n    work_dir = job.fileStore.getLocalTempDir()\n    input_files = {\n        'rna.bam': bams['tumor_rna'],\n        'rna.bam.bai': bams['tumor_rnai'],\n        'tumor.bam': bams['tumor_dna'],\n        'tumor.bam.bai': bams['tumor_dnai'],\n        'normal.bam': bams['normal_dna'],\n        'normal.bam.bai': bams['normal_dnai'],\n        'genome.fasta': radia_options['genome_fasta'],\n        'genome.fasta.fai': radia_options['genome_fai']}\n    input_files = get_files_from_filestore(job, input_files, work_dir,\n                                           docker=True)\n    radia_output = ''.join([work_dir, '/radia_', chrom, '.vcf'])\n    radia_log = ''.join([work_dir, '/radia_', chrom, '_radia.log'])\n    parameters = [univ_options['patient'],  # shortID\n                  chrom,\n                  '-n', input_files['normal.bam'],\n                  '-t', input_files['tumor.bam'],\n                  '-r', input_files['rna.bam'],\n                  ''.join(['--rnaTumorFasta=', input_files['genome.fasta']]),\n                  '-f', input_files['genome.fasta'],\n                  '-o', docker_path(radia_output),\n                  '-i', 'hg19_M_rCRS',\n                  '-m', input_files['genome.fasta'],\n                  '-d', 'aarjunrao@soe.ucsc.edu',\n                  '-q', 'Illumina',\n                  '--disease', 'CANCER',\n                  '-l', 'INFO',\n                  '-g', docker_path(radia_log)]\n    docker_call(tool='radia', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'])\n    output_files = defaultdict()\n    for radia_file in [radia_output, radia_log]:\n        output_files[os.path.basename(radia_file)] = \\\n            job.fileStore.writeGlobalFile(radia_file)\n    filterradia = job.wrapJobFn(run_filter_radia, bams,\n                                output_files[os.path.basename(radia_output)],\n                                univ_options, radia_options, chrom, disk='60G', memory='6G')\n    job.addChild(filterradia)\n    return filterradia.rv()", "label": 1}
{"code": "function (methodName, params, execOptions) {\n                var defer = vow.defer();\n                var url = this._basePath + methodName;\n                var data = JSON.stringify(params);\n\n                sendAjaxRequest(url, data, execOptions).then(\n                    this._resolvePromise.bind(this, defer),\n                    this._rejectPromise.bind(this, defer)\n                );\n\n                return defer.promise();\n            }", "label": 3}
{"code": "public function getCached()\n    {\n        return $this->app['cache']->remember($this->config('cache.key'), $this->config('cache.lifetime'), function () {\n            return $this->toCollection()->toArray();\n        });\n    }", "label": 2}
{"code": "private int findIndexForName(String[] fieldNames, String searchName)\r\n    {\r\n        for(int i = 0; i < fieldNames.length; i++)\r\n        {\r\n            if(searchName.equals(fieldNames[i]))\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n        throw new PersistenceBrokerException(\"Can't find field name '\" + searchName +\r\n                \"' in given array of field names\");\r\n    }", "label": 0}
{"code": "func (m *Manager) CreateImportSpec(ctx context.Context, ovfDescriptor string, resourcePool mo.Reference, datastore mo.Reference, cisp types.OvfCreateImportSpecParams) (*types.OvfCreateImportSpecResult, error) {\n\treq := types.CreateImportSpec{\n\t\tThis:          m.Reference(),\n\t\tOvfDescriptor: ovfDescriptor,\n\t\tResourcePool:  resourcePool.Reference(),\n\t\tDatastore:     datastore.Reference(),\n\t\tCisp:          cisp,\n\t}\n\n\tres, err := methods.CreateImportSpec(ctx, m.c, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &res.Returnval, nil\n}", "label": 5}
{"code": "func CreateOptionMyAlias(alias string) EndpointOption {\n\treturn func(ep *endpoint) {\n\t\tep.myAliases = append(ep.myAliases, alias)\n\t}\n}", "label": 5}
{"code": "public static vpnglobal_vpnintranetapplication_binding[] get(nitro_service service) throws Exception{\n\t\tvpnglobal_vpnintranetapplication_binding obj = new vpnglobal_vpnintranetapplication_binding();\n\t\tvpnglobal_vpnintranetapplication_binding response[] = (vpnglobal_vpnintranetapplication_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func isDoc(val reflect.Value) bool {\n\titerations := 0\n\tfor val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr {\n\t\tval = val.Elem()\n\t\t// preventing cycles\n\t\titerations++\n\t\tif iterations > 10 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn val.Kind() == reflect.Struct || val.Kind() == reflect.Map\n}", "label": 5}
{"code": "def generate_entries_for_all_tags\n      puts \"Generating entry...\" if options[:verbose]\n\n      entries = generate_unreleased_entry\n\n      @tag_section_mapping.each_pair do |_tag_section, left_right_tags|\n        older_tag, newer_tag = left_right_tags\n        entries += generate_entry_between_tags(older_tag, newer_tag)\n      end\n\n      entries\n    end", "label": 4}
{"code": "public function rowData($attribute, array $template)\n    {\n        if (count($template)) {\n            $this->data[$attribute] = [];\n            foreach ($template as $key => $value) {\n                $this->data[$attribute][$key] = Helper::compileContent($value, $this->data, $this->row);\n            }\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "def extract_all(zipfile, dest_folder):\n    \"\"\"\n    reads the zip file, determines compression\n    and unzips recursively until source files \n    are extracted \n    \"\"\"\n    z = ZipFile(zipfile)\n    print(z)\n    z.extract(dest_folder)", "label": 1}
{"code": "def _render_template(options)\n        if options.delete(:stream)\n          Rack::Chunked::Body.new view_renderer.render_body(view_context, options)\n        else\n          super\n        end\n      end", "label": 4}
{"code": "public static Trajectory addPositionNoise(Trajectory t, double sd){\n\t\tCentralRandomNumberGenerator r = CentralRandomNumberGenerator.getInstance();\n\t\tTrajectory newt = new Trajectory(t.getDimension());\n\t\t\n\t\tfor(int i = 0; i < t.size(); i++){\n\t\t\tnewt.add(t.get(i));\n\t\t\tfor(int j = 1; j <= t.getDimension(); j++){\n\t\t\t\tswitch (j) {\n\t\t\t\tcase 1:\n\t\t\t\t\tnewt.get(i).setX(newt.get(i).x + r.nextGaussian()*sd);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tnewt.get(i).setY(newt.get(i).y + r.nextGaussian()*sd);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tnewt.get(i).setZ(newt.get(i).z + r.nextGaussian()*sd);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn newt;\n\t\t\n\t}", "label": 0}
{"code": "function augmentFactory(options) {\n    /**\n     * Apply custom augmentation\n     *\n     * @param {Object} bemNode - representation of bem entity\n     * @returns {Object} bemNode\n     */\n    function augment(bemNode) {\n\n        if (bemNode.block === 'md-root') {\n            bemNode.isRoot = true;\n        }\n\n        if (options.html) {\n            bemNode = augmentHtml(bemNode, options.html);\n        }\n\n        if (options.map) {\n            bemNode = augmentMap(bemNode, options.map);\n        }\n\n        if (options.prefix) {\n            bemNode = augmentPrefix(bemNode, options.prefix);\n        }\n\n        if (options.scope) {\n            bemNode = augmentScope(bemNode, options.scope);\n        }\n\n        if (bemNode.isRoot) delete bemNode.isRoot;\n\n        return bemNode;\n    }\n\n    return augment;\n}", "label": 3}
{"code": "function baseParse(text, strict) {\n  const lines = String(text).replace(/(?:\\r?\\n)+$/, '').split(/\\r?\\n/);\n  const records = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}", "label": 3}
{"code": "func (c *Category) Patch(src *Category) {\n\tif src.Name != \"\" {\n\t\tc.Name = src.Name\n\t}\n\tif src.Description != \"\" {\n\t\tc.Description = src.Description\n\t}\n\tif src.Cardinality != \"\" {\n\t\tc.Cardinality = src.Cardinality\n\t}\n\t// Note that in order to append to AssociableTypes any existing types must be included in their original order.\n\tfor _, kind := range src.AssociableTypes {\n\t\tif !c.hasType(kind) {\n\t\t\tc.AssociableTypes = append(c.AssociableTypes, kind)\n\t\t}\n\t}\n}", "label": 5}
{"code": "def list(*args)\n      params = arguments(args).params\n\n      response = if (user = params.delete('user'))\n        get_request(\"/users/#{user}/gists\", params)\n      elsif args.map(&:to_s).include?('public')\n        get_request(\"/gists/public\", params)\n      else\n        get_request(\"/gists\", params)\n      end\n      return response unless block_given?\n      response.each { |el| yield el }\n    end", "label": 4}
{"code": "function ServiceFactory(injector) {\n    this.cache = {};\n    this.injector = injector || {};\n\n    // if we are in debug mode, then add the debug handler\n    var pattern = this.injector.debugPattern || '*.*.*.*.*';\n    var handler = this.injector.debugHandler || debugHandler;\n    if (this.injector.debug) {\n        eventBus.on(pattern, handler);\n    }\n}", "label": 3}
{"code": "def edit(self, changelist=0):\n        \"\"\"Checks out the file\n\n        :param changelist: Optional changelist to checkout the file into\n        :type changelist: :class:`.Changelist`\n        \"\"\"\n        command = 'reopen' if self.action in ('add', 'edit') else 'edit'\n        if int(changelist):\n            self._connection.run([command, '-c', str(changelist.change), self.depotFile])\n        else:\n            self._connection.run([command, self.depotFile])\n\n        self.query()", "label": 1}
{"code": "def search(query, n_results, web):\n    \"\"\"Search for a pypi package.\n\n    \\b\n    Examples:\n        \\b\n        pypi search requests\n        pypi search 'requests oauth'\n        pypi search requests -n 20\n        pypi search 'requests toolbelt' --web\n\n    \"\"\"\n    if web:\n        secho(u'Opening search page for \"{0}\"...'.format(query), bold=True)\n        url = SEARCH_URL.format(query=urlquote(query))\n        click.launch(url)\n    else:\n        searcher = Searcher()\n        results = searcher.search(query, n=n_results)\n        first_line = style(u'Search results for \"{0}\"\\n'.format(query),\n                           bold=True)\n        echo_via_pager(\n            first_line +\n            '\\n'.join([format_result(result) for result in results])\n        )", "label": 1}
{"code": "public static nslimitselector get(nitro_service service, String selectorname) throws Exception{\n\t\tnslimitselector obj = new nslimitselector();\n\t\tobj.set_selectorname(selectorname);\n\t\tnslimitselector response = (nslimitselector) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (a *CellView) SetCursor(x, y int) {\n\ta.cursorX = x\n\ta.cursorY = y\n\ta.model.SetCursor(x, y)\n}", "label": 5}
{"code": "public void setShortAttribute(String name, Short value) {\n\t\tensureValue();\n\t\tAttribute attribute = new ShortAttribute(value);\n\t\tattribute.setEditable(isEditable(name));\n\t\tgetValue().getAllAttributes().put(name, attribute);\n\t}", "label": 0}
{"code": "def api_requests(options = {})\n      if config.stub_responses\n        if options[:exclude_presign]\n          @api_requests.reject {|req| req[:context][:presigned_url] }\n        else\n          @api_requests\n        end\n      else\n        msg = 'This method is only implemented for stubbed clients, and is '\n        msg << 'available when you enable stubbing in the constructor with `stub_responses: true`'\n        raise NotImplementedError.new(msg)\n      end\n    end", "label": 4}
{"code": "func MinTTL(a, b time.Duration) time.Duration {\n\tif a == 0 {\n\t\treturn b\n\t}\n\tif b == 0 {\n\t\treturn a\n\t}\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}", "label": 5}
{"code": "private function createSnapshot(\n        ConnectionInterface $connection,\n        ValueMapper $valueMapper,\n        DocumentReference $reference,\n        array $options = []\n    ) {\n        $document = [];\n        $fields = [];\n        $exists = true;\n\n        try {\n            $document = $this->getSnapshot($connection, $reference->name(), $options);\n        } catch (NotFoundException $e) {\n            $exists = false;\n        }\n\n        return $this->createSnapshotWithData($valueMapper, $reference, $document, $exists);\n    }", "label": 2}
{"code": "func (dal *DjangoAdminLog) Delete(db XODB) error {\n\tvar err error\n\n\t// if doesn't exist, bail\n\tif !dal._exists {\n\t\treturn nil\n\t}\n\n\t// if deleted, bail\n\tif dal._deleted {\n\t\treturn nil\n\t}\n\n\t// sql query\n\tconst sqlstr = `DELETE FROM django.django_admin_log WHERE id = ?`\n\n\t// run query\n\tXOLog(sqlstr, dal.ID)\n\t_, err = db.Exec(sqlstr, dal.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set deleted\n\tdal._deleted = true\n\n\treturn nil\n}", "label": 5}
{"code": "def validate_yaml(self, properties):\n        \"\"\"Validate the parsed YAML file for adherance to the ChemKED format.\n\n        Arguments:\n            properties (`dict`): Dictionary created from the parsed YAML file\n\n        Raises:\n            `ValueError`: If the YAML file cannot be validated, a `ValueError` is raised whose\n                string contains the errors that are present.\n        \"\"\"\n        validator = OurValidator(schema)\n        if not validator.validate(properties):\n            for key, value in validator.errors.items():\n                if any(['unallowed value' in v for v in value]):\n                    print(('{key} has an illegal value. Allowed values are {values} and are case '\n                           'sensitive.').format(key=key, values=schema[key]['allowed']))\n\n            raise ValueError(validator.errors)", "label": 1}
{"code": "def installed_identities\n      available = request_valid_identities\n      ids = {}\n      available.split(\"\\n\").each do |current|\n        begin\n          sha1 = current.match(/[a-zA-Z0-9]{40}/).to_s\n          name = current.match(/.*\\\"(.*)\\\"/)[1]\n          ids[sha1] = name\n        rescue\n          nil\n        end # the last line does not match\n      end\n\n      ids\n    end", "label": 4}
{"code": "func New(cfg Config) (*Memory, error) {\n\tif err := cfg.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tctx, cancel := context.WithCancel(cfg.Context)\n\tbuf, err := backend.NewCircularBuffer(ctx, cfg.BufferSize)\n\tif err != nil {\n\t\tcancel()\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tm := &Memory{\n\t\tMutex: &sync.Mutex{},\n\t\tEntry: log.WithFields(log.Fields{\n\t\t\ttrace.Component: teleport.ComponentMemory,\n\t\t}),\n\t\tConfig: cfg,\n\t\ttree:   btree.New(cfg.BTreeDegree),\n\t\theap:   newMinHeap(),\n\t\tcancel: cancel,\n\t\tctx:    ctx,\n\t\tbuf:    buf,\n\t}\n\treturn m, nil\n}", "label": 5}
{"code": "public function doLogin()\n  {\n      if ($this->parent->isLoggedIn()) {\n          return true;\n      }\n\n      $this->parent->writer->resetKey();\n      $this->parent->reader->resetKey();\n      $resource = Constants::PLATFORM.'-'.Constants::WHATSAPP_VER;\n      $data = $this->parent->writer->StartStream(Constants::WHATSAPP_SERVER, $resource);\n      $feat = $this->createFeaturesNode();\n      $auth = $this->createAuthNode();\n      $this->parent->sendData($data);\n      $this->parent->sendNode($feat);\n      $this->parent->sendNode($auth);\n\n      $this->parent->pollMessage();\n      $this->parent->pollMessage();\n      $this->parent->pollMessage();\n\n      if ($this->parent->getChallengeData() != null) {\n          $data = $this->createAuthResponseNode();\n          $this->parent->sendNode($data);\n          $this->parent->reader->setKey($this->inputKey);\n          $this->parent->writer->setKey($this->outputKey);\n          while (!$this->parent->pollMessage()) {\n          };\n      }\n\n      if ($this->parent->getLoginStatus() === Constants::DISCONNECTED_STATUS) {\n          throw new LoginFailureException();\n      }\n\n      $this->parent->logFile('info', '{number} successfully logged in', ['number' => $this->phoneNumber]);\n      $this->parent->sendAvailableForChat();\n      $this->parent->sendGetPrivacyBlockedList();\n      $this->parent->sendGetClientConfig();\n      $this->parent->setMessageId(substr(bin2hex(mcrypt_create_iv(64, MCRYPT_DEV_URANDOM)), 0, 22)); // 11 char hex\n\n      if (extension_loaded('curve25519') || extension_loaded('protobuf')) {\n          if (file_exists($this->parent->dataFolder.'axolotl-'.$this->phoneNumber.'.db')) {\n              $pre_keys = $this->parent->getAxolotlStore()->loadPreKeys();\n              if (empty($pre_keys)) {\n                  $this->parent->sendSetPreKeys();\n                  $this->parent->logFile('info', 'Sending prekeys to WA server');\n              }\n          }\n      }\n\n      return true;\n  }", "label": 2}
{"code": "public function clean() {\n\t\tif ( ! $this->enabled ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$ttl      = $this->ttl;\n\t\t$max_size = $this->max_size;\n\n\t\t// unlink expired files\n\t\tif ( $ttl > 0 ) {\n\t\t\ttry {\n\t\t\t\t$expire = new \\DateTime();\n\t\t\t} catch ( \\Exception $e ) {\n\t\t\t\t\\WP_CLI::error( $e->getMessage() );\n\t\t\t}\n\t\t\t$expire->modify( '-' . $ttl . ' seconds' );\n\n\t\t\t$finder = $this->get_finder()->date( 'until ' . $expire->format( 'Y-m-d H:i:s' ) );\n\t\t\tforeach ( $finder as $file ) {\n\t\t\t\tunlink( $file->getRealPath() );\n\t\t\t}\n\t\t}\n\n\t\t// unlink older files if max cache size is exceeded\n\t\tif ( $max_size > 0 ) {\n\t\t\t$files = array_reverse( iterator_to_array( $this->get_finder()->sortByAccessedTime()->getIterator() ) );\n\t\t\t$total = 0;\n\n\t\t\tforeach ( $files as $file ) {\n\t\t\t\tif ( ( $total + $file->getSize() ) <= $max_size ) {\n\t\t\t\t\t$total += $file->getSize();\n\t\t\t\t} else {\n\t\t\t\t\tunlink( $file->getRealPath() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}", "label": 2}
{"code": "def app_activate(caption):\n    \"\"\"\n    use shell to bring the application with caption to front\n    \"\"\"\n    try:\n        shell = win32com.client.Dispatch(\"WScript.Shell\")\n        shell.AppActivate(caption)\n    except Exception as ex:\n        print('error calling win32com.client.Dispatch (AppActivate)')", "label": 1}
{"code": "def calculate_pages(client, method, request_options)\n      # Makes the first API call so that we can call last_response\n      check_github_response do\n        client.send(method, user_project, DEFAULT_REQUEST_OPTIONS.merge(request_options))\n      end\n\n      last_response = client.last_response\n\n      if (last_pg = last_response.rels[:last])\n        querystring_as_hash(last_pg.href)[\"page\"].to_i\n      else\n        1\n      end\n    end", "label": 4}
{"code": "func (cli *NetworkCli) CmdNetworkInfo(chain string, args ...string) error {\n\tcmd := cli.Subcmd(chain, \"info\", \"NETWORK\", \"Displays detailed information on a network\", false)\n\tcmd.Require(flag.Exact, 1)\n\terr := cmd.ParseFlags(args, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tid, err := lookupNetworkID(cli, cmd.Arg(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tobj, _, err := readBody(cli.call(\"GET\", \"/networks/\"+id, nil, nil))\n\tif err != nil {\n\t\treturn err\n\t}\n\tnetworkResource := &networkResource{}\n\tif err := json.NewDecoder(bytes.NewReader(obj)).Decode(networkResource); err != nil {\n\t\treturn err\n\t}\n\tfmt.Fprintf(cli.out, \"Network Id: %s\\n\", networkResource.ID)\n\tfmt.Fprintf(cli.out, \"Name: %s\\n\", networkResource.Name)\n\tfmt.Fprintf(cli.out, \"Type: %s\\n\", networkResource.Type)\n\tif networkResource.Services != nil {\n\t\tfor _, serviceResource := range networkResource.Services {\n\t\t\tfmt.Fprintf(cli.out, \"  Service Id: %s\\n\", serviceResource.ID)\n\t\t\tfmt.Fprintf(cli.out, \"\\tName: %s\\n\", serviceResource.Name)\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def find_loader(module_name)\n    if module_name.nil? || EMPTY_STRING == module_name\n      # Use the public environment loader\n      public_environment_loader\n    else\n      # TODO : Later check if definition is private, and then add it to private_loader_for_module\n      #\n      loader = public_loader_for_module(module_name)\n      if loader.nil?\n        raise Puppet::ParseError, _(\"Internal Error: did not find public loader for module: '%{module_name}'\") % { module_name: module_name }\n      end\n      loader\n    end\n  end", "label": 4}
{"code": "public static csvserver_cmppolicy_binding[] get(nitro_service service, String name) throws Exception{\n\t\tcsvserver_cmppolicy_binding obj = new csvserver_cmppolicy_binding();\n\t\tobj.set_name(name);\n\t\tcsvserver_cmppolicy_binding response[] = (csvserver_cmppolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def where_exp(input, variable, expression)\n      return input unless input.respond_to?(:select)\n\n      input = input.values if input.is_a?(Hash) # FIXME\n\n      condition = parse_condition(expression)\n      @context.stack do\n        input.select do |object|\n          @context[variable] = object\n          condition.evaluate(@context)\n        end\n      end || []\n    end", "label": 4}
{"code": "private void processQueue()\r\n    {\r\n        CacheEntry sv;\r\n        while((sv = (CacheEntry) queue.poll()) != null)\r\n        {\r\n            sessionCache.remove(sv.oid);\r\n        }\r\n    }", "label": 0}
{"code": "function(model, attrs, validatedAttrs) {\n      var error,\n          invalidAttrs = {},\n          isValid = true,\n          computed = _.clone(attrs);\n\n      _.each(validatedAttrs, function(val, attr) {\n        error = validateAttrWithOpenArray(model, attr, val, computed);\n        if (error) {\n          invalidAttrs[attr] = error;\n          isValid = false;\n        }\n      });\n\n      return {\n        invalidAttrs: invalidAttrs,\n        isValid: isValid\n      };\n    }", "label": 3}
{"code": "def links_to_data(self, col_name_col_num, col_val_col_num, id_a_col_num, id_b_col_num):\n        \"\"\"\n        This is the reverse of data_to_links and takes a links table and \n        generates a data table as follows\n        Input Table                         Output Table\n        Cat_Name,CAT_val,Person_a,person_b  NAME,Location  \n        Location,Perth,John,Fred            John,Perth\n        Location,Perth,John,Cindy           Cindy,Perth\n        Location,Perth,Fred,Cindy           Fred,Perth\n        \"\"\"\n        print('Converting links to data')\n        self.op_data\n        unique_ids = []\n        unique_vals = []\n        self.op_data.append(['Name', self.ip_data[1][col_name_col_num]])\n        \n        for r in self.ip_data[1:]:\n            if r[id_a_col_num] not in unique_ids:\n                unique_ids.append(r[id_a_col_num])\n                self.op_data.append([r[id_a_col_num], r[col_val_col_num]])\n            if r[id_b_col_num] not in unique_ids:\n                unique_ids.append(r[id_b_col_num])\n            if r[col_val_col_num] not in unique_vals:\n                unique_vals.append(r[col_val_col_num])\n                \n        \n        #for id in unique_ids:\n        #    self.op_data.append([id, ''])\n        \n            \n        print('unique_ids = ', unique_ids)\n        print('unique_vals= ', unique_vals)\n        print('op_data   = ', self.op_data)\n        \n        \n        return self.op_data", "label": 1}
{"code": "func (m *Mux) Serve() error {\n\tdefer m.waitCancel()\n\tbackoffTimer := time.NewTicker(5 * time.Second)\n\tdefer backoffTimer.Stop()\n\tfor {\n\t\tconn, err := m.Listener.Accept()\n\t\tif err == nil {\n\t\t\tif tcpConn, ok := conn.(*net.TCPConn); ok {\n\t\t\t\ttcpConn.SetKeepAlive(true)\n\t\t\t\ttcpConn.SetKeepAlivePeriod(3 * time.Minute)\n\t\t\t}\n\t\t\tgo m.detectAndForward(conn)\n\t\t\tcontinue\n\t\t}\n\t\tif m.isClosed() {\n\t\t\treturn nil\n\t\t}\n\t\tselect {\n\t\tcase <-backoffTimer.C:\n\t\t\tm.Debugf(\"backoff on accept error: %v\", trace.DebugReport(err))\n\t\tcase <-m.context.Done():\n\t\t\treturn nil\n\t\t}\n\t}\n}", "label": 5}
{"code": "function createRelease(endpoint, version) {\n  return new Promise(function(resolve, reject) {\n    superagent\n      .post(endpoint)\n      .set(HEADERS)\n      .send({ version: version })\n      .end(function(err, res) {\n        if (!err) {\n          console.log('Sentry - Pushed release. Version: ' + version);\n          resolve(res);\n        } else {\n          reject(err);\n        }\n      });\n  });\n}", "label": 3}
{"code": "public static void recursiveAddZip(File parent, ZipOutputStream zout, File fileSource)\n      throws IOException {\n\n    File[] files = fileSource.listFiles();\n\n    for (int i = 0; i < files.length; i++) {\n      if (files[i].isDirectory()) {\n        recursiveAddZip(parent, zout, files[i]);\n        continue;\n      }\n\n      byte[] buffer = new byte[1024];\n\n      FileInputStream fin = new FileInputStream(files[i]);\n\n      ZipEntry zipEntry =\n          new ZipEntry(files[i].getAbsolutePath()\n              .replace(parent.getAbsolutePath(), \"\").substring(1)); //$NON-NLS-1$\n      zout.putNextEntry(zipEntry);\n\n      int length;\n      while ((length = fin.read(buffer)) > 0) {\n        zout.write(buffer, 0, length);\n      }\n\n      zout.closeEntry();\n\n      fin.close();\n\n    }\n\n  }", "label": 0}
{"code": "def insert_one(document, opts = {})\n      client.send(:with_session, opts) do |session|\n        write_with_retry(session, write_concern) do |server, txn_num|\n          Operation::Insert.new(\n              :documents => [ document ],\n              :db_name => database.name,\n              :coll_name => name,\n              :write_concern => write_concern,\n              :bypass_document_validation => !!opts[:bypass_document_validation],\n              :options => opts,\n              :id_generator => client.options[:id_generator],\n              :session => session,\n              :txn_num => txn_num\n           ).execute(server)\n        end\n      end\n    end", "label": 4}
{"code": "func (c *Client) Do(ctx context.Context, req *http.Request, resBody interface{}) error {\n\tswitch req.Method {\n\tcase http.MethodPost, http.MethodPatch:\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n\t}\n\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tif s, ok := ctx.Value(signerContext{}).(Signer); ok {\n\t\tif err := s.SignRequest(req); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn c.Client.Do(ctx, req, func(res *http.Response) error {\n\t\tswitch res.StatusCode {\n\t\tcase http.StatusOK:\n\t\tcase http.StatusBadRequest:\n\t\t\t// TODO: structured error types\n\t\t\tdetail, err := ioutil.ReadAll(res.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%s: %s\", res.Status, bytes.TrimSpace(detail))\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"%s %s: %s\", req.Method, req.URL, res.Status)\n\t\t}\n\n\t\tif resBody == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch b := resBody.(type) {\n\t\tcase io.Writer:\n\t\t\t_, err := io.Copy(b, res.Body)\n\t\t\treturn err\n\t\tdefault:\n\t\t\tval := struct {\n\t\t\t\tValue interface{} `json:\"value,omitempty\"`\n\t\t\t}{\n\t\t\t\tresBody,\n\t\t\t}\n\t\t\treturn json.NewDecoder(res.Body).Decode(&val)\n\t\t}\n\t})\n}", "label": 5}
{"code": "func (v *ViewPort) ScrollLeft(cols int) {\n\tv.viewx -= cols\n\tv.ValidateViewX()\n}", "label": 5}
{"code": "public function rename($name, array $options = [])\n    {\n        $destinationBucket = isset($options['destinationBucket'])\n            ? $options['destinationBucket']\n            : $this->identity['bucket'];\n        unset($options['destinationBucket']);\n\n        $copiedObject = $this->copy($destinationBucket, [\n            'name' => $name\n        ] + $options);\n\n        $this->delete(\n            array_intersect_key($options, [\n                'restOptions' => null,\n                'retries' => null\n            ])\n        );\n        $this->info = [];\n\n        return $copiedObject;\n    }", "label": 2}
{"code": "function parse (input, opts) {\n  // Wrap parser.parse to allow specifying the start rule\n  // as a shorthand option\n  if (!opts) {\n    opts = {}\n  }\n  else if (typeof opts == 'string') {\n    opts = { startRule: opts }\n  }\n  return parser.parse(input, opts)\n}", "label": 3}
{"code": "function notDefined(keyToTest, keySupplied, instance) {\n  return new RegExp(\"^\" + keyToTest + \"$\").test(keySupplied.toString()) && !instance.hasOwnProperty(keyToTest);\n}", "label": 3}
{"code": "public static String chomp(String s) {\r\n    if(s.length() == 0)\r\n      return s;\r\n    int l_1 = s.length() - 1;\r\n    if (s.charAt(l_1) == '\\n') {\r\n      return s.substring(0, l_1);\r\n    }\r\n    return s;\r\n  }", "label": 0}
{"code": "public Enumeration getPKEnumerationByQuery(Class primaryKeyClass, Query query) throws PersistenceBrokerException\n    {\n        if (logger.isDebugEnabled()) logger.debug(\"getPKEnumerationByQuery \" + query);\n\n        query.setFetchSize(1);\n        ClassDescriptor cld = getClassDescriptor(query.getSearchClass());\n        return new PkEnumeration(query, cld, primaryKeyClass, this);\n    }", "label": 0}
{"code": "def lowercase(text_string):\n    '''\n    Converts text_string into lowercase and returns the converted string as type str.\n\n    Keyword argument:\n\n    - text_string: string instance\n\n    Exceptions raised:\n\n    - InputError: occurs should a non-string argument be passed\n    '''\n    if text_string is None or text_string == \"\":\n        return \"\"\n    elif isinstance(text_string, str):\n        return text_string.lower()\n    else:\n        raise InputError(\"string not passed as argument for text_string\")", "label": 1}
{"code": "func PgInheritsByInhparent(db XODB, inhparent pgtypes.Oid) ([]*PgInherit, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, ctid, inhrelid, inhparent, inhseqno ` +\n\t\t`FROM pg_catalog.pg_inherits ` +\n\t\t`WHERE inhparent = $1`\n\n\t// run query\n\tXOLog(sqlstr, inhparent)\n\tq, err := db.Query(sqlstr, inhparent)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer q.Close()\n\n\t// load results\n\tres := []*PgInherit{}\n\tfor q.Next() {\n\t\tpi := PgInherit{}\n\n\t\t// scan\n\t\terr = q.Scan(&pi.Tableoid, &pi.Cmax, &pi.Xmax, &pi.Cmin, &pi.Xmin, &pi.Ctid, &pi.Inhrelid, &pi.Inhparent, &pi.Inhseqno)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres = append(res, &pi)\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "def with_temp_dir(dir=nil)\n      dir ||= Dir.mktmpdir(TEMP_PREFIX, @temp_root)\n      dir = Pathname.new(dir)\n\n      yield dir\n    ensure\n      FileUtils.rm_rf(dir.to_s)\n    end", "label": 4}
{"code": "private void reorder()\r\n    {\r\n        if(getTransaction().isOrdering() && needsCommit && mhtObjectEnvelopes.size() > 1)\r\n        {\r\n            ObjectEnvelopeOrdering ordering = new ObjectEnvelopeOrdering(mvOrderOfIds, mhtObjectEnvelopes);\r\n            ordering.reorder();\r\n            Identity[] newOrder = ordering.getOrdering();\r\n\r\n            mvOrderOfIds.clear();\r\n            for(int i = 0; i < newOrder.length; i++)\r\n            {\r\n                mvOrderOfIds.add(newOrder[i]);\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "function isAbstractConstructorType(type) {\n            if (type.flags & 2097152 /* Anonymous */) {\n                var symbol = type.symbol;\n                if (symbol && symbol.flags & 32 /* Class */) {\n                    var declaration = getClassLikeDeclarationOfSymbol(symbol);\n                    if (declaration && declaration.flags & 128 /* Abstract */) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "label": 3}
{"code": "public function whitelist_url( $url, $key = null, $ttl = null ) {\n\t\t$key                     = $key ? : $url;\n\t\t$this->whitelist[ $url ] = compact( 'key', 'ttl' );\n\t}", "label": 2}
{"code": "public static base_response add(nitro_service client, linkset resource) throws Exception {\n\t\tlinkset addresource = new linkset();\n\t\taddresource.id = resource.id;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "private static int checkResult(int result)\n    {\n        if (exceptionsEnabled && result !=\n            cudnnStatus.CUDNN_STATUS_SUCCESS)\n        {\n            throw new CudaException(cudnnStatus.stringFor(result));\n        }\n        return result;\n    }", "label": 0}
{"code": "public function setSensitiveAttribute($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\FieldId::class);\n        $this->sensitive_attribute = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func contains(fl FieldLevel) bool {\n\treturn strings.Contains(fl.Field().String(), fl.Param())\n}", "label": 5}
{"code": "func (e *InvalidValidationError) Error() string {\n\n\tif e.Type == nil {\n\t\treturn \"validator: (nil)\"\n\t}\n\n\treturn \"validator: (nil \" + e.Type.String() + \")\"\n}", "label": 5}
{"code": "def virtualbox_host():\n    '''Install a VirtualBox host system.\n\n    More Infos:\n     * overview:     https://wiki.ubuntuusers.de/VirtualBox/\n     * installation: https://wiki.ubuntuusers.de/VirtualBox/Installation/\n    '''\n    if query_yes_no(question='Uninstall virtualbox-dkms?', default='yes'):\n        run('sudo apt-get remove virtualbox-dkms')\n    install_packages([\n        'virtualbox',\n        'virtualbox-qt',\n        'virtualbox-dkms',\n        'virtualbox-guest-dkms',\n        'virtualbox-guest-additions-iso',\n    ])\n    users = [env.user]\n    for username in users:\n        run(flo('sudo  adduser {username} vboxusers'))", "label": 1}
{"code": "public static String getDefaultConversionFor(String javaType)\r\n    {\r\n        return _jdbcConversions.containsKey(javaType) ? (String)_jdbcConversions.get(javaType) : null;\r\n    }", "label": 0}
{"code": "def write_puml(self, filename=''):\n        \"\"\"\n            Writes PUML from the system. If filename is given, stores result in the file.\n            Otherwise returns result as a string.\n        \"\"\"\n        def get_type(o):\n            type = 'program'\n            if isinstance(o, AbstractSensor):\n                type = 'sensor'\n            elif isinstance(o, AbstractActuator):\n                type = 'actuator'\n            return type\n\n        if filename:\n            s = open(filename, 'w')\n        else:\n            s = io.StringIO()\n        s.write('@startuml\\n')\n        s.write('skinparam state {\\n')\n        for k, v in list(self.background_colors.items()):\n            s.write('BackGroundColor<<%s>> %s\\n' % (k, v))\n        s.write('}\\n')\n\n        for o in self.system.objects:\n            if isinstance(o, DefaultProgram) or o.hide_in_uml:\n                continue\n\n            if isinstance(o, ProgrammableSystemObject):\n                s.write('state \"%s\" as %s <<%s>>\\n' % (o, o, get_type(o)))\n\n                s.write('%s: %s\\n' % (o, o.class_name))\n                if isinstance(o, AbstractActuator):\n                    for p in reversed(o.program_stack):\n                        s.write('%s: %s :: %s\\n' % (o, p, o.program_status.get(p, '-')))\n                elif hasattr(o, 'status'):\n                    s.write('%s: Status: %s\\n' % (o, o.status))\n                if getattr(o, 'is_program', False):\n                    s.write('%s: Priority: %s\\n' % (o, o.priority))\n\n                for t in o.actual_triggers:\n                    if isinstance(t, DefaultProgram) or t.hide_in_uml:\n                        continue\n                    s.write('%s -[%s]-> %s\\n' % (t, self.arrow_colors['trigger'], o))\n                for t in o.actual_targets:\n                    if t.hide_in_uml:\n                        continue\n                    if o.active:\n                        color = 'active_target'\n                    else:\n                        color = 'inactive_target'\n                    if getattr(t, 'program', None) == o:\n                        color = 'controlled_target'\n\n                    s.write('%s -[%s]-> %s\\n' % (o, self.arrow_colors[color], t))\n        s.write('@enduml\\n')\n        if filename:\n            s.close()\n        else:\n            return s.getvalue()", "label": 1}
{"code": "public static nsdiameter get(nitro_service service) throws Exception{\n\t\tnsdiameter obj = new nsdiameter();\n\t\tnsdiameter[] response = (nsdiameter[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "function createConnection(port, host, options) {\n  if (isObject(port)) {\n    options = port;\n  }\n  else if (isObject(host)) {\n    options = host;\n  }\n  else if (isObject(options)) {\n    options = options;\n  }\n  else {\n    options = {};\n  }\n\n  if (isNumber(port)) {\n    options.port = port;\n  }\n\n  if (isString(host)) {\n    options.host = host;\n  }\n\n  debug('createConnection', options);\n  return tls.connect(options);\n}", "label": 3}
{"code": "function resolveId(details, filepath) {\n  let id = '';\n\n  if ('string' == typeof filepath) {\n    // Only version if more than one package\n    const version = details.id.includes(versionDelimiter) ? versionDelimiter + details.version : '';\n    const versioned = (id, stripExtension) => {\n      // Strip extension\n      if (stripExtension) id = id.replace(path.extname(id), '');\n      return (process.platform == 'win32' ? id.replace(/\\\\/g, '/') : id) + version;\n    };\n\n    // Resolve aliases\n    id = alias.resolve(filepath, details.aliases);\n    // Ignore disabled (false)\n    id = id || filepath;\n    // Return if resolved id\n    if (!isFilepath(id)) return versioned(id, false);\n    // Resolve alias to id (also handles main => id)\n    id = alias.resolveReverse(id, details.aliases);\n    // Return if resolved id\n    if (!isFilepath(id)) return versioned(id, false);\n\n    // Resolve ids from project root if nested project package\n    const pkgpath = details.isNestedProjectPackage\n      ? process.cwd()\n      : // Resolve ids from node_modules root if npm package\n        details.isNpmPackage ? details.dirname : details.pkgpath;\n\n    [...details.paths, pkgpath].some(sourcepath => {\n      if (filepath.includes(sourcepath)) {\n        id = path.relative(sourcepath, filepath);\n        return true;\n      }\n    });\n\n    return versioned(id, true);\n  }\n\n  return id;\n}", "label": 3}
{"code": "func (f FileManager) DeleteDatastoreFile(ctx context.Context, name string, dc *Datacenter) (*Task, error) {\n\treq := types.DeleteDatastoreFile_Task{\n\t\tThis: f.Reference(),\n\t\tName: name,\n\t}\n\n\tif dc != nil {\n\t\tref := dc.Reference()\n\t\treq.Datacenter = &ref\n\t}\n\n\tres, err := methods.DeleteDatastoreFile_Task(ctx, f.c, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewTask(f.c, res.Returnval), nil\n}", "label": 5}
{"code": "public static appfwjsoncontenttype[] get(nitro_service service, options option) throws Exception{\n\t\tappfwjsoncontenttype obj = new appfwjsoncontenttype();\n\t\tappfwjsoncontenttype[] response = (appfwjsoncontenttype[])obj.get_resources(service,option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function saveToFile(filename, cfg) {\n  // Use 'wx' flag to fails if filename exists\n  fs.writeFileSync(filename, JSON.stringify(cfg, null, 2), {flag: 'wx'})\n}", "label": 3}
{"code": "def render(view)\n      view.tag(name, prepare_attributes(attributes), MetaTags.config.open_meta_tags?)\n    end", "label": 4}
{"code": "private Entry getEntry(Object key)\r\n    {\r\n        if (key == null) return null;\r\n        int hash = hashCode(key);\r\n        int index = indexFor(hash);\r\n        for (Entry entry = table[index]; entry != null; entry = entry.next)\r\n        {\r\n            if ((entry.hash == hash) && equals(key, entry.getKey()))\r\n            {\r\n                return entry;\r\n            }\r\n        }\r\n        return null;\r\n    }", "label": 0}
{"code": "public static base_responses add(nitro_service client, cmpaction resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tcmpaction addresources[] = new cmpaction[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new cmpaction();\n\t\t\t\taddresources[i].name = resources[i].name;\n\t\t\t\taddresources[i].cmptype = resources[i].cmptype;\n\t\t\t\taddresources[i].deltatype = resources[i].deltatype;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def default_arguments(cls):\n        \"\"\"Returns the available kwargs of the called class\"\"\"\n        func = cls.__init__\n        args = func.__code__.co_varnames\n        defaults = func.__defaults__\n        index = -len(defaults)\n        return {k: v for k, v in zip(args[index:], defaults)}", "label": 1}
{"code": "def to_s\n     data = [@name.concat(Array.new(32-@name.size, 0)), \n             @name_size, \n             @type, \n             @color, \n             @left, \n             @right, \n             @child, \n             @created,\n             @modified, \n             @sector, \n             @size].flatten\n      data.pack(PACKING)\n    end", "label": 4}
{"code": "public void cross(Vector3d v1, Vector3d v2) {\n        double tmpx = v1.y * v2.z - v1.z * v2.y;\n        double tmpy = v1.z * v2.x - v1.x * v2.z;\n        double tmpz = v1.x * v2.y - v1.y * v2.x;\n\n        x = tmpx;\n        y = tmpy;\n        z = tmpz;\n    }", "label": 0}
{"code": "func (h *hawkularSink) updateDefinitions(mds []*metrics.MetricDefinition) error {\n\tfor _, p := range mds {\n\t\tif model, f := h.models[p.Tags[descriptorTag]]; f && !h.recent(p, model) {\n\t\t\tif err := h.client.UpdateTags(p.Type, p.ID, p.Tags, h.modifiers...); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\th.cache(p)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def bids_to_pwl(self, bids):\n        \"\"\" Updates the piece-wise linear total cost function using the given\n        bid blocks.\n\n        Based on off2case.m from MATPOWER by Ray Zimmerman, developed at PSERC\n        Cornell. See U{http://www.pserc.cornell.edu/matpower/} for more info.\n        \"\"\"\n        assert self.is_load\n        # Apply only those bids associated with this dispatchable load.\n        vl_bids = [bid for bid in bids if bid.vLoad == self]\n        # Filter out zero quantity bids.\n        gt_zero = [bid for bid in vl_bids if round(bid.quantity, 4) > 0.0]\n        # Ignore withheld offers.\n        valid_bids = [bid for bid in gt_zero if not bid.withheld]\n\n        p_bids = [v for v in valid_bids if not v.reactive]\n        q_bids = [v for v in valid_bids if v.reactive]\n\n        if p_bids:\n            self.p_cost = self._offbids_to_points(p_bids, True)\n            self.pcost_model = PW_LINEAR\n            self.online = True\n        else:\n            self.p_cost = [(0.0, 0.0), (self.p_max, 0.0)]\n            self.pcost_model = PW_LINEAR\n            logger.info(\"No valid active power bids for dispatchable load \"\n                        \"[%s], shutting down.\" % self.name)\n            self.online = False\n\n        if q_bids:\n            self.q_cost = self._offbids_to_points(q_bids, True)\n            self.qcost_model = PW_LINEAR\n            self.online = True\n        else:\n            self.q_cost = [(self.q_min, 0.0), (0.0, 0.0), (self.q_max, 0.0)]\n            self.qcost_model = PW_LINEAR\n#            logger.info(\"No valid bids for dispatchable load, shutting down.\")\n#            self.online = False\n\n        self._adjust_limits()", "label": 1}
{"code": "def boolean_from_response(method, path, options = {})\n      request(method, path, options)\n      @last_response.status == 204\n    rescue Octokit::NotFound\n      false\n    end", "label": 4}
{"code": "public function entries(array $options = [])\n    {\n        $resultLimit = $this->pluck('resultLimit', $options, false);\n        $logNameFilter = \"logName = $this->formattedName\";\n        $options += [\n            'resourceNames' => [\"projects/$this->projectId\"],\n            'filter' => isset($options['filter'])\n                ? $options['filter'] .= \" AND $logNameFilter\"\n                : $logNameFilter\n        ];\n\n        return new ItemIterator(\n            new PageIterator(\n                function (array $entry) {\n                    return new Entry($entry);\n                },\n                [$this->connection, 'listEntries'],\n                $options,\n                [\n                    'itemsKey' => 'entries',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "func (l *DiagnosticLog) Copy(ctx context.Context, w io.Writer) (int, error) {\n\tconst max = 500 // VC max == 500, ESX max == 1000\n\twritten := 0\n\n\tfor {\n\t\th, err := l.m.BrowseLog(ctx, l.Host, l.Key, l.Start, max)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tfor _, line := range h.LineText {\n\t\t\tn, err := fmt.Fprintln(w, line)\n\t\t\twritten += n\n\t\t\tif err != nil {\n\t\t\t\treturn written, err\n\t\t\t}\n\t\t}\n\n\t\tl.Start += int32(len(h.LineText))\n\n\t\tif l.Start >= h.LineEnd {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn written, nil\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, nssimpleacl resource) throws Exception {\n\t\tnssimpleacl addresource = new nssimpleacl();\n\t\taddresource.aclname = resource.aclname;\n\t\taddresource.aclaction = resource.aclaction;\n\t\taddresource.td = resource.td;\n\t\taddresource.srcip = resource.srcip;\n\t\taddresource.destport = resource.destport;\n\t\taddresource.protocol = resource.protocol;\n\t\taddresource.ttl = resource.ttl;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public static float[] toFloat(int[] array) {\n        float[] n = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            n[i] = (float) array[i];\n        }\n        return n;\n    }", "label": 0}
{"code": "func (sl *DiskSessionLogger) Finalize() error {\n\tsl.Lock()\n\tdefer sl.Unlock()\n\n\treturn sl.finalize()\n}", "label": 5}
{"code": "function(cb) {\n            log.log('git remote prune origin ' + repoDir);\n            self.pruneOrigin(repoDir, function(err, stdout, stderr) {\n                if (err) {\n                    log.warn(err.msg + \":\", err.err.msg);\n                }\n                cb(null, {prune: {stdout: stdout, stderr: stderr}});\n            });\n        }", "label": 3}
{"code": "public static FullTypeSignature getTypeSignature(Class<?> clazz, Class<?>[] typeArgs) {\n\t\tClassTypeSignature rawClassTypeSignature = (ClassTypeSignature) javaTypeToTypeSignature\n\t\t\t\t.getTypeSignature(clazz);\n\t\tTypeArgSignature[] typeArgSignatures = new TypeArgSignature[typeArgs.length];\n\t\tfor (int i = 0; i < typeArgs.length; i++) {\n\t\t\ttypeArgSignatures[i] = new TypeArgSignature(\n\t\t\t\t\tTypeArgSignature.NO_WILDCARD,\n\t\t\t\t\t(FieldTypeSignature) javaTypeToTypeSignature\n\t\t\t\t\t\t\t.getTypeSignature(typeArgs[i]));\n\t\t}\n\t\tClassTypeSignature classTypeSignature = new ClassTypeSignature(\n\t\t\t\trawClassTypeSignature.getBinaryName(), typeArgSignatures,\n\t\t\t\trawClassTypeSignature.getOwnerTypeSignature());\n\n\t\treturn classTypeSignature;\n\t}", "label": 0}
{"code": "def publish(events, stream_name: GLOBAL_STREAM, expected_version: :any)\n      enriched_events = enrich_events_metadata(events)\n      serialized_events = serialize_events(enriched_events)\n      append_to_stream_serialized_events(serialized_events, stream_name: stream_name, expected_version: expected_version)\n      enriched_events.zip(serialized_events) do |event, serialized_event|\n        with_metadata(\n          correlation_id: event.metadata[:correlation_id] || event.event_id,\n          causation_id:   event.event_id,\n        ) do\n          broker.(event, serialized_event)\n        end\n      end\n      self\n    end", "label": 4}
{"code": "def addlogo(community_id, logo):\n    \"\"\"Add logo to the community.\"\"\"\n    # Create the bucket\n    c = Community.get(community_id)\n    if not c:\n        click.secho('Community {0} does not exist.'.format(community_id),\n                    fg='red')\n        return\n    ext = save_and_validate_logo(logo, logo.name, c.id)\n    c.logo_ext = ext\n    db.session.commit()", "label": 1}
{"code": "def get(self, signal=None):\n        \"\"\"\n        Returns a single signal or a dictionary of signals for this plugin.\n        \"\"\"\n        return self.__app.signals.get(signal, self._plugin)", "label": 1}
{"code": "public static BufferedImage resizeToHeight(BufferedImage originalImage, int heightOut) {\n\n    int width = originalImage.getWidth();\n\n    int height = originalImage.getHeight();\n\n    int heightPercent = (heightOut * 100) / height;\n\n    int newWidth = (width * heightPercent) / 100;\n\n    BufferedImage resizedImage =\n        new BufferedImage(newWidth, heightOut, BufferedImage.TYPE_INT_ARGB);\n    Graphics2D g = resizedImage.createGraphics();\n    g.drawImage(originalImage, 0, 0, newWidth, heightOut, null);\n    g.dispose();\n\n    return resizedImage;\n  }", "label": 0}
{"code": "public void createContainer(String container) {\n\n        ContainerController controller = this.platformContainers.get(container);\n        if (controller == null) {\n\n            // TODO make this configurable\n            Profile p = new ProfileImpl();\n            p.setParameter(Profile.PLATFORM_ID, PLATFORM_ID);\n            p.setParameter(Profile.MAIN_HOST, MAIN_HOST);\n            p.setParameter(Profile.MAIN_PORT, MAIN_PORT);\n            p.setParameter(Profile.LOCAL_HOST, MAIN_HOST);\n            int port = Integer.parseInt(MAIN_PORT);\n            port = port + 1 + this.platformContainers.size();\n            p.setParameter(Profile.LOCAL_PORT, Integer.toString(port));\n            p.setParameter(Profile.CONTAINER_NAME, container);\n            logger.fine(\"Creating container \" + container + \"...\");\n            ContainerController agentContainer = this.runtime\n                    .createAgentContainer(p);\n            this.platformContainers.put(container, agentContainer);\n            logger.fine(\"Container \" + container + \" created successfully.\");\n        } else {\n            logger.fine(\"Container \" + container + \" is already created.\");\n        }\n\n    }", "label": 0}
{"code": "public ConnectionRepository readConnectionRepository(InputStream inst)\r\n    {\r\n        try\r\n        {\r\n            RepositoryPersistor persistor = new RepositoryPersistor();\r\n            return persistor.readConnectionRepository(inst);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            throw new MetadataException(\"Can not read repository from \" + inst, e);\r\n        }\r\n    }", "label": 0}
{"code": "function(name) {\n      if (name === 'change' || name.indexOf('change:') === 0) {\n        View.prototype.trigger.apply(this.view, arguments);\n      }\n      if (name.indexOf('change:hide:') === 0) {\n        this.view.render();\n      }\n      NestedCell.prototype.trigger.apply(this, arguments);\n    }", "label": 3}
{"code": "def destroyable?\n      if self.environment.try(:library?) && self.content_view.default?\n        if self.environment.organization.being_deleted?\n          return true\n        elsif self.custom? && self.deletable?\n          return true\n        elsif !self.custom? && self.redhat_deletable?\n          return true\n        else\n          errors.add(:base, _(\"Repository cannot be deleted since it has already been included in a published Content View. \" \\\n                              \"Please delete all Content View versions containing this repository before attempting to delete it.\"))\n\n          return false\n        end\n      end\n      return true\n    end", "label": 4}
{"code": "async function askResetPassword(form) {\n  await client.connect();\n\n  try {\n    await api.askResetPassword(\n      {\n        login: form.login.value\n      },\n      \"user\"\n    );\n    displayMessage(\n      \"Reset password\",\n      \"A link was sent to reset your password\",\n      \"is-success\"\n    );\n    goTo(\"login\");\n  } catch (e) {\n    displayMessage(\n      \"Reset password\",\n      `Failed to send the link to reset your password. Cause: ${e.message}`,\n      \"is-danger\"\n    );\n  }\n}", "label": 3}
{"code": "def sorted_options(sort_options):\n    \"\"\"Sort sort options for display.\n\n    :param sort_options: A dictionary containing the field name as key and\n        asc/desc as value.\n    :returns: A dictionary with sorting options for Invenio-Search-JS.\n    \"\"\"\n    return [\n        {\n            'title': v['title'],\n            'value': ('-{0}'.format(k)\n                      if v.get('default_order', 'asc') == 'desc' else k),\n        }\n        for k, v in\n        sorted(sort_options.items(), key=lambda x: x[1].get('order', 0))\n    ]", "label": 1}
{"code": "public function setCodepointRange($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\Range::class);\n        $this->codepoint_range = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def read_extended_object\n      mod = safe_const_get(read)\n      object = read\n      object.extend(mod)\n      object\n    end", "label": 4}
{"code": "function parseBuild(builds, fileExtensions, fileFactory, npmModulepaths, runtimeOptions, serverConfig, parent, level) {\n  if (!parent) {\n    numBuilds = 0;\n    level = 1;\n  }\n\n  // Deprecate sources\n  if ('sources' in builds) {\n    warn(DEPRECATED_SOURCES, 1);\n  }\n  // Deprecate targets\n  if ('targets' in builds) {\n    warn(DEPRECATED_VERSION, 1);\n    builds = builds.targets;\n  }\n\n  // Support basic mode with single build target\n  if (!Array.isArray(builds)) builds = [builds];\n\n  return builds.reduce(\n    (builds, buildConfig) => {\n      const childBuilds = buildConfig.build || buildConfig.children;\n      const options = buildConfig.options;\n      const version = buildConfig.version;\n\n      delete buildConfig.build;\n      delete buildConfig.options;\n      delete buildConfig.version;\n\n      // Deprecate old formats\n      if ('js' in buildConfig || 'css' in buildConfig || 'html' in buildConfig || 'targets' in buildConfig) {\n        warn(DEPRECATED_VERSION);\n        return builds;\n      }\n      // Deprecate aliases\n      if (buildConfig.alias) warn(DEPRECATED_ALIAS, 1);\n      // Deprecate modular\n      if ('modular' in buildConfig) warn(DEPRECATED_MODULAR, 1);\n      // Deprecate sources\n      if (buildConfig.sources) warn(DEPRECATED_SOURCES, 1);\n\n      if (buildConfig.bootstrap == null) buildConfig.bootstrap = true;\n      if (buildConfig.label == null) buildConfig.label = '';\n      if (buildConfig.bundle == null || buildConfig.modular) buildConfig.bundle = true;\n      buildConfig.batch = false;\n      buildConfig.boilerplate = true;\n      buildConfig.index = ++numBuilds;\n      buildConfig.level = level;\n      buildConfig.parent = parent;\n      buildConfig.runtimeOptions = runtimeOptions;\n      buildConfig.watchOnly = !buildConfig.output;\n\n      parseInputOutput(buildConfig, fileExtensions, runtimeOptions);\n      // Ignore build targets with nulled input (no grep match)\n      if (!('input' in buildConfig && buildConfig.input != null)) return builds;\n\n      const build = buildFactory(buildConfig);\n      const caches = parent\n        ? { fileCache: parent.fileCache, resolverCache: parent.resolverCache }\n        : cache.createCaches(runtimeOptions.watch);\n\n      build.browser = parent ? parent.browser : buildPlugins.isBrowserEnvironment(version);\n      build.fileCache = caches.fileCache;\n      build.resolverCache = caches.resolverCache;\n      build.fileFactoryOptions = getFileFactoryOptions(build, parent, version, options, {\n        fileExtensions,\n        fileFactory,\n        npmModulepaths,\n        runtimeOptions,\n        sourceroot: serverConfig.sourceroot,\n        webroot: serverConfig.webroot\n      });\n      build.fileFactory = build.fileFactoryOptions.fileFactory;\n      // Flag as app server target\n      build.isAppServer = isAppServer(build.inputpaths, serverConfig);\n\n      // Traverse child build targets\n      if (childBuilds) {\n        build.builds = parseBuild(\n          childBuilds,\n          fileExtensions,\n          fileFactory,\n          npmModulepaths,\n          runtimeOptions,\n          serverConfig,\n          build,\n          level + 1\n        );\n        parseChildInputpaths(build);\n      }\n\n      builds.push(build);\n\n      return builds;\n    },\n    []\n  );\n}", "label": 3}
{"code": "public function failedRows()\n    {\n        $rows = [];\n\n        if ($this->isSuccessful()) {\n            return $rows;\n        }\n\n        foreach ($this->info['insertErrors'] as $error) {\n            $rows[] = $error + [\n                'rowData' => $this->rows[$error['index']]['json']\n            ];\n        }\n\n        return $rows;\n    }", "label": 2}
{"code": "public function setIamPolicy($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Iam\\V1\\Policy::class);\n        $this->iam_policy = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function isTypeOfKind(type, kind) {\n            if (type.flags & kind) {\n                return true;\n            }\n            if (type.flags & 524288 /* Union */) {\n                var types = type.types;\n                for (var _i = 0, types_14 = types; _i < types_14.length; _i++) {\n                    var t = types_14[_i];\n                    if (!isTypeOfKind(t, kind)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            if (type.flags & 1048576 /* Intersection */) {\n                var types = type.types;\n                for (var _a = 0, types_15 = types; _a < types_15.length; _a++) {\n                    var t = types_15[_a];\n                    if (isTypeOfKind(t, kind)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "label": 3}
{"code": "def run_radia_perchrom(job, bams, univ_options, radia_options, chrom):\n    \"\"\"\n    Run RADIA call on a single chromosome in the input bams.\n\n    :param dict bams: Dict of bam and bai for tumor DNA-Seq, normal DNA-Seq and tumor RNA-Seq\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict radia_options: Options specific to RADIA\n    :param str chrom: Chromosome to process\n    :return: fsID for the chromsome vcf\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    work_dir = os.getcwd()\n    input_files = {\n        'rna.bam': bams['tumor_rna'],\n        'rna.bam.bai': bams['tumor_rnai'],\n        'tumor.bam': bams['tumor_dna'],\n        'tumor.bam.bai': bams['tumor_dnai'],\n        'normal.bam': bams['normal_dna'],\n        'normal.bam.bai': bams['normal_dnai'],\n        'genome.fa.tar.gz': radia_options['genome_fasta'],\n        'genome.fa.fai.tar.gz': radia_options['genome_fai']}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n\n    for key in ('genome.fa', 'genome.fa.fai'):\n        input_files[key] = untargz(input_files[key + '.tar.gz'], work_dir)\n    input_files = {key: docker_path(path) for key, path in input_files.items()}\n\n    radia_output = ''.join([work_dir, '/radia_', chrom, '.vcf'])\n    radia_log = ''.join([work_dir, '/radia_', chrom, '_radia.log'])\n    parameters = [univ_options['patient'],  # shortID\n                  chrom,\n                  '-n', input_files['normal.bam'],\n                  '-t', input_files['tumor.bam'],\n                  '-r', input_files['rna.bam'],\n                  ''.join(['--rnaTumorFasta=', input_files['genome.fa']]),\n                  '-f', input_files['genome.fa'],\n                  '-o', docker_path(radia_output),\n                  '-i', univ_options['ref'],\n                  '-m', input_files['genome.fa'],\n                  '-d', 'aarjunrao@soe.ucsc.edu',\n                  '-q', 'Illumina',\n                  '--disease', 'CANCER',\n                  '-l', 'INFO',\n                  '-g', docker_path(radia_log)]\n    docker_call(tool='radia', tool_parameters=parameters,\n                work_dir=work_dir, dockerhub=univ_options['dockerhub'],\n                tool_version=radia_options['version'])\n    output_file = job.fileStore.writeGlobalFile(radia_output)\n    job.fileStore.logToMaster('Ran radia on %s:%s successfully' % (univ_options['patient'], chrom))\n    return output_file", "label": 1}
{"code": "def upload_individual_item(app, version, language, key, value)\n      details = app.details\n      version.send(key)[language] = value if LOCALISED_VERSION_VALUES.include?(key)\n      details.send(key)[language] = value if LOCALISED_APP_VALUES.include?(key)\n      Helper.show_loading_indicator(\"Uploading #{language} #{key} to App Store Connect\")\n      version.save!\n      Helper.hide_loading_indicator\n      begin\n        details.save!\n        UI.success(\"Successfully uploaded #{language} #{key} to App Store Connect\")\n      rescue Spaceship::TunesClient::ITunesConnectError => e\n        UI.error(\"Error in #{language} #{key}: \\n#{value}\")\n        UI.error(e.message) # Don't use user_error to allow all values to get checked\n      end\n    end", "label": 4}
{"code": "def find_valid_json_in(text, opts = {})\n      break_on_first = opts.key?(:break_on_first) ? opts[:break_on_first] : true\n\n      json_result = break_on_first ? nil : []\n\n      text.scan(%r{\\{(?:[^{}]|(?:\\g<0>))*\\}}x) do |str|\n        begin\n          if break_on_first\n            json_result = JSON.parse(str)\n            break\n          else\n            json_result.push(JSON.parse(str))\n          end\n        rescue JSON::ParserError\n          next\n        end\n      end\n\n      json_result\n    end", "label": 4}
{"code": "def cpu_source_extraction(in1, tolerance, neg_comp):\n    \"\"\"\n    The following function determines connectivity within a given wavelet decomposition. These connected and labelled\n    structures are thresholded to within some tolerance of the maximum coefficient at the scale. This determines\n    whether on not an object is to be considered as significant. Significant objects are extracted and factored into\n    a mask which is finally multiplied by the wavelet coefficients to return only wavelet coefficients belonging to\n    significant objects across all scales.\n\n    INPUTS:\n    in1         (no default):   Array containing the wavelet decomposition.\n    tolerance   (no default):   Percentage of maximum coefficient at which objects are deemed significant.\n\n    OUTPUTS:\n    objects*in1                 The wavelet coefficients of the significant structures.\n    objects                     The mask of the significant structures.\n    \"\"\"\n\n    # The following initialises some variables for storing the labelled image and the number of labels. The per scale\n    # maxima are also initialised here.\n\n    scale_maxima = np.empty([in1.shape[0],1])\n\n    objects = np.empty_like(in1, dtype=np.int32)\n    object_count = np.empty([in1.shape[0],1], dtype=np.int32)\n\n    # The following loop uses functionality from the ndimage module to assess connectivity. The maxima are also\n    # calculated here.\n\n    for i in range(in1.shape[0]):\n        if neg_comp:\n            scale_maxima[i] = np.max(abs(in1[i,:,:]))\n        else:\n            scale_maxima[i] = np.max(in1[i,:,:])\n        objects[i,:,:], object_count[i] = ndimage.label(in1[i,:,:], structure=[[1,1,1],[1,1,1],[1,1,1]])\n\n    # The following removes the insignificant objects and then extracts the remaining ones.\n\n    for i in range(-1,-in1.shape[0]-1,-1):\n        if neg_comp:\n            if i==(-1):\n                tmp = (abs(in1[i,:,:])>=(tolerance*scale_maxima[i]))*objects[i,:,:]\n            else:\n                tmp = (abs(in1[i,:,:])>=(tolerance*scale_maxima[i]))*objects[i,:,:]*objects[i+1,:,:]\n        else:\n            if i==(-1):\n                tmp = (in1[i,:,:]>=(tolerance*scale_maxima[i]))*objects[i,:,:]\n            else:\n                tmp = (in1[i,:,:]>=(tolerance*scale_maxima[i]))*objects[i,:,:]*objects[i+1,:,:]\n\n        labels = np.unique(tmp[tmp>0])\n\n        for j in labels:\n            objects[i,(objects[i,:,:]==j)] = -1\n\n        objects[i,(objects[i,:,:]>0)] = 0\n        objects[i,:,:] = -(objects[i,:,:])\n\n    return objects*in1, objects", "label": 1}
{"code": "function (block) {\n        es.readArray([\n          '<!--',\n          '  processed by htmlbuild',\n          '-->'\n        ].map(function (str) {\n          return block.indent + str;\n        })).pipe(block);\n      }", "label": 3}
{"code": "def _check_column_lengths(self):\n        \"\"\"\n        Make sure columns are of the same length or else DataFrame construction\n        will fail.\n        \"\"\"\n        column_lengths_dict = {\n            name: len(xs)\n            for (name, xs)\n            in self.columns_dict.items()\n        }\n        unique_column_lengths = set(column_lengths_dict.values())\n        if len(unique_column_lengths) != 1:\n            raise ValueError(\n                \"Mismatch between lengths of columns: %s\" % (column_lengths_dict,))", "label": 1}
{"code": "func (a *ACL) Free() error {\n\tacl_free, err := getSymbolPointer(a.lib.handle, \"acl_free\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tret, err := C.my_acl_free(acl_free, a.a)\n\tif ret < 0 {\n\t\treturn errwrap.Wrap(errors.New(\"error calling acl_free\"), err)\n\t}\n\n\treturn a.lib.close()\n}", "label": 5}
{"code": "public function runJob(JobConfigurationInterface $config, array $options = [])\n    {\n        $maxRetries = $this->pluck('maxRetries', $options, false);\n        $job = $this->startJob($config, $options);\n        $job->waitUntilComplete(['maxRetries' => $maxRetries]);\n\n        return $job;\n    }", "label": 2}
{"code": "def filter_paired(list):\n\t\"\"\"\n\trequire that both pairs are mapped in the sam file in order to remove the reads\n\t\"\"\"\n\tpairs = {}\n\tfiltered = []\n\tfor id in list:\n\t\tread = id.rsplit('/')[0]\n\t\tif read not in pairs:\n\t\t\tpairs[read] = []\n\t\tpairs[read].append(id)\n\tfor read in pairs:\n\t\tids = pairs[read]\n\t\tif len(ids) == 2:\n\t\t\tfiltered.extend(ids)\n\treturn set(filtered)", "label": 1}
{"code": "public void setLongAttribute(String name, Long value) {\n\t\tensureValue();\n\t\tAttribute attribute = new LongAttribute(value);\n\t\tattribute.setEditable(isEditable(name));\n\t\tgetValue().getAllAttributes().put(name, attribute);\n\t}", "label": 0}
{"code": "public function mutation($operation, $table, $mutation)\n    {\n        return [\n            $operation => [\n                'table' => $table,\n                'columns' => array_keys($mutation),\n                'values' => $this->mapper->encodeValuesAsSimpleType(array_values($mutation))\n            ]\n        ];\n    }", "label": 2}
{"code": "public static function mergePrefixData($data, $prefixData)\n    {\n        $prefixGroups = $prefixData['prefix-groups'];\n\n        foreach ($data[\"partitions\"] as $index => $partition) {\n            foreach ($prefixGroups as $current => $old) {\n                $serviceData = Env::search(\"services.{$current}\", $partition);\n                if (!empty($serviceData)) {\n                    foreach ($old as $prefix) {\n                        if (empty(Env::search(\"services.{$prefix}\", $partition))) {\n                            $data[\"partitions\"][$index][\"services\"][$prefix] = $serviceData;\n                        }\n                    }\n                }\n            }\n        }\n\n        return $data;\n    }", "label": 2}
{"code": "private function fileExistsForClassLike(ClassLikes $classlikes, $fq_class_name)\n    {\n        $fq_class_name_lc = strtolower($fq_class_name);\n\n        if (isset($this->classlike_files[$fq_class_name_lc])) {\n            return true;\n        }\n\n        if ($fq_class_name === 'self') {\n            return false;\n        }\n\n        if (isset($this->existing_classlikes_lc[$fq_class_name_lc])) {\n            throw new \\InvalidArgumentException('Why are you asking about a builtin class?');\n        }\n\n        $composer_file_path = $this->config->getComposerFilePathForClassLike($fq_class_name);\n\n        if ($composer_file_path && file_exists($composer_file_path)) {\n            if ($this->debug_output) {\n                echo 'Using composer to locate file for ' . $fq_class_name . \"\\n\";\n            }\n\n            $classlikes->addFullyQualifiedClassLikeName(\n                $fq_class_name_lc,\n                realpath($composer_file_path)\n            );\n\n            return true;\n        }\n\n        $old_level = error_reporting();\n\n        if (!$this->debug_output) {\n            error_reporting(E_ERROR);\n        }\n\n        try {\n            if ($this->debug_output) {\n                echo 'Using reflection to locate file for ' . $fq_class_name . \"\\n\";\n            }\n\n            /** @psalm-suppress TypeCoercion */\n            $reflected_class = new \\ReflectionClass($fq_class_name);\n        } catch (\\Throwable $e) {\n            error_reporting($old_level);\n\n            // do not cache any results here (as case-sensitive filenames can screw things up)\n\n            return false;\n        }\n\n        error_reporting($old_level);\n\n        /** @psalm-suppress MixedMethodCall due to Reflection class weirdness */\n        $file_path = (string)$reflected_class->getFileName();\n\n        // if the file was autoloaded but exists in evaled code only, return false\n        if (!file_exists($file_path)) {\n            return false;\n        }\n\n        $new_fq_class_name = $reflected_class->getName();\n\n        if (strtolower($new_fq_class_name) !== strtolower($fq_class_name)) {\n            $classlikes->addClassAlias($new_fq_class_name, strtolower($fq_class_name));\n            $fq_class_name_lc = strtolower($new_fq_class_name);\n        }\n\n        $fq_class_name = $new_fq_class_name;\n        $classlikes->addFullyQualifiedClassLikeName($fq_class_name_lc);\n\n        if ($reflected_class->isInterface()) {\n            $classlikes->addFullyQualifiedInterfaceName($fq_class_name, $file_path);\n        } elseif ($reflected_class->isTrait()) {\n            $classlikes->addFullyQualifiedTraitName($fq_class_name, $file_path);\n        } else {\n            $classlikes->addFullyQualifiedClassName($fq_class_name, $file_path);\n        }\n\n        return true;\n    }", "label": 2}
{"code": "func (v *ViewPort) Fill(ch rune, style tcell.Style) {\n\tif v.v != nil {\n\t\tfor y := 0; y < v.height; y++ {\n\t\t\tfor x := 0; x < v.width; x++ {\n\t\t\t\tv.v.SetContent(x+v.physx, y+v.physy, ch, nil, style)\n\t\t\t}\n\t\t}\n\t}\n}", "label": 5}
{"code": "def clip_at filename, position\n      position = Position.normalize(position)\n      SourceMap::Clip.new(self, cursor_at(filename, position))\n    end", "label": 4}
{"code": "def validate_complex_list(prop, value, xpath_map=None):\n    \"\"\" Default validation for Attribute Details data structure \"\"\"\n\n    if value is not None:\n        validate_type(prop, value, (dict, list))\n\n        if prop in _complex_definitions:\n            complex_keys = _complex_definitions[prop]\n        else:\n            complex_keys = {} if xpath_map is None else xpath_map\n\n        for idx, complex_struct in enumerate(wrap_value(value)):\n            cs_idx = prop + '[' + str(idx) + ']'\n            validate_type(cs_idx, complex_struct, dict)\n\n            for cs_prop, cs_val in iteritems(complex_struct):\n                cs_key = '.'.join((cs_idx, cs_prop))\n\n                if cs_prop not in complex_keys:\n                    _validation_error(prop, None, value, ('keys: {0}'.format(','.join(complex_keys))))\n\n                if not isinstance(cs_val, list):\n                    validate_type(cs_key, cs_val, (string_types, list))\n                else:\n                    for list_idx, list_val in enumerate(cs_val):\n                        list_prop = cs_key + '[' + str(list_idx) + ']'\n                        validate_type(list_prop, list_val, string_types)", "label": 1}
{"code": "func (n *network) getMatchingSubnet(ip *net.IPNet) *subnet {\n\tif ip == nil {\n\t\treturn nil\n\t}\n\tfor _, s := range n.subnets {\n\t\t// first check if the mask lengths are the same\n\t\ti, _ := s.subnetIP.Mask.Size()\n\t\tj, _ := ip.Mask.Size()\n\t\tif i != j {\n\t\t\tcontinue\n\t\t}\n\t\tif s.subnetIP.IP.Equal(ip.IP) {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def attribute_values\n      result = element_call { execute_js(:attributeValues, @element) }\n      result.keys.each do |key|\n        next unless key == key[/[a-zA-Z\\-]*/]\n\n        result[key.tr('-', '_').to_sym] = result.delete(key)\n      end\n      result\n    end", "label": 4}
{"code": "def specific_oauth_error(resp, error_code, context)\n      description = resp.data[:error_description] || error_code\n\n      Util.log_error(\"Stripe OAuth error\",\n                     status: resp.http_status,\n                     error_code: error_code,\n                     error_description: description,\n                     idempotency_key: context.idempotency_key,\n                     request_id: context.request_id)\n\n      args = [error_code, description, {\n        http_status: resp.http_status, http_body: resp.http_body,\n        json_body: resp.data, http_headers: resp.http_headers,\n      },]\n\n      case error_code\n      when \"invalid_client\"            then OAuth::InvalidClientError.new(*args)\n      when \"invalid_grant\"             then OAuth::InvalidGrantError.new(*args)\n      when \"invalid_request\"           then OAuth::InvalidRequestError.new(*args)\n      when \"invalid_scope\"             then OAuth::InvalidScopeError.new(*args)\n      when \"unsupported_grant_type\"    then OAuth::UnsupportedGrantTypeError.new(*args)\n      when \"unsupported_response_type\" then OAuth::UnsupportedResponseTypeError.new(*args)\n      else\n        # We'd prefer that all errors are typed, but we create a generic\n        # OAuthError in case we run into a code that we don't recognize.\n        OAuth::OAuthError.new(*args)\n      end\n    end", "label": 4}
{"code": "public function setVersion($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Logging\\V2\\LogMetric_ApiVersion::class);\n        $this->version = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "async function run() {\n  // Read the records\n  const records = await BB.all(process.argv.slice(2).map(f => readAsync(f)))\n  // Write them to Kinesis\n  return BB.map(records, record => kinesis.putRecord({\n    Data: JSON.stringify(yaml.safeLoad(record)),\n    PartitionKey: '0',\n    StreamName: process.env.LAMBDA_KINESIS_STREAM_NAME\n  }).promise())\n}", "label": 3}
{"code": "protected function maxNestedFieldsResolved(int $nested): bool\n    {\n        if ($this->maxNestedFields === 0) {\n            return false;\n        }\n\n        return $nested >= $this->maxNestedFields;\n    }", "label": 2}
{"code": "public function sendSetPrivacyBlockedList($blockedJids = [])\n    {\n        if (!is_array($blockedJids)) {\n            $blockedJids = [$blockedJids];\n        }\n\n        $items = [];\n        foreach ($blockedJids as $index => $jid) {\n            $item = new ProtocolNode('item',\n                [\n                    'type'   => 'jid',\n                    'value'  => $this->getJID($jid),\n                    'action' => 'deny',\n                    'order'  => $index + 1, //WhatsApp stream crashes on zero index\n                ], null, null);\n            $items[] = $item;\n        }\n\n        $child = new ProtocolNode('list',\n            [\n                'name' => 'default',\n            ], $items, null);\n\n        $child2 = new ProtocolNode('query', null, [$child], null);\n        $node = new ProtocolNode('iq',\n            [\n                'id'    => $this->createIqId(),\n                'xmlns' => 'jabber:iq:privacy',\n                'type'  => 'set',\n            ], [$child2], null);\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "def get_universe(self, as_str=False):\n        \"\"\"Returns universe the client is connected to. See ``Universe``.\n\n        :param bool as_str: Return human-friendly universe name instead of an ID.\n        :rtype: int|str\n        \"\"\"\n        result = self._iface.get_connected_universe()\n\n        if as_str:\n            return Universe.get_alias(result)\n\n        return result", "label": 1}
{"code": "def read_with_one_retry(options = nil)\n      yield\n    rescue Error::SocketError, Error::SocketTimeoutError => e\n      retry_message = options && options[:retry_message]\n      log_retry(e, message: retry_message)\n      yield\n    end", "label": 4}
{"code": "func (t *TestTLSServer) CertPool() (*x509.CertPool, error) {\n\ttlsConfig, err := t.Identity.TLSConfig(t.AuthServer.CipherSuites)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn tlsConfig.RootCAs, nil\n}", "label": 5}
{"code": "public static function writeLog($priority, $tag, $msg) // [int priority, String tag, String msg]\n    {\n        $logger = AxolotlLoggerProvider::getProvider();\n        if (($logger != null)) {\n            $logger->log($priority, $tag, $msg);\n        }\n    }", "label": 2}
{"code": "func NewBeeConfig(name, class, description string, options BeeOptions) (BeeConfig, error) {\n\tif len(name) == 0 {\n\t\treturn BeeConfig{}, errors.New(\"A Bee's name can't be empty\")\n\t}\n\n\tb := GetBee(name)\n\tif b != nil {\n\t\treturn BeeConfig{}, errors.New(\"A Bee with that name already exists\")\n\t}\n\n\tf := GetFactory(class)\n\tif f == nil {\n\t\treturn BeeConfig{}, errors.New(\"Invalid class specified\")\n\t}\n\n\treturn BeeConfig{\n\t\tName:        name,\n\t\tClass:       class,\n\t\tDescription: description,\n\t\tOptions:     options,\n\t}, nil\n}", "label": 5}
{"code": "function flattenHead(obj) {\n    var newHead = [];\n\n    _arrayCopy(newHead, obj[\"head-start\"]);\n    _arrayCopy(newHead, obj[\"head\"]);\n    _arrayCopy(newHead, obj[\"head-end\"]);\n\n    delete obj[\"head-start\"];\n    delete obj[\"head-end\"];\n    obj.head = newHead;\n\n    return obj;\n}", "label": 3}
{"code": "def to_s\n      msg = super\n      @file = nil if (@file.is_a?(String) && @file.empty?)\n      msg += Puppet::Util::Errors.error_location_with_space(@file, @line, @pos)\n      msg\n    end", "label": 4}
{"code": "function handleReSort(link) {\n    var classes = link.attr('class').split(/\\s+/);\n    for (var i=0; i<classes.length; i++) {\n      if (classes[i] != 'sort-option') {\n\tby = classes[i].substring(2);\n      }\n    }\n    setComparator();\n    // Save/update the sortBy cookie.\n    var expiration = new Date();\n    expiration.setDate(expiration.getDate() + 365);\n    document.cookie= 'sortBy=' + escape(by) +\n                     ';expires=' + expiration.toUTCString();\n    $('ul.comment-ul').each(function(index, ul) {\n      var comments = getChildren($(ul), true);\n      comments = sortComments(comments);\n      appendComments(comments, $(ul).empty());\n    });\n  }", "label": 3}
{"code": "public void setOutRGB(IntRange outRGB) {\r\n        this.outRed = outRGB;\r\n        this.outGreen = outRGB;\r\n        this.outBlue = outRGB;\r\n\r\n        CalculateMap(inRed, outRGB, mapRed);\r\n        CalculateMap(inGreen, outRGB, mapGreen);\r\n        CalculateMap(inBlue, outRGB, mapBlue);\r\n    }", "label": 0}
{"code": "func Raw(args ...string) ([]byte, error) {\n\tif firewalldRunning {\n\t\tstartTime := time.Now()\n\t\toutput, err := Passthrough(Iptables, args...)\n\t\tif err == nil || !strings.Contains(err.Error(), \"was not provided by any .service files\") {\n\t\t\treturn filterOutput(startTime, output, args...), err\n\t\t}\n\t}\n\treturn raw(args...)\n}", "label": 5}
{"code": "public function setDiskConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dataproc\\V1beta2\\DiskConfig::class);\n        $this->disk_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func (n *networkNamespace) programRoute(path string, dest *net.IPNet, nh net.IP) error {\n\tgwRoutes, err := n.nlHandle.RouteGet(nh)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"route for the next hop %s could not be found: %v\", nh, err)\n\t}\n\n\treturn n.nlHandle.RouteAdd(&netlink.Route{\n\t\tScope:     netlink.SCOPE_UNIVERSE,\n\t\tLinkIndex: gwRoutes[0].LinkIndex,\n\t\tGw:        nh,\n\t\tDst:       dest,\n\t})\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, gslbservice resource) throws Exception {\n\t\tgslbservice addresource = new gslbservice();\n\t\taddresource.servicename = resource.servicename;\n\t\taddresource.cnameentry = resource.cnameentry;\n\t\taddresource.ip = resource.ip;\n\t\taddresource.servername = resource.servername;\n\t\taddresource.servicetype = resource.servicetype;\n\t\taddresource.port = resource.port;\n\t\taddresource.publicip = resource.publicip;\n\t\taddresource.publicport = resource.publicport;\n\t\taddresource.maxclient = resource.maxclient;\n\t\taddresource.healthmonitor = resource.healthmonitor;\n\t\taddresource.sitename = resource.sitename;\n\t\taddresource.state = resource.state;\n\t\taddresource.cip = resource.cip;\n\t\taddresource.cipheader = resource.cipheader;\n\t\taddresource.sitepersistence = resource.sitepersistence;\n\t\taddresource.cookietimeout = resource.cookietimeout;\n\t\taddresource.siteprefix = resource.siteprefix;\n\t\taddresource.clttimeout = resource.clttimeout;\n\t\taddresource.svrtimeout = resource.svrtimeout;\n\t\taddresource.maxbandwidth = resource.maxbandwidth;\n\t\taddresource.downstateflush = resource.downstateflush;\n\t\taddresource.maxaaausers = resource.maxaaausers;\n\t\taddresource.monthreshold = resource.monthreshold;\n\t\taddresource.hashid = resource.hashid;\n\t\taddresource.comment = resource.comment;\n\t\taddresource.appflowlog = resource.appflowlog;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "async def dump_blob(elem, elem_type=None):\n    \"\"\"\n    Dumps blob message.\n    Supports both blob and raw value.\n\n    :param writer:\n    :param elem:\n    :param elem_type:\n    :param params:\n    :return:\n    \"\"\"\n    elem_is_blob = isinstance(elem, x.BlobType)\n    data = getattr(elem, x.BlobType.DATA_ATTR) if elem_is_blob else elem\n    if data is None or len(data) == 0:\n        return b''\n    if isinstance(data, (bytes, bytearray, list)):\n        return base64.b16encode(bytes(data))\n    else:\n        raise ValueError('Unknown blob type')", "label": 1}
{"code": "def get_state(self, caller):\n        \"\"\"\n            Get per-program state.\n        \"\"\"\n\n        if caller in self.state:\n            return self.state[caller]\n        else:\n            rv = self.state[caller] = DictObject()\n            return rv", "label": 1}
{"code": "function isValid(attribute) {\n  try {\n    this.validate(attribute);\n  } catch (e) {\n    if (e instanceof errors.ValidationError) {\n      return false;\n    } else {\n      throw e;\n    }\n  }\n  return true;\n}", "label": 3}
{"code": "private function createReleaseNotes(array $release)\n    {\n        $buildDir = $this->rootPath .'/build';\n        $locationTemplate = $buildDir . '/release-%s.md';\n\n        if (!is_dir($buildDir)) {\n            mkdir($buildDir);\n        }\n\n        $umbrella = $release[self::DEFAULT_COMPONENT];\n        $location = sprintf($locationTemplate, $umbrella['version']);\n\n        unset($release[self::DEFAULT_COMPONENT]);\n\n        ksort($release);\n\n        $notes = [];\n        foreach ($release as $key => $component) {\n            $messages = [];\n            foreach ($component['messages'] as $message) {\n                $messages[] = sprintf('* %s', $message);\n            }\n\n            $notes[] = sprintf('### google/%s v%s', $key, $component['version'])\n                . PHP_EOL . PHP_EOL . implode(PHP_EOL, $messages);\n        }\n\n        $template = file_get_contents(__DIR__ .'/templates/release-notes.md.txt');\n        $template = str_replace('{version}', $umbrella['version'], $template);\n        $template = str_replace('{notes}', implode(PHP_EOL . PHP_EOL, $notes), $template);\n\n        file_put_contents($location, $template);\n\n        return $location;\n    }", "label": 2}
{"code": "function(i, delaySort)\n  {\n    var removing;\n\n    if (i >= 0 && i < this.length)\n    {\n      removing = this[ i ];\n\n      this.map.removeAt( i );\n      this.trigger( Collection.Events.Remove, [this, removing, i] );\n\n      if ( !delaySort )\n      {\n        this.sort();\n      }\n    }\n\n    return removing;\n  }", "label": 3}
{"code": "public static locationfile get(nitro_service service) throws Exception{\n\t\tlocationfile obj = new locationfile();\n\t\tlocationfile[] response = (locationfile[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def set_value(*args, **kwargs):\n    \"\"\"Set value in the global Config object.\"\"\"\n    global _config\n    if _config is None:\n        raise ValueError('configuration not set; must run figgypy.set_config first')\n    return _config.set_value(*args, **kwargs)", "label": 1}
{"code": "public static authenticationtacacspolicy_authenticationvserver_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauthenticationtacacspolicy_authenticationvserver_binding obj = new authenticationtacacspolicy_authenticationvserver_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationtacacspolicy_authenticationvserver_binding response[] = (authenticationtacacspolicy_authenticationvserver_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public String getKeyValue(String key){\n        String keyName = keysMap.get(key);\n        if (keyName != null){\n            return keyName;\n        }\n        return \"\"; //key wasn't defined in keys properties file\n    }", "label": 0}
{"code": "public static systemuser_binding get(nitro_service service, String username) throws Exception{\n\t\tsystemuser_binding obj = new systemuser_binding();\n\t\tobj.set_username(username);\n\t\tsystemuser_binding response = (systemuser_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func New(bk backend.Backend) (Service, error) {\n\ts := &server{\n\t\tbk:    bk,\n\t\tclock: clockwork.NewRealClock(),\n\t}\n\tif s.activeSessionTTL == 0 {\n\t\ts.activeSessionTTL = defaults.ActiveSessionTTL\n\t}\n\treturn s, nil\n}", "label": 5}
{"code": "func (a *CellView) SetView(view View) {\n\tport := a.port\n\tport.SetView(view)\n\ta.view = view\n\tif view == nil {\n\t\treturn\n\t}\n\twidth, height := view.Size()\n\ta.port.Resize(0, 0, width, height)\n\tif a.model != nil {\n\t\tw, h := a.model.GetBounds()\n\t\ta.port.SetContentSize(w, h, true)\n\t}\n\ta.Resize()\n}", "label": 5}
{"code": "public function setSnapshots($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\PubSub\\V1\\Snapshot::class);\n        $this->snapshots = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function CountingClock() {\n  var self = this, at, mark = null;\n\n  self.at = function() {\n    return at;\n  };\n\n  self.init = function() {\n    at = mark = 0;\n    return at;\n  };\n\n  self.inc = function() {\n    at += 1;\n  };\n\n  self.tick = function() {\n    if (mark === null) {\n      mark = at + 1;\n    }\n\n    return ((at - mark) >= 1);\n  };\n\n  self.tock = function(elapsed) {\n    var d = at - elapsed;\n    if ( d >= 1) {\n      mark += 1;\n      return true;\n    }\n    return false;\n  };\n}", "label": 3}
{"code": "def setup_markers(seqs):\n    \"\"\"\n    setup unique marker for every orf annotation\n    - change size if necessary\n    \"\"\"\n    family2marker = {} # family2marker[family] = [marker, size]\n    markers = cycle(['^', 'p', '*', '+', 'x', 'd', '|', 'v', '>', '<', '8'])\n    size = 60\n    families = []\n    for seq in list(seqs.values()):\n        for insertion in seq[2]:\n            for family in list(insertion[-1].values()):\n                if family not in families:\n                    families.append(family)\n    for family in families:\n        marker = next(markers) \n        if marker == '^':\n            size = size * 0.5\n        family2marker[family] = [marker, size]\n    return family2marker", "label": 1}
{"code": "func (ph Placeholders) Bind(name string, dst interface{}) error {\n\tv := ph.Value(name)\n\tif v == nil {\n\t\treturn errors.New(\"Placeholder with name \" + name + \" not found\")\n\t}\n\n\treturn ConvertValue(v, dst)\n}", "label": 5}
{"code": "def format_from_extension(fname):\n    \"\"\" Tries to infer a protocol from the file extension.\"\"\"\n    _base, ext = os.path.splitext(fname)\n    if not ext:\n        return None\n    try:\n        format = known_extensions[ext.replace('.', '')]\n    except KeyError:\n        format = None\n    return format", "label": 1}
{"code": "def paths\n      relative_paths = gem_names.flat_map do |plugin|\n        Dir.glob(\"vendor/gems/ruby/*/gems/#{plugin}*/lib/**/**/**/**.rb\")\n      end\n\n      relative_paths.map { |path| File.join(dir, path) }\n    end", "label": 4}
{"code": "def process_files\n      if @options[:parallel].empty?\n        files.map { |path| check_path(path) }\n      else\n        Parallel.map(files, @options[:parallel]) { |path| check_path(path) }\n      end\n    end", "label": 4}
{"code": "def for_lane(lane_name)\n      if lane_name.to_s.split(\" \").count > 1\n        # That's the legacy syntax 'platform name'\n        puts(\"You use deprecated syntax '#{lane_name}' in your Appfile.\".yellow)\n        puts(\"Please follow the Appfile guide: https://docs.fastlane.tools/advanced/#appfile\".yellow)\n        platform, lane_name = lane_name.split(\" \")\n\n        return unless platform == ENV[\"FASTLANE_PLATFORM_NAME\"]\n        # the lane name will be verified below\n      end\n\n      if ENV[\"FASTLANE_LANE_NAME\"] == lane_name.to_s\n        yield\n      end\n    end", "label": 4}
{"code": "public static appfwlearningdata[] get(nitro_service service, appfwlearningdata_args args) throws Exception{\n\t\tappfwlearningdata obj = new appfwlearningdata();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tappfwlearningdata[] response = (appfwlearningdata[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def execute(builder = nil, wait = false)\n      raise TypeError, 'builder needs to be nil or like a Discordrb::Webhooks::Builder!' unless\n        builder.respond_to?(:file) && builder.respond_to?(:to_multipart_hash) || builder.respond_to?(:to_json_hash) || builder.nil?\n\n      builder ||= Builder.new\n\n      yield builder if block_given?\n\n      if builder.file\n        post_multipart(builder, wait)\n      else\n        post_json(builder, wait)\n      end\n    end", "label": 4}
{"code": "public static String getPostString(InputStream is, String encoding) {\n        try {\n            StringWriter sw = new StringWriter();\n            IOUtils.copy(is, sw, encoding);\n\n            return sw.toString();\n        } catch (IOException e) {\n            // no op\n            return null;\n        } finally {\n            IOUtils.closeQuietly(is);\n        }\n    }", "label": 0}
{"code": "function mergeChildren(children) {\n            var nameToItems = ts.createMap();\n            ts.filterMutate(children, function (child) {\n                var decl = child.node;\n                var name = decl.name && nodeText(decl.name);\n                if (!name) {\n                    // Anonymous items are never merged.\n                    return true;\n                }\n                var itemsWithSameName = nameToItems[name];\n                if (!itemsWithSameName) {\n                    nameToItems[name] = child;\n                    return true;\n                }\n                if (itemsWithSameName instanceof Array) {\n                    for (var _i = 0, itemsWithSameName_1 = itemsWithSameName; _i < itemsWithSameName_1.length; _i++) {\n                        var itemWithSameName = itemsWithSameName_1[_i];\n                        if (tryMerge(itemWithSameName, child)) {\n                            return false;\n                        }\n                    }\n                    itemsWithSameName.push(child);\n                    return true;\n                }\n                else {\n                    var itemWithSameName = itemsWithSameName;\n                    if (tryMerge(itemWithSameName, child)) {\n                        return false;\n                    }\n                    nameToItems[name] = [itemWithSameName, child];\n                    return true;\n                }\n                function tryMerge(a, b) {\n                    if (shouldReallyMerge(a.node, b.node)) {\n                        merge(a, b);\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            /** a and b have the same name, but they may not be mergeable. */\n            function shouldReallyMerge(a, b) {\n                return a.kind === b.kind && (a.kind !== 225 /* ModuleDeclaration */ || areSameModule(a, b));\n                // We use 1 NavNode to represent 'A.B.C', but there are multiple source nodes.\n                // Only merge module nodes that have the same chain. Don't merge 'A.B.C' with 'A'!\n                function areSameModule(a, b) {\n                    if (a.body.kind !== b.body.kind) {\n                        return false;\n                    }\n                    if (a.body.kind !== 225 /* ModuleDeclaration */) {\n                        return true;\n                    }\n                    return areSameModule(a.body, b.body);\n                }\n            }\n            /** Merge source into target. Source should be thrown away after this is called. */\n            function merge(target, source) {\n                target.additionalNodes = target.additionalNodes || [];\n                target.additionalNodes.push(source.node);\n                if (source.additionalNodes) {\n                    (_a = target.additionalNodes).push.apply(_a, source.additionalNodes);\n                }\n                target.children = ts.concatenate(target.children, source.children);\n                if (target.children) {\n                    mergeChildren(target.children);\n                    sortChildren(target.children);\n                }\n                var _a;\n            }\n        }", "label": 3}
{"code": "def create(options = {})\n      headers = extract_headers!(options)\n      json = client.post(\"/v1/auth/token/create\", JSON.fast_generate(options), headers)\n      return Secret.decode(json)\n    end", "label": 4}
{"code": "def color=(v)\n        @color = v if v.is_a? Color\n        self.color.rgb = v if v.is_a? String\n        @color\n      end", "label": 4}
{"code": "def arc(start_x, start_y, end_x, end_y, start_degrees, end_degrees)\n      primitive 'arc ' + format('%g,%g %g,%g %g,%g',\n                                start_x, start_y, end_x, end_y, start_degrees, end_degrees)\n    end", "label": 4}
{"code": "func NewClusterConfig(spec ClusterConfigSpecV3) (ClusterConfig, error) {\n\tcc := ClusterConfigV3{\n\t\tKind:    KindClusterConfig,\n\t\tVersion: V3,\n\t\tMetadata: Metadata{\n\t\t\tName:      MetaNameClusterConfig,\n\t\t\tNamespace: defaults.Namespace,\n\t\t},\n\t\tSpec: spec,\n\t}\n\tif err := cc.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn &cc, nil\n}", "label": 5}
{"code": "function (root_path, default_prefix) {\n\t\tvar arr = SR.Settings.SR_PATH.split(SR.path.sep);\n\t\tvar prefix = arr[arr.length-1] + '-';\n\t\tvar dirs = UTIL.getDirectoriesSync(root_path);\n\n\t\tif (default_prefix)\n\t\t\tprefix = default_prefix;\n\t\t\n\t\t//LOG.warn('default_prefix: ' + default_prefix + ' prefix: ' + prefix + ' paths to check:');\n\t\tfor (var i in dirs) {\n\t\t\t//LOG.warn(dirs[i]);\n\t\t\tif (dirs[i].startsWith(prefix)) { \n\t\t\t\tSR.Settings.MOD_PATHS.push(SR.path.resolve(root_path, dirs[i]));\n\t\t\t}\n\t\t}\n\t}", "label": 3}
{"code": "func (k *Keygen) GetNewKeyPairFromPool() ([]byte, []byte, error) {\n\tselect {\n\tcase key := <-k.keysCh:\n\t\treturn key.privPem, key.pubBytes, nil\n\tdefault:\n\t\treturn GenerateKeyPair(\"\")\n\t}\n}", "label": 5}
{"code": "def getHomoloGene(taxfile=\"build_inputs/taxid_taxname\",\\\n                  genefile=\"homologene.data\",\\\n                  proteinsfile=\"build_inputs/all_proteins.data\",\\\n                  proteinsclusterfile=\"build_inputs/proteins_for_clustering.data\",\\\n                  baseURL=\"http://ftp.ncbi.nih.gov/pub/HomoloGene/current/\"):\n    \"\"\"\n    Returns NBCI's Homolog Gene tables.\n\n    :param taxfile: path to local file or to baseURL/taxfile\n    :param genefile: path to local file or to baseURL/genefile\n    :param proteinsfile: path to local file or to baseURL/proteinsfile\n    :param proteinsclusterfile: path to local file or to baseURL/proteinsclusterfile\n    :param baseURL: baseURL for downloading files\n\n    :returns genedf: Homolog gene Pandas dataframe\n    :returns protclusdf: Pandas dataframe. Lists one protein per gene that were used for homologene clustering.\n                        If a gene has multiple protein accessions derived from alternative splicing,\n                        only one protein isoform that give most protein alignment to proteins in other species\n                        was selected for clustering and it is listed in this file.\n    :returns proteinsdf: Pandas dataframe. Lists all proteins and their gene information.\n                        If a gene has multple protein accessions derived from alternative splicing event,\n                        each protein accession is list in a separate line.\n    \"\"\"\n\n    def getDf(inputfile):\n        if os.path.isfile(inputfile):\n            df=pd.read_table(inputfile,header=None)\n        else:\n            df = urllib2.urlopen(baseURL+inputfile)\n            df=df.read().split(\"\\n\")\n            df=[ s for s in df if len(s) > 0 ]\n            df=[s.split(\"\\t\") for s in df]\n            df=pd.DataFrame(df)\n        return df\n\n    taxdf=getDf(taxfile)\n    taxdf.set_index([0],inplace=True)\n    taxdi=taxdf.to_dict().get(1)\n\n    genedf=getDf(genefile)\n    genecols=[\"HID\",\"Taxonomy ID\",\"Gene ID\",\"Gene Symbol\",\"Protein gi\",\"Protein accession\"]\n    genedf.columns=genecols\n    genedf[\"organism\"]=genedf[\"Taxonomy ID\"].apply(lambda x:taxdi.get(x))\n\n    proteinsdf=getDf(proteinsfile)\n    proteinscols=[\"taxid\",\"entrez GeneID\",\"gene symbol\",\"gene description\",\"protein accession.ver\",\"mrna accession.ver\",\\\n                 \"length of protein  listed in column 5\",\"-11) contains data about gene location on the genome\",\\\n                  \"starting position of gene in 0-based coordinate\",\\\n                  \"end position of the gene in 0-based coordinate\",\"strand\",\"nucleotide gi of genomic sequence where this gene is annotated\"]\n    proteinsdf.columns=proteinscols\n    proteinsdf[\"organism\"]=proteinsdf[\"taxid\"].apply(lambda x:taxdi.get(x))\n\n    protclusdf=getDf(proteinsclusterfile)\n    protclustercols=[\"taxid\",\"entrez GeneID\",\"gene symbol\",\"gene description\",\"protein accession.ver\",\"mrna accession.ver\",\\\n                 \"length of protein  listed in column 5\",\"-11) contains data about gene location on the genome\",\\\n                  \"starting position of gene in 0-based coordinate\",\\\n                  \"end position of the gene in 0-based coordinate\",\"strand\",\"nucleotide gi of genomic sequence where this gene is annotated\"]\n    protclusdf.columns=proteinscols\n    protclusdf[\"organism\"]=protclusdf[\"taxid\"].apply(lambda x:taxdi.get(x))\n\n    return genedf, protclusdf, proteinsdf", "label": 1}
{"code": "public static List<File> extract(File zipFile, File outputFolder) throws IOException {\n    List<File> extracted = new ArrayList<File>();\n\n    byte[] buffer = new byte[2048];\n\n    if (!outputFolder.exists()) {\n      outputFolder.mkdir();\n    }\n\n    ZipInputStream zipInput = new ZipInputStream(new FileInputStream(zipFile));\n\n    ZipEntry zipEntry = zipInput.getNextEntry();\n\n    while (zipEntry != null) {\n\n      String neFileNameName = zipEntry.getName();\n      File newFile = new File(outputFolder + File.separator + neFileNameName);\n\n      newFile.getParentFile().mkdirs();\n\n      if (!zipEntry.isDirectory()) {\n        FileOutputStream fos = new FileOutputStream(newFile);\n\n        int size;\n        while ((size = zipInput.read(buffer)) > 0) {\n          fos.write(buffer, 0, size);\n        }\n\n        fos.close();\n        extracted.add(newFile);\n      }\n\n      zipEntry = zipInput.getNextEntry();\n    }\n\n    zipInput.closeEntry();\n    zipInput.close();\n\n    return extracted;\n\n  }", "label": 0}
{"code": "def _clean_params(self, params):\n        \"\"\"Removes parameters whose values are set to None.\n        \"\"\"\n        clean_params = {}\n        for key, value in params.iteritems():\n            if value is not None:\n                clean_params[key] = value\n\n        return clean_params", "label": 1}
{"code": "func (m *Manager) metaDiscoverPubKeyLocations(prefix string) ([]string, error) {\n\tapp, err := discovery.NewAppFromString(prefix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thostHeaders := config.ResolveAuthPerHost(m.AuthPerHost)\n\tinsecure := discovery.InsecureNone\n\tif m.InsecureAllowHTTP {\n\t\tinsecure = insecure | discovery.InsecureHTTP\n\t}\n\tif m.InsecureSkipTLSCheck {\n\t\tinsecure = insecure | discovery.InsecureTLS\n\t}\n\n\tkeys, attempts, err := discovery.DiscoverPublicKeys(*app, hostHeaders, insecure, 0)\n\tif err != nil && m.Debug {\n\t\tfor _, a := range attempts {\n\t\t\tlog.PrintE(fmt.Sprintf(\"meta tag 'ac-discovery-pubkeys' not found on %s\", a.Prefix), a.Error)\n\t\t}\n\t}\n\n\treturn keys, err\n}", "label": 5}
{"code": "def open?\n      ProcTable.ps.any? { |p| p.comm == path }\n    # See https://github.com/djberg96/sys-proctable/issues/44\n    rescue ArgumentError\n      false\n    end", "label": 4}
{"code": "public static function memoize(callable $provider)\n    {\n        $cache = [];\n        return function ($version, $service, $region) use (&$cache, $provider) {\n            $key = \"($version)($service)($region)\";\n            if (!isset($cache[$key])) {\n                $cache[$key] = $provider($version, $service, $region);\n            }\n            return $cache[$key];\n        };\n    }", "label": 2}
{"code": "function (definitions) {\n                var\n                    result = [],\n                    len = definitions.length,\n                    idx,\n                    definition;\n                for (idx = 0; idx < len; ++idx) {\n                    definition = definitions[idx];\n                    if (!(definition instanceof gpf.Parameter)) {\n                        definition = this._createFromObject(definition);\n                    }\n                    result.push(definition);\n                }\n                return result;\n            }", "label": 3}
{"code": "public static base_response update(nitro_service client, gslbsite resource) throws Exception {\n\t\tgslbsite updateresource = new gslbsite();\n\t\tupdateresource.sitename = resource.sitename;\n\t\tupdateresource.metricexchange = resource.metricexchange;\n\t\tupdateresource.nwmetricexchange = resource.nwmetricexchange;\n\t\tupdateresource.sessionexchange = resource.sessionexchange;\n\t\tupdateresource.triggermonitor = resource.triggermonitor;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function remove(req, res, next) {\n  var params = {\"_id\": req.params.id};\n\n  logger.debug(\"Middleware Submissions Remove \", {params: params});\n  forms.deleteSubmission(req.connectionOptions, params, submissionsHandler(constants.resultTypes.submissions, req, next));\n}", "label": 3}
{"code": "public static base_responses add(nitro_service client, gslbsite resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tgslbsite addresources[] = new gslbsite[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new gslbsite();\n\t\t\t\taddresources[i].sitename = resources[i].sitename;\n\t\t\t\taddresources[i].sitetype = resources[i].sitetype;\n\t\t\t\taddresources[i].siteipaddress = resources[i].siteipaddress;\n\t\t\t\taddresources[i].publicip = resources[i].publicip;\n\t\t\t\taddresources[i].metricexchange = resources[i].metricexchange;\n\t\t\t\taddresources[i].nwmetricexchange = resources[i].nwmetricexchange;\n\t\t\t\taddresources[i].sessionexchange = resources[i].sessionexchange;\n\t\t\t\taddresources[i].triggermonitor = resources[i].triggermonitor;\n\t\t\t\taddresources[i].parentsite = resources[i].parentsite;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function StackItem(axis, options, isNegative, x, stackOption) {\n\n        var inverted = axis.chart.inverted;\n\n        this.axis = axis;\n\n        // Tells if the stack is negative\n        this.isNegative = isNegative;\n\n        // Save the options to be able to style the label\n        this.options = options;\n\n        // Save the x value to be able to position the label later\n        this.x = x;\n\n        // Initialize total value\n        this.total = null;\n\n        // This will keep each points' extremes stored by series.index and point index\n        this.points = {};\n\n        // Save the stack option on the series configuration object, and whether to treat it as percent\n        this.stack = stackOption;\n\n        // The align options and text align varies on whether the stack is negative and\n        // if the chart is inverted or not.\n        // First test the user supplied value, then use the dynamic.\n        this.alignOptions = {\n            align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n            verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n            y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n            x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n        };\n\n        this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');\n    }", "label": 3}
{"code": "def RdatabasesBM(host=rbiomart_host):\n    \"\"\"\n    Lists BioMart databases through a RPY2 connection.\n\n    :param host: address of the host server, default='www.ensembl.org'\n\n    :returns: nothing\n\n    \"\"\"\n    biomaRt = importr(\"biomaRt\")\n    print(biomaRt.listMarts(host=host))", "label": 1}
{"code": "def load_txt_to_sql(tbl_name, src_file_and_path, src_file, op_folder):\n    \"\"\"\n    creates a SQL loader script to load a text file into a database\n    and then executes it.\n    Note that src_file is \n    \"\"\"\n    if op_folder == '':\n        pth = ''\n    else:\n        pth = op_folder + os.sep\n    \n    fname_create_script = pth + 'CREATE_' + tbl_name + '.SQL'\n    fname_backout_file  = pth + 'BACKOUT_' + tbl_name + '.SQL'\n    fname_control_file  = pth + tbl_name + '.CTL'\n   \n    cols = read_csv_cols_to_table_cols(src_file)\n    create_script_staging_table(fname_create_script, tbl_name, cols)    \n    create_file(fname_backout_file, 'DROP TABLE ' + tbl_name + ' CASCADE CONSTRAINTS;\\n')\n    create_CTL(fname_control_file, tbl_name, cols, 'TRUNCATE')", "label": 1}
{"code": "def search query\n      rake_yard(store)\n      found = []\n      code_object_paths.each do |k|\n        if found.empty? || (query.include?('.') || query.include?('#')) || !(k.include?('.') || k.include?('#'))\n          found.push k if k.downcase.include?(query.downcase)\n        end\n      end\n      found\n    end", "label": 4}
{"code": "function fade(progress) {\n  var to = (this.options.to !== undefined) ? this.options.to : 0;\n  var from = (this.options.from !== undefined) ? this.options.from : 1;\n  var opacity = (to - from) * progress + from;\n\n  this.element.style.opacity = opacity;\n}", "label": 3}
{"code": "def add(name, value, opts = {})\n      cookie = {\n        name: name,\n        value: value\n      }\n      cookie[:secure] = opts[:secure] if opts.key?(:secure)\n      cookie[:path] = opts[:path] if opts.key?(:path)\n      expires = opts[:expires]\n      if expires\n        cookie[:expires] = expires.is_a?(String) ? ::Time.parse(expires) : expires\n      end\n      cookie[:domain] = opts[:domain] if opts.key?(:domain)\n\n      @control.add_cookie cookie\n    end", "label": 4}
{"code": "func (c *StatusCommand) Initialize(app *kingpin.Application, config *service.Config) {\n\tc.config = config\n\tc.status = app.Command(\"status\", \"Report cluster status\")\n}", "label": 5}
{"code": "func SupportsOverlay() error {\n\t// ignore exec.Command error, modprobe may not be present on the system,\n\t// or the kernel module will fail to load.\n\t// we'll find out by reading the side effect in /proc/filesystems\n\t_ = exec.Command(\"modprobe\", \"overlay\").Run()\n\n\tf, err := os.Open(\"/proc/filesystems\")\n\tif err != nil {\n\t\t// don't use errwrap so consumers can type-check on ErrOverlayUnsupported\n\t\treturn ErrOverlayUnsupported(fmt.Sprintf(\"cannot open /proc/filesystems: %v\", err))\n\t}\n\tdefer f.Close()\n\n\ts := bufio.NewScanner(f)\n\tfor s.Scan() {\n\t\tif s.Text() == \"nodev\\toverlay\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn ErrOverlayUnsupported(\"overlay entry not present in /proc/filesystems\")\n}", "label": 5}
{"code": "def put_title_into_background_stacked(background, title, keyword)\n      resize_text(title)\n      resize_text(keyword)\n\n      vertical_padding = vertical_frame_padding # assign padding to variable\n      spacing_between_title_and_keyword = (actual_font_size / 2)\n      title_left_space = (background.width / 2.0 - title.width / 2.0).round\n      keyword_left_space = (background.width / 2.0 - keyword.width / 2.0).round\n\n      self.space_to_device += title.height + keyword.height + spacing_between_title_and_keyword + vertical_padding\n\n      if title_below_image\n        keyword_top = background.height - effective_text_height / 2 - (keyword.height + spacing_between_title_and_keyword + title.height) / 2\n      else\n        keyword_top = device_top(background) / 2 - spacing_between_title_and_keyword / 2 - keyword.height\n      end\n      title_top = keyword_top + keyword.height + spacing_between_title_and_keyword\n\n      # keyword\n      background = background.composite(keyword, \"png\") do |c|\n        c.compose(\"Over\")\n        c.geometry(\"+#{keyword_left_space}+#{keyword_top}\")\n      end\n      # Place the title below the keyword\n      background = background.composite(title, \"png\") do |c|\n        c.compose(\"Over\")\n        c.geometry(\"+#{title_left_space}+#{title_top}\")\n      end\n      background\n    end", "label": 4}
{"code": "public void beforeClose(PBStateEvent event)\r\n    {\r\n        /*\r\n        arminw:\r\n        this is a workaround for use in managed environments. When a PB instance is used\r\n        within a container a PB.close call is done when leave the container method. This close\r\n        the PB handle (but the real instance is still in use) and the PB listener are notified.\r\n        But the JTA tx was not committed at\r\n        this point in time and the session cache should not be cleared, because the updated/new\r\n        objects will be pushed to the real cache on commit call (if we clear, nothing to push).\r\n        So we check if the real broker is in a local tx (in this case we are in a JTA tx and the handle\r\n        is closed), if true we don't reset the session cache.\r\n        */\r\n        if(!broker.isInTransaction())\r\n        {\r\n            if(log.isDebugEnabled()) log.debug(\"Clearing the session cache\");\r\n            resetSessionCache();\r\n        }\r\n    }", "label": 0}
{"code": "public Constructor getZeroArgumentConstructor()\r\n    {\r\n        if (zeroArgumentConstructor == null && !alreadyLookedupZeroArguments)\r\n        {\r\n            try\r\n            {\r\n                zeroArgumentConstructor = getClassOfObject().getConstructor(NO_PARAMS);\r\n            }\r\n            catch (NoSuchMethodException e)\r\n            {\r\n                //no public zero argument constructor available let's try for a private/protected one\r\n                try\r\n                {\r\n                    zeroArgumentConstructor = getClassOfObject().getDeclaredConstructor(NO_PARAMS);\r\n\r\n                    //we found one, now let's make it accessible\r\n                    zeroArgumentConstructor.setAccessible(true);\r\n                }\r\n                catch (NoSuchMethodException e2)\r\n                {\r\n                    //out of options, log the fact and let the method return null\r\n                    LoggerFactory.getDefaultLogger().warn(\r\n                        this.getClass().getName()\r\n                            + \": \"\r\n                            + \"No zero argument constructor defined for \"\r\n                            + this.getClassOfObject());\r\n                }\r\n            }\r\n\r\n            alreadyLookedupZeroArguments = true;\r\n        }\r\n\r\n        return zeroArgumentConstructor;\r\n    }", "label": 0}
{"code": "function assertProperties(object, path, properties) {\n  let errors = [];\n\n  (properties || []).forEach((property) => {\n    if (get(object, property, undefined) === undefined) {\n      errors = [...errors, { path, id: object.id, error: `${object.type} is missing the '${property}' property` }];\n    }\n  });\n\n  return errors;\n}", "label": 3}
{"code": "def sort_above(other = nil)\n      other = @server.role(other.resolve_id) if other\n      roles = @server.roles.sort_by(&:position)\n      roles.delete_at(@position)\n\n      index = other ? roles.index { |role| role.id == other.id } + 1 : 1\n      roles.insert(index, self)\n\n      updated_roles = roles.map.with_index { |role, position| { id: role.id, position: position } }\n      @server.update_role_positions(updated_roles)\n      index\n    end", "label": 4}
{"code": "private function formatStructForApi(array $fields)\n    {\n        $fFields = [];\n\n        foreach ($fields as $key => $value) {\n            $fFields[$key] = $this->formatValueForApi($value);\n        }\n\n        return ['fields' => $fFields];\n    }", "label": 2}
{"code": "def printMetaDataFor(archive, location):\n    \"\"\" Prints metadata for given location.\n\n    :param archive: CombineArchive instance\n    :param location:\n    :return:\n    \"\"\"\n    desc = archive.getMetadataForLocation(location)\n    if desc.isEmpty():\n        print(\"  no metadata for '{0}'\".format(location))\n        return None\n\n    print(\"  metadata for '{0}':\".format(location))\n    print(\"     Created : {0}\".format(desc.getCreated().getDateAsString()))\n    for i in range(desc.getNumModified()):\n        print(\"     Modified : {0}\".format(desc.getModified(i).getDateAsString()))\n\n    print(\"     # Creators: {0}\".format(desc.getNumCreators()))\n    for i in range(desc.getNumCreators()):\n        creator = desc.getCreator(i)\n        print(\"       {0} {1}\".format(creator.getGivenName(), creator.getFamilyName()))", "label": 1}
{"code": "public function scopeWhereSubject(Builder $query, $model)\n    {\n        $query->whereSubjectModel(get_class($model))\n            ->where('subject_id', $model->id);\n    }", "label": 2}
{"code": "def sam2fastq(line):\n    \"\"\"\n    print fastq from sam\n    \"\"\"\n    fastq = []\n    fastq.append('@%s' % line[0])\n    fastq.append(line[9])\n    fastq.append('+%s' % line[0])\n    fastq.append(line[10])\n    return fastq", "label": 1}
{"code": "def add_scope(self, scope_type, scope_name, scope_start, is_method=False):\n        \"\"\"we identified a scope and add it to positions.\"\"\"\n        if self._curr is not None:\n            self._curr['end'] = scope_start - 1  # close last scope\n        self._curr = {\n            'type': scope_type, 'name': scope_name,\n            'start': scope_start, 'end': scope_start\n        }\n\n        if is_method and self._positions:\n            last = self._positions[-1]\n            if not 'methods' in last:\n                last['methods'] = []\n            last['methods'].append(self._curr)\n        else:\n            self._positions.append(self._curr)", "label": 1}
{"code": "public function setTargetIds($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::INT32);\n        $this->target_ids = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def get(self, name=None):\n        \"\"\"\n        Returns requested shared objects, which were registered by the current plugin.\n\n        If access to objects of other plugins are needed, use :func:`access` or perform get on application level::\n\n            my_app.shared_objects.get(name=\"...\")\n\n        :param name: Name of a request shared object\n        :type name: str or None\n        \"\"\"\n        return self.app.shared_objects.get(name, self.plugin)", "label": 1}
{"code": "def print_available_reporters\n      log.info 'Available reporters:'\n\n      HamlLint::Reporter.available.map(&:cli_name).sort.each do |reporter_name|\n        log.log \" - #{reporter_name}\"\n      end\n    end", "label": 4}
{"code": "function autoLayout() {\n      if (!clay.meta.activeWatchInfo ||\n          clay.meta.activeWatchInfo.firmware.major === 2 ||\n          ['aplite', 'diorite'].indexOf(clay.meta.activeWatchInfo.platform) > -1 &&\n          !self.config.allowGray) {\n        return standardLayouts.BLACK_WHITE;\n      }\n\n      if (['aplite', 'diorite'].indexOf(clay.meta.activeWatchInfo.platform) > -1 &&\n          self.config.allowGray) {\n        return standardLayouts.GRAY;\n      }\n\n      return standardLayouts.COLOR;\n    }", "label": 3}
{"code": "private function formatUrlStat($result = null)\n    {\n        $stat = $this->getStatTemplate();\n        switch (gettype($result)) {\n            case 'NULL':\n            case 'string':\n                // Directory with 0777 access - see \"man 2 stat\".\n                $stat['mode'] = $stat[2] = 0040777;\n                break;\n            case 'array':\n                // Regular file with 0777 access - see \"man 2 stat\".\n                $stat['mode'] = $stat[2] = 0100777;\n                // Pluck the content-length if available.\n                if (isset($result['ContentLength'])) {\n                    $stat['size'] = $stat[7] = $result['ContentLength'];\n                } elseif (isset($result['Size'])) {\n                    $stat['size'] = $stat[7] = $result['Size'];\n                }\n                if (isset($result['LastModified'])) {\n                    // ListObjects or HeadObject result\n                    $stat['mtime'] = $stat[9] = $stat['ctime'] = $stat[10]\n                        = strtotime($result['LastModified']);\n                }\n        }\n\n        return $stat;\n    }", "label": 2}
{"code": "def bytes\n      return 0 if member_object_ids.empty?\n\n      raise \"Collection must be saved to query for bytes\" if new_record?\n\n      # One query per member_id because Solr is not a relational database\n      member_object_ids.collect { |work_id| size_for_work(work_id) }.sum\n    end", "label": 4}
{"code": "function() {\n            system.log('Application:Starting');\n\n            if (this.title) {\n                document.title = this.title;\n            }\n\n            return system.defer(function (dfd) {\n                $(function() {\n                    loadPlugins().then(function(){\n                        dfd.resolve();\n                        system.log('Application:Started');\n                    });\n                });\n            }).promise();\n        }", "label": 3}
{"code": "function(event) {\n    if (typeof event.touches != 'undefined' && event.touches.length > 0) {\n      var c = {\n        x: event.touches[0].pageX, \n        y: event.touches[0].pageY\n      };\n    } else {\n      var  c = {\n        x: (event.pageX || (event.clientX + document.body.scrollLeft)),\n        y: (event.pageY || (event.clientY + document.body.scrollTop))\n      };\n    }\n    \n    return c;\n  }", "label": 3}
{"code": "func (i *TeleInstance) StartProxy(cfg ProxyConfig) error {\n\tdataDir, err := ioutil.TempDir(\"\", \"cluster-\"+i.Secrets.SiteName+\"-\"+cfg.Name)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\ttconf := service.MakeDefaultConfig()\n\n\tauthServer := utils.MustParseAddr(net.JoinHostPort(i.Hostname, i.GetPortAuth()))\n\ttconf.AuthServers = append(tconf.AuthServers, *authServer)\n\ttconf.CachePolicy = service.CachePolicy{Enabled: true}\n\ttconf.DataDir = dataDir\n\ttconf.UploadEventsC = i.UploadEventsC\n\ttconf.HostUUID = cfg.Name\n\ttconf.Hostname = cfg.Name\n\ttconf.Token = \"token\"\n\n\ttconf.Auth.Enabled = false\n\n\ttconf.SSH.Enabled = false\n\n\ttconf.Proxy.Enabled = true\n\ttconf.Proxy.SSHAddr.Addr = net.JoinHostPort(i.Hostname, fmt.Sprintf(\"%v\", cfg.SSHPort))\n\ttconf.Proxy.PublicAddrs = []utils.NetAddr{\n\t\tutils.NetAddr{\n\t\t\tAddrNetwork: \"tcp\",\n\t\t\tAddr:        Loopback,\n\t\t},\n\t\tutils.NetAddr{\n\t\t\tAddrNetwork: \"tcp\",\n\t\t\tAddr:        Host,\n\t\t},\n\t}\n\ttconf.Proxy.ReverseTunnelListenAddr.Addr = net.JoinHostPort(i.Hostname, fmt.Sprintf(\"%v\", cfg.ReverseTunnelPort))\n\ttconf.Proxy.WebAddr.Addr = net.JoinHostPort(i.Hostname, fmt.Sprintf(\"%v\", cfg.WebPort))\n\ttconf.Proxy.DisableReverseTunnel = false\n\ttconf.Proxy.DisableWebService = true\n\n\t// Create a new Teleport process and add it to the list of nodes that\n\t// compose this \"cluster\".\n\tprocess, err := service.NewTeleport(tconf)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\ti.Nodes = append(i.Nodes, process)\n\n\t// Build a list of expected events to wait for before unblocking based off\n\t// the configuration passed in.\n\texpectedEvents := []string{\n\t\tservice.ProxyReverseTunnelReady,\n\t\tservice.ProxySSHReady,\n\t}\n\n\t// Start the process and block until the expected events have arrived.\n\treceivedEvents, err := startAndWait(process, expectedEvents)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\tlog.Debugf(\"Teleport proxy (in instance %v) started: %v/%v events received.\",\n\t\ti.Secrets.SiteName, len(expectedEvents), len(receivedEvents))\n\treturn nil\n}", "label": 5}
{"code": "function loadModules(rootDir, paths) {\n        var serverModules = {};\n        var me = this;\n\n        // return empty object if no rootDir or paths\n        if (!rootDir || !paths) { return serverModules; }\n\n        // loop through paths and load all modules in those directories\n        _.each(paths, function (relativePath) {\n            var fullPath = path.normalize(rootDir + delim + relativePath);\n\n            // if the directory doesn't exist, then skip to the next loop iteration\n            if (fs.existsSync(fullPath)) {\n\n                _.each(fs.readdirSync(fullPath), function (fileName) {\n\n                    // if it is a javascript file and it DOES NOT end in .service.js, then save the mapping\n                    if (utils.isJavaScript(fileName) && !fileName.match(/^.*\\.service\\.js$/)) {\n                        var nameLower = utils.getCamelCase(fileName).toLowerCase();\n                        var fullFilePath = path.normalize(fullPath + '/' + fileName);\n\n                        // there are 2 diff potential aliases for any given server module\n                        serverModules[nameLower + 'fromplugin'] = serverModules[nameLower] = require(fullFilePath);\n                    }\n\n                    // else if we are dealing   with a directory, recurse down into the folder\n                    else if (fs.lstatSync(path.join(fullPath, fileName)).isDirectory()) {\n                        _.extend(serverModules, me.loadModules(rootDir, [relativePath + '/' + fileName]));\n                    }\n\n                });\n            }\n        });\n\n        return serverModules;\n    }", "label": 3}
{"code": "func NewForwardRecorder(cfg ForwardRecorderConfig) (*ForwardRecorder, error) {\n\tif err := cfg.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\t// Always write sessions to local disk first, then forward them to the Auth\n\t// Server later.\n\tauditLog, err := NewForwarder(ForwarderConfig{\n\t\tSessionID:      cfg.SessionID,\n\t\tServerID:       teleport.ComponentUpload,\n\t\tDataDir:        cfg.DataDir,\n\t\tRecordSessions: cfg.RecordSessions,\n\t\tNamespace:      cfg.Namespace,\n\t\tForwardTo:      cfg.ForwardTo,\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tsr := &ForwardRecorder{\n\t\tForwardRecorderConfig: cfg,\n\t\tEntry: logrus.WithFields(logrus.Fields{\n\t\t\ttrace.Component: cfg.Component,\n\t\t}),\n\t\tAuditLog: auditLog,\n\t}\n\treturn sr, nil\n}", "label": 5}
{"code": "func (s *MockStore) AtomicDelete(key string, previous *store.KVPair) (bool, error) {\n\tmData := s.db[key]\n\tif mData != nil && mData.Index != previous.LastIndex {\n\t\treturn false, types.BadRequestErrorf(\"atomic delete failed due to mismatched Index\")\n\t}\n\treturn true, s.Delete(key)\n}", "label": 5}
{"code": "func DefaultConfig() *Config {\n\thostname, _ := os.Hostname()\n\treturn &Config{\n\t\tNodeID:            stringid.TruncateID(stringid.GenerateRandomID()),\n\t\tHostname:          hostname,\n\t\tBindAddr:          \"0.0.0.0\",\n\t\tPacketBufferSize:  1400,\n\t\tStatsPrintPeriod:  5 * time.Minute,\n\t\tHealthPrintPeriod: 1 * time.Minute,\n\t\treapEntryInterval: 30 * time.Minute,\n\t}\n}", "label": 5}
{"code": "func PgCollationByCollnameCollencodingCollnamespace(db XODB, collname pgtypes.Name, collencoding int, collnamespace pgtypes.Oid) (*PgCollation, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, collname, collnamespace, collowner, collencoding, collcollate, collctype ` +\n\t\t`FROM pg_catalog.pg_collation ` +\n\t\t`WHERE collname = $1 AND collencoding = $2 AND collnamespace = $3`\n\n\t// run query\n\tXOLog(sqlstr, collname, collencoding, collnamespace)\n\tpc := PgCollation{}\n\n\terr = db.QueryRow(sqlstr, collname, collencoding, collnamespace).Scan(&pc.Tableoid, &pc.Cmax, &pc.Xmax, &pc.Cmin, &pc.Xmin, &pc.Oid, &pc.Ctid, &pc.Collname, &pc.Collnamespace, &pc.Collowner, &pc.Collencoding, &pc.Collcollate, &pc.Collctype)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pc, nil\n}", "label": 5}
{"code": "def whitelisted_params\n      whitelist = params_for_resource(:sign_up)\n\n      whitelist.inject({}) do |coll, key|\n        param = omniauth_params[key.to_s]\n        coll[key] = param if param\n        coll\n      end\n    end", "label": 4}
{"code": "public function setInfo($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\Intent_Message_SelectItemInfo::class);\n        $this->info = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def get_patient_expression(job, patient_dict):\n    \"\"\"\n    Convenience function to get the expression from the patient dict\n\n    :param dict patient_dict: dict of patient info\n    :return: The gene and isoform expression\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    expression_archive = job.fileStore.readGlobalFile(patient_dict['expression_files'])\n    expression_archive = untargz(expression_archive, os.getcwd())\n    output_dict = {}\n    for filename in 'rsem.genes.results', 'rsem.isoforms.results':\n        output_dict[filename] = job.fileStore.writeGlobalFile(os.path.join(expression_archive,\n                                                                           filename))\n    return output_dict", "label": 1}
{"code": "function updateConfig(req, res, next) {\n  var params = {\n    appId: req.params.id\n  };\n\n  forms.updateAppConfig(req.connectionOptions, _.extend(req.body, params), formsResultHandlers(constants.resultTypes.formProjects, req, next));\n}", "label": 3}
{"code": "def sync_repos(repo_ids)\n      collected = []\n      repos = Repository.where(:id => repo_ids).syncable\n      repos.each do |repo|\n        if latest_task(repo).try(:state) != 'running'\n          ForemanTasks.async_task(::Actions::Katello::Repository::Sync, repo)\n        end\n        collected << format_sync_progress(repo)\n      end\n      collected\n    end", "label": 4}
{"code": "function module(filename) {\n            return function () {\n                if (verbose.local) console.log(filename);\n                response.write(fs.readFileSync(filename) + '\\n/*:oxsep:*/\\n');\n            };\n        }", "label": 3}
{"code": "def load_permissions_on_identity_loaded(sender, identity):\n    \"\"\"Add system roles \"Needs\" to users' identities.\n\n    Every user gets the **any_user** Need.\n    Authenticated users get in addition the **authenticated_user** Need.\n    \"\"\"\n    identity.provides.add(\n        any_user\n    )\n    # if the user is not anonymous\n    if current_user.is_authenticated:\n        # Add the need provided to authenticated users\n        identity.provides.add(\n            authenticated_user\n        )", "label": 1}
{"code": "public function recordNotification(NotificationSent $event)\n    {\n        if (! Telescope::isRecording()) {\n            return;\n        }\n\n        Telescope::recordNotification(IncomingEntry::make([\n            'notification' => get_class($event->notification),\n            'queued' => in_array(ShouldQueue::class, class_implements($event->notification)),\n            'notifiable' => $this->formatNotifiable($event->notifiable),\n            'channel' => $event->channel,\n            'response' => $event->response,\n        ])->tags($this->tags($event)));\n    }", "label": 2}
{"code": "public static gslbdomain_stats get(nitro_service service, String name) throws Exception{\n\t\tgslbdomain_stats obj = new gslbdomain_stats();\n\t\tobj.set_name(name);\n\t\tgslbdomain_stats response = (gslbdomain_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function basic_recover($requeue = false)\n    {\n        list($class_id, $method_id, $args) = $this->protocolWriter->basicRecover($requeue);\n        $this->send_method_frame(array($class_id, $method_id), $args);\n\n        return $this->wait(array(\n            $this->waitHelper->get_wait('basic.recover_ok')\n        ), false, $this->channel_rpc_timeout);\n    }", "label": 2}
{"code": "public function setPornographyLikelihood($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\VideoIntelligence\\V1\\Likelihood::class);\n        $this->pornography_likelihood = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static Interface[] get(nitro_service service) throws Exception{\n\t\tInterface obj = new Interface();\n\t\tInterface[] response = (Interface[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private function checkExistenceWithCommand(CommandInterface $command)\n    {\n        try {\n            $this->execute($command);\n            return true;\n        } catch (S3Exception $e) {\n            if ($e->getAwsErrorCode() == 'AccessDenied') {\n                return true;\n            }\n            if ($e->getStatusCode() >= 500) {\n                throw $e;\n            }\n            return false;\n        }\n    }", "label": 2}
{"code": "def authorized_item_ids\n        @member_item_list_ids ||= begin\n          items = ordered_ids\n          items.delete_if { |m| !current_ability.can?(:read, m) } if Flipflop.hide_private_items?\n          items\n        end\n      end", "label": 4}
{"code": "func shiftBackups(dir string, oldest int) error {\n\tif oldest < 0 {\n\t\treturn nil\n\t}\n\tfor i := oldest; i >= 0; i-- {\n\t\tcurrent := filepath.Join(dir, strconv.Itoa(i))\n\t\tinc := filepath.Join(dir, strconv.Itoa(i+1))\n\t\tif err := os.Rename(current, inc); err != nil && !os.IsNotExist(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "protected void processTusFiles(String assemblyUrl) throws IOException, ProtocolException {\n        tusClient.setUploadCreationURL(new URL(getClient().getHostUrl() + \"/resumable/files/\"));\n        tusClient.enableResuming(tusURLStore);\n\n        for (Map.Entry<String, File> entry : files.entrySet()) {\n            processTusFile(entry.getValue(), entry.getKey(), assemblyUrl);\n        }\n\n        for (Map.Entry<String, InputStream> entry : fileStreams.entrySet()) {\n            processTusFile(entry.getValue(), entry.getKey(), assemblyUrl);\n        }\n    }", "label": 0}
{"code": "func KeysEqual(ak, bk ssh.PublicKey) bool {\n\ta := ssh.Marshal(ak)\n\tb := ssh.Marshal(bk)\n\treturn (len(a) == len(b) && subtle.ConstantTimeCompare(a, b) == 1)\n}", "label": 5}
{"code": "function one(config, node) {\n  var offset = config.location.toOffset\n  var parser = config.parser\n  var doc = config.doc\n  var type = node.type\n  var start = offset(position.start(node))\n  var end = offset(position.end(node))\n\n  if (config.ignore.indexOf(type) === -1) {\n    if (config.source.indexOf(type) !== -1) {\n      return patch(\n        config,\n        [parser.tokenizeSource(doc.slice(start, end))],\n        start\n      )\n    }\n\n    if (node.children) {\n      return all(config, node)\n    }\n\n    if (type === 'image' || type === 'imageReference') {\n      return patch(config, parser.tokenize(node.alt), start + 2)\n    }\n\n    if (type === 'text' || type === 'escape') {\n      return patch(config, parser.tokenize(node.value), start)\n    }\n\n    if (node.type === 'break') {\n      return patch(config, [parser.tokenizeWhiteSpace('\\n')], start)\n    }\n  }\n\n  return null\n}", "label": 3}
{"code": "def list_signals(self):\n        \"\"\"\n        Prints a list of all registered signals. Including description and plugin name.\n        \"\"\"\n        print(\"Signal list\")\n        print(\"***********\\n\")\n        for key, signal in self.app.signals.signals.items():\n            print(\"%s (%s)\\n  %s\\n\" % (signal.name, signal.plugin.name, signal.description))", "label": 1}
{"code": "def _get_voltage_magnitude_var(self, buses, generators):\n        \"\"\" Returns the voltage magnitude variable set.\n        \"\"\"\n        Vm = array([b.v_magnitude for b in buses])\n\n        # For buses with generators initialise Vm from gen data.\n        for g in generators:\n            Vm[g.bus._i] = g.v_magnitude\n\n        Vmin = array([b.v_min for b in buses])\n        Vmax = array([b.v_max for b in buses])\n\n        return Variable(\"Vm\", len(buses), Vm, Vmin, Vmax)", "label": 1}
{"code": "def normalized_site\n      return nil unless self.site\n      @normalized_site ||= begin\n        site_string = \"\".dup\n        if self.normalized_scheme != nil\n          site_string << \"#{self.normalized_scheme}:\"\n        end\n        if self.normalized_authority != nil\n          site_string << \"//#{self.normalized_authority}\"\n        end\n        site_string\n      end\n      # All normalized values should be UTF-8\n      @normalized_site.force_encoding(Encoding::UTF_8) if @normalized_site\n      @normalized_site\n    end", "label": 4}
{"code": "public function setInputConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Vision\\V1\\InputConfig::class);\n        $this->input_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_response update(nitro_service client, ntpserver resource) throws Exception {\n\t\tntpserver updateresource = new ntpserver();\n\t\tupdateresource.serverip = resource.serverip;\n\t\tupdateresource.servername = resource.servername;\n\t\tupdateresource.minpoll = resource.minpoll;\n\t\tupdateresource.maxpoll = resource.maxpoll;\n\t\tupdateresource.preferredntpserver = resource.preferredntpserver;\n\t\tupdateresource.autokey = resource.autokey;\n\t\tupdateresource.key = resource.key;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def send_email(request, context, subject_template, body_template,\n               from_email, recipients, priority=\"medium\", reply_to=None,\n               headers=None, cc=None, bcc=None):\n    \"\"\"\n    Sends an email based on templates for subject and body.\n\n    :param request: The current request instance.\n    :param context: A dictionary of items that should be added to the\n        templates' contexts.\n    :param subject_template: A string representing the path to the template of\n        of the email's subject.\n    :param body_template: A string representing the path to the template of\n        the email's body.\n    :param from_email: String that represents the sender of the email.\n    :param recipients: A list of tuples of recipients. The tuples are similar\n        to the ADMINS setting.\n    :param priority: Sets the priority of the email (only used by django-mailer\n        to prioritise email sendings).\n    :param reply_to: Optional email address to reply to.\n    :param headers: Additional dictionary to add header attributes.\n    :param cc: A list of CC recipients\n    :param bcc: A list of BCC recipients\n    \"\"\"\n    headers = headers or {}\n    if not reply_to:\n        reply_to = from_email\n\n    # Add additional context\n    if hasattr(settings, 'DJANGO_LIBS_EMAIL_CONTEXT'):\n        context_fn = load_member_from_setting('DJANGO_LIBS_EMAIL_CONTEXT')\n        context.update(context_fn(request))\n\n    if request and request.get_host():\n        domain = request.get_host()\n        protocol = 'https://' if request.is_secure() else 'http://'\n    else:\n        domain = getattr(settings, 'DOMAIN', Site.objects.get_current().domain)\n        protocol = getattr(settings, 'PROTOCOL', 'http://')\n    context.update({\n        'domain': domain,\n        'protocol': protocol,\n    })\n    subject = render_to_string(template_name=subject_template,\n                               context=context, request=request)\n    subject = ''.join(subject.splitlines())\n    message_html = render_to_string(template_name=body_template,\n                                    context=context, request=request)\n    message_plaintext = html_to_plain_text(message_html)\n    subject = force_text(subject)\n    message = force_text(message_plaintext)\n    email = EmailMultiAlternatives(\n        subject=subject,\n        body=message,\n        from_email=from_email,\n        to=recipients,\n        cc=cc,\n        bcc=bcc,\n        headers=headers,\n        reply_to=[reply_to],\n    )\n    email.attach_alternative(message_html, \"text/html\")\n    if settings.EMAIL_BACKEND == 'mailer.backend.DbBackend':\n        # We customize `mailer.send_html_mail` to enable CC and BCC\n        priority = mailer.get_priority(priority)\n        msg = make_message(\n            subject=subject,\n            body=message,\n            from_email=from_email,\n            to=recipients,\n            priority=priority,\n        )\n        msg.email = email\n        msg.save()\n    else:\n        email.send()", "label": 1}
{"code": "function (CurrentEntity) {\n  return function (entity) {\n    expect(arguments).to.have.length.below(\n      2,\n      'Invalid arguments length when creating a new Entity function (it has ' +\n      'to be passed less than 2 arguments)'\n    );\n\n    return function (attributeValues) {\n      expect(arguments).to.have.length.below(\n        2,\n        'Invalid arguments length when creating a new Entity (it has ' +\n        'not to be passed less than 2 arguments)'\n      );\n\n      var EntityClass = CurrentEntity;\n\n      if (entity) {\n        EntityClass = Entity.getSpecialization(entity);\n      }\n\n      return new EntityClass(attributeValues);\n    };\n  };\n}", "label": 3}
{"code": "func BeeConfigs() []BeeConfig {\n\tbs := []BeeConfig{}\n\tfor _, b := range bees {\n\t\tbs = append(bs, (*b).Config())\n\t}\n\n\treturn bs\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, dnssrvrec resource) throws Exception {\n\t\tdnssrvrec addresource = new dnssrvrec();\n\t\taddresource.domain = resource.domain;\n\t\taddresource.target = resource.target;\n\t\taddresource.priority = resource.priority;\n\t\taddresource.weight = resource.weight;\n\t\taddresource.port = resource.port;\n\t\taddresource.ttl = resource.ttl;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def format_exception(exception)\n      return exception.to_s unless exception.is_a?(Hash)\n\n      msg = exception['message'].to_s\n\n      if exception['backtrace']\n        msg += \"\\n\"\n        msg += Array(exception['backtrace']).join(\"\\n\")\n      end\n\n      if exception['blobstore_id']\n        blob = download_and_delete_blob(exception['blobstore_id'])\n        msg += \"\\n\"\n        msg += blob.to_s\n      end\n\n      msg\n    end", "label": 4}
{"code": "public static spilloverpolicy_stats get(nitro_service service, String name) throws Exception{\n\t\tspilloverpolicy_stats obj = new spilloverpolicy_stats();\n\t\tobj.set_name(name);\n\t\tspilloverpolicy_stats response = (spilloverpolicy_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private boolean absoluteBasic(int row)\r\n    {\r\n        boolean retval = false;\r\n        \r\n        if (row > m_current_row)\r\n        {\r\n            try\r\n            {\r\n                while (m_current_row < row && getRsAndStmt().m_rs.next())\r\n                {\r\n                    m_current_row++;\r\n                }\r\n                if (m_current_row == row)\r\n                {\r\n                    retval = true;\r\n                }\r\n                else\r\n                {\r\n                    setHasCalledCheck(true);\r\n                    setHasNext(false);\r\n                    retval = false;\r\n                    autoReleaseDbResources();\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                setHasCalledCheck(true);\r\n                setHasNext(false);\r\n                retval = false;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            logger.info(\"Your driver does not support advanced JDBC Functionality, \" +\r\n                    \"you cannot call absolute() with a position < current\");\r\n        }\r\n        return retval;\r\n    }", "label": 0}
{"code": "protected Object[] idsOf(final List<?> idsOrValues) {\n        // convert list to array that we can mutate\n        final Object[] ids = idsOrValues.toArray();\n\n        // mutate array to contain only non-empty ids\n        int length = 0;\n        for (int i = 0; i < ids.length;) {\n            final Object p = ids[i++];\n            if (p instanceof HasId) {\n                // only use values with ids that are non-empty\n                final String id = ((HasId) p).getId();\n                if (!StringUtils.isEmpty(id)) {\n                    ids[length++] = id;\n                }\n            } else if (p instanceof String) {\n                // only use ids that are non-empty\n                final String id = p.toString();\n                if (!StringUtils.isEmpty(id)) {\n                    ids[length++] = id;\n                }\n            } else if (p != null) {\n                throw new StoreException(\"Invalid id or value of type \" + p);\n            }\n        }\n\n        // no ids in array\n        if (length == 0) {\n            return null;\n        }\n\n        // some ids in array\n        if (length != ids.length) {\n            final Object[] tmp = new Object[length];\n            System.arraycopy(ids, 0, tmp, 0, length);\n            return tmp;\n        }\n\n        // array was full\n        return ids;\n    }", "label": 0}
{"code": "def sheet_by_name(name)\n      index = @worksheets.index { |sheet| sheet.name == name }\n      @worksheets[index] if index\n    end", "label": 4}
{"code": "function ConstantAggregateExpression(number) {\n    if(!Number.isFinite(number))\n        this.number = parseFloat(number);\n    else\n        this.number = number;\n}", "label": 3}
{"code": "func (a *ACL) ParseACL(acl string) error {\n\tacl_from_text, err := getSymbolPointer(a.lib.handle, \"acl_from_text\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tcacl := C.CString(acl)\n\tdefer C.free(unsafe.Pointer(cacl))\n\n\tretACL, err := C.my_acl_from_text(acl_from_text, cacl)\n\tif retACL == nil {\n\t\treturn errwrap.Wrap(errors.New(\"error calling acl_from_text\"), err)\n\t}\n\n\ta.a = retACL\n\n\treturn nil\n}", "label": 5}
{"code": "public static <E> void dotProductInPlace(Counter<E> target, Counter<E> term) {\r\n    for (E key : target.keySet()) {\r\n      target.setCount(key, target.getCount(key) * term.getCount(key));\r\n    }\r\n  }", "label": 0}
{"code": "public void forAllClassDefinitions(String template, Properties attributes) throws XDocletException\r\n    {\r\n        for (Iterator it = _model.getClasses(); it.hasNext(); )\r\n        {\r\n            _curClassDef = (ClassDescriptorDef)it.next();\r\n            generate(template);\r\n        }\r\n        _curClassDef = null;\r\n\r\n        LogHelper.debug(true, OjbTagsHandler.class, \"forAllClassDefinitions\", \"Processed \"+_model.getNumClasses()+\" types\");\r\n    }", "label": 0}
{"code": "def max_mtime(paths)\n        time_now = Time.now\n        max_mtime = nil\n\n        # Time comparisons are performed with #compare_without_coercion because\n        # AS redefines these operators in a way that is much slower and does not\n        # bring any benefit in this particular code.\n        #\n        # Read t1.compare_without_coercion(t2) < 0 as t1 < t2.\n        paths.each do |path|\n          mtime = File.mtime(path)\n\n          next if time_now.compare_without_coercion(mtime) < 0\n\n          if max_mtime.nil? || max_mtime.compare_without_coercion(mtime) < 0\n            max_mtime = mtime\n          end\n        end\n\n        max_mtime\n      end", "label": 4}
{"code": "func (f *Fpdf) CreateTemplateCustom(corner PointType, size SizeType, fn func(*Tpl)) Template {\n\treturn newTpl(corner, size, f.defOrientation, f.unitStr, f.fontDirStr, fn, f)\n}", "label": 5}
{"code": "public static function intToByteString($intValue)\n    {\n        if (!self::isSupported()) {\n            throw new \\RuntimeException('This utility is only supported on 64 bit machines with PHP version > 5.5.');\n        }\n        if (!is_int($intValue)) {\n            throw new \\InvalidArgumentException(\n                sprintf(\n                    'Expected argument to be of type int, instead got \\'%s\\'.',\n                    gettype($intValue)\n                )\n            );\n        }\n        $bytes = pack(\"J\", $intValue);\n        return $bytes;\n    }", "label": 2}
{"code": "def add_emoji(name, image, roles = [], reason: nil)\n      image_string = image\n      if image.respond_to? :read\n        image_string = 'data:image/jpg;base64,'\n        image_string += Base64.strict_encode64(image.read)\n      end\n\n      data = JSON.parse(API::Server.add_emoji(@bot.token, @id, image_string, name, roles.map(&:resolve_id), reason))\n      new_emoji = Emoji.new(data)\n      @emoji[new_emoji.id] = new_emoji\n    end", "label": 4}
{"code": "public static cmpparameter get(nitro_service service) throws Exception{\n\t\tcmpparameter obj = new cmpparameter();\n\t\tcmpparameter[] response = (cmpparameter[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def grab_keyfile(cert_url):\n    \"\"\"\n    Function to acqure the keyfile\n\n    SNS keys expire and Amazon does not promise they will use the same key\n    for all SNS requests. So we need to keep a copy of the cert in our\n    cache\n    \"\"\"\n    key_cache = caches[getattr(settings, 'BOUNCY_KEY_CACHE', 'default')]\n\n    pemfile = key_cache.get(cert_url)\n    if not pemfile:\n        response = urlopen(cert_url)\n        pemfile = response.read()\n        # Extract the first certificate in the file and confirm it's a valid\n        # PEM certificate\n        certificates = pem.parse(smart_bytes(pemfile))\n\n        # A proper certificate file will contain 1 certificate\n        if len(certificates) != 1:\n            logger.error('Invalid Certificate File: URL %s', cert_url)\n            raise ValueError('Invalid Certificate File')\n\n        key_cache.set(cert_url, pemfile)\n    return pemfile", "label": 1}
{"code": "func (au *AuthUser) Save(db XODB) error {\n\tif au.Exists() {\n\t\treturn au.Update(db)\n\t}\n\n\treturn au.Insert(db)\n}", "label": 5}
{"code": "def __parse_loc_data(loc_data, result):\n    \"\"\"Parse the json data from selected weatherstation.\"\"\"\n    result[DATA] = {ATTRIBUTION: ATTRIBUTION_INFO,\n                    FORECAST: [],\n                    PRECIPITATION_FORECAST: None}\n\n    for key, [value, func] in SENSOR_TYPES.items():\n        result[DATA][key] = None\n        try:\n            sens_data = loc_data[value]\n            if key == CONDITION:\n                # update weather symbol & status text\n                desc = loc_data[__WEATHERDESCRIPTION]\n                result[DATA][CONDITION] = __cond_from_desc(desc)\n                result[DATA][CONDITION][IMAGE] = loc_data[__ICONURL]\n                continue\n            if key == STATIONNAME:\n                result[DATA][key] = __getStationName(loc_data[__STATIONNAME],\n                                                     loc_data[__STATIONID])\n                continue\n            # update all other data:\n            if func is not None:\n                result[DATA][key] = func(sens_data)\n            else:\n                result[DATA][key] = sens_data\n        except KeyError:\n            if result[MESSAGE] is None:\n                result[MESSAGE] = \"Missing key(s) in br data: \"\n            result[MESSAGE] += \"%s \" % value\n            log.warning(\"Data element with key='%s' \"\n                        \"not loaded from br data!\", key)\n    result[SUCCESS] = True\n    return result", "label": 1}
{"code": "public function enable($name)\n    {\n        if ($this->isEnabled($name)) {\n            return;\n        }\n\n        $extension = $this->getExtension($name);\n\n        $this->dispatcher->dispatch(new Enabling($extension));\n\n        $enabled = $this->getEnabled();\n\n        $enabled[] = $name;\n\n        $this->migrate($extension);\n\n        $this->publishAssets($extension);\n\n        $this->setEnabled($enabled);\n\n        $extension->enable($this->app);\n\n        $this->dispatcher->dispatch(new Enabled($extension));\n    }", "label": 2}
{"code": "public function drop(array $options = [])\n    {\n        $this->connection->dropDatabase($options + [\n            'name' => $this->name\n        ]);\n\n        if ($this->sessionPool) {\n            $this->sessionPool->clear();\n        }\n\n        if ($this->session) {\n            $this->session->delete($options);\n            $this->session = null;\n        }\n    }", "label": 2}
{"code": "def evaluate_template_definitions\n      source_code = IO.read(@template_definitions_path)\n      begin\n        instance_eval(source_code, @template_definitions_path)\n      rescue Exception => e\n        if e.class == SystemExit # allow exit to happen normally\n          raise\n        else\n          task_definition_error(e)\n          puts \"\\nFull error:\"\n          raise\n        end\n      end\n    end", "label": 4}
{"code": "def with_zero_or_one(cls, converter, pattern=None):\n        \"\"\"Creates a type converter for a T with 0..1 times\n        by using the type converter for one item of T.\n\n        :param converter: Type converter (function) for data type T.\n        :param pattern:  Regexp pattern for an item (=converter.pattern).\n        :return: type-converter for optional<T> (T or None).\n        \"\"\"\n        cardinality = Cardinality.zero_or_one\n        if not pattern:\n            pattern = getattr(converter, \"pattern\", cls.default_pattern)\n        optional_pattern = cardinality.make_pattern(pattern)\n        group_count = cardinality.compute_group_count(pattern)\n\n        def convert_optional(text, m=None):\n            if text:\n                text = text.strip()\n            if not text:\n                return None\n            return converter(text)\n        convert_optional.pattern = optional_pattern\n        # OLD: convert_optional.group_count = group_count\n        convert_optional.regex_group_count = group_count\n        return convert_optional", "label": 1}
{"code": "def sign_out(authenticatable_class)\n      key = cookie_name(authenticatable_class)\n      cookies.encrypted.permanent[key] = {value: nil}\n      cookies.delete(key)\n      true\n    end", "label": 4}
{"code": "function resourcePath(resourceId, dest = '') {\n  const subPath = idKeys(resourceId);\n  // Remove first item because it is the \"resource type\"\n  // If there _is_ only one item in the ID, it will be left alone\n  // To serve as the filename.\n  if (subPath.length !== 0 && subPath.length > 1) {\n    subPath.shift();\n  }\n  const filename = subPath.pop() + '.html';\n  const outputPath = path.normalize(\n    path.join(dest, subPath.join(path.sep), filename)\n  );\n  return outputPath;\n}", "label": 3}
{"code": "def _guess_type(self, full_path):\n        \"\"\"Guess the mime type magically or using the mimetypes module.\"\"\"\n        magic = self._match_magic(full_path)\n        if magic is not None:\n            return (mimetypes.guess_type(magic.old_path(full_path))[0]\n                    or 'text/plain')\n        else:\n            return mimetypes.guess_type(full_path)[0] or 'text/plain'", "label": 1}
{"code": "public static int[] getTileScreenSize(double[] worldSize, double scale) {\n\t\tint screenWidth = (int) Math.round(scale * worldSize[0]);\n\t\tint screenHeight = (int) Math.round(scale * worldSize[1]);\n\t\treturn new int[] { screenWidth, screenHeight };\n\t}", "label": 0}
{"code": "public static String capitalizePropertyName(String s) {\r\n\t\tif (s.length() == 0) {\r\n\t\t\treturn s;\r\n\t\t}\r\n\r\n\t\tchar[] chars = s.toCharArray();\r\n\t\tchars[0] = Character.toUpperCase(chars[0]);\r\n\t\treturn new String(chars);\r\n\t}", "label": 0}
{"code": "def kick(user, reason = nil)\n      API::Server.remove_member(@bot.token, @id, user.resolve_id, reason)\n    end", "label": 4}
{"code": "function add(base, addend) {\r\n  if (util.isDate(base)) {\r\n    return new Date(base.getTime() + interval(addend));\r\n  }\r\n  return interval(base) + interval(addend);\r\n}", "label": 3}
{"code": "def info(cls, name, message, *args):\n        \"\"\"\n        Convenience function to log a message at the INFO level.\n\n        :param name:    The name of the logger instance in the VSG namespace (VSG.<name>)\n        :param message: A message format string.\n        :param args:    The arguments that are are merged into msg using the string formatting operator.\n        :..note:        The native logger's `kwargs` are not used in this function.\n        \"\"\"\n        cls.getLogger(name).info(message, *args)", "label": 1}
{"code": "def [](value)\n      if value.is_a?(Range)\n        to_a[value]\n      elsif @selector.key? :adjacent\n        to_a[value] || element_class.new(@query_scope, invalid_locator: true)\n      elsif @to_a && @to_a[value]\n        @to_a[value]\n      else\n        element_class.new(@query_scope, @selector.merge(index: value))\n      end\n    end", "label": 4}
{"code": "def add_data_validation(cells, data_validation)\n      dv = DataValidation.new(data_validation)\n      dv.sqref = cells\n      data_validations << dv\n    end", "label": 4}
{"code": "function spawnWatcher() {\n  var subprocess = spawn(process.argv[0], ['prebuild.js', '--watcher'], {detached: true, stdio: 'ignore'})\n  subprocess.unref()\n}", "label": 3}
{"code": "public function pollMessage()\n    {\n        if (!$this->isConnected()) {\n            throw new ConnectionException('Connection Closed!');\n        }\n\n        $r = [$this->socket];\n        $w = [];\n        $e = [];\n        $s = socket_select($r, $w, $e, Constants::TIMEOUT_SEC, Constants::TIMEOUT_USEC);\n\n        if ($s) {\n\n            // Something to read\n            if ($stanza = $this->readStanza()) {\n                $this->processInboundData($stanza);\n\n                return true;\n            }\n        }\n        if (time() - $this->timeout > 60) {\n            if ($this->pingCounter >= 3)\n            {\n              $this->sendOfflineStatus();\n              $this->disconnect();\n              $this->iqCounter = 1;\n              $this->connect();\n              $this->loginWithPassword($this->password);\n              $this->pingCounter = 1;\n            }\n            else {\n              $this->sendPing();\n              $this->pingCounter++;\n            }\n        }\n\n        return false;\n    }", "label": 2}
{"code": "public function setClusterLabels($var)\n    {\n        $arr = GPBUtil::checkMapField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->cluster_labels = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (c *Manager) ListAttachedObjects(ctx context.Context, tagID string) ([]mo.Reference, error) {\n\tid, err := c.tagID(ctx, tagID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\turl := internal.URL(c, internal.AssociationPath).WithID(id).WithAction(\"list-attached-objects\")\n\tvar res []internal.AssociatedObject\n\tif err := c.Do(ctx, url.Request(http.MethodPost, nil), &res); err != nil {\n\t\treturn nil, err\n\t}\n\n\trefs := make([]mo.Reference, len(res))\n\tfor i := range res {\n\t\trefs[i] = res[i]\n\t}\n\treturn refs, nil\n}", "label": 5}
{"code": "def unregister(self, fileobj):\n        \"\"\" Unregister a file object from being monitored. \"\"\"\n        try:\n            key = self._fd_to_key.pop(self._fileobj_lookup(fileobj))\n        except KeyError:\n            raise KeyError(\"{0!r} is not registered\".format(fileobj))\n\n        # Getting the fileno of a closed socket on Windows errors with EBADF.\n        except socket.error as err:\n            if err.errno != errno.EBADF:\n                raise\n            else:\n                for key in self._fd_to_key.values():\n                    if key.fileobj is fileobj:\n                        self._fd_to_key.pop(key.fd)\n                        break\n                else:\n                    raise KeyError(\"{0!r} is not registered\".format(fileobj))\n        return key", "label": 1}
{"code": "private void ensureNext() {\n        // Check if the current scan result has more keys (i.e. the index did not reach the end of the result list)\n        if (resultIndex < scanResult.getResult().size()) {\n            return;\n        }\n        // Since the current scan result was fully iterated,\n        // if there is another cursor scan it and ensure next key (recursively)\n        if (!FIRST_CURSOR.equals(scanResult.getStringCursor())) {\n            scanResult = scan(scanResult.getStringCursor(), scanParams);\n            resultIndex = 0;\n            ensureNext();\n        }\n    }", "label": 0}
{"code": "function attachKeybindings (binding, method) {\n  if (!binding) return console.warn('attachKeybinding requires character or object for binding');\n  if (typeof binding === 'string' && !method) console.warn('attachKeybindings requries method as second arg');\n  if (hasKeybinding(binding, method)) return console.warn(`attachKeybinding: already attached ${binding} to method`, method);\n\n  if (typeof binding === 'string') addMethod(binding, method);\n  else Object.keys(binding).forEach((key) => addMethod(key, binding[key]))\n}", "label": 3}
{"code": "def _on_change(self, obj, old, value, **kwargs):\n        \"\"\"Called internally to emit changes from the instance object\n\n        The keyword arguments here will be passed to callbacks through the\n        instance object's :meth:`~pydispatch.dispatch.Dispatcher.emit` method.\n\n        Keyword Args:\n            property: The :class:`Property` instance. This is useful if multiple\n                properties are bound to the same callback. The attribute name\n            keys (optional): If the :class:`Property` is a container type\n                (:class:`ListProperty` or :class:`DictProperty`), the changes\n                may be found here.\n                This is not implemented for nested containers and will only be\n                available for operations that do not alter the size of the\n                container.\n\n        \"\"\"\n        kwargs['property'] = self\n        obj.emit(self.name, obj, value, old=old, **kwargs)", "label": 1}
{"code": "function (member) {\n        _gpfAsserts({\n            \"Expected a _GpfClassDefMember\": member instanceof _GpfClassDefMember,\n            \"Member is already assigned to a class\": null === member._classDef\n        });\n        this._checkMemberBeforeAdd(member);\n        this._members[member.getName()] = member;\n        member._classDef = this;\n        return this;\n    }", "label": 3}
{"code": "function LanguagePicker(lang = 'en', config = {}) {\n  const scripts = ls.adjust({ override: dataOverrides });\n\n  this.userLang = lang;\n  this.nameTag = config.nameTag;\n  // The prefix is either given or is the nameTag\n  // with an underscore\n  // See Babel.js#24\n  this.prefix = config.multiTag || (this.nameTag && `${this.nameTag}_`) || '';\n  this.forceLocal = !!config.forceLocal;\n\n  if (this.forceLocal) {\n    // If we are forcing a local language, we don't need\n    // any of the fallback calculations\n    return;\n  }\n  // Store language script\n  this.langScript = scripts[lang] || 'Latn';\n\n  // Add known fallbacks for the language\n  let fallbacks;\n  if (config.languageMap) {\n    fallbacks = config.languageMap[lang];\n    if (fallbacks && !Array.isArray(fallbacks)) {\n      fallbacks = [fallbacks];\n    }\n  }\n  if (!fallbacks) {\n    fallbacks = [];\n  }\n\n  // Use the given language as first choice\n  fallbacks = [lang].concat(fallbacks);\n\n  // Remove duplicates\n  fallbacks = fallbacks.filter((item, i) => fallbacks.indexOf(item) === i);\n\n  // Add prefix to all languages if exists\n  // eslint-disable-next-line arrow-body-style\n  fallbacks = fallbacks.map((code) => {\n    return code === this.nameTag ? code : this.prefix + code;\n  });\n\n  // Store initial fallbacks\n  this.fallbacks = fallbacks;\n\n  this.prefixedEnglish = this.prefix ? `${this.prefix}en` : 'en';\n  this.prefixedLangScript = `-${this.langScript}`;\n}", "label": 3}
{"code": "public static function isBucketDnsCompatible($bucket)\n    {\n        $bucketLen = strlen($bucket);\n\n        return ($bucketLen >= 3 && $bucketLen <= 63) &&\n            // Cannot look like an IP address\n            !filter_var($bucket, FILTER_VALIDATE_IP) &&\n            preg_match('/^[a-z0-9]([a-z0-9\\-\\.]*[a-z0-9])?$/', $bucket);\n    }", "label": 2}
{"code": "private List getColumns(List fields)\r\n    {\r\n        ArrayList columns = new ArrayList();\r\n\r\n        for (Iterator it = fields.iterator(); it.hasNext();)\r\n        {\r\n            FieldDescriptorDef fieldDef = (FieldDescriptorDef)it.next();\r\n\r\n            columns.add(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_COLUMN));\r\n        }\r\n        return columns;\r\n    }", "label": 0}
{"code": "def check_region(read, pair, region):\n    \"\"\"\n    determine whether or not reads map to specific region of scaffold\n    \"\"\"\n    if region is False:\n        return True\n    for mapping in read, pair:\n        if mapping is False:\n            continue\n        start, length = int(mapping[3]), len(mapping[9])\n        r = [start, start + length - 1]\n        if get_overlap(r, region) > 0:\n            return True\n    return False", "label": 1}
{"code": "public List<DbLicense> getModuleLicenses(final String moduleId,\n                                             final LicenseMatcher licenseMatcher) {\n        final DbModule module = getModule(moduleId);\n\n        final List<DbLicense> licenses = new ArrayList<>();\n        final FiltersHolder filters = new FiltersHolder();\n        final ArtifactHandler artifactHandler = new ArtifactHandler(repositoryHandler, licenseMatcher);\n\n        for (final String gavc : DataUtils.getAllArtifacts(module)) {\n            licenses.addAll(artifactHandler.getArtifactLicenses(gavc, filters));\n        }\n\n        return licenses;\n    }", "label": 0}
{"code": "public function sendGetProfilePicture($number, $large = false)\n    {\n        $msgId = $this->nodeId['getprofilepic'] = $this->createIqId();\n\n        $hash = [];\n        $hash['type'] = 'image';\n        if (!$large) {\n            $hash['type'] = 'preview';\n        }\n        $picture = new ProtocolNode('picture', $hash, null, null);\n\n        $node = new ProtocolNode('iq',\n            [\n                'id'    => $msgId,\n                'type'  => 'get',\n                'xmlns' => 'w:profile:picture',\n                'to'    => $this->getJID($number),\n            ], [$picture], null);\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "func (info *HostCertificateInfo) FromCertificate(cert *x509.Certificate) *HostCertificateInfo {\n\tinfo.Certificate = cert\n\tinfo.subjectName = &cert.Subject\n\tinfo.issuerName = &cert.Issuer\n\n\tinfo.Issuer = info.fromName(info.issuerName)\n\tinfo.NotBefore = &cert.NotBefore\n\tinfo.NotAfter = &cert.NotAfter\n\tinfo.Subject = info.fromName(info.subjectName)\n\n\tinfo.ThumbprintSHA1 = soap.ThumbprintSHA1(cert)\n\n\t// SHA-256 for info purposes only, API fields all use SHA-1\n\tsum := sha256.Sum256(cert.Raw)\n\thex := make([]string, len(sum))\n\tfor i, b := range sum {\n\t\thex[i] = fmt.Sprintf(\"%02X\", b)\n\t}\n\tinfo.ThumbprintSHA256 = strings.Join(hex, \":\")\n\n\tif info.Status == \"\" {\n\t\tinfo.Status = string(types.HostCertificateManagerCertificateInfoCertificateStatusUnknown)\n\t}\n\n\treturn info\n}", "label": 5}
{"code": "func NetworkOptionGeneric(generic map[string]interface{}) NetworkOption {\n\treturn func(n *network) {\n\t\tif n.generic == nil {\n\t\t\tn.generic = make(map[string]interface{})\n\t\t}\n\t\tif val, ok := generic[netlabel.EnableIPv6]; ok {\n\t\t\tn.enableIPv6 = val.(bool)\n\t\t}\n\t\tif val, ok := generic[netlabel.Internal]; ok {\n\t\t\tn.internal = val.(bool)\n\t\t}\n\t\tfor k, v := range generic {\n\t\t\tn.generic[k] = v\n\t\t}\n\t}\n}", "label": 5}
{"code": "public void removeLinks(ServiceReference<S> declarationBinderRef) {\n        for (D declaration : linkerManagement.getMatchedDeclaration()) {\n            if (declaration.getStatus().getServiceReferencesBounded().contains(declarationBinderRef)) {\n                linkerManagement.unlink(declaration, declarationBinderRef);\n            }\n        }\n    }", "label": 0}
{"code": "function translateX(progress) {\n  var to = (this.options.to !== undefined) ? this.options.to : 0;\n  var from = (this.options.from !== undefined) ? this.options.from : 0;\n  var offset = (to - from) * progress + from;\n\n  this.transforms.position[0] = offset;\n}", "label": 3}
{"code": "function(){\n\t\tvar pkg = utils.extend({}, this.orig);\n\n\t\tvar isFlat = this.context.isFlatFileStructure;\n\t\tvar fileUrl = this.pkg.fileUrl;\n\t\tvar context = this.context;\n\n\t\tif(isFlat && !pkg.__crawledNestedPosition) {\n\t\t\tpkg.__crawledNestedPosition = true;\n\t\t\tpkg.nextFileUrl = pkg.nestedFileUrl;\n\t\t}\n\t\telse {\n\t\t\t// make sure we aren't loading something we've already loaded\n\t\t\tvar parentAddress = utils.path.parentNodeModuleAddress(fileUrl);\n\t\t\tif(!parentAddress) {\n\t\t\t\tthrow new Error('Did not find ' + pkg.origFileUrl);\n\t\t\t}\n\t\t\tvar nodeModuleAddress = parentAddress + \"/\" + pkg.name +\n\t\t\t\t\"/package.json\";\n\n\t\t\tpkg.nextFileUrl = nodeModuleAddress;\n\t\t}\n\n\t\treturn pkg;\n\t}", "label": 3}
{"code": "def node_name\n      path = self.class.to_s\n      if i = path.rindex('::')\n        path = path[(i+2)..-1]\n      end\n      path[0] = path[0].chr.downcase\n      path\n    end", "label": 4}
{"code": "public function setUptimeCheckConfigs($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Monitoring\\V3\\UptimeCheckConfig::class);\n        $this->uptime_check_configs = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func PgProcByPronameProargtypesPronamespace(db XODB, proname pgtypes.Name, proargtypes pgtypes.Oidvector, pronamespace pgtypes.Oid) (*PgProc, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, proname, pronamespace, proowner, prolang, procost, prorows, provariadic, protransform, proisagg, proiswindow, prosecdef, proleakproof, proisstrict, proretset, provolatile, pronargs, pronargdefaults, prorettype, proargtypes, proallargtypes, proargmodes, proargnames, proargdefaults, protrftypes, prosrc, probin, proconfig, proacl ` +\n\t\t`FROM pg_catalog.pg_proc ` +\n\t\t`WHERE proname = $1 AND proargtypes = $2 AND pronamespace = $3`\n\n\t// run query\n\tXOLog(sqlstr, proname, proargtypes, pronamespace)\n\tpp := PgProc{}\n\n\terr = db.QueryRow(sqlstr, proname, proargtypes, pronamespace).Scan(&pp.Tableoid, &pp.Cmax, &pp.Xmax, &pp.Cmin, &pp.Xmin, &pp.Oid, &pp.Ctid, &pp.Proname, &pp.Pronamespace, &pp.Proowner, &pp.Prolang, &pp.Procost, &pp.Prorows, &pp.Provariadic, &pp.Protransform, &pp.Proisagg, &pp.Proiswindow, &pp.Prosecdef, &pp.Proleakproof, &pp.Proisstrict, &pp.Proretset, &pp.Provolatile, &pp.Pronargs, &pp.Pronargdefaults, &pp.Prorettype, &pp.Proargtypes, &pp.Proallargtypes, &pp.Proargmodes, &pp.Proargnames, &pp.Proargdefaults, &pp.Protrftypes, &pp.Prosrc, &pp.Probin, &pp.Proconfig, &pp.Proacl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pp, nil\n}", "label": 5}
{"code": "private function rowInProgress(CellChunk $chunk)\n    {\n        $this->validateRowInProgress($chunk);\n        if ($chunk->getResetRow()) {\n            $this->reset();\n            return;\n        }\n        if ($chunk->getFamilyName()) {\n            $familyName = $chunk->getFamilyName()->getValue();\n            if (!isset($this->row[$familyName])) {\n                $this->row[$familyName] = [];\n            }\n            $this->family = &$this->row[$familyName];\n        }\n        if ($chunk->getQualifier()) {\n            $qualifierName = $chunk->getQualifier()->getValue();\n            if (!isset($this->family[$qualifierName])) {\n                $this->family[$qualifierName] = [];\n            }\n            $this->qualifiers = &$this->family[$qualifierName];\n        }\n        $labels = ($chunk->getLabels()->getIterator()->valid())\n            ? implode(iterator_to_array($chunk->getLabels()->getIterator()))\n            : '';\n        $qualifier = [\n            'value' => $chunk->getValue(),\n            'labels' => $labels,\n            'timeStamp' => $chunk->getTimestampMicros()\n        ];\n        $this->qualifierValue = &$qualifier['value'];\n        $this->qualifiers[] = &$qualifier;\n        $this->moveToNextState($chunk);\n    }", "label": 2}
{"code": "public static rnatip_stats get(nitro_service service, String Rnatip) throws Exception{\n\t\trnatip_stats obj = new rnatip_stats();\n\t\tobj.set_Rnatip(Rnatip);\n\t\trnatip_stats response = (rnatip_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (d *driver) restoreNetworkFromStore(nid string) *network {\n\tn := d.getNetworkFromStore(nid)\n\tif n != nil {\n\t\tn.driver = d\n\t\tn.endpoints = endpointTable{}\n\t\td.networks[nid] = n\n\t}\n\treturn n\n}", "label": 5}
{"code": "func (self *realKubeFramework) CreateServiceAccount(sa *v1.ServiceAccount) error {\n\t_, err := self.kubeClient.CoreV1().ServiceAccounts(sa.Namespace).Create(sa)\n\treturn err\n}", "label": 5}
{"code": "public function recordJob($connection, $queue, array $payload)\n    {\n        if (! Telescope::isRecording()) {\n            return;\n        }\n\n        $content = array_merge([\n            'status' => 'pending',\n        ], $this->defaultJobData($connection, $queue, $payload, $this->data($payload)));\n\n        Telescope::recordJob(\n            $entry = IncomingEntry::make($content)\n                        ->tags($this->tags($payload))\n        );\n\n        return $entry;\n    }", "label": 2}
{"code": "public function remove( $key ) {\n\t\tif ( ! $this->enabled ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$filename = $this->filename( $key );\n\n\t\tif ( file_exists( $filename ) ) {\n\t\t\treturn unlink( $filename );\n\t\t}\n\n\t\treturn false;\n\t}", "label": 2}
{"code": "def verify_version\n      app_version = options[:app_version]\n      UI.message(\"Making sure the latest version on App Store Connect matches '#{app_version}' from the ipa file...\")\n\n      changed = options[:app].ensure_version!(app_version, platform: options[:platform])\n\n      if changed\n        UI.success(\"Successfully set the version to '#{app_version}'\")\n      else\n        UI.success(\"'#{app_version}' is the latest version on App Store Connect\")\n      end\n    end", "label": 4}
{"code": "def rows_generator include_meta_data=false, use_simple_rows_format=false\n      path = if @sheetfile.start_with? \"/xl/\" or @sheetfile.start_with? \"xl/\" then @sheetfile else \"xl/#{@sheetfile}\" end\n      if @book.files.file.exist?(path)\n        # SAX parsing, Each element in the stream comes through as two events:\n        # one to open the element and one to close it.\n        opener = Nokogiri::XML::Reader::TYPE_ELEMENT\n        closer = Nokogiri::XML::Reader::TYPE_END_ELEMENT\n        Enumerator.new do |y|\n          row, cells, cell = nil, {}, nil\n          cell_type  = nil\n          cell_style_idx = nil\n          @book.files.file.open(path) do |xml|\n            Nokogiri::XML::Reader.from_io(xml).each do |node|\n              if (node.name.eql? 'row') and (node.node_type.eql? opener)\n                row = node.attributes\n                row['cells'] = Hash.new\n                cells = Hash.new\n                y << (include_meta_data ? row : cells) if node.self_closing?\n              elsif (node.name.eql? 'row') and (node.node_type.eql? closer)\n                processed_cells = fill_in_empty_cells(cells, row['r'], cell, use_simple_rows_format)\n\n                if @images_present\n                  processed_cells.each do |cell_name, cell_value|\n                    next unless cell_value.nil?\n                    processed_cells[cell_name] = images_at(cell_name)\n                  end\n                end\n\n                row['cells'] = processed_cells\n                y << (include_meta_data ? row : processed_cells)\n              elsif (node.name.eql? 'c') and (node.node_type.eql? opener)\n                cell_type      = node.attributes['t']\n                cell_style_idx = node.attributes['s']\n                cell           = node.attributes['r']\n              elsif (['v', 't'].include? node.name) and (node.node_type.eql? opener)\n                unless cell.nil?\n                  node.read\n                  cells[(use_simple_rows_format ? cell.tr(\"0-9\", \"\") : cell)] = convert(node.value, cell_type, cell_style_idx)\n                end\n              end\n            end\n          end\n        end\n      end\n    end", "label": 4}
{"code": "public function addCustomHydrationMode(string $modeName, string $hydratorClassName) : void\n    {\n        $this->customHydrationModes[$modeName] = $hydratorClassName;\n    }", "label": 2}
{"code": "def identify_col_pos(txt):\r\n\t\"\"\"\r\n\tassume no delimiter in this file, so guess the best\r\n\tfixed column widths to split by\r\n\t\"\"\"\r\n\tres = []\r\n\t#res.append(0)\r\n\tlines = txt.split('\\n')\r\n\tprev_ch = ''\r\n\tfor col_pos, ch in enumerate(lines[0]):\r\n\t\tif _is_white_space(ch) is False and _is_white_space(prev_ch) is True:\r\n\t\t\tres.append(col_pos)\r\n\t\tprev_ch = ch\r\n\tres.append(col_pos)\r\n\treturn res", "label": 1}
{"code": "function Entry(name, hash, status, mode, deed, registrationDate, value, highestBid) {\n  // TODO: improve Entry constructor so that unknown names can be handled via getEntry\n  this.name = name;\n  this.hash = hash;\n  this.status = status;\n  this.mode = mode;\n  this.deed = deed;\n  this.registrationDate = registrationDate;\n  this.value = value;\n  this.highestBid = highestBid;\n}", "label": 3}
{"code": "public static function passRequestToSocket($port = 8080, Request $request = null)\n    {\n        if (empty($request)) {\n            $request = Request::createFromGlobals();\n        }\n\n        $client = stream_socket_client('tcp://127.0.0.1:'.$port);\n        fwrite($client, json_encode([\n            'attributes' => $request->attributes->all(),\n            'query' => $request->query->all(),\n            'request' => $request->request->all(),\n            'content' => $request->getContent(),\n        ]));\n        fclose($client);\n    }", "label": 2}
{"code": "def default_build_settings(key: nil, optional: true)\n      options[:scheme] ||= schemes.first if is_workspace\n      build_settings(key: key, optional: optional)\n    end", "label": 4}
{"code": "func (this *sinkManager) ExportEvents(data *core.EventBatch) {\n\tvar wg sync.WaitGroup\n\tfor _, sh := range this.sinkHolders {\n\t\twg.Add(1)\n\t\tgo func(sh sinkHolder, wg *sync.WaitGroup) {\n\t\t\tdefer wg.Done()\n\t\t\tglog.V(2).Infof(\"Pushing events to: %s\", sh.sink.Name())\n\t\t\tselect {\n\t\t\tcase sh.eventBatchChannel <- data:\n\t\t\t\tglog.V(2).Infof(\"Data events completed: %s\", sh.sink.Name())\n\t\t\t\t// everything ok\n\t\t\tcase <-time.After(this.exportEventsTimeout):\n\t\t\t\tglog.Warningf(\"Failed to events data to sink: %s\", sh.sink.Name())\n\t\t\t}\n\t\t}(sh, &wg)\n\t}\n\t// Wait for all pushes to complete or timeout.\n\twg.Wait()\n}", "label": 5}
{"code": "private function detectProjectId(array $config)\n    {\n        $config += [\n            'httpHandler' => null,\n            'projectId' => null,\n            'projectIdRequired' => false,\n            'hasEmulator' => false,\n            'preferNumericProjectId' => false,\n            'suppressKeyFileNotice' => false\n        ];\n\n        if ($config['projectId']) {\n            return $config['projectId'];\n        }\n\n        if ($config['hasEmulator']) {\n            return 'emulator-project';\n        }\n\n        if (isset($config['keyFile'])) {\n            if (isset($config['keyFile']['project_id'])) {\n                return $config['keyFile']['project_id'];\n            }\n\n            if ($config['suppressKeyFileNotice'] !== true) {\n                $serviceAccountUri = 'https://cloud.google.com/iam/docs/' .\n                    'creating-managing-service-account-keys#creating_service_account_keys';\n\n                trigger_error(\n                    sprintf(\n                        'A keyfile was given, but it does not contain a project ' .\n                        'ID. This can indicate an old and obsolete keyfile, ' .\n                        'in which case you should create a new one. To suppress ' .\n                        'this message, set `suppressKeyFileNotice` to `true` in your client configuration. ' .\n                        'To learn more about generating new keys, see this URL: %s',\n                        $serviceAccountUri\n                    ),\n                    E_USER_NOTICE\n                );\n            }\n        }\n\n        if (getenv('GOOGLE_CLOUD_PROJECT')) {\n            return getenv('GOOGLE_CLOUD_PROJECT');\n        }\n\n        if (getenv('GCLOUD_PROJECT')) {\n            return getenv('GCLOUD_PROJECT');\n        }\n\n        if ($this->onGce($config['httpHandler'])) {\n            $metadata = $this->getMetaData();\n            $projectId = $config['preferNumericProjectId']\n                ? $metadata->getNumericProjectId()\n                : $metadata->getProjectId();\n            if ($projectId) {\n                return $projectId;\n            }\n        }\n\n        if ($config['projectIdRequired']) {\n            throw new GoogleException(\n                'No project ID was provided, ' .\n                'and we were unable to detect a default project ID.'\n            );\n        }\n    }", "label": 2}
{"code": "public static List<Dependency> getCorporateDependencies(final Module module, final List<String> corporateFilters) {\n        final List<Dependency> corporateDependencies = new ArrayList<Dependency>();\n        final Pattern corporatePattern = generateCorporatePattern(corporateFilters);\n\n        for(final Dependency dependency: getAllDependencies(module)){\n            if(dependency.getTarget().getGavc().matches(corporatePattern.pattern())){\n                corporateDependencies.add(dependency);\n            }\n        }\n\n        return corporateDependencies;\n    }", "label": 0}
{"code": "public function setRawHashes($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\WebRisk\\V1beta1\\RawHashes::class);\n        $this->raw_hashes = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def check_return_type(value, expected_type, strict_floats):\n    \"\"\"Checks that the given return value has the correct type.\n\n    :param value: Value returned by the method\n    :type value: object\n    :param expected_type: Expected return type\n    :type expected_type: type\n    :param strict_floats: If False, treat integers as floats\n    :type strict_floats: bool\n    \"\"\"\n    if expected_type is None:\n        if value is not None:\n            raise InvalidReturnTypeError(\"Returned value is '{}' but None was expected\"\n                                         .format(value))\n    elif not _is_instance(value, expected_type, strict_floats):\n        raise InvalidReturnTypeError(\"Type of return value '{}' does not match expected type {}\"\n                                     .format(value, expected_type))", "label": 1}
{"code": "def get_steam():\n  \"\"\"\n  Returns a Steam object representing the current Steam installation on the\n  users computer. If the user doesn't have Steam installed, returns None.\n  \"\"\"\n  # Helper function which checks if the potential userdata directory exists\n  # and returns a new Steam instance with that userdata directory if it does.\n  # If the directory doesnt exist it returns None instead\n  helper = lambda udd: Steam(udd) if os.path.exists(udd) else None\n\n  # For both OS X and Linux, Steam stores it's userdata in a consistent\n  # location.\n  plat = platform.system()\n  if plat == 'Darwin':\n    return helper(paths.default_osx_userdata_path())\n  if plat == 'Linux':\n    return helper(paths.default_linux_userdata_path())\n\n  # Windows is a bit trickier. The userdata directory is stored in the Steam\n  # installation directory, meaning that theoretically it could be anywhere.\n  # Luckily, Valve stores the installation directory in the registry, so its\n  # still possible for us to figure out automatically\n  if plat == 'Windows':\n    possible_dir = winutils.find_userdata_directory()\n    # Unlike the others, `possible_dir` might be None (if something odd\n    # happened with the registry)\n    return helper(possible_dir) if possible_dir is not None else None\n  # This should never be hit. Windows, OS X, and Linux should be the only\n  # supported platforms.\n  # TODO: Add logging here so that the user (developer) knows that something\n  # odd happened.\n  return None", "label": 1}
{"code": "public function setLandmarks($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\FaceAnnotation\\Landmark::class);\n        $this->landmarks = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def edit_shares(self, id, user_ids): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Edit shares for a config.\n\n        :param id: Config ID as an int.\n        :param user_ids: User IDs as int list.\n        :return: :class:`cdrouter.Share <cdrouter.Share>` list\n        \"\"\"\n        return self.service.edit_shares(self.base, id, user_ids)", "label": 1}
{"code": "func (a *ArgType) hasfield(fields []*Field, name string) bool {\n\tfor _, f := range fields {\n\t\tif f.Name == name {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "label": 5}
{"code": "public static gslbservice_stats get(nitro_service service, String servicename) throws Exception{\n\t\tgslbservice_stats obj = new gslbservice_stats();\n\t\tobj.set_servicename(servicename);\n\t\tgslbservice_stats response = (gslbservice_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (a *HistoricalApi) podContainerAggregations(request *restful.Request, response *restful.Response) {\n\tvar key core.HistoricalKey\n\tif request.PathParameter(\"pod-id\") != \"\" {\n\t\tkey = core.HistoricalKey{\n\t\t\tObjectType:    core.MetricSetTypePodContainer,\n\t\t\tPodId:         request.PathParameter(\"pod-id\"),\n\t\t\tContainerName: request.PathParameter(\"container-name\"),\n\t\t}\n\t} else {\n\t\tkey = core.HistoricalKey{\n\t\t\tObjectType:    core.MetricSetTypePodContainer,\n\t\t\tNamespaceName: request.PathParameter(\"namespace-name\"),\n\t\t\tPodName:       request.PathParameter(\"pod-name\"),\n\t\t\tContainerName: request.PathParameter(\"container-name\"),\n\t\t}\n\t}\n\ta.processAggregationRequest(key, request, response)\n}", "label": 5}
{"code": "async function main() { // eslint-disable-line no-unused-vars\n  try {\n    // `path` is the absolute path to the executable.\n    const path = await which('foobar');\n    console.log(`The command \"foobar\" is located at: ${path}`);\n  }\n\n  catch (err) {\n    // `err` is an instance of `FinderError`.\n    console.log(`The command \"${err.command}\" was not found`);\n  }\n}", "label": 3}
{"code": "async def load_varint(reader):\n    \"\"\"\n    Binary load of variable size integer serialized by dump_varint\n\n    :param reader:\n    :return:\n    \"\"\"\n    buffer = _UINT_BUFFER\n\n    await reader.areadinto(buffer)\n    width = int_mark_to_size(buffer[0] & PortableRawSizeMark.MASK)\n    result = buffer[0]\n\n    shift = 8\n    for _ in range(width-1):\n        await reader.areadinto(buffer)\n        result += buffer[0] << shift\n        shift += 8\n    return result >> 2", "label": 1}
{"code": "function getSubmissionFile(req, res, next) {\n  var params = {\"_id\": req.params.fileId};\n  logger.debug(\"Middleware getSubmissionFile \", {params: params});\n  forms.getSubmissionFile(req.connectionOptions, params, submissionsHandler(constants.resultTypes.submissions, req, next));\n}", "label": 3}
{"code": "def mp_iuwt_recomposition(in1, scale_adjust, core_count, smoothed_array):\n    \"\"\"\n    This function calls the a trous algorithm code to recompose the input into a single array. This is the\n    implementation of the isotropic undecimated wavelet transform recomposition for multiple CPU cores.\n\n    INPUTS:\n    in1             (no default):   Array containing wavelet coefficients.\n    scale_adjust    (no default):   Indicates the number of omitted array pages.\n    core_count      (no default):   Indicates the number of cores to be used.\n    smoothed_array  (default=None): For a complete inverse transform, this must be the smoothest approximation.\n\n    OUTPUTS:\n    recomposiiton                   Array containing the reconstructed image.\n    \"\"\"\n\n    wavelet_filter = (1./16)*np.array([1,4,6,4,1])      # Filter-bank for use in the a trous algorithm.\n\n    # Determines scale with adjustment and creates a zero array to store the output, unless smoothed_array is given.\n\n    max_scale = in1.shape[0] + scale_adjust\n\n    if smoothed_array is None:\n        recomposition = np.zeros([in1.shape[1], in1.shape[2]])\n    else:\n        recomposition = smoothed_array\n\n    # The following loops call the a trous algorithm code to recompose the input. The first loop assumes that there are\n    # non-zero wavelet coefficients at scales above scale_adjust, while the second loop completes the recomposition\n    # on the scales less than scale_adjust.\n\n    for i in range(max_scale-1, scale_adjust-1, -1):\n        recomposition = mp_a_trous(recomposition, wavelet_filter, i, core_count) + in1[i-scale_adjust,:,:]\n\n    if scale_adjust>0:\n        for i in range(scale_adjust-1, -1, -1):\n            recomposition = mp_a_trous(recomposition, wavelet_filter, i, core_count)\n\n    return recomposition", "label": 1}
{"code": "def _get_name(self):\n        \"\"\" Returns the name, which is generated if it has not been already.\n        \"\"\"\n        if self._name is None:\n            self._name = self._generate_name()\n        return self._name", "label": 1}
{"code": "public function getByName(string $name): Conversion\n    {\n        $conversion = $this->first(function (Conversion $conversion) use ($name) {\n            return $conversion->getName() === $name;\n        });\n\n        if (! $conversion) {\n            throw InvalidConversion::unknownName($name);\n        }\n\n        return $conversion;\n    }", "label": 2}
{"code": "function nonPaginateList(formSubmissionModel, params, callback) {\n  logger.debug(\"nonPaginateList\", params);\n  var submissionQuery = formSubmissionModel.find(params.query || {});\n  var fieldModel = params.fieldModel;\n\n  //Sorting can be defined by the user\n  var sortBy = params.sortBy || {\n    submissionCompletedTimestamp: -1\n  };\n\n  //If the full submission is not required, then limit the response payload size.\n  if (!params.includeFullSubmission) {\n    submissionQuery.select({\"formSubmittedAgainst.name\": 1, \"_id\": 1, \"formId\": 1, \"appId\": 1, \"appEnvironment\": 1, \"formFields\": 1});\n  }\n\n  submissionQuery.sort(sortBy)\n  .populate({\"path\": \"formFields.fieldId\", \"model\": fieldModel, \"select\": \"_id type name\"})\n  //Assigning a lean query to not parse the response as a mongoose document. This is to improve query performance.\n  .lean()\n  .exec(function(err, foundSubmissions) {\n    handleListResult(err, params, foundSubmissions, callback);\n  });\n}", "label": 3}
{"code": "function(a, b, aParent, bParent, prop, compares, options){\n\t\t// if everything is the same OR doesn't have a property on the left or right (only)\n\t\t// and union values\n\t\toptions.result = {};\n\t\toptions.performedUnion = 0;\n\t\toptions.checks = [\n\t\t\tcompareHelpers.unionComparesType,\n\t\t\taddToResult(compareHelpers.equalBasicTypes, \"equalBasicTypes\"),\n\t\t\taddToResult(compareHelpers.unionArrayLike, \"unionArrayLike\"),\n\t\t\taddResultsToNewObject(compareHelpers.unionObject, \"unionObject\")\n\t\t];\n\t\toptions.getUnions = [];\n\n\t\toptions[\"default\"] = false;\n\n\t\tvar res = loop(a, b, aParent, bParent, prop, compares, options);\n\t\tif(res === true) {\n\t\t\treturn options.result;\n\t\t}\n\t\treturn false;\n\t}", "label": 3}
{"code": "private void addModuleToTree(final DbModule module, final TreeNode tree) {\n        final TreeNode subTree = new TreeNode();\n        subTree.setName(module.getName());\n        tree.addChild(subTree);\n\n        // Add SubsubModules\n        for (final DbModule subsubmodule : module.getSubmodules()) {\n            addModuleToTree(subsubmodule, subTree);\n        }\n    }", "label": 0}
{"code": "function (a, b) {\n        if (null === a || null === b || \"object\" !== typeof a) {\n            return false; // Because we know that a !== b\n        }\n        this._stack(a, b);\n        return true;\n    }", "label": 3}
{"code": "public static function wrap(\n        Service $service,\n        callable $bytesGenerator = null\n    ) {\n        return function (callable $handler) use ($service, $bytesGenerator) {\n            return new self($handler, $service, $bytesGenerator);\n        };\n    }", "label": 2}
{"code": "func (c *Manager) GetTagForCategory(ctx context.Context, id, category string) (*Tag, error) {\n\tif category == \"\" {\n\t\treturn c.GetTag(ctx, id)\n\t}\n\n\tids, err := c.ListTagsForCategory(ctx, category)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, tagid := range ids {\n\t\ttag, err := c.GetTag(ctx, tagid)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"get tag for category %s %s: %s\", category, tagid, err)\n\t\t}\n\t\tif tag.ID == id || tag.Name == id {\n\t\t\treturn tag, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"tag %q not found in category %q\", id, category)\n}", "label": 5}
{"code": "def form_for_filterrific(record, options = {}, &block)\n      options[:as] ||= :filterrific\n      options[:html] ||= {}\n      options[:html][:method] ||= :get\n      options[:html][:id] ||= :filterrific_filter\n      options[:url] ||= url_for(\n        :controller => controller.controller_name,\n        :action => controller.action_name\n      )\n      form_for(record, options, &block)\n    end", "label": 4}
{"code": "func (a *HistoricalApi) nodeList(request *restful.Request, response *restful.Response) {\n\tif resp, err := a.historicalSource.GetNodes(); err != nil {\n\t\tresponse.WriteError(http.StatusInternalServerError, err)\n\t} else {\n\t\tresponse.WriteEntity(resp)\n\t}\n}", "label": 5}
{"code": "function (input, encoding) {\n        var module = _gpfEncodings[encoding];\n        if (undefined === module) {\n            gpf.Error.encodingNotSupported();\n        }\n        return new EncoderStream(module[0], input);\n    }", "label": 3}
{"code": "def target_schema(link)\n      if link.target_schema\n        link.target_schema\n      elsif legacy_hyper_schema_rel?(link)\n        link.parent\n      end\n    end", "label": 4}
{"code": "public function batch($instanceId, $databaseId)\n    {\n        $operation = new Operation(\n            $this->connection,\n            $this->returnInt64AsObject\n        );\n\n        return new BatchClient(\n            $operation,\n            GapicSpannerClient::databaseName(\n                $this->projectId,\n                $instanceId,\n                $databaseId\n            )\n        );\n    }", "label": 2}
{"code": "public boolean checkSuffixes(String uri, String[] patterns) {\n\t\tfor (String pattern : patterns) {\n\t\t\tif (pattern.length() > 0) {\n\t\t\t\tif (uri.endsWith(pattern)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "label": 0}
{"code": "def abs_thresholds(scale, max_value)\n      at = []\n      scale.each { |v|\n        at.push(v * max_value)\n      }\n      return at\n    end", "label": 4}
{"code": "def objparse(ts)\n    ts = eat('{', ts)\n    obj = {}\n\n    if ts[0][0] == '}'\n      return obj, ts[1..-1]\n    end\n\n    k, v, ts = pairparse(ts)\n    obj[k] = v\n\n    if ts[0][0] == '}'\n      return obj, ts[1..-1]\n    end\n\n    loop do\n      ts = eat(',', ts)\n\n      k, v, ts = pairparse(ts)\n      obj[k] = v\n\n      if ts[0][0] == '}'\n        return obj, ts[1..-1]\n      end\n    end\n  end", "label": 4}
{"code": "public function setFalseMutations($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Bigtable\\V2\\Mutation::class);\n        $this->false_mutations = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function processGroupArray($phone, $groupArray)\n    {\n        $formattedGroups = [];\n\n        if (!empty($groupArray)) {\n            foreach ($groupArray as $group) {\n                $formattedGroups[] = ['name' => 'GROUP: '.$group['subject'], 'id' => $group['id']];\n            }\n\n            $this->waGroupList = $formattedGroups;\n\n            return true;\n        }\n\n        return false;\n    }", "label": 2}
{"code": "def attributes_for_actor\n        raw_params = params[hash_key_for_curation_concern]\n        attributes = if raw_params\n                       work_form_service.form_class(curation_concern).model_attributes(raw_params)\n                     else\n                       {}\n                     end\n\n        # If they selected a BrowseEverything file, but then clicked the\n        # remove button, it will still show up in `selected_files`, but\n        # it will no longer be in uploaded_files. By checking the\n        # intersection, we get the files they added via BrowseEverything\n        # that they have not removed from the upload widget.\n        uploaded_files = params.fetch(:uploaded_files, [])\n        selected_files = params.fetch(:selected_files, {}).values\n        browse_everything_urls = uploaded_files &\n                                 selected_files.map { |f| f[:url] }\n\n        # we need the hash of files with url and file_name\n        browse_everything_files = selected_files\n                                  .select { |v| uploaded_files.include?(v[:url]) }\n        attributes[:remote_files] = browse_everything_files\n        # Strip out any BrowseEverthing files from the regular uploads.\n        attributes[:uploaded_files] = uploaded_files -\n                                      browse_everything_urls\n        attributes\n      end", "label": 4}
{"code": "public function diffInRealSeconds($date = null, $absolute = true)\n    {\n        /** @var CarbonInterface $date */\n        $date = $this->resolveCarbon($date);\n        $value = $date->getTimestamp() - $this->getTimestamp();\n\n        return $absolute ? abs($value) : $value;\n    }", "label": 2}
{"code": "func (v VirtualMachine) BootOptions(ctx context.Context) (*types.VirtualMachineBootOptions, error) {\n\tvar o mo.VirtualMachine\n\n\terr := v.Properties(ctx, v.Reference(), []string{\"config.bootOptions\"}, &o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn o.Config.BootOptions, nil\n}", "label": 5}
{"code": "function(value, attr, required, model, computed) {\n        var isRequired = _.isFunction(required) ? required.call(model, value, attr, computed) : required;\n        if(!isRequired && !hasValue(value)) {\n          return false; // overrides all other validators\n        }\n        if (isRequired && !hasValue(value)) {\n          return this.format(getMessageKey(this.msgKey, defaultMessages.required), this.formatLabel(attr, model));\n        }\n      }", "label": 3}
{"code": "public static appfwprofile_stats get(nitro_service service, String name) throws Exception{\n\t\tappfwprofile_stats obj = new appfwprofile_stats();\n\t\tobj.set_name(name);\n\t\tappfwprofile_stats response = (appfwprofile_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func NewTerminalParamsFromUint32(w uint32, h uint32) (*TerminalParams, error) {\n\tif w > maxSize || w < minSize {\n\t\treturn nil, trace.BadParameter(\"bad width\")\n\t}\n\tif h > maxSize || h < minSize {\n\t\treturn nil, trace.BadParameter(\"bad height\")\n\t}\n\treturn &TerminalParams{W: int(w), H: int(h)}, nil\n}", "label": 5}
{"code": "def produce(epubfile, basedir, tmpdir)\n      produce_write_common(basedir, tmpdir)\n\n      File.open(\"#{tmpdir}/OEBPS/#{@producer.config['bookname']}.ncx\", 'w') do |f|\n        @producer.ncx(f, @producer.config['epubmaker']['ncxindent'])\n      end\n      if @producer.config['mytoc']\n        File.open(\"#{tmpdir}/OEBPS/#{@producer.config['bookname']}-toc.#{@producer.config['htmlext']}\", 'w') do |f|\n          @producer.mytoc(f)\n        end\n      end\n\n      @producer.call_hook(@producer.config['epubmaker']['hook_prepack'], tmpdir)\n      expoter = EPUBMaker::ZipExporter.new(tmpdir, @producer.config)\n      expoter.export_zip(epubfile)\n    end", "label": 4}
{"code": "private function hasExpectedBase($org, $repo, $version)\n    {\n        $url = sprintf(\n            self::GITHUB_RELEASES_ENDPOINT,\n            $org,\n            $repo,\n            $version\n        );\n\n        try {\n            $res = $this->http->get($url, [\n                'auth' => [null, $this->token]\n            ]);\n            return true;\n        } catch (RequestException $e) {\n            return false;\n        }\n    }", "label": 2}
{"code": "private int getPositiveInteger(String number) {\n    try {\n      return Math.max(0, Integer.parseInt(number));\n    } catch (NumberFormatException e) {\n      return 0;\n    }\n  }", "label": 0}
{"code": "def process_deny_action(processors, action, argument):\n    \"\"\"Process deny action.\"\"\"\n    for processor in processors:\n        processor(action, argument)\n    db.session.commit()", "label": 1}
{"code": "func (t *FpdfTpl) Size() (corner PointType, size SizeType) {\n\treturn t.corner, t.size\n}", "label": 5}
{"code": "function parse_files(files, options, callback) {\n  var nodes = {\n    // root section node\n    '': {\n      id: '',\n      type: 'section',\n      children: [],\n      description: '',\n      short_description: '',\n      href: '#',\n      root: true,\n      file: '',\n      line: 0\n    }\n  };\n\n  var reportObject = { };\n  \n  async.forEachSeries(files, function (file, next_file) {\n    var fn = parsers[path.extname(file)];\n\n    if (!fn) {\n      next_file();\n      return;\n    }\n\n    console.info('Parsing file: ' + file);\n    fn(file, options, function (err, file_nodes, file_report) {\n      // TODO:  fail on name clash here as well -- as we might get name clash\n      //        from different parsers, or even different files\n      _.extend(nodes, file_nodes);\n      _.extend(reportObject, file_report);\n      next_file(err);\n    });\n  }, function (err) {\n    callback(err, nodes, reportObject);\n  });\n}", "label": 3}
{"code": "public static base_response update(nitro_service client, inat resource) throws Exception {\n\t\tinat updateresource = new inat();\n\t\tupdateresource.name = resource.name;\n\t\tupdateresource.privateip = resource.privateip;\n\t\tupdateresource.tcpproxy = resource.tcpproxy;\n\t\tupdateresource.ftp = resource.ftp;\n\t\tupdateresource.tftp = resource.tftp;\n\t\tupdateresource.usip = resource.usip;\n\t\tupdateresource.usnip = resource.usnip;\n\t\tupdateresource.proxyip = resource.proxyip;\n\t\tupdateresource.mode = resource.mode;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function getWildcardDirectories(include, exclude, path, useCaseSensitiveFileNames) {\n        // We watch a directory recursively if it contains a wildcard anywhere in a directory segment\n        // of the pattern:\n        //\n        //  /a/b/**/d   - Watch /a/b recursively to catch changes to any d in any subfolder recursively\n        //  /a/b/*/d    - Watch /a/b recursively to catch any d in any immediate subfolder, even if a new subfolder is added\n        //\n        // We watch a directory without recursion if it contains a wildcard in the file segment of\n        // the pattern:\n        //\n        //  /a/b/*      - Watch /a/b directly to catch any new file\n        //  /a/b/a?z    - Watch /a/b directly to catch any new file matching a?z\n        var rawExcludeRegex = ts.getRegularExpressionForWildcard(exclude, path, \"exclude\");\n        var excludeRegex = rawExcludeRegex && new RegExp(rawExcludeRegex, useCaseSensitiveFileNames ? \"\" : \"i\");\n        var wildcardDirectories = ts.createMap();\n        if (include !== undefined) {\n            var recursiveKeys = [];\n            for (var _i = 0, include_1 = include; _i < include_1.length; _i++) {\n                var file = include_1[_i];\n                var name_36 = ts.normalizePath(ts.combinePaths(path, file));\n                if (excludeRegex && excludeRegex.test(name_36)) {\n                    continue;\n                }\n                var match = wildcardDirectoryPattern.exec(name_36);\n                if (match) {\n                    var key = useCaseSensitiveFileNames ? match[0] : match[0].toLowerCase();\n                    var flags = watchRecursivePattern.test(name_36) ? 1 /* Recursive */ : 0 /* None */;\n                    var existingFlags = wildcardDirectories[key];\n                    if (existingFlags === undefined || existingFlags < flags) {\n                        wildcardDirectories[key] = flags;\n                        if (flags === 1 /* Recursive */) {\n                            recursiveKeys.push(key);\n                        }\n                    }\n                }\n            }\n            // Remove any subpaths under an existing recursively watched directory.\n            for (var key in wildcardDirectories) {\n                for (var _a = 0, recursiveKeys_1 = recursiveKeys; _a < recursiveKeys_1.length; _a++) {\n                    var recursiveKey = recursiveKeys_1[_a];\n                    if (key !== recursiveKey && ts.containsPath(recursiveKey, key, path, !useCaseSensitiveFileNames)) {\n                        delete wildcardDirectories[key];\n                    }\n                }\n            }\n        }\n        return wildcardDirectories;\n    }", "label": 3}
{"code": "func FailCommand(err error) *HTTPResult {\n\treturn &HTTPResult{\n\t\tMessage: \"FAIL\",\n\t\tDetails: &ErrorCmd{Error: err.Error()},\n\t}\n}", "label": 5}
{"code": "def get_path(url):\n    \"\"\"\n    Get the path from a given url, including the querystring.\n\n    Args:\n        url (str)\n    Returns:\n        str\n\n    \"\"\"\n\n    url = urlsplit(url)\n    path = url.path\n    if url.query:\n        path += \"?{}\".format(url.query)\n    return path", "label": 1}
{"code": "public function setArrayConfig($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Firestore\\Admin\\V1\\Index_IndexField_ArrayConfig::class);\n        $this->writeOneof(3, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def paused?(topic, partition)\n      pause = pause_for(topic, partition)\n      pause.paused? && !pause.expired?\n    end", "label": 4}
{"code": "def _check_point(self, lat, lng):\n        \"\"\" Checks if latitude and longitude correct \"\"\"\n        if abs(lat) > 90 or abs(lng) > 180:\n            msg = \"Illegal lat and/or lng, (%s, %s) provided.\" % (lat, lng)\n            raise IllegalPointException(msg)", "label": 1}
{"code": "public static filteraction[] get(nitro_service service) throws Exception{\n\t\tfilteraction obj = new filteraction();\n\t\tfilteraction[] response = (filteraction[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def upload_messages_screenshot(app_version, upload_image, device)\n      raise \"app_version is required\" unless app_version\n      raise \"upload_image is required\" unless upload_image\n      raise \"device is required\" unless device\n\n      du_client.upload_messages_screenshot(app_version, upload_image, content_provider_id, sso_token_for_image, device)\n    end", "label": 4}
{"code": "def select_collection(collection)\n      first('a.select2-choice').click\n      find('.select2-input').set(collection.title.first)\n      expect(page).to have_css('div.select2-result-label')\n      first('div.select2-result-label').click\n      first('[data-behavior~=add-relationship]').click\n      within('[data-behavior~=collection-relationships]') do\n        within('table.table.table-striped') do\n          expect(page).to have_content(collection.title.first)\n        end\n      end\n    end", "label": 4}
{"code": "public function withHeader($key, $value, $replace = true)\n    {\n        return $this->header($key, $value, $replace);\n    }", "label": 2}
{"code": "function renderSummaryDetails(rules, problemFiles, currDir) {\n\tlet summaryDetails = '<div class=\"row\">';\n\n\t// errors exist\n\tif (rules['2']) {\n\t\tsummaryDetails += summaryDetailsTemplate({\n\t\t\truleType: 'error',\n\t\t\ttopRules: renderRules(rules['2'])\n\t\t});\n\t}\n\n\t// warnings exist\n\tif (rules['1']) {\n\t\tsummaryDetails += summaryDetailsTemplate({\n\t\t\truleType: 'warning',\n\t\t\ttopRules: renderRules(rules['1'])\n\t\t});\n\t}\n\n\tsummaryDetails += '</div>';\n\n\t// files with problems exist\n\tif (!_.isEmpty(problemFiles)) {\n\t\tsummaryDetails += mostProblemsTemplate({\n\t\t\tfiles: renderProblemFiles(problemFiles, currDir)\n\t\t});\n\t}\n\n\treturn summaryDetails;\n}", "label": 3}
{"code": "def acknowledge(self, status):\n        \"\"\"Acknowledges the status update.\n\n        This should only be called once the status update is processed durably\n        by the scheduler.\n\n        Not that explicit acknowledgements must be requested via the constructor\n        argument, otherwise a call to this method will cause the driver to\n        crash.\n        \"\"\"\n        logging.info('Acknowledges status update {}'.format(status))\n        return self.driver.acknowledgeStatusUpdate(encode(status))", "label": 1}
{"code": "func (f *file) lintErrors() {\n\tfor _, decl := range f.f.Decls {\n\t\tgd, ok := decl.(*ast.GenDecl)\n\t\tif !ok || gd.Tok != token.VAR {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, spec := range gd.Specs {\n\t\t\tspec := spec.(*ast.ValueSpec)\n\t\t\tif len(spec.Names) != 1 || len(spec.Values) != 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tce, ok := spec.Values[0].(*ast.CallExpr)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !isPkgDot(ce.Fun, \"errors\", \"New\") && !isPkgDot(ce.Fun, \"fmt\", \"Errorf\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tid := spec.Names[0]\n\t\t\tprefix := \"err\"\n\t\t\tif id.IsExported() {\n\t\t\t\tprefix = \"Err\"\n\t\t\t}\n\t\t\tif !strings.HasPrefix(id.Name, prefix) {\n\t\t\t\tf.errorf(id, 0.9, category(\"naming\"), \"error var %s should have name of the form %sFoo\", id.Name, prefix)\n\t\t\t}\n\t\t}\n\t}\n}", "label": 5}
{"code": "func (p *PortList) PopIntSlice(num int) []int {\n\tports := make([]int, num)\n\tfor i := range ports {\n\t\tports[i] = p.PopInt()\n\t}\n\treturn ports\n}", "label": 5}
{"code": "def scroll_to(text, scrollable_index = 0)\n      text = %(\"#{text}\")\n      rid  = resource_id(text, \"new UiSelector().resourceId(#{text})\")\n      args = rid.empty? ? [\"new UiSelector().textContains(#{text})\", \"new UiSelector().descriptionContains(#{text})\"] : [rid]\n      args.each_with_index do |arg, index|\n        begin\n          elem = find_element :uiautomator, scroll_uiselector(arg, scrollable_index)\n          return elem\n        rescue StandardError => e\n          raise e if index == args.size - 1\n        end\n      end\n    end", "label": 4}
{"code": "def []=(index, v)\n      DataTypeValidator.validate :SimpleTypedList_insert, @allowed_types, v\n      raise ArgumentError, \"Item is protected and cannot be changed\" if protected? index\n      @list[index] = v\n      v\n    end", "label": 4}
{"code": "function getOwnKeys(map) {\n        var keys = [];\n        for (var key in map)\n            if (hasOwnProperty.call(map, key)) {\n                keys.push(key);\n            }\n        return keys;\n    }", "label": 3}
{"code": "def task_definition_error(e)\n      error_info = e.backtrace.first\n      path, line_no, _ = error_info.split(':')\n      line_no = line_no.to_i\n      puts \"Error evaluating #{path}:\".color(:red)\n      puts e.message\n      puts \"Here's the line in #{path} with the error:\\n\\n\"\n\n      contents = IO.read(path)\n      content_lines = contents.split(\"\\n\")\n      context = 5 # lines of context\n      top, bottom = [line_no-context-1, 0].max, line_no+context-1\n      spacing = content_lines.size.to_s.size\n      content_lines[top..bottom].each_with_index do |line_content, index|\n        line_number = top+index+1\n        if line_number == line_no\n          printf(\"%#{spacing}d %s\\n\".color(:red), line_number, line_content)\n        else\n          printf(\"%#{spacing}d %s\\n\", line_number, line_content)\n        end\n      end\n    end", "label": 4}
{"code": "function ccw(c) {\n    var n = c.length\n    var area = [0]\n    for(var j=0; j<n; ++j) {\n      var a = positions[c[j]]\n      var b = positions[c[(j+1)%n]]\n      var t00 = twoProduct(-a[0], a[1])\n      var t01 = twoProduct(-a[0], b[1])\n      var t10 = twoProduct( b[0], a[1])\n      var t11 = twoProduct( b[0], b[1])\n      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)))\n    }\n    return area[area.length-1] > 0\n  }", "label": 3}
{"code": "def is_dragon(host, timeout=1):\n        \"\"\"\n        Check if host is a dragon.\n\n        Check if the specified host is a dragon based on simple heuristic.\n        The code simply checks if particular strings are in the index page.\n        It should work for DragonMint or Innosilicon branded miners.\n        \"\"\"\n        try:\n            r = requests.get('http://{}/'.format(host), timeout=timeout)\n            if r.status_code == 200:\n                if '<title>DragonMint</title>' in r.text or \\\n                        '<title>AsicMiner</title>' in r.text:\n                    return True\n        except requests.exceptions.RequestException:\n            pass\n        return False", "label": 1}
{"code": "public function getFillable()\n    {\n        if (!$this->fillable) {\n            return '[]';\n        }\n        $results = '[' . PHP_EOL;\n\n        foreach ($this->getSchemaParser()->toArray() as $column => $value) {\n            $results .= \"\\t\\t'{$column}',\" . PHP_EOL;\n        }\n\n        return $results . \"\\t\" . ']';\n    }", "label": 2}
{"code": "def _convert_agent_types(ind, to_string=False, **kwargs):\n    '''Convenience method to allow specifying agents by class or class name.'''\n    if to_string:\n        return serialize_distribution(ind, **kwargs)\n    return deserialize_distribution(ind, **kwargs)", "label": 1}
{"code": "public static int[] Concatenate(int[] array, int[] array2) {\n        int[] all = new int[array.length + array2.length];\n        int idx = 0;\n\n        //First array\n        for (int i = 0; i < array.length; i++)\n            all[idx++] = array[i];\n\n        //Second array\n        for (int i = 0; i < array2.length; i++)\n            all[idx++] = array2[i];\n\n        return all;\n    }", "label": 0}
{"code": "function (silent) {\n\t\t\t\t\tif(options.on_destroy) {\n\t\t\t\t\t\toptions.on_destroy.call(options.context, silent);\n\t\t\t\t\t}\n\t\t\t\t\tnode.destroy(silent);\n\t\t\t\t}", "label": 3}
{"code": "def validate(mcs, bases, attributes):\n        \"\"\"Check attributes.\"\"\"\n        if bases[0] is object:\n            return None\n        mcs.check_model_cls(attributes)\n        mcs.check_include_exclude(attributes)\n        mcs.check_properties(attributes)", "label": 1}
{"code": "def load!\n      load_default_stack\n      stack.each { |m, args, block| builder.use(load_middleware(m), *args, &block) }\n      builder.run routes\n\n      self\n    end", "label": 4}
{"code": "public function contains($entity)\n    {\n        return $this->unitOfWork->isScheduledForInsert($entity)\n            || ($this->unitOfWork->isInIdentityMap($entity) && ! $this->unitOfWork->isScheduledForDelete($entity));\n    }", "label": 2}
{"code": "function validateExtensions(input) {\n  return new Promise((resolve, reject) => {\n    try {\n      const extensionPath = getExtensionsPath();\n\n      if (!fs.existsSync(extensionPath)) {\n        fs.mkdirSync(extensionPath);\n      }\n\n      if (!input.imports.length) {\n        return resolve(null);\n      }\n\n      return resolve(input);\n    } catch (e) {\n      return reject(new Error(t('EXTENSION_COULD_NOT_BE_VALIDATED')));\n    }\n  });\n}", "label": 3}
{"code": "def singledispatch(function):  # noqa\n    \"\"\"Single-dispatch generic function decorator.\n\n    Transforms a function into a generic function, which can have different\n    behaviours depending upon the type of its first argument. The decorated\n    function acts as the default implementation, and additional\n    implementations can be registered using the register() attribute of the\n    generic function.\n\n    \"\"\"\n    registry = {}\n    dispatch_cache = WeakKeyDictionary()\n\n    def ns():\n        pass\n\n    ns.cache_token = None\n\n    # noinspection PyIncorrectDocstring\n    def dispatch(cls):\n        \"\"\"generic_func.dispatch(cls) -> <function implementation>\n\n        Runs the dispatch algorithm to return the best available implementation\n        for the given *cls* registered on *generic_func*.\n\n        \"\"\"\n        if ns.cache_token is not None:\n            current_token = get_cache_token()\n            if ns.cache_token != current_token:\n                dispatch_cache.clear()\n                ns.cache_token = current_token\n        try:\n            impl = dispatch_cache[cls]\n        except KeyError:\n            try:\n                impl = registry[cls]\n            except KeyError:\n                impl = _find_impl(cls, registry)\n            dispatch_cache[cls] = impl\n        return impl\n\n    # noinspection PyIncorrectDocstring\n    def register(cls, func=None):\n        \"\"\"generic_func.register(cls, func) -> func\n\n        Registers a new implementation for the given *cls* on a *generic_func*.\n\n        \"\"\"\n        if func is None:\n            return lambda f: register(cls, f)\n        registry[cls] = func\n        if ns.cache_token is None and hasattr(cls, '__abstractmethods__'):\n            ns.cache_token = get_cache_token()\n        dispatch_cache.clear()\n        return func\n\n    def wrapper(*args, **kw):\n        return dispatch(args[0].__class__)(*args, **kw)\n\n    registry[object] = function\n    wrapper.register = register\n    wrapper.dispatch = dispatch\n    wrapper.registry = MappingProxyType(registry)\n    wrapper._clear_cache = dispatch_cache.clear\n    update_wrapper(wrapper, function)\n    return wrapper", "label": 1}
{"code": "def bowtiedb(fa, keepDB):\n    \"\"\"\n    make bowtie db\n    \"\"\"\n    btdir = '%s/bt2' % (os.getcwd())\n    # make directory for\n    if not os.path.exists(btdir):\n        os.mkdir(btdir)\n    btdb = '%s/%s' % (btdir, fa.rsplit('/', 1)[-1])\n    if keepDB is True:\n        if os.path.exists('%s.1.bt2' % (btdb)):\n            return btdb\n    p = subprocess.Popen('bowtie2-build -q %s %s' \\\n        % (fa, btdb), shell = True)\n    p.communicate()\n    return btdb", "label": 1}
{"code": "private function enumerate_commands( CompositeCommand $command, array &$list, $parent = '' ) {\n\t\tforeach ( $command->get_subcommands() as $subcommand ) {\n\t\t\t/** @var CompositeCommand $subcommand */\n\t\t\t$command_string = empty( $parent )\n\t\t\t\t? $subcommand->get_name()\n\t\t\t\t: \"{$parent} {$subcommand->get_name()}\";\n\n\t\t\t$list[] = $command_string;\n\n\t\t\t$this->enumerate_commands( $subcommand, $list, $command_string );\n\t\t}\n\t}", "label": 2}
{"code": "func (o HostNetworkSystem) AddServiceConsoleVirtualNic(ctx context.Context, portgroup string, nic types.HostVirtualNicSpec) (string, error) {\n\treq := types.AddServiceConsoleVirtualNic{\n\t\tThis:      o.Reference(),\n\t\tPortgroup: portgroup,\n\t\tNic:       nic,\n\t}\n\n\tres, err := methods.AddServiceConsoleVirtualNic(ctx, o.c, &req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn res.Returnval, nil\n}", "label": 5}
{"code": "function getIndexLogTranslations(type = TYPE_WIDGETS) {\n  const params = { type: t(`TYPE_${type}`) };\n\n  return {\n    logStart: `  ${t('INDEXING_TYPE', params)}`,\n    logEnd: `  ${t('INDEXED_TYPE', params)}`,\n    logNotFound: `  ${t('NO_EXTENSIONS_FOUND_FOR_TYPE', params)}`,\n  };\n}", "label": 3}
{"code": "function cx(classNames) {\n  var classNamesArray;\n  if (typeof classNames == 'object') {\n    classNamesArray = Object.keys(classNames).filter(function(className) {\n      return classNames[className];\n    });\n  } else {\n    classNamesArray = Array.prototype.slice.call(arguments);\n  }\n\n  return classNamesArray.map(getClassName).join(' ');\n}", "label": 3}
{"code": "func (l *localFileSystem) GetFileInfo(filePath string) (FileInfo, error) {\n\tinfo, err := makeFileInfo(filePath)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn info, nil\n}", "label": 5}
{"code": "def __get_table_size(self):\n\t\t\"\"\"\n\t\tRetrieve the size of the buffer needed by calling the method\n\t\twith a null pointer and length of zero. This should trigger an\n\t\tinsufficient buffer error and return the size needed for the\n\t\tbuffer.\n\t\t\"\"\"\n\t\tlength = ctypes.wintypes.DWORD()\n\t\tres = self.method(None, length, False)\n\t\tif res != errors.ERROR_INSUFFICIENT_BUFFER:\n\t\t\traise RuntimeError(\"Error getting table length (%d)\" % res)\n\t\treturn length.value", "label": 1}
{"code": "def list_orphan_networks\n      Models::Network.where(orphaned: true).map do |network|\n        {\n          'name' => network.name,\n          'type' => network.type,\n          'created_at' => network.created_at.to_s,\n          'orphaned_at' => network.orphaned_at.to_s,\n        }\n      end\n    end", "label": 4}
{"code": "function(element) {\n    var r = { x: element.offsetLeft, y: element.offsetTop };\n    if (element.offsetParent) {\n      var tmp = getAbsolutePosition(element.offsetParent);\n      r.x += tmp.x;\n      r.y += tmp.y;\n    }\n    return r;\n  }", "label": 3}
{"code": "def get_postgres_encoding(python_encoding: str) -> str:\n    \"\"\"Python to postgres encoding map.\"\"\"\n\n    encoding = normalize_encoding(python_encoding.lower())\n    encoding_ = aliases.aliases[encoding.replace('_', '', 1)].upper()\n    pg_encoding = PG_ENCODING_MAP[encoding_.replace('_', '')]\n\n    return pg_encoding", "label": 1}
{"code": "public void setWorkDir(String dir) throws IOException\r\n    {\r\n        File workDir = new File(dir);\r\n\r\n        if (!workDir.exists() || !workDir.canWrite() || !workDir.canRead())\r\n        {\r\n            throw new IOException(\"Cannot access directory \"+dir);\r\n        }\r\n        _workDir = workDir;\r\n    }", "label": 0}
{"code": "public function unknown_assoc( $assoc_args ) {\n\t\t$generic = $this->query_spec(\n\t\t\tarray(\n\t\t\t\t'type' => 'generic',\n\t\t\t)\n\t\t);\n\n\t\tif ( count( $generic ) ) {\n\t\t\treturn array();\n\t\t}\n\n\t\t$known_assoc = array();\n\n\t\tforeach ( $this->spec as $param ) {\n\t\t\tif ( in_array( $param['type'], array( 'assoc', 'flag' ), true ) ) {\n\t\t\t\t$known_assoc[] = $param['name'];\n\t\t\t}\n\t\t}\n\n\t\treturn array_diff( array_keys( $assoc_args ), $known_assoc );\n\t}", "label": 2}
{"code": "func (s *MockStore) Delete(key string) error {\n\tdelete(s.db, key)\n\treturn nil\n}", "label": 5}
{"code": "def _parse_rdf(self, file):\n        \"\"\" Returns a case from the given file.\n        \"\"\"\n        store = Graph()\n        store.parse(file)\n\n        print len(store)", "label": 1}
{"code": "function(collection, out, equals)\n  {\n    var target = out || this.cloneEmpty();\n    var equality = equals || equalsStrict;\n\n    for (var i = 0; i < this.length; i++)\n    {\n      var a = this[ i ];\n      var exists = false;\n\n      for (var j = 0; j < collection.length && !exists; j++)\n      {\n        exists = equality( a, collection[ j ] );\n      }\n\n      if (!exists)\n      {\n        target.push( a );\n      }\n    }\n\n    return target;\n  }", "label": 3}
{"code": "public static DocumentBuilder getXmlParser() {\r\n    DocumentBuilder db = null;\r\n    try {\r\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n      dbf.setValidating(false);\r\n\r\n      //Disable DTD loading and validation\r\n      //See http://stackoverflow.com/questions/155101/make-documentbuilder-parse-ignore-dtd-references\r\n      dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-dtd-grammar\", false);\r\n      dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\r\n\r\n      db = dbf.newDocumentBuilder();\r\n      db.setErrorHandler(new SAXErrorHandler());\r\n\r\n    } catch (ParserConfigurationException e) {\r\n      System.err.printf(\"%s: Unable to create XML parser\\n\", XMLUtils.class.getName());\r\n      e.printStackTrace();\r\n\r\n    } catch(UnsupportedOperationException e) {\r\n      System.err.printf(\"%s: API error while setting up XML parser. Check your JAXP version\\n\", XMLUtils.class.getName());\r\n      e.printStackTrace();\r\n    }\r\n\r\n    return db;\r\n  }", "label": 0}
{"code": "def _render_template(options)\n        variant = options.delete(:variant)\n        assigns = options.delete(:assigns)\n        context = view_context\n\n        context.assign assigns if assigns\n        lookup_context.variants = variant if variant\n\n        rendered_template = context.in_rendering_context(options) do |renderer|\n          renderer.render_to_object(context, options)\n        end\n\n        rendered_format = rendered_template.format || lookup_context.formats.first\n        @rendered_format = Template::Types[rendered_format]\n\n        rendered_template.body\n      end", "label": 4}
{"code": "def handle_gadgets(gadgets, libc_file)\n      return false if gadgets.empty? # error occurs when fetching gadgets\n      return handle_script(gadgets, @options[:script]) if @options[:script]\n      return handle_near(libc_file, gadgets, @options[:near]) if @options[:near]\n\n      display_gadgets(gadgets, @options[:raw])\n    end", "label": 4}
{"code": "protected ObjectPool setupPool(JdbcConnectionDescriptor jcd)\r\n    {\r\n        log.info(\"Create new ObjectPool for DBCP connections:\" + jcd);\r\n\r\n        try\r\n        {\r\n            ClassHelper.newInstance(jcd.getDriver());\r\n        }\r\n        catch (InstantiationException e)\r\n        {\r\n            log.fatal(\"Unable to instantiate the driver class: \" + jcd.getDriver() + \" in ConnectionFactoryDBCImpl!\" , e);\r\n        }\r\n        catch (IllegalAccessException e)\r\n        {\r\n            log.fatal(\"IllegalAccessException while instantiating the driver class: \" + jcd.getDriver() + \" in ConnectionFactoryDBCImpl!\" , e);\r\n        }\r\n        catch (ClassNotFoundException e)\r\n        {\r\n            log.fatal(\"Could not find the driver class : \" + jcd.getDriver() + \" in ConnectionFactoryDBCImpl!\" , e);\r\n        }\r\n\r\n        // Get the configuration for the connection pool\r\n        GenericObjectPool.Config conf = jcd.getConnectionPoolDescriptor().getObjectPoolConfig();\r\n\r\n        // Get the additional abandoned configuration\r\n        AbandonedConfig ac = jcd.getConnectionPoolDescriptor().getAbandonedConfig();\r\n\r\n        // Create the ObjectPool that serves as the actual pool of connections.\r\n        final ObjectPool connectionPool = createConnectionPool(conf, ac);\r\n\r\n        // Create a DriverManager-based ConnectionFactory that\r\n        // the connectionPool will use to create Connection instances\r\n        final org.apache.commons.dbcp.ConnectionFactory connectionFactory;\r\n        connectionFactory = createConnectionFactory(jcd);\r\n\r\n        // Create PreparedStatement object pool (if any)\r\n        KeyedObjectPoolFactory statementPoolFactory = createStatementPoolFactory(jcd);\r\n\r\n        // Set validation query and auto-commit mode\r\n        final String validationQuery;\r\n        final boolean defaultAutoCommit;\r\n        final boolean defaultReadOnly = false;\r\n        validationQuery = jcd.getConnectionPoolDescriptor().getValidationQuery();\r\n        defaultAutoCommit = (jcd.getUseAutoCommit() != JdbcConnectionDescriptor.AUTO_COMMIT_SET_FALSE);\r\n\r\n        //\r\n        // Now we'll create the PoolableConnectionFactory, which wraps\r\n        // the \"real\" Connections created by the ConnectionFactory with\r\n        // the classes that implement the pooling functionality.\r\n        //\r\n        final PoolableConnectionFactory poolableConnectionFactory;\r\n        poolableConnectionFactory = new PoolableConnectionFactory(connectionFactory,\r\n                connectionPool,\r\n                statementPoolFactory,\r\n                validationQuery,\r\n                defaultReadOnly,\r\n                defaultAutoCommit,\r\n                ac);\r\n        return poolableConnectionFactory.getPool();\r\n    }", "label": 0}
{"code": "function (defer, response) {\n                var error = response.error;\n                if (error) {\n                    defer.reject(new ApiError(error.type, error.message, error.data));\n                } else {\n                    defer.resolve(response.data);\n                }\n            }", "label": 3}
{"code": "function emitAssignment(name, value, shouldEmitCommaBeforeAssignment, nodeForSourceMap) {\n                if (shouldEmitCommaBeforeAssignment) {\n                    write(\", \");\n                }\n                var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule(name);\n                if (exportChanged) {\n                    write(exportFunctionForFile + \"(\\\"\");\n                    emitNodeWithCommentsAndWithoutSourcemap(name);\n                    write(\"\\\", \");\n                }\n                var isVariableDeclarationOrBindingElement = name.parent && (name.parent.kind === 218 /* VariableDeclaration */ || name.parent.kind === 169 /* BindingElement */);\n                // If this is first var declaration, we need to start at var/let/const keyword instead\n                // otherwise use nodeForSourceMap as the start position\n                emitStart(isFirstVariableDeclaration(nodeForSourceMap) ? nodeForSourceMap.parent : nodeForSourceMap);\n                withTemporaryNoSourceMap(function () {\n                    if (isVariableDeclarationOrBindingElement) {\n                        emitModuleMemberName(name.parent);\n                    }\n                    else {\n                        emit(name);\n                    }\n                    write(\" = \");\n                    emit(value);\n                });\n                emitEnd(nodeForSourceMap, /*stopOverridingSpan*/ true);\n                if (exportChanged) {\n                    write(\")\");\n                }\n            }", "label": 3}
{"code": "def diri(table):\n    \"\"\"\n    from SparCC - \"randomly draw from the corresponding posterior\n    Dirichlet distribution with a uniform prior\"\n    \"\"\"\n    t = []\n    for i in table:\n        a = [j + 1 for j in i]\n        t.append(np.ndarray.tolist(np.random.mtrand.dirichlet(a)))\n    return t", "label": 1}
{"code": "function isPortInUse(port) {\n  _validatePortFormat(port);\n  if (isPlatform('unix')) {\n    if (isPlatform('linux') && fileExists('/proc/net')) {\n      return _isPortInUseRaw(port);\n    } else if (isInPath('netstat')) {\n      return _isPortInUseNetstat(port);\n    } else {\n      throw new Error('Cannot check port status');\n    }\n  } else {\n    throw new Error('Port checking not supported on this platform');\n  }\n}", "label": 3}
{"code": "function makeTempVariableName(flags) {\n                if (flags && !(tempFlags & flags)) {\n                    var name_24 = flags === 268435456 /* _i */ ? \"_i\" : \"_n\";\n                    if (isUniqueName(name_24)) {\n                        tempFlags |= flags;\n                        return name_24;\n                    }\n                }\n                while (true) {\n                    var count = tempFlags & 268435455 /* CountMask */;\n                    tempFlags++;\n                    // Skip over 'i' and 'n'\n                    if (count !== 8 && count !== 13) {\n                        var name_25 = count < 26 ? \"_\" + String.fromCharCode(97 /* a */ + count) : \"_\" + (count - 26);\n                        if (isUniqueName(name_25)) {\n                            return name_25;\n                        }\n                    }\n                }\n            }", "label": 3}
{"code": "def database(name, database_id = nil, &block)\n      @databases << get_class_from_scope(Database, name)\n        .new(self, database_id, &block)\n    end", "label": 4}
{"code": "public function setMetadata($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\ResponseMetadata::class);\n        $this->metadata = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def put_json(self, url, data, cls=None, **kwargs):\n        \"\"\"\n        PUT data to the api-server\n\n        :param url: resource location (eg: \"/type/uuid\")\n        :type url: str\n        :param cls: JSONEncoder class\n        :type cls: JSONEncoder\n        \"\"\"\n        kwargs['data'] = to_json(data, cls=cls)\n        kwargs['headers'] = self.default_headers\n        return self.put(url, **kwargs).json()", "label": 1}
{"code": "func (c *Manager) GetLibraryItemUpdateSession(ctx context.Context, id string) (*UpdateSession, error) {\n\turl := internal.URL(c, internal.LibraryItemUpdateSession).WithID(id)\n\tvar res UpdateSession\n\treturn &res, c.Do(ctx, url.Request(http.MethodGet), &res)\n}", "label": 5}
{"code": "public function responseToEntityProperties(array $entityData, $className = Entity::class)\n    {\n        if (!is_subclass_of($className, EntityInterface::class)) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Class %s must implement EntityInterface.',\n                $className\n            ));\n        }\n\n        $properties = [];\n        $excludes = [];\n        $meanings = [];\n\n        $mappings = $className::mappings();\n        foreach ($entityData as $key => $property) {\n            $mapClassName = Entity::class;\n            if (array_key_exists($key, $mappings)) {\n                $mapClassName = $mappings[$key];\n            }\n\n            if ($mapClassName) {\n                if (!is_subclass_of($mapClassName, EntityInterface::class)) {\n                    throw new \\InvalidArgumentException(sprintf(\n                        'Class %s must implement EntityInterface. (Found in mappings on %s)',\n                        $mapClassName,\n                        $className\n                    ));\n                }\n            }\n\n            $properties[$key] = $this->getPropertyValue($property, $mapClassName);\n\n            if (isset($property['excludeFromIndexes']) && $property['excludeFromIndexes']) {\n                $excludes[] = $key;\n            }\n\n            if (isset($property['meaning']) && $property['meaning']) {\n                $meanings[$key] = $property['meaning'];\n            }\n        }\n\n        return [\n            'properties' => $properties,\n            'excludes' => $excludes,\n            'meanings' => $meanings\n        ];\n    }", "label": 2}
{"code": "public static lbmonbindings_servicegroup_binding[] get(nitro_service service, String monitorname) throws Exception{\n\t\tlbmonbindings_servicegroup_binding obj = new lbmonbindings_servicegroup_binding();\n\t\tobj.set_monitorname(monitorname);\n\t\tlbmonbindings_servicegroup_binding response[] = (lbmonbindings_servicegroup_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "protected function smartGlobalSearch($keyword)\n    {\n        collect(explode(' ', $keyword))\n            ->reject(function ($keyword) {\n                return trim($keyword) === '';\n            })\n            ->each(function ($keyword) {\n                $this->globalSearch($keyword);\n            });\n    }", "label": 2}
{"code": "def from_variant_sequence_and_reference_context(\n            cls,\n            variant_sequence,\n            reference_context,\n            min_transcript_prefix_length,\n            max_transcript_mismatches,\n            include_mismatches_after_variant,\n            protein_sequence_length=None):\n        \"\"\"\n        Attempt to translate a single VariantSequence using the reading frame\n        from a single ReferenceContext.\n\n        Parameters\n        ----------\n        variant_sequence : VariantSequence\n\n        reference_context : ReferenceContext\n\n        min_transcript_prefix_length : int\n            Minimum number of nucleotides before the variant to test whether\n            our variant sequence can use the reading frame from a reference\n            transcript.\n\n        max_transcript_mismatches : int\n            Don't use the reading frame from a context where the cDNA variant\n            sequences disagrees at more than this number of positions before the\n            variant nucleotides.\n\n        include_mismatches_after_variant : bool\n            If true, mismatches after the variant nucleotides will also count\n            against max_transcript_mismatches filtering.\n\n        protein_sequence_length : int, optional\n            Truncate protein to be at most this long\n\n        Returns either a ProteinSequence object or None if the number of\n        mismatches between the RNA and reference transcript sequences exceeds\n        given threshold.\n        \"\"\"\n        variant_sequence_in_reading_frame = match_variant_sequence_to_reference_context(\n            variant_sequence,\n            reference_context,\n            min_transcript_prefix_length=min_transcript_prefix_length,\n            max_transcript_mismatches=max_transcript_mismatches,\n            include_mismatches_after_variant=include_mismatches_after_variant)\n\n        if variant_sequence_in_reading_frame is None:\n            logger.info(\"Unable to determine reading frame for %s\", variant_sequence)\n            return None\n\n        cdna_sequence = variant_sequence_in_reading_frame.cdna_sequence\n        cdna_codon_offset = variant_sequence_in_reading_frame.offset_to_first_complete_codon\n\n        # get the offsets into the cDNA sequence which pick out the variant nucleotides\n        cdna_variant_start_offset = variant_sequence_in_reading_frame.variant_cdna_interval_start\n        cdna_variant_end_offset = variant_sequence_in_reading_frame.variant_cdna_interval_end\n\n        # TODO: determine if the first codon is the start codon of a\n        # transcript, for now any of the unusual start codons like CTG\n        # will translate to leucine instead of methionine.\n        variant_amino_acids, ends_with_stop_codon = translate_cdna(\n            cdna_sequence[cdna_codon_offset:],\n            first_codon_is_start=False,\n            mitochondrial=reference_context.mitochondrial)\n\n        variant_aa_interval_start, variant_aa_interval_end, frameshift = \\\n            find_mutant_amino_acid_interval(\n                cdna_sequence=cdna_sequence,\n                cdna_first_codon_offset=cdna_codon_offset,\n                cdna_variant_start_offset=cdna_variant_start_offset,\n                cdna_variant_end_offset=cdna_variant_end_offset,\n                n_ref=len(reference_context.sequence_at_variant_locus),\n                n_amino_acids=len(variant_amino_acids))\n\n        if protein_sequence_length and len(variant_amino_acids) > protein_sequence_length:\n            if protein_sequence_length <= variant_aa_interval_start:\n                logger.warn(\n                    (\"Truncating amino acid sequence %s \"\n                     \"to only %d elements loses all variant residues\"),\n                    variant_amino_acids,\n                    protein_sequence_length)\n                return None\n            # if the protein is too long then shorten it, which implies\n            # we're no longer stopping due to a stop codon and that the variant\n            # amino acids might need a new stop index\n            variant_amino_acids = variant_amino_acids[:protein_sequence_length]\n            variant_aa_interval_end = min(variant_aa_interval_end, protein_sequence_length)\n            ends_with_stop_codon = False\n\n        return Translation(\n            amino_acids=variant_amino_acids,\n            frameshift=frameshift,\n            ends_with_stop_codon=ends_with_stop_codon,\n            variant_aa_interval_start=variant_aa_interval_start,\n            variant_aa_interval_end=variant_aa_interval_end,\n            untrimmed_variant_sequence=variant_sequence,\n            reference_context=reference_context,\n            variant_sequence_in_reading_frame=variant_sequence_in_reading_frame)", "label": 1}
{"code": "func (d *driver) DeleteNetwork(nid string) error {\n\tdefer osl.InitOSContext()()\n\tn := d.network(nid)\n\tif n == nil {\n\t\treturn fmt.Errorf(\"network id %s not found\", nid)\n\t}\n\t// if the driver created the slave interface, delete it, otherwise leave it\n\tif ok := n.config.CreatedSlaveLink; ok {\n\t\t// if the interface exists, only delete if it matches iface.vlan or dummy.net_id naming\n\t\tif ok := parentExists(n.config.Parent); ok {\n\t\t\t// only delete the link if it is named the net_id\n\t\t\tif n.config.Parent == getDummyName(stringid.TruncateID(nid)) {\n\t\t\t\terr := delDummyLink(n.config.Parent)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.Debugf(\"link %s was not deleted, continuing the delete network operation: %v\",\n\t\t\t\t\t\tn.config.Parent, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// only delete the link if it matches iface.vlan naming\n\t\t\t\terr := delVlanLink(n.config.Parent)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.Debugf(\"link %s was not deleted, continuing the delete network operation: %v\",\n\t\t\t\t\t\tn.config.Parent, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor _, ep := range n.endpoints {\n\t\tif link, err := ns.NlHandle().LinkByName(ep.srcName); err == nil {\n\t\t\tif err := ns.NlHandle().LinkDel(link); err != nil {\n\t\t\t\tlogrus.WithError(err).Warnf(\"Failed to delete interface (%s)'s link on endpoint (%s) delete\", ep.srcName, ep.id)\n\t\t\t}\n\t\t}\n\n\t\tif err := d.storeDelete(ep); err != nil {\n\t\t\tlogrus.Warnf(\"Failed to remove ipvlan endpoint %.7s from store: %v\", ep.id, err)\n\t\t}\n\t}\n\t// delete the *network\n\td.deleteNetwork(nid)\n\t// delete the network record from persistent cache\n\terr := d.storeDelete(n.config)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error deleting deleting id %s from datastore: %v\", nid, err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def build_report(self, op_file, tpe='md'):\n        \"\"\"\n        create a report showing all project details\n        \"\"\"\n        if tpe == 'md':\n            res = self.get_report_md()\n        elif tpe == 'rst':\n            res = self.get_report_rst()\n        elif tpe == 'html':\n            res = self.get_report_html()\n        else:\n            res = 'Unknown report type passed to project.build_report'\n        \n        with open(op_file, 'w') as f:\n            f.write(res)", "label": 1}
{"code": "def oauth_unlink_external_id(external_id):\n    \"\"\"Unlink a user from an external id.\n\n    :param external_id: The external id associated with the user.\n    \"\"\"\n    with db.session.begin_nested():\n        UserIdentity.query.filter_by(id=external_id['id'],\n                                     method=external_id['method']).delete()", "label": 1}
{"code": "public function setState($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\SecurityCenter\\V1\\Finding_State::class);\n        $this->state = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def render(view)\n      tags = []\n\n      render_charset(tags)\n      render_title(tags)\n      render_icon(tags)\n      render_with_normalization(tags, :description)\n      render_with_normalization(tags, :keywords)\n      render_refresh(tags)\n      render_noindex(tags)\n      render_alternate(tags)\n      render_open_search(tags)\n      render_links(tags)\n\n      render_hashes(tags)\n      render_custom(tags)\n\n      tags.tap(&:compact!).map! { |tag| tag.render(view) }\n      view.safe_join tags, MetaTags.config.minify_output ? \"\" : \"\\n\"\n    end", "label": 4}
{"code": "function hydrateAndValue(value, prop, SchemaType, hydrateChild) {\n\t// The `SchemaType` is the type of value on `instances` of\n\t// the schema. `Instances` values are different from `Set` values.\n\tif (SchemaType) {\n\t\t// If there's a `SetType`, we will use that\n\t\tvar SetType = SchemaType[setTypeSymbol];\n\t\tif (SetType) {\n\t\t\t/// If it exposes a hydrate, this means it can use the current hydrator to\n\t\t\t// hydrate its children.\n\t\t\t// I'm not sure why it's not taking the `unknown` hydrator instead.\n\t\t\tif (SetType.hydrate) {\n\t\t\t\treturn SetType.hydrate(value, comparisonsConverter.hydrate);\n\t\t\t}\n\t\t\t// If the SetType implemented `union`, `intersection`, `difference`\n\t\t\t// We can create instances of it directly.\n\t\t\telse if (set.hasComparisons(SetType)) {\n\t\t\t\t// Todo ... canReflect.new\n\t\t\t\treturn new SetType(value);\n\t\t\t}\n\t\t\t// If the SetType did not implement the comparison methods,\n\t\t\t// it's probably just a \"Value\" comparison type. We will hydrate\n\t\t\t// as a comparison converter, but create an instance of this `\"Value\"`\n\t\t\t// comparison type within the comparison converter.\n\t\t\telse {\n\t\t\t\t// inner types\n\t\t\t\treturn comparisonsConverter.hydrate(value, function(value) {\n\t\t\t\t\treturn new SetType(value);\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else {\n\t\t\t// There is a `SchemaType`, but it doesn't have a `SetType`.\n\t\t\t// Can we create the SetType from the `SchemaType`?\n\t\t\tif (makeEnum.canMakeEnumSetType(SchemaType)) {\n\t\t\t\tif (!setTypeMap.has(SchemaType)) {\n\t\t\t\t\tsetTypeMap.set(SchemaType, makeEnum.makeEnumSetType(SchemaType));\n\t\t\t\t}\n\t\t\t\tSetType = setTypeMap.get(SchemaType);\n\t\t\t\treturn new SetType(value);\n\t\t\t}\n\t\t\t// It could also have a `ComparisonSetType` which are the values\n\t\t\t// within the Maybe type.\n\t\t\telse if (makeMaybe.canMakeMaybeSetType(SchemaType)) {\n\t\t\t\tif (!setTypeMap.has(SchemaType)) {\n\t\t\t\t\tsetTypeMap.set(SchemaType, makeMaybe.makeMaybeSetTypes(SchemaType));\n\t\t\t\t}\n\t\t\t\tSetType = setTypeMap.get(SchemaType).Maybe;\n\t\t\t\treturn SetType.hydrate(value, comparisonsConverter.hydrate);\n\t\t\t}\n\t\t\t// We can't create the `SetType`, so lets hydrate with the default behavior.\n\t\t\telse {\n\t\t\t\treturn comparisonsConverter.hydrate(value, hydrateChild);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// HERE {$gt: 1} -> new is.GreaterThan(1)\n\t\treturn comparisonsConverter.hydrate(value, hydrateChild);\n\t}\n}", "label": 3}
{"code": "function partialCallback(text, urlIndex) {\n        result[urlIndex] = text;\n        numComplete++;\n\n        // When all files have downloaded\n        if (numComplete == numUrls) {\n            callback(result);\n        }\n    }", "label": 3}
{"code": "public function rowValue($attribute, $template)\n    {\n        if (! empty($template)) {\n            if (! is_callable($template) && Arr::get($this->data, $template)) {\n                $this->data[$attribute] = Arr::get($this->data, $template);\n            } else {\n                $this->data[$attribute] = Helper::compileContent($template, $this->data, $this->row);\n            }\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "public static ci[] get(nitro_service service) throws Exception{\n\t\tci obj = new ci();\n\t\tci[] response = (ci[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func getV6Network(config *networkConfiguration, i *bridgeInterface) *net.IPNet {\n\tif config.AddressIPv6 != nil {\n\t\treturn config.AddressIPv6\n\t}\n\tif i.bridgeIPv6 != nil && i.bridgeIPv6.IP != nil && !i.bridgeIPv6.IP.IsLinkLocalUnicast() {\n\t\treturn i.bridgeIPv6\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "private static function guess_url( $assoc_args ) {\n\t\tif ( isset( $assoc_args['blog'] ) ) {\n\t\t\t$assoc_args['url'] = $assoc_args['blog'];\n\t\t}\n\n\t\tif ( isset( $assoc_args['url'] ) ) {\n\t\t\t$url = $assoc_args['url'];\n\t\t\tif ( true === $url ) {\n\t\t\t\tWP_CLI::warning( 'The --url parameter expects a value.' );\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $url ) ) {\n\t\t\treturn $url;\n\t\t}\n\n\t\treturn false;\n\t}", "label": 2}
{"code": "function(bindingContext, view, obj) {\n            if (obj && bindingContext) {\n                bindingContext = bindingContext.createChildContext(obj);\n            }\n\n            return doBind(obj, view, bindingContext, obj || (bindingContext ? bindingContext.$data : null));\n        }", "label": 3}
{"code": "def tearpage_backend(filename, teared_pages=None):\n    \"\"\"\n    Copy filename to a tempfile, write pages to filename except the teared one.\n\n    ..note ::\n\n        Adapted from sciunto's code, https://github.com/sciunto/tear-pages\n\n    :param filename: PDF filepath\n    :param teared_pages: Numbers of the pages to tear. Default to first page \\\n            only.\n    \"\"\"\n    # Handle default argument\n    if teared_pages is None:\n        teared_pages = [0]\n\n    # Copy the pdf to a tmp file\n    with tempfile.NamedTemporaryFile() as tmp:\n        # Copy the input file to tmp\n        shutil.copy(filename, tmp.name)\n\n        # Read the copied pdf\n        # TODO: Use with syntax\n        try:\n            input_file = PdfFileReader(open(tmp.name, 'rb'))\n        except PdfReadError:\n            fix_pdf(filename, tmp.name)\n            input_file = PdfFileReader(open(tmp.name, 'rb'))\n        # Seek for the number of pages\n        num_pages = input_file.getNumPages()\n\n        # Write pages excepted the first one\n        output_file = PdfFileWriter()\n        for i in range(num_pages):\n            if i in teared_pages:\n                continue\n            output_file.addPage(input_file.getPage(i))\n\n        tmp.close()\n        outputStream = open(filename, \"wb\")\n        output_file.write(outputStream)", "label": 1}
{"code": "function (cb) {\n\t\t\to1._client.createContainer(sName, function (err, _container) {\n\t\t\t\tif (err)\n\t\t\t\t\treturn cb(err);\n\n\t\t\t\t// check that a parallel operation didn't just add the same container\n\t\t\t\tcontainer = _.find(o1.aContainers, { name : sName });\n\n\t\t\t\tif (!container) {\n\t\t\t\t\to1.aContainers.push(_container);\n\t\t\t\t\tcontainer = _container;\n\t\t\t\t}\n\n\t\t\t\tcb();\n\t\t\t});\n\t\t}", "label": 3}
{"code": "function K8sutil() {\n    // this.getNamespace();\n    podName = os.hostname();\n    podGenerateName = podName.substr(0, podName.lastIndexOf('-'));\n    logger.debug('k8sutil', 'K8sutil()', 'The pod name: ', podName);\n    fetchContainerID();\n    try {\n        // var kubeconfig = Api.config.fromKubeconfig();\n        var kubeconfig = Api.config.getInCluster();\n        kubeconfig.promises = true;\n        // kubeconfig.namespace = 'default';\n        logger.debug('k8sutil', 'K8sutil()', 'Kubeconfig', kubeconfig);\n        core = new Api.Core(kubeconfig);\n        ext = new Api.Extensions(kubeconfig);\n        namespace = core.namespaces.namespace;\n        logger.info('k8sutil', 'K8sutil()', 'Current namespace', namespace);\n        if (!podJson) {\n            core.ns(namespace).pods(this.getPodName()).get().then(parsePodInfo).catch(\n                function(err) {\n                    logger.error('k8sutil', 'K8sutil()', err.message);\n                }\n            );\n        }\n\n    } catch (e) {\n        logger.debug('k8sutil', 'K8sutil()',\n            'Failed to load K8S configuration, is not a ICp environment.');\n    }\n    findIngressSvc();\n    setNodeIPs();\n}", "label": 3}
{"code": "public int[] sampleBatchWithoutReplacement() {\n        int[] batch = new int[batchSize];\n        for (int i=0; i<batch.length; i++) {\n            if (cur == indices.length) {\n                cur = 0;\n            }\n            if (cur == 0) {\n                IntArrays.shuffle(indices);\n            }\n            batch[i] = indices[cur++];\n        }\n        return batch;\n    }", "label": 0}
{"code": "public static String replaceHtmlEntities(String content, Map<String, Character> map) {\n    \n    for (Entry<String, Character> entry : escapeStrings.entrySet()) {\n      \n      if (content.indexOf(entry.getKey()) != -1) {\n        content = content.replace(entry.getKey(), String.valueOf(entry.getValue()));\n      }\n      \n    }\n    \n    return content;\n  }", "label": 0}
{"code": "function verifyEmitFilePath(emitFileName, emitFilesSeen) {\n                if (emitFileName) {\n                    var emitFilePath = ts.toPath(emitFileName, currentDirectory, getCanonicalFileName);\n                    // Report error if the output overwrites input file\n                    if (filesByName.contains(emitFilePath)) {\n                        createEmitBlockingDiagnostics(emitFileName, emitFilePath, ts.Diagnostics.Cannot_write_file_0_because_it_would_overwrite_input_file);\n                    }\n                    // Report error if multiple files write into same file\n                    if (emitFilesSeen.contains(emitFilePath)) {\n                        // Already seen the same emit file - report error\n                        createEmitBlockingDiagnostics(emitFileName, emitFilePath, ts.Diagnostics.Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files);\n                    }\n                    else {\n                        emitFilesSeen.set(emitFilePath, true);\n                    }\n                }\n            }", "label": 3}
{"code": "def column(column_number, sheet = nil)\n      if column_number.is_a?(::String)\n        column_number = ::Roo::Utils.letter_to_number(column_number)\n      end\n      sheet_for(sheet).column(column_number)\n    end", "label": 4}
{"code": "func AuthGroupPermissionsByPermissionID(db XODB, permissionID int) ([]*AuthGroupPermission, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`id, group_id, permission_id ` +\n\t\t`FROM django.auth_group_permissions ` +\n\t\t`WHERE permission_id = ?`\n\n\t// run query\n\tXOLog(sqlstr, permissionID)\n\tq, err := db.Query(sqlstr, permissionID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer q.Close()\n\n\t// load results\n\tres := []*AuthGroupPermission{}\n\tfor q.Next() {\n\t\tagp := AuthGroupPermission{\n\t\t\t_exists: true,\n\t\t}\n\n\t\t// scan\n\t\terr = q.Scan(&agp.ID, &agp.GroupID, &agp.PermissionID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres = append(res, &agp)\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "def add_file_metadata(self, fname):\r\n        \"\"\"\r\n        collects the files metadata - note that this will fail\r\n        with strange errors if network connection drops out to\r\n        shared folder, but it is better to stop the program\r\n        rather than do a try except otherwise you will get an\r\n        incomplete set of files.\r\n        \"\"\"\r\n\r\n        file_dict = {}\r\n        file_dict[\"fullfilename\"] = fname\r\n        try:\r\n            file_dict[\"name\"] = os.path.basename(fname)\r\n            file_dict[\"date\"] = self.GetDateAsString(fname)\r\n            file_dict[\"size\"] = os.path.getsize(fname)\r\n            file_dict[\"path\"] = os.path.dirname(fname)\r\n        except IOError:\r\n            print('Error getting metadata for file')\r\n\r\n        self.fl_metadata.append(file_dict)", "label": 1}
{"code": "def resolve_args_without_dependencies(args)\n      task_name = args.shift\n      if args.size == 1 && args.first.respond_to?(:to_ary)\n        arg_names = args.first.to_ary\n      else\n        arg_names = args\n      end\n      [task_name, arg_names, []]\n    end", "label": 4}
{"code": "function (method, methodName, superMembers) {\n        return {\n            _method_: method,\n            _methodName_: methodName,\n            _superMembers_: superMembers,\n            _classDef_: this\n        };\n    }", "label": 3}
{"code": "public function snapshot(Session $session, array $options = [])\n    {\n        $options += [\n            'singleUse' => false,\n            'className' => Snapshot::class\n        ];\n\n        if (!$options['singleUse']) {\n            $res = $this->beginTransaction($session, $options);\n        } else {\n            $res = [];\n        }\n\n        $className = $this->pluck('className', $options);\n        return $this->createSnapshot(\n            $session,\n            $res + $options,\n            $className\n        );\n    }", "label": 2}
{"code": "def file_set_ids\n        @file_set_ids ||= begin\n                            ActiveFedora::SolrService.query(\"{!field f=has_model_ssim}FileSet\",\n                                                            rows: 10_000,\n                                                            fl: ActiveFedora.id_field,\n                                                            fq: \"{!join from=ordered_targets_ssim to=id}id:\\\"#{id}/list_source\\\"\")\n                                                     .flat_map { |x| x.fetch(ActiveFedora.id_field, []) }\n                          end\n      end", "label": 4}
{"code": "func (o HostNetworkSystem) QueryNetworkHint(ctx context.Context, device []string) error {\n\treq := types.QueryNetworkHint{\n\t\tThis:   o.Reference(),\n\t\tDevice: device,\n\t}\n\n\t_, err := methods.QueryNetworkHint(ctx, o.c, &req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def set_page_part_block_contents(_page_part_key, locale, fragment_details)\n      # page_part = self.page_parts.find_by_page_part_key page_part_key\n      if page_part.present?\n        page_part.block_contents[locale] = fragment_details\n        page_part.save!\n        # fragment_details passed in might be a params object\n        # - retrieving what has just been saved will return it as JSON\n        fragment_details = page_part.block_contents[locale]\n      end\n\n      fragment_details\n    end", "label": 4}
{"code": "def register_font_from_pdf_object(font_name, font_object)\n      # FIXME:\n      # - add stream deflation for the CMap file.\n      # - add :Encoding CMaps (such as :WinAnsiEncoding etc`)\n      # - the ToUnicode CMap parsing assumes 8 Bytes <0F0F> while 16 Bytes and multiple unicode chars are also possible.\n\n      # first, create cmap, as it will be used to correctly create the widths directory.\n\n      # find the CMap from one of the two systems (TrueType vs. Type0 fonts)\n      # at the moment doen't suppot :Encoding cmaps...\n      cmap = {}\n      if font_object[:ToUnicode]\n        to_unicode = font_object[:ToUnicode]\n        to_unicode = to_unicode[:referenced_object] if to_unicode[:is_reference_only]\n        # deflate the cmap file stream before parsing\n        to_unicode = create_deep_copy to_unicode\n        CombinePDF::PDFFilter.inflate_object to_unicode\n        # parse the deflated stream\n        cmap = parse_cmap to_unicode[:raw_stream_content]\n      else\n        warn \"didn't find ToUnicode object for #{font_object}\"\n        return false\n      end\n\n      # second, create the metrics directory.\n      metrics = {}\n      old_widths = font_object\n      if font_object[:DescendantFonts]\n        old_widths = font_object[:DescendantFonts]\n        old_widths = old_widths[:referenced_object][:indirect_without_dictionary] if old_widths.is_a?(Hash) && old_widths[:is_reference_only]\n        old_widths = old_widths[0][:referenced_object]\n        avrg_height = 360\n        avrg_height = old_widths[:XHeight] if old_widths[:XHeight]\n        avrg_height = (avrg_height + old_widths[:CapHeight]) / 2 if old_widths[:CapHeight]\n        avrg_width = old_widths[:AvgWidth] || 0\n        avarage_bbox = [0, 0, avrg_width, avrg_height] # data is missing for full box metrics, just ignore\n      end\n\n      # compute the metrics values using the appropiate system (TrueType vs. Type0 fonts)\n      cmap_inverted = {}\n      cmap.each { |k, v| cmap_inverted[v.hex] = k }\n      if old_widths[:W]\n        old_widths = old_widths[:W]\n        if old_widths.is_a?(Hash) && old_widths[:is_reference_only]\n          old_widths = old_widths[:referenced_object][:indirect_without_dictionary]\n        end\n        old_widths = create_deep_copy old_widths\n        while old_widths[0]\n          a = old_widths.shift\n          b = old_widths.shift\n          if b.is_a?(Array)\n            b.each_index { |i| metrics[cmap_inverted[(a + i)] || (a + i)] = { wx: b[i], boundingbox: avarage_bbox } }\n          else\n            c = old_widths.shift\n            (b - a).times { |i| metrics[cmap_inverted[(a + i)] || (a + i)] = { wx: c[0], boundingbox: avarage_bbox } }\n          end\n\n        end\n      elsif old_widths[:Widths]\n        first_char = old_widths[:FirstChar]\n        old_widths = old_widths[:Widths]\n        if old_widths.is_a?(Hash) && old_widths[:is_reference_only]\n          old_widths = old_widths[:referenced_object][:indirect_without_dictionary]\n        end\n        old_widths.each_index { |i| metrics[cmap_inverted[(i + first_char)] || (i + first_char)] = { wx: old_widths[i], boundingbox: avarage_bbox } }\n      else\n        warn \"didn't find widths object for #{old_widths}\"\n        return false\n      end\n      # register the font and return the font object\n      cmap = nil if cmap.empty?\n      CombinePDF::Fonts.register_font font_name, metrics, font_object, cmap\n    end", "label": 4}
{"code": "def remove_upvote\n      begin\n        client.delete(\"/cards/#{id}/membersVoted/#{me.id}\")\n      rescue Trello::Error => e\n        fail e unless e.message =~ /has not voted/i\n      end\n\n      self\n    end", "label": 4}
{"code": "function generateTransformer(name, transformerFns, templateDir, pluginOptions) {\n\n    var Transformer = function () {};\n    var transformer = new Transformer();\n\n    // add function mixins to the transformer\n    _.extend(transformer, transformerFns, baseTransformer, annotationHelper, utensils, pluginOptions);\n\n    // add reference to the template function\n    transformer.setTemplate(templateDir, name, pluginOptions.clientType);\n\n    // each transformer can reference each other\n    transformer.transformers = cache;\n\n    // return the transformer\n    return transformer;\n}", "label": 3}
{"code": "public function getIcon()\n    {\n        $icon = $this->composerJsonAttribute('extra.flarum-extension.icon');\n        $file = Arr::get($icon, 'image');\n\n        if (is_null($icon) || is_null($file)) {\n            return $icon;\n        }\n\n        $file = $this->path.'/'.$file;\n\n        if (file_exists($file)) {\n            $extension = pathinfo($file, PATHINFO_EXTENSION);\n            if (! array_key_exists($extension, self::LOGO_MIMETYPES)) {\n                throw new \\RuntimeException('Invalid image type');\n            }\n\n            $mimetype = self::LOGO_MIMETYPES[$extension];\n            $data = base64_encode(file_get_contents($file));\n\n            $icon['backgroundImage'] = \"url('data:$mimetype;base64,$data')\";\n        }\n\n        return $icon;\n    }", "label": 2}
{"code": "func (t *Torrent) forReaderOffsetPieces(f func(begin, end pieceIndex) (more bool)) (all bool) {\n\tfor r := range t.readers {\n\t\tp := r.pieces\n\t\tif p.begin >= p.end {\n\t\t\tcontinue\n\t\t}\n\t\tif !f(p.begin, p.end) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "label": 5}
{"code": "function isFile(file, options) {\n  options = _.sanitize(options, {acceptLinks: true});\n  try {\n    return _fileStats(file, options).isFile();\n  } catch (e) {\n    return false;\n  }\n}", "label": 3}
{"code": "private function singleUseState()\n    {\n        if ($this->type === self::TYPE_SINGLE_USE) {\n            if ($this->state === self::STATE_SINGLE_USE_USED) {\n                throw new \\BadMethodCallException('This single-use transaction has already been used.');\n            }\n\n            $this->state = self::STATE_SINGLE_USE_USED;\n\n            return true;\n        }\n\n        return false;\n    }", "label": 2}
{"code": "def allow_any(self, ctx, ops):\n        ''' like allow except that it will authorize as many of the\n        operations as possible without requiring any to be authorized. If all\n        the operations succeeded, the array will be nil.\n\n        If any the operations failed, the returned error will be the same\n        that allow would return and each element in the returned slice will\n        hold whether its respective operation was allowed.\n\n        If all the operations succeeded, the returned slice will be None.\n\n        The returned AuthInfo will always be non-None.\n\n        The LOGIN_OP operation is treated specially - it is always required if\n        present in ops.\n        @param ctx AuthContext\n        @param ops an array of Op\n        :return: an AuthInfo object and the auth used as an array of int.\n        '''\n        authed, used = self._allow_any(ctx, ops)\n        return self._new_auth_info(used), authed", "label": 1}
{"code": "def set_headers(self):\n        \"\"\"\n        Sets the content headers on the response.\n        \"\"\"\n        self.set_header(\"Accept-Ranges\", \"bytes\")\n\n        content_type = self.get_content_type()\n        if content_type:\n            self.set_header(\"Content-Type\", content_type)", "label": 1}
{"code": "def replace_self(uri)\n      # Reset dependent values\n      instance_variables.each do |var|\n        if instance_variable_defined?(var) && var != :@validation_deferred\n          remove_instance_variable(var)\n        end\n      end\n\n      @scheme = uri.scheme\n      @user = uri.user\n      @password = uri.password\n      @host = uri.host\n      @port = uri.port\n      @path = uri.path\n      @query = uri.query\n      @fragment = uri.fragment\n      return self\n    end", "label": 4}
{"code": "def get_all_days():\n    \"\"\" Returns percentages of peak load for all days of the year.\n    Data from the IEEE RTS.\n    \"\"\"\n    weekly = get_weekly()\n    daily = get_daily()\n\n    return [w * (d / 100.0) for w in weekly for d in daily]", "label": 1}
{"code": "def get_file_sample(self, numLines=10):\n        \"\"\" retrieve a sample of the file \"\"\"\n        res = ''\n        try:\n            with open(self.fullname, 'r') as f:\n                for line_num, line in enumerate(f):\n                    res += str(line_num).zfill(5) + ' ' + line \n                    if line_num >= numLines-1:\n                        break\n            return res\n        except Exception as ex:\n            print('cant get_file_sample in \"', self.fullname, '\":', str(ex))\n            return res", "label": 1}
{"code": "func (roles Roles) Equals(other Roles) bool {\n\tif len(roles) != len(other) {\n\t\treturn false\n\t}\n\tfor _, r := range roles {\n\t\tif !other.Include(r) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "label": 5}
{"code": "function _gpfLoadSources () { //jshint ignore:line\n    var sourceListContent = _gpfSyncReadForBoot(gpfSourcesPath + \"sources.json\"),\n        _gpfSources = _GpfFunc(\"return \" + sourceListContent)(),\n        allContent = [],\n        idx = 0;\n    for (; idx < _gpfSources.length; ++idx) {\n        _gpfProcessSource(_gpfSources[idx], allContent);\n    }\n    return allContent.join(\"\\n\");\n}", "label": 3}
{"code": "def get_descriptions(fastas):\n    \"\"\"\n    get the description for each ORF \n    \"\"\"\n    id2desc = {}\n    for fasta in fastas:\n        for seq in parse_fasta(fasta):\n            header = seq[0].split('>')[1].split(' ')\n            id = header[0]\n            if len(header) > 1:\n                desc = ' '.join(header[1:])\n            else:\n                desc = 'n/a'\n            length = float(len([i for i in seq[1].strip() if i != '*']))\n            id2desc[id] = [fasta, desc, length]\n    return id2desc", "label": 1}
{"code": "def require_program(*keys)\n      keys.each do |key|\n        fail CommandError, \"program #{key} required\" if program(key).nil? || program(key).empty?\n      end\n    end", "label": 4}
{"code": "public function window($handle)\n    {\n        $params = ['name' => (string) $handle];\n        $this->executor->execute(DriverCommand::SWITCH_TO_WINDOW, $params);\n\n        return $this->driver;\n    }", "label": 2}
{"code": "def _patch():\n\t\"\"\"Patch pymongo's Collection object to add a tail method.\n\t\n\tWhile not nessicarily recommended, you can use this to inject `tail` as a method into Collection, making it\n\tgenerally accessible.\n\t\"\"\"\n\t\n\tif not __debug__:  # pragma: no cover\n\t\timport warnings\n\t\twarnings.warn(\"A catgirl has died.\", ImportWarning)\n\t\n\tfrom pymongo.collection import Collection\n\tCollection.tail = tail", "label": 1}
{"code": "public function document($name)\n    {\n        return $this->getDocumentReference(\n            $this->connection,\n            $this->valueMapper,\n            $this->projectId,\n            $this->database,\n            $name\n        );\n    }", "label": 2}
{"code": "def from_bs_date(cls, year, month, day):\n        \"\"\" Create and update an NepDate object for bikram sambat date \"\"\"\n        return NepDate(year, month, day).update()", "label": 1}
{"code": "func IsFile(fp string) bool {\n\tfi, err := os.Stat(fp)\n\tif err == nil {\n\t\treturn !fi.IsDir()\n\t}\n\treturn false\n}", "label": 5}
{"code": "def remove_global_options(options, args)\n      # TODO: refactor with flipflop, please TJ ! have time to refactor me !\n      options.each do |option|\n        switches = option[:switches].dup\n        next if switches.empty?\n\n        if (switch_has_arg = switches.any? { |s| s =~ /[ =]/ })\n          switches.map! { |s| s[0, s.index('=') || s.index(' ') || s.length] }\n        end\n\n        switches = expand_optionally_negative_switches(switches)\n\n        past_switch, arg_removed = false, false\n        args.delete_if do |arg|\n          if switches.any? { |s| s[0, arg.length] == arg }\n            arg_removed = !switch_has_arg\n            past_switch = true\n          elsif past_switch && !arg_removed && arg !~ /^-/\n            arg_removed = true\n          else\n            arg_removed = true\n            false\n          end\n        end\n      end\n    end", "label": 4}
{"code": "func Skip(message string, callerSkip ...int) {\n\tskip := 0\n\tif len(callerSkip) > 0 {\n\t\tskip = callerSkip[0]\n\t}\n\n\tglobalFailer.Skip(message, codelocation.New(skip+1))\n\tpanic(GINKGO_PANIC)\n}", "label": 5}
{"code": "async function main() {\n  const { window } = webContext();\n  if (window) {\n    await windowReadiness(window);\n    render(window);\n    bootWebWorker(window);\n  } else {\n    console.warn(\"No web window. Can't run browser-demo.\");\n  }\n}", "label": 3}
{"code": "public function setResolverArguments($root, array $args, GraphQLContext $context, ResolveInfo $resolveInfo): self\n    {\n        return $this\n            ->setRoot($root)\n            ->setArgs($args)\n            ->setContext($context)\n            ->setResolveInfo($resolveInfo);\n    }", "label": 2}
{"code": "def run_action_requiring_special_handling(command: nil, parameter_map: nil, action_return_type: nil)\n      action_return = nil\n      closure_argument_value = nil # only used if the action uses it\n\n      case command.method_name\n      when \"sh\"\n        error_callback = proc { |string_value| closure_argument_value = string_value }\n        command_param = parameter_map[:command]\n        log_param = parameter_map[:log]\n        action_return = Fastlane::FastFile.sh(command_param, log: log_param, error_callback: error_callback)\n      end\n\n      command_return = ActionCommandReturn.new(\n        return_value: action_return,\n        return_value_type: action_return_type,\n        closure_argument_value: closure_argument_value\n      )\n\n      return command_return\n    end", "label": 4}
{"code": "public static dnstxtrec[] get(nitro_service service, dnstxtrec_args args) throws Exception{\n\t\tdnstxtrec obj = new dnstxtrec();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tdnstxtrec[] response = (dnstxtrec[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (factory *IrcBeeFactory) States() []bees.StateDescriptor {\n\topts := []bees.StateDescriptor{\n\t\t{\n\t\t\tName:        \"connected\",\n\t\t\tDescription: \"Whether this bee is currently connected to IRC\",\n\t\t\tType:        \"bool\",\n\t\t},\n\t\t{\n\t\t\tName:        \"channels\",\n\t\t\tDescription: \"Which channels this bee is currently connected to\",\n\t\t\tType:        \"[]string\",\n\t\t},\n\t}\n\treturn opts\n}", "label": 5}
{"code": "func RegisterBee(bee BeeInterface) {\n\tlog.Println(\"Worker bee ready:\", bee.Name(), \"-\", bee.Description())\n\n\tbees[bee.Name()] = &bee\n}", "label": 5}
{"code": "function (deltaTime, on, channel, note, velocity) {\n  var status = on ? 0x90 : 0x80;\n\n  status += channel;\n  deltaTime = makeVLQ(deltaTime);\n\n  return Buffer.concat([deltaTime, new Buffer([status, note, velocity])]);\n}", "label": 3}
{"code": "def _nln_constraints(self, nb, nl):\n        \"\"\" Returns non-linear constraints for OPF.\n        \"\"\"\n        Pmis = NonLinearConstraint(\"Pmis\", nb)\n        Qmis = NonLinearConstraint(\"Qmis\", nb)\n        Sf = NonLinearConstraint(\"Sf\", nl)\n        St = NonLinearConstraint(\"St\", nl)\n\n        return Pmis, Qmis, Sf, St", "label": 1}
{"code": "func (c *controller) SandboxDestroy(id string) error {\n\tvar sb *sandbox\n\tc.Lock()\n\tfor _, s := range c.sandboxes {\n\t\tif s.containerID == id {\n\t\t\tsb = s\n\t\t\tbreak\n\t\t}\n\t}\n\tc.Unlock()\n\n\t// It is not an error if sandbox is not available\n\tif sb == nil {\n\t\treturn nil\n\t}\n\n\treturn sb.Delete()\n}", "label": 5}
{"code": "def fire_event(event_name)\n      event_name = event_name.to_s.sub(/^on/, '').downcase\n\n      element_call { execute_js :fireEvent, @element, event_name }\n    end", "label": 4}
{"code": "def find_by_prefix(prefix)\n      @machines.each do |uuid, data|\n        return data.merge(\"id\" => uuid) if uuid.start_with?(prefix)\n      end\n\n      nil\n    end", "label": 4}
{"code": "public static appfwpolicylabel_stats[] get(nitro_service service) throws Exception{\n\t\tappfwpolicylabel_stats obj = new appfwpolicylabel_stats();\n\t\tappfwpolicylabel_stats[] response = (appfwpolicylabel_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static function uriToPath(string $uri)\n    {\n        $fragments = parse_url($uri);\n        if ($fragments === false || !isset($fragments['scheme']) || $fragments['scheme'] !== 'file') {\n            throw new \\InvalidArgumentException(\"Not a valid file URI: $uri\");\n        }\n        $filepath = urldecode((string) $fragments['path']);\n        if (strpos($filepath, ':') !== false) {\n            if ($filepath[0] === '/') {\n                $filepath = substr($filepath, 1);\n            }\n            $filepath = str_replace('/', '\\\\', $filepath);\n        }\n        return $filepath;\n    }", "label": 2}
{"code": "func replacePlaceholders(str string, kv ...string) string {\n\tfor ph, value := range toMap(kv...) {\n\t\tstr = strings.Replace(str, \"!!!\"+ph+\"!!!\", value, -1)\n\t}\n\treturn str\n}", "label": 5}
{"code": "function resolveServer(path, options) {\n    if (options === void 0) { options = {}; }\n    var serverUrl = options.serverUrl || init.initOptions.serverUrl;\n    if (path) {\n        if (serverUrl) {\n            path = url.resolve(serverUrl, path);\n        }\n    }\n    else {\n        path = serverUrl;\n    }\n    return url.resolve(path, '/');\n}", "label": 3}
{"code": "def _init_kelas(self, makna_label):\n        \"\"\"Memproses kelas kata yang ada dalam makna.\n\n        :param makna_label: BeautifulSoup untuk makna yang ingin diproses.\n        :type makna_label: BeautifulSoup\n        \"\"\"\n\n        kelas = makna_label.find(color='red')\n        lain = makna_label.find(color='darkgreen')\n        info = makna_label.find(color='green')\n        if kelas:\n            kelas = kelas.find_all('span')\n        if lain:\n            self.kelas = {lain.text.strip(): lain['title'].strip()}\n            self.submakna = lain.next_sibling.strip()\n            self.submakna += ' ' + makna_label.find(color='grey').text.strip()\n        else:\n            self.kelas = {\n                k.text.strip(): k['title'].strip() for k in kelas\n            } if kelas else {}\n        self.info = info.text.strip() if info else ''", "label": 1}
{"code": "func (a *AuthServer) GetClusterConfig(opts ...services.MarshalOption) (services.ClusterConfig, error) {\n\treturn a.GetCache().GetClusterConfig(opts...)\n}", "label": 5}
{"code": "public static final Long date2utc(Date date) {\n\n        // use null for a null date\n        if (date == null) return null;\n        \n        long time = date.getTime();\n        \n        // remove the timezone offset        \n        time -= timezoneOffsetMillis(date);\n        \n        return time;\n    }", "label": 0}
{"code": "public function getIterableRoutes($version = null)\n    {\n        $iterable = [];\n\n        foreach ($this->getRoutes($version) as $version => $collector) {\n            $routeData = $collector->getData();\n\n            // The first element in the array are the static routes that do not have any parameters.\n            foreach ($this->normalizeStaticRoutes($routeData[0]) as $method => $routes) {\n                if ($method === 'HEAD') {\n                    continue;\n                }\n\n                foreach ($routes as $route) {\n                    $route['methods'] = $this->setRouteMethods($route, $method);\n\n                    $iterable[$version][] = $route;\n                }\n            }\n\n            // The second element is the more complicated regex routes that have parameters.\n            foreach ($routeData[1] as $method => $routes) {\n                if ($method === 'HEAD') {\n                    continue;\n                }\n\n                foreach ($routes as $data) {\n                    foreach ($data['routeMap'] as list($route, $parameters)) {\n                        $route['methods'] = $this->setRouteMethods($route, $method);\n\n                        $iterable[$version][] = $route;\n                    }\n                }\n            }\n        }\n\n        return new ArrayIterator($iterable);\n    }", "label": 2}
{"code": "def text_ui(self):\n        \"\"\"\n            Start Text UI main loop\n        \"\"\"\n        self.logger.info(\"Starting command line interface\")\n        self.help()\n        try:\n            self.ipython_ui()\n        except ImportError:\n            self.fallback_ui()\n        self.system.cleanup()", "label": 1}
{"code": "protected long buildNextSequence(PersistenceBroker broker, ClassDescriptor cld, String sequenceName)\r\n            throws LookupException, SQLException, PlatformException\r\n    {\r\n        CallableStatement cs = null;\r\n        try\r\n        {\r\n            Connection con = broker.serviceConnectionManager().getConnection();\r\n            cs = getPlatform().prepareNextValProcedureStatement(con, PROCEDURE_NAME, sequenceName);\r\n            cs.executeUpdate();\r\n            return cs.getLong(1);\r\n        }\r\n        finally\r\n        {\r\n            try\r\n            {\r\n                if (cs != null)\r\n                    cs.close();\r\n            }\r\n            catch (SQLException ignore)\r\n            {\r\n                // ignore it\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "def start_driver(http_client_ops =\n                         { http_client: ::Appium::Http::Default.new, open_timeout: 999_999, read_timeout: 999_999 })\n      @core.quit_driver\n\n      # If automationName is set only in server side, then the following automation_name should be nil before\n      # starting driver.\n      automation_name = @core.automation_name\n\n      @driver = @core.start_driver(server_url: server_url, http_client_ops: http_client_ops)\n      @http_client = @core.http_client\n\n      # if automation_name was nil before start_driver, then re-extend driver specific methods\n      # to be able to extend correctly.\n      extend_for(device: @core.device, automation_name: @core.automation_name) if automation_name.nil?\n\n      @appium_server_status = appium_server_version\n\n      @driver\n    end", "label": 4}
{"code": "public void createDB() throws PlatformException\r\n    {\r\n        if (_creationScript == null)\r\n        {\r\n            createCreationScript();\r\n        }\r\n\r\n        Project             project    = new Project();\r\n        TorqueDataModelTask modelTask  = new TorqueDataModelTask();\r\n        File                tmpDir     = null;\r\n        File                scriptFile = null;\r\n        \r\n        try\r\n        {\r\n            tmpDir = new File(getWorkDir(), \"schemas\");\r\n            tmpDir.mkdir();\r\n\r\n            scriptFile = new File(tmpDir, CREATION_SCRIPT_NAME);\r\n\r\n            writeCompressedText(scriptFile, _creationScript);\r\n\r\n            project.setBasedir(tmpDir.getAbsolutePath());\r\n\r\n            // we use the ant task 'sql' to perform the creation script\r\n\t        SQLExec         sqlTask = new SQLExec();\r\n\t        SQLExec.OnError onError = new SQLExec.OnError();\r\n\t\r\n\t        onError.setValue(\"continue\");\r\n\t        sqlTask.setProject(project);\r\n\t        sqlTask.setAutocommit(true);\r\n\t        sqlTask.setDriver(_jcd.getDriver());\r\n\t        sqlTask.setOnerror(onError);\r\n\t        sqlTask.setUserid(_jcd.getUserName());\r\n\t        sqlTask.setPassword(_jcd.getPassWord() == null ? \"\" : _jcd.getPassWord());\r\n\t        sqlTask.setUrl(getDBCreationUrl());\r\n\t        sqlTask.setSrc(scriptFile);\r\n\t        sqlTask.execute();\r\n\r\n\t        deleteDir(tmpDir);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            // clean-up\r\n            if ((tmpDir != null) && tmpDir.exists())\r\n            {\r\n                try\r\n                {\r\n                    scriptFile.delete();\r\n                }\r\n                catch (NullPointerException e) \r\n                {\r\n                    LoggerFactory.getLogger(this.getClass()).error(\"NPE While deleting scriptFile [\" + scriptFile.getName() + \"]\", e);\r\n                }\r\n            }\r\n            throw new PlatformException(ex);\r\n        }\r\n    }", "label": 0}
{"code": "public ClassicCounter<K2> setCounter(K1 o, Counter<K2> c) {\r\n    ClassicCounter<K2> old = getCounter(o);\r\n    total -= old.totalCount();\r\n    if (c instanceof ClassicCounter) {\r\n      map.put(o, (ClassicCounter<K2>) c);\r\n    } else {\r\n      map.put(o, new ClassicCounter<K2>(c));\r\n    }\r\n    total += c.totalCount();\r\n    return old;\r\n  }", "label": 0}
{"code": "func (agp *AuthGroupPermission) Delete(db XODB) error {\n\tvar err error\n\n\t// if doesn't exist, bail\n\tif !agp._exists {\n\t\treturn nil\n\t}\n\n\t// if deleted, bail\n\tif agp._deleted {\n\t\treturn nil\n\t}\n\n\t// sql query\n\tconst sqlstr = `DELETE FROM auth_group_permissions WHERE id = ?`\n\n\t// run query\n\tXOLog(sqlstr, agp.ID)\n\t_, err = db.Exec(sqlstr, agp.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set deleted\n\tagp._deleted = true\n\n\treturn nil\n}", "label": 5}
{"code": "function timeDiff(newest, oldest) {\n  var diff = (parseFloat(newest) - parseFloat(oldest));\n  if (diff < 0) {\n    diff = ((10000 + parseFloat(newest)) - parseFloat(oldest));\n  }\n  return diff;\n}", "label": 3}
{"code": "public static aaapreauthenticationparameter get(nitro_service service,  options option) throws Exception{\n\t\taaapreauthenticationparameter obj = new aaapreauthenticationparameter();\n\t\taaapreauthenticationparameter[] response = (aaapreauthenticationparameter[])obj.get_resources(service,option);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def list_cash_drawer_shifts(location_id, opts = {})\n      data, _status_code, _headers = list_cash_drawer_shifts_with_http_info(location_id, opts)\n      return data\n    end", "label": 4}
{"code": "func (b *BoxLayout) AddWidget(widget Widget, fill float64) {\n\tc := &boxLayoutCell{\n\t\twidget: widget,\n\t\tfill:   fill,\n\t\tview:   NewViewPort(b.view, 0, 0, 0, 0),\n\t}\n\twidget.SetView(c.view)\n\tb.cells = append(b.cells, c)\n\tb.changed = true\n\twidget.Watch(b)\n\tb.layout()\n\tb.PostEventWidgetContent(b)\n}", "label": 5}
{"code": "public DependencyReport getDependencyReport(final String moduleId, final FiltersHolder filters) {\n        final DbModule module = moduleHandler.getModule(moduleId);\n        final DbOrganization organization = moduleHandler.getOrganization(module);\n        filters.setCorporateFilter(new CorporateFilter(organization));\n\n        final DependencyReport report = new DependencyReport(moduleId);\n        final List<String> done = new ArrayList<String>();\n        for(final DbModule submodule: DataUtils.getAllSubmodules(module)){\n            done.add(submodule.getId());\n        }\n\n        addModuleToReport(report, module, filters, done, 1);\n\n        return report;\n    }", "label": 0}
{"code": "func (t *remoteTerminal) prepareRemoteSession(session *ssh.Session, ctx *ServerContext) {\n\tenvs := map[string]string{\n\t\tteleport.SSHTeleportUser:        ctx.Identity.TeleportUser,\n\t\tteleport.SSHSessionWebproxyAddr: ctx.ProxyPublicAddress(),\n\t\tteleport.SSHTeleportHostUUID:    ctx.srv.ID(),\n\t\tteleport.SSHTeleportClusterName: ctx.ClusterName,\n\t\tteleport.SSHSessionID:           string(ctx.session.id),\n\t}\n\n\tfor k, v := range envs {\n\t\tif err := session.Setenv(k, v); err != nil {\n\t\t\tt.log.Debugf(\"Unable to set environment variable: %v: %v\", k, v)\n\t\t}\n\t}\n}", "label": 5}
{"code": "def read_with_retry_cursor(session, server_selector, view, &block)\n      read_with_retry(session, server_selector) do |server|\n        result = yield server\n        Cursor.new(view, result, server, session: session)\n      end\n    end", "label": 4}
{"code": "public function find($name)\n    {\n        foreach ($this->all() as $module) {\n            if ($module->getLowerName() === strtolower($name)) {\n                return $module;\n            }\n        }\n\n        return;\n    }", "label": 2}
{"code": "def histogram(data):\n    \"\"\"Returns a histogram of your data.\n\n    :param data: The data to histogram\n    :type data: list[object]\n    :return: The histogram\n    :rtype: dict[object, int]\n    \"\"\"\n    ret = {}\n    for datum in data:\n        if datum in ret:\n            ret[datum] += 1\n        else:\n            ret[datum] = 1\n    return ret", "label": 1}
{"code": "public function permissions()\n    {\n        $groupIds = [Group::GUEST_ID];\n\n        // If a user's account hasn't been activated, they are essentially no\n        // more than a guest. If they are activated, we can give them the\n        // standard 'member' group, as well as any other groups they've been\n        // assigned to.\n        if ($this->is_email_confirmed) {\n            $groupIds = array_merge($groupIds, [Group::MEMBER_ID], $this->groups->pluck('id')->all());\n        }\n\n        event(new PrepareUserGroups($this, $groupIds));\n\n        return Permission::whereIn('group_id', $groupIds);\n    }", "label": 2}
{"code": "public function getWaiters()\n    {\n        if (!isset($this->waiters)) {\n            $res = call_user_func(\n                $this->apiProvider,\n                'waiter',\n                $this->serviceName,\n                $this->apiVersion\n            );\n            $this->waiters = isset($res['waiters'])\n                ? $res['waiters']\n                : [];\n        }\n\n        return $this->waiters;\n    }", "label": 2}
{"code": "function (format, numTracks) {\n  var chunklen = padNumber(6, 4); // MIDI header is always 6 bytes long\n  var ntracks = padNumber(numTracks, 2);\n  var tickdiv = padNumber(ticksPerBeat, 2);\n  format = padNumber(format, 2); // Usually format 1 MIDI file (multuple overlayed tracks)\n\n  return Buffer.concat([midiHeader, chunklen, format, ntracks, tickdiv]);\n}", "label": 3}
{"code": "func (app *Application) initialize() error {\n\tif app.screen == nil {\n\t\tif app.screen, app.err = tcell.NewScreen(); app.err != nil {\n\t\t\treturn app.err\n\t\t}\n\t\tapp.screen.SetStyle(app.style)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def render(context, params = {})\n      partial_root  = params.delete(:root)         || 'public_activity'\n      partial_path  = nil\n      layout_root   = params.delete(:layout_root)  || 'layouts'\n\n      if params.has_key? :display\n        if params[:display].to_sym == :\"i18n\"\n          text = self.text(params)\n          return context.render :text => text, :plain => text\n        else\n          partial_path = File.join(partial_root, params[:display].to_s)\n        end\n      end\n\n      context.render(\n        params.merge({\n          :partial => prepare_partial(partial_root, partial_path),\n          :layout  => prepare_layout(layout_root, params.delete(:layout)),\n          :locals  => prepare_locals(params)\n        })\n      )\n    end", "label": 4}
{"code": "func (c *Client) GetSession(namespace string, id session.ID) (*session.Session, error) {\n\tif namespace == \"\" {\n\t\treturn nil, trace.BadParameter(MissingNamespaceError)\n\t}\n\t// saving extra round-trip\n\tif err := id.Check(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tout, err := c.Get(c.Endpoint(\"namespaces\", namespace, \"sessions\", string(id)), url.Values{})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvar sess *session.Session\n\tif err := json.Unmarshal(out.Bytes(), &sess); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn sess, nil\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, snmpuser resource) throws Exception {\n\t\tsnmpuser addresource = new snmpuser();\n\t\taddresource.name = resource.name;\n\t\taddresource.group = resource.group;\n\t\taddresource.authtype = resource.authtype;\n\t\taddresource.authpasswd = resource.authpasswd;\n\t\taddresource.privtype = resource.privtype;\n\t\taddresource.privpasswd = resource.privpasswd;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def start(self, autopush=True):\n        \"\"\"Start a new animation instance\"\"\"\n        if self.enabled:\n            if autopush:\n                self.push_message(self.message)\n                self.spinner.message = ' - '.join(self.animation.messages)\n            if not self.spinner.running:\n                self.animation.thread = threading.Thread(target=_spinner,\n                                                         args=(self.spinner,))\n                self.spinner.running = True\n                self.animation.thread.start()\n                sys.stdout = stream.Clean(sys.stdout, self.spinner.stream)", "label": 1}
{"code": "def all_number_types(phone, data, not_valid = false)\n      response = { valid: [], possible: [] }\n\n      types_for_check(data).each do |type|\n        possible, valid = get_patterns(data, type)\n\n        valid_and_possible, possible_result =\n            number_valid_and_possible?(phone, possible, valid, not_valid)\n        response[:possible] << type if possible_result\n        response[:valid] << type if valid_and_possible\n      end\n\n      sanitize_fixed_mobile(response)\n    end", "label": 4}
{"code": "def handle_preconditions(id_generator)\n      # Nest multiple preconditions under a single root precondition\n      @preconditions = @entry.xpath('./*/cda:precondition[not(@nullFlavor)]', HQMF2::Document::NAMESPACES)\n                       .collect do |pre|\n        precondition = Precondition.parse(pre, @doc, id_generator)\n        precondition.reference.nil? && precondition.preconditions.empty? ? nil : precondition\n      end\n      # Remove uneeded nils from the array\n      @preconditions.compact!\n    end", "label": 4}
{"code": "function AdapterNotFoundError(adapterName, innerError) {\n  /**\n   * The name of the adapter that was not found.\n   * @type {?string}\n   */\n  this.adapterName = adapterName;\n  /**\n   * The inner error that generated the current error.\n   * @type {?Error}\n   */\n  this.innerError = innerError;\n\n  expect(arguments).to.have.length.below(\n    3,\n    'Invalid arguments length when creating a new ' +\n    'EntityNotFoundError (it has to be passed less than 3 arguments)'\n  );\n\n  this.name = 'AdapterNotFoundError';\n\n  this.message = 'Cannot find Adapter';\n  if (adapterName) {\n    expect(adapterName).to.be.a(\n      'string',\n      'Invalid argument \"adapterName\" when creating a new ' +\n      'AdapterNotFoundError (it has to be a string)'\n    );\n    this.message += ' \"' + adapterName + '\"';\n  }\n\n  this.stack = (new Error(this.message)).stack;\n  if (innerError) {\n    expect(innerError).to.be.an.instanceof(\n      Error,\n      'Invalid argument \"innerError\" when creating a new ' +\n      'AdapterNotFoundError (it has to be an Error)'\n    );\n    this.stack += '\\n\\n' + innerError.stack;\n  }\n}", "label": 3}
{"code": "func (s *CA) CreateCertAuthority(ca services.CertAuthority) error {\n\tif err := ca.Check(); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tvalue, err := services.GetCertAuthorityMarshaler().MarshalCertAuthority(ca)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\titem := backend.Item{\n\t\tKey:     backend.Key(authoritiesPrefix, string(ca.GetType()), ca.GetName()),\n\t\tValue:   value,\n\t\tExpires: ca.Expiry(),\n\t}\n\n\t_, err = s.Create(context.TODO(), item)\n\tif err != nil {\n\t\tif trace.IsAlreadyExists(err) {\n\t\t\treturn trace.AlreadyExists(\"cluster %q already exists\", ca.GetName())\n\t\t}\n\t\treturn trace.Wrap(err)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "public function clearMediaCollection(string $collectionName = 'default'): self\n    {\n        $this->getMedia($collectionName)\n            ->each->delete();\n\n        event(new CollectionHasBeenCleared($this, $collectionName));\n\n        if ($this->mediaIsPreloaded()) {\n            unset($this->media);\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "protected function dumpDatabases(): array\n    {\n        return $this->dbDumpers->map(function (DbDumper $dbDumper, $key) {\n            consoleOutput()->info(\"Dumping database {$dbDumper->getDbName()}...\");\n\n            $dbType = mb_strtolower(basename(str_replace('\\\\', '/', get_class($dbDumper))));\n\n            $dbName = $dbDumper->getDbName();\n            if ($dbDumper instanceof Sqlite) {\n                $dbName = $key.'-database';\n            }\n\n            $fileName = \"{$dbType}-{$dbName}.{$this->getExtension($dbDumper)}\";\n\n            if (config('backup.backup.gzip_database_dump')) {\n                $dbDumper->useCompressor(new GzipCompressor());\n                $fileName .= '.'.$dbDumper->getCompressorExtension();\n            }\n\n            if ($compressor = config('backup.backup.database_dump_compressor')) {\n                $dbDumper->useCompressor(new $compressor());\n                $fileName .= '.'.$dbDumper->getCompressorExtension();\n            }\n\n            $temporaryFilePath = $this->temporaryDirectory->path('db-dumps'.DIRECTORY_SEPARATOR.$fileName);\n\n            $dbDumper->dumpToFile($temporaryFilePath);\n\n            return $temporaryFilePath;\n        })->toArray();\n    }", "label": 2}
{"code": "protected static function createConnection($connection, Configuration $config, ?EventManager $eventManager = null)\n    {\n        if (is_array($connection)) {\n            return DriverManager::getConnection($connection, $config, $eventManager ?: new EventManager());\n        }\n\n        if (! $connection instanceof Connection) {\n            throw new InvalidArgumentException(\n                sprintf(\n                    'Invalid $connection argument of type %s given%s.',\n                    is_object($connection) ? get_class($connection) : gettype($connection),\n                    is_object($connection) ? '' : ': \"' . $connection . '\"'\n                )\n            );\n        }\n\n        if ($eventManager !== null && $connection->getEventManager() !== $eventManager) {\n            throw MismatchedEventManager::create();\n        }\n\n        return $connection;\n    }", "label": 2}
{"code": "protected void initializeJdbcConnection(Connection con, JdbcConnectionDescriptor jcd)\r\n            throws LookupException\r\n    {\r\n        try\r\n        {\r\n            PlatformFactory.getPlatformFor(jcd).initializeJdbcConnection(jcd, con);\r\n        }\r\n        catch (PlatformException e)\r\n        {\r\n            throw new LookupException(\"Platform dependent initialization of connection failed\", e);\r\n        }\r\n    }", "label": 0}
{"code": "func (t *TextBar) HandleEvent(ev tcell.Event) bool {\n\tswitch ev.(type) {\n\tcase *EventWidgetContent:\n\t\tt.changed = true\n\t\treturn true\n\t}\n\treturn false\n}", "label": 5}
{"code": "public static authorizationpolicylabel_binding get(nitro_service service, String labelname) throws Exception{\n\t\tauthorizationpolicylabel_binding obj = new authorizationpolicylabel_binding();\n\t\tobj.set_labelname(labelname);\n\t\tauthorizationpolicylabel_binding response = (authorizationpolicylabel_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function parseBoolean(value, context) {\n    if (value === true || value === 'true') return true;\n    if (value === false || value === 'false') return false;\n    throw new ImplementationError(`Invalid boolean value \"${value}\"${context.errorContext}`);\n}", "label": 3}
{"code": "func (t *Torrent) addrActive(addr string) bool {\n\tif _, ok := t.halfOpen[addr]; ok {\n\t\treturn true\n\t}\n\tfor c := range t.conns {\n\t\tra := c.remoteAddr\n\t\tif ra.String() == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "label": 5}
{"code": "function updateMetadata(metadata, form) {\n  metadata.files[form.id] = {\n    name: form.name,\n    path: path.join(ZIP_SUBFOLDER_NAME, form.id + '.json')\n  };\n}", "label": 3}
{"code": "func (s *CA) ActivateCertAuthority(id services.CertAuthID) error {\n\titem, err := s.Get(context.TODO(), backend.Key(authoritiesPrefix, deactivatedPrefix, string(id.Type), id.DomainName))\n\tif err != nil {\n\t\tif trace.IsNotFound(err) {\n\t\t\treturn trace.BadParameter(\"can not activate cert authority %q which has not been deactivated\", id.DomainName)\n\t\t}\n\t\treturn trace.Wrap(err)\n\t}\n\n\tcertAuthority, err := services.GetCertAuthorityMarshaler().UnmarshalCertAuthority(\n\t\titem.Value, services.WithResourceID(item.ID), services.WithExpires(item.Expires))\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\terr = s.UpsertCertAuthority(certAuthority)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\terr = s.Delete(context.TODO(), backend.Key(authoritiesPrefix, deactivatedPrefix, string(id.Type), id.DomainName))\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def lookup(token, options = {})\n      headers = extract_headers!(options)\n      json = client.post(\"/v1/auth/token/lookup\", JSON.fast_generate(\n        token: token,\n      ), headers)\n      return Secret.decode(json)\n    end", "label": 4}
{"code": "public void sendMessageToAgentsWithExtraProperties(String[] agent_name,\n            String msgtype, Object message_content,\n            ArrayList<Object> properties, Connector connector) {\n        HashMap<String, Object> hm = new HashMap<String, Object>();\n        hm.put(\"performative\", msgtype);\n        hm.put(SFipa.CONTENT, message_content);\n\n        for (Object property : properties) {\n            // Logger logger = Logger.getLogger(\"JadexMessenger\");\n            // logger.info(\"Sending message with extra property: \"+property.get(0)+\", with value \"+property.get(1));\n            hm.put((String) ((Tuple) property).get(0), ((Tuple) property).get(1));\n        }\n\n        IComponentIdentifier[] ici = new IComponentIdentifier[agent_name.length];\n        for (int i = 0; i < agent_name.length; i++) {\n            ici[i] = (IComponentIdentifier) connector.getAgentID(agent_name[i]);\n        }\n        ((IMessageService) connector.getMessageService()).deliverMessage(hm,\n                \"fipa\", ici);\n    }", "label": 0}
{"code": "def push_bus(self, tokens):\n        \"\"\" Adds a Bus object to the case.\n        \"\"\"\n        logger.debug(\"Pushing bus data: %s\" % tokens)\n\n        bus = Bus()\n        bus.name = tokens[\"bus_no\"]\n        bus.v_magnitude = tokens[\"v_magnitude\"]\n        bus.v_angle = tokens[\"v_angle\"]\n        bus.v_magnitude = tokens[\"v_magnitude\"]\n        bus.v_angle = tokens[\"v_angle\"]\n\n        self.case.buses.append(bus)", "label": 1}
{"code": "function status(req, res, next) {\n  var params = {\n    submission: {\n      submissionId: req.params.id\n    }\n  };\n\n  logger.debug(\"Middleware Submission status \", {params: params});\n\n  forms.getSubmissionStatus(_.extend(params, req.connectionOptions), submissionsHandler(constants.resultTypes.submissions, req, next));\n}", "label": 3}
{"code": "func registerPod(root string, uuid *types.UUID, apps schema.AppList) (token string, rerr error) {\n\tu := uuid.String()\n\n\tvar err error\n\ttoken, err = generateMDSToken()\n\tif err != nil {\n\t\trerr = errwrap.Wrap(errors.New(\"failed to generate MDS token\"), err)\n\t\treturn\n\t}\n\n\tpmfPath := common.PodManifestPath(root)\n\tpmf, err := os.Open(pmfPath)\n\tif err != nil {\n\t\trerr = errwrap.Wrap(fmt.Errorf(\"failed to open runtime manifest (%v)\", pmfPath), err)\n\t\treturn\n\t}\n\n\tpth := fmt.Sprintf(\"/pods/%v?token=%v\", u, token)\n\terr = httpRequest(\"PUT\", pth, pmf)\n\tpmf.Close()\n\tif err != nil {\n\t\trerr = errwrap.Wrap(errors.New(\"failed to register pod with metadata svc\"), err)\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tif rerr != nil {\n\t\t\tunregisterPod(root, uuid)\n\t\t}\n\t}()\n\n\trf, err := os.Create(filepath.Join(root, mdsRegisteredFile))\n\tif err != nil {\n\t\trerr = errwrap.Wrap(errors.New(\"failed to create mds-register file\"), err)\n\t\treturn\n\t}\n\trf.Close()\n\n\tfor _, app := range apps {\n\t\tampath := common.ImageManifestPath(root, app.Name)\n\t\tamf, err := os.Open(ampath)\n\t\tif err != nil {\n\t\t\trerr = errwrap.Wrap(fmt.Errorf(\"failed reading app manifest %q\", ampath), err)\n\t\t\treturn\n\t\t}\n\n\t\terr = registerApp(u, app.Name.String(), amf)\n\t\tamf.Close()\n\t\tif err != nil {\n\t\t\trerr = errwrap.Wrap(errors.New(\"failed to register app with metadata svc\"), err)\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}", "label": 5}
{"code": "def build_rendering(file_set_id)\n      file_set_document = query_for_rendering(file_set_id)\n      label = file_set_document.label.present? ? \": #{file_set_document.label}\" : ''\n      mime = file_set_document.mime_type.present? ? file_set_document.mime_type : I18n.t(\"hyrax.manifest.unknown_mime_text\")\n      {\n        '@id' => Hyrax::Engine.routes.url_helpers.download_url(file_set_document.id, host: @hostname),\n        'format' => mime,\n        'label' => I18n.t(\"hyrax.manifest.download_text\") + label\n      }\n    end", "label": 4}
{"code": "function resourceId(resourceFile, relativeTo, resourceCollection = '') {\n  const pathKeys = relativePathArray(resourceFile.path, relativeTo).map(\n    keyname\n  );\n  const resourceBits = [];\n  if (resourceCollection && resourceCollection.length !== 0) {\n    resourceBits.push(resourceCollection);\n  }\n  return resourceBits\n    .concat(pathKeys)\n    .concat([keyname(resourceFile.path)])\n    .join('.');\n}", "label": 3}
{"code": "def __get_precipfc_data(latitude, longitude):\n    \"\"\"Get buienradar forecasted precipitation.\"\"\"\n    url = 'https://gpsgadget.buienradar.nl/data/raintext?lat={}&lon={}'\n    # rounding coordinates prevents unnecessary redirects/calls\n    url = url.format(\n        round(latitude, 2),\n        round(longitude, 2)\n    )\n    result = __get_url(url)\n    return result", "label": 1}
{"code": "def random_offset(self, lst):\n        \"\"\" \n        offsets a pattern list generated below to a random\n        position in the grid\n        \"\"\"\n        res = []\n        x = random.randint(4,self.max_x - 42)\n        y = random.randint(4,self.max_y - 10)\n        for itm in lst:\n            res.append([itm[0] + y, itm[1] + x])\n        return res", "label": 1}
{"code": "def run\n      @run_mutex.synchronize do\n        fail 'cannot run without registering services' if rpc_descs.size.zero?\n        @pool.start\n        @server.start\n        transition_running_state(:running)\n        @run_cond.broadcast\n      end\n      loop_handle_server_calls\n    end", "label": 4}
{"code": "public double estimateExcludedVolumeFraction(){\n\t\t//Calculate volume/area of the of the scene without obstacles\n\t\tif(recalculateVolumeFraction){\n\t\t\tCentralRandomNumberGenerator r = CentralRandomNumberGenerator.getInstance();\n\t\t\tboolean firstRandomDraw = false;\n\t\t\tif(randomNumbers==null){\n\t\t\t\trandomNumbers = new double[nRandPoints*dimension];\n\t\t\t\tfirstRandomDraw = true;\n\t\t\t}\n\t\t\tint countCollision = 0;\n\t\t\tfor(int i = 0; i< nRandPoints; i++){\n\t\t\t\tdouble[] pos = new double[dimension];\n\t\t\t\tfor(int j = 0; j < dimension; j++){\n\t\t\t\t\tif(firstRandomDraw){\n\t\t\t\t\t\trandomNumbers[i*dimension + j] = r.nextDouble();\n\t\t\t\t\t}\n\t\t\t\t\tpos[j] = randomNumbers[i*dimension + j]*size[j];\n\t\t\t\t}\n\t\t\t\tif(checkCollision(pos)){\n\t\t\t\t\tcountCollision++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfraction = countCollision*1.0/nRandPoints;\n\t\t\trecalculateVolumeFraction = false;\n\t\t}\n\t\treturn fraction;\n\t}", "label": 0}
{"code": "def retrieve_transaction(location_id, transaction_id, opts = {})\n      data, _status_code, _headers = retrieve_transaction_with_http_info(location_id, transaction_id, opts)\n      return data\n    end", "label": 4}
{"code": "def update_fields(fields)\n      attributes[:name]      = fields['name'] || attributes[:name]\n      attributes[:id]        = fields['id'] || attributes[:id]\n      attributes[:pos]       = fields['pos'] || attributes[:pos]\n      attributes[:url]       = fields['url'] || attributes[:url]\n      attributes[:bytes]     = fields['bytes'].to_i || attributes[:bytes]\n      attributes[:member_id] = fields['idMember'] || attributes[:member_id]\n      attributes[:date]      = Time.parse(fields['date']).presence || attributes[:date]\n      attributes[:is_upload] = fields['isUpload'] if fields.has_key?('isUpload')\n      attributes[:mime_type] = fields['mimeType'] || attributes[:mime_type]\n      attributes[:previews]  = fields['previews'] if fields.has_key?('previews')\n      self\n    end", "label": 4}
{"code": "def encrypt(str, random_iv: SymmetricEncryption.randomize_iv?, compress: false, header: always_add_header)\n      return if str.nil?\n\n      str = str.to_s\n      return str if str.empty?\n\n      encrypted = binary_encrypt(str, random_iv: random_iv, compress: compress, header: header)\n      encode(encrypted)\n    end", "label": 4}
{"code": "public function findByIds(array $ids, User $actor = null)\n    {\n        $posts = $this->queryIds($ids, $actor)->get();\n\n        $posts = $posts->sort(function ($a, $b) use ($ids) {\n            $aPos = array_search($a->id, $ids);\n            $bPos = array_search($b->id, $ids);\n\n            if ($aPos === $bPos) {\n                return 0;\n            }\n\n            return $aPos < $bPos ? -1 : 1;\n        });\n\n        return $posts;\n    }", "label": 2}
{"code": "function deltaE(labA, labB) {\n      var deltaL = labA[0] - labB[0];\n      var deltaA = labA[1] - labB[1];\n      var deltaB = labA[2] - labB[2];\n\n      return Math.sqrt(Math.pow(deltaL, 2) +\n                       Math.pow(deltaA, 2) +\n                       Math.pow(deltaB, 2));\n    }", "label": 3}
{"code": "private Field getFieldRecursive(Class c, String name) throws NoSuchFieldException\r\n    {\r\n        try\r\n        {\r\n            return c.getDeclaredField(name);\r\n        }\r\n        catch (NoSuchFieldException e)\r\n        {\r\n            // if field  could not be found in the inheritance hierarchy, signal error\r\n            if ((c == Object.class) || (c.getSuperclass() == null) || c.isInterface())\r\n            {\r\n                throw e;\r\n            }\r\n            // if field could not be found in class c try in superclass\r\n            else\r\n            {\r\n                return getFieldRecursive(c.getSuperclass(), name);\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "def tokenize string\n      return nil if string.empty?\n      return string if @string_cache.key?(string)\n      return @symbol_cache[string] if @symbol_cache.key?(string)\n\n      case string\n      # Check for a String type, being careful not to get caught by hash keys, hex values, and\n      # special floats (e.g., -.inf).\n      when /^[^\\d\\.:-]?[A-Za-z_\\s!@#\\$%\\^&\\*\\(\\)\\{\\}\\<\\>\\|\\/\\\\~;=]+/, /\\n/\n        if string.length > 5\n          @string_cache[string] = true\n          return string\n        end\n\n        case string\n        when /^[^ytonf~]/i\n          @string_cache[string] = true\n          string\n        when '~', /^null$/i\n          nil\n        when /^(yes|true|on)$/i\n          true\n        when /^(no|false|off)$/i\n          false\n        else\n          @string_cache[string] = true\n          string\n        end\n      when TIME\n        begin\n          parse_time string\n        rescue ArgumentError\n          string\n        end\n      when /^\\d{4}-(?:1[012]|0\\d|\\d)-(?:[12]\\d|3[01]|0\\d|\\d)$/\n        require 'date'\n        begin\n          class_loader.date.strptime(string, '%Y-%m-%d')\n        rescue ArgumentError\n          string\n        end\n      when /^\\.inf$/i\n        Float::INFINITY\n      when /^-\\.inf$/i\n        -Float::INFINITY\n      when /^\\.nan$/i\n        Float::NAN\n      when /^:./\n        if string =~ /^:([\"'])(.*)\\1/\n          @symbol_cache[string] = class_loader.symbolize($2.sub(/^:/, ''))\n        else\n          @symbol_cache[string] = class_loader.symbolize(string.sub(/^:/, ''))\n        end\n      when /^[-+]?[0-9][0-9_]*(:[0-5]?[0-9]){1,2}$/\n        i = 0\n        string.split(':').each_with_index do |n,e|\n          i += (n.to_i * 60 ** (e - 2).abs)\n        end\n        i\n      when /^[-+]?[0-9][0-9_]*(:[0-5]?[0-9]){1,2}\\.[0-9_]*$/\n        i = 0\n        string.split(':').each_with_index do |n,e|\n          i += (n.to_f * 60 ** (e - 2).abs)\n        end\n        i\n      when FLOAT\n        if string =~ /\\A[-+]?\\.\\Z/\n          @string_cache[string] = true\n          string\n        else\n          Float(string.gsub(/[,_]|\\.([Ee]|$)/, '\\1'))\n        end\n      else\n        int = parse_int string.gsub(/[,_]/, '')\n        return int if int\n\n        @string_cache[string] = true\n        string\n      end\n    end", "label": 4}
{"code": "public function sendPresenceSubscription($to)\n    {\n        $node = new ProtocolNode('presence', ['type' => 'subscribe', 'to' => $this->getJID($to)], null, '');\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "private function boolCall(callable $fn, $flags = null)\n    {\n        try {\n            return $fn();\n        } catch (\\Exception $e) {\n            return $this->triggerError($e->getMessage(), $flags);\n        }\n    }", "label": 2}
{"code": "public function setScriptReadOnly($script, $readonly = true)\n    {\n        $sha1 = sha1($script);\n\n        if ($readonly) {\n            $this->readonlySHA1[$sha1] = $readonly;\n        } else {\n            unset($this->readonlySHA1[$sha1]);\n        }\n    }", "label": 2}
{"code": "public function meridiem(bool $isLower = false): string\n    {\n        $hour = $this->hour;\n        $index = $hour < 12 ? 0 : 1;\n\n        if ($isLower) {\n            $key = 'meridiem.'.($index + 2);\n            $result = $this->translate($key);\n\n            if ($result !== $key) {\n                return $result;\n            }\n        }\n\n        $key = \"meridiem.$index\";\n        $result = $this->translate($key);\n        if ($result === $key) {\n            $result = $this->translate('meridiem', [\n                ':hour' => $this->hour,\n                ':minute' => $this->minute,\n                ':isLower' => $isLower,\n            ]);\n\n            if ($result === 'meridiem') {\n                return $isLower ? $this->latinMeridiem : $this->latinUpperMeridiem;\n            }\n        } elseif ($isLower) {\n            $result = mb_strtolower($result);\n        }\n\n        return $result;\n    }", "label": 2}
{"code": "def write_attribute(name, value)\n      name = name.to_sym\n\n      if association = @associations[name]\n        association.reset\n      end\n\n      @attributes_before_type_cast[name] = value\n\n      value_casted = TypeCasting.cast_field(value, self.class.attributes[name])\n      attributes[name] = value_casted\n    end", "label": 4}
{"code": "def create(*args)\n      arguments(args, required: [:user, :repo, :path]) do\n        assert_required REQUIRED_CONTENT_OPTIONS\n      end\n      params = arguments.params\n      params.strict_encode64('content')\n\n      put_request(\"/repos/#{arguments.user}/#{arguments.repo}/contents/#{arguments.path}\", params)\n    end", "label": 4}
{"code": "def _process_tz(self, dt, naive, tz):\n\t\t\"\"\"Process timezone casting and conversion.\"\"\"\n\t\t\n\t\tdef _tz(t):\n\t\t\tif t in (None, 'naive'):\n\t\t\t\treturn t\n\t\t\t\n\t\t\tif t == 'local':\n\t\t\t\tif __debug__ and not localtz:\n\t\t\t\t\traise ValueError(\"Requested conversion to local timezone, but `localtz` not installed.\")\n\t\t\t\t\n\t\t\t\tt = localtz\n\t\t\t\n\t\t\tif not isinstance(t, tzinfo):\n\t\t\t\tif __debug__ and not localtz:\n\t\t\t\t\traise ValueError(\"The `pytz` package must be installed to look up timezone: \" + repr(t))\n\t\t\t\t\n\t\t\t\tt = get_tz(t)\n\t\t\t\n\t\t\tif not hasattr(t, 'normalize') and get_tz:  # Attempt to handle non-pytz tzinfo.\n\t\t\t\tt = get_tz(t.tzname(dt))\n\t\t\t\n\t\t\treturn t\n\t\t\n\t\tnaive = _tz(naive)\n\t\ttz = _tz(tz)\n\t\t\n\t\tif not dt.tzinfo and naive:\n\t\t\tif hasattr(naive, 'localize'):\n\t\t\t\tdt = naive.localize(dt)\n\t\t\telse:\n\t\t\t\tdt = dt.replace(tzinfo=naive)\n\t\t\n\t\tif not tz:\n\t\t\treturn dt\n\t\t\n\t\tif hasattr(tz, 'normalize'):\n\t\t\tdt = tz.normalize(dt.astimezone(tz))\n\t\telif tz == 'naive':\n\t\t\tdt = dt.replace(tzinfo=None)\n\t\telse:\n\t\t\tdt = dt.astimezone(tz)  # Warning: this might not always be entirely correct!\n\t\t\n\t\treturn dt", "label": 1}
{"code": "func (s *InstanceSecrets) GetRoles() []services.Role {\n\tvar roles []services.Role\n\tfor _, ca := range s.GetCAs() {\n\t\tif ca.GetType() != services.UserCA {\n\t\t\tcontinue\n\t\t}\n\t\trole := services.RoleForCertAuthority(ca)\n\t\trole.SetLogins(services.Allow, s.AllowedLogins())\n\t\troles = append(roles, role)\n\t}\n\treturn roles\n}", "label": 5}
{"code": "def _get_translation(self, field, code):\n        \"\"\"\n        Gets the translation of a specific field for a specific language code.\n\n        This raises ObjectDoesNotExist if the lookup was unsuccesful. As of\n        today, this stuff is cached. As the cache is rather aggressive it\n        might cause rather strange effects. However, we would see the same\n        effects when an ordinary object is changed which is already in memory:\n        the old state would remain.\n        \"\"\"\n\n        if not code in self._translation_cache:\n            translations = self.translations.select_related()\n\n            logger.debug(\n                u'Matched with field %s for language %s. Attempting lookup.',\n                field, code\n            )\n\n            try:\n                translation_obj = translations.get(language_code=code)\n\n            except ObjectDoesNotExist:\n                translation_obj = None\n\n            self._translation_cache[code] = translation_obj\n\n            logger.debug(u'Translation not found in cache.')\n\n        else:\n            logger.debug(u'Translation found in cache.')\n            # Get the translation from the cache\n            translation_obj = self._translation_cache.get(code)\n\n        # If this is none, it means that a translation does not exist\n        # It is important to cache this one as well\n        if not translation_obj:\n            raise ObjectDoesNotExist\n\n        field_value = getattr(translation_obj, field)\n\n        logger.debug(\n            u'Found translation object %s, returning value %s.',\n            translation_obj, field_value\n        )\n\n        return field_value", "label": 1}
{"code": "def create_variation(location_id, item_id, body, opts = {})\n      data, _status_code, _headers = create_variation_with_http_info(location_id, item_id, body, opts)\n      return data\n    end", "label": 4}
{"code": "public function cascade()\n    {\n        foreach (static::getFlipCascadeFactors() as $source => [$target, $factor]) {\n            if ($source === 'dayz' && $target === 'weeks') {\n                continue;\n            }\n\n            $value = $this->$source;\n            $this->$source = $modulo = ($factor + ($value % $factor)) % $factor;\n            $this->$target += ($value - $modulo) / $factor;\n            if ($this->$source > 0 && $this->$target < 0) {\n                $this->$source -= $factor;\n                $this->$target++;\n            }\n        }\n\n        return $this->solveNegativeInterval();\n    }", "label": 2}
{"code": "def extract_fields(cls, schema):\n        \"\"\"Extract fields in a parse expression schema.\n\n        :param schema: Parse expression schema/format to use (as string).\n        :return: Generator for fields in schema (as Field objects).\n        \"\"\"\n        # -- BASED-ON: parse.Parser._generate_expression()\n        for part in parse.PARSE_RE.split(schema):\n            if not part or part == '{{' or part == '}}':\n                continue\n            elif part[0] == '{':\n                # this will be a braces-delimited field to handle\n                yield cls.parse(part)", "label": 1}
{"code": "func (a *HistoricalApi) namespacePodList(request *restful.Request, response *restful.Response) {\n\tif resp, err := a.historicalSource.GetPodsFromNamespace(request.PathParameter(\"namespace-name\")); err != nil {\n\t\tresponse.WriteError(http.StatusInternalServerError, err)\n\t} else {\n\t\tresponse.WriteEntity(resp)\n\t}\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, dnsview resource) throws Exception {\n\t\tdnsview addresource = new dnsview();\n\t\taddresource.viewname = resource.viewname;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public void calculateSize(PdfContext context) {\n\t\tfloat width = 0;\n\t\tfloat height = 0;\n\t\tfor (PrintComponent<?> child : children) {\n\t\t\tchild.calculateSize(context);\n\t\t\tfloat cw = child.getBounds().getWidth() + 2 * child.getConstraint().getMarginX();\n\t\t\tfloat ch = child.getBounds().getHeight() + 2 * child.getConstraint().getMarginY();\n\t\t\tswitch (getConstraint().getFlowDirection()) {\n\t\t\t\tcase LayoutConstraint.FLOW_NONE:\n\t\t\t\t\twidth = Math.max(width, cw);\n\t\t\t\t\theight = Math.max(height, ch);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LayoutConstraint.FLOW_X:\n\t\t\t\t\twidth += cw;\n\t\t\t\t\theight = Math.max(height, ch);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LayoutConstraint.FLOW_Y:\n\t\t\t\t\twidth = Math.max(width, cw);\n\t\t\t\t\theight += ch;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException(\"Unknown flow direction \" + getConstraint().getFlowDirection());\n\t\t\t}\n\t\t}\n\t\tif (getConstraint().getWidth() != 0) {\n\t\t\twidth = getConstraint().getWidth();\n\t\t}\n\t\tif (getConstraint().getHeight() != 0) {\n\t\t\theight = getConstraint().getHeight();\n\t\t}\n\t\tsetBounds(new Rectangle(0, 0, width, height));\n\t}", "label": 0}
{"code": "public static authenticationvserver_authenticationlocalpolicy_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauthenticationvserver_authenticationlocalpolicy_binding obj = new authenticationvserver_authenticationlocalpolicy_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationvserver_authenticationlocalpolicy_binding response[] = (authenticationvserver_authenticationlocalpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public long removeRangeByLex(final LexRange lexRange) {\n        return doWithJedis(new JedisCallable<Long>() {\n            @Override\n            public Long call(Jedis jedis) {\n                return jedis.zremrangeByLex(getKey(), lexRange.from(), lexRange.to());\n            }\n        });\n    }", "label": 0}
{"code": "def initialise_by_names(self, plugins=None):\n        \"\"\"\n        Initialises given plugins, but does not activate them.\n\n        This is needed to import and configure libraries, which are imported by used patterns, like GwFlask.\n\n        After this action, all needed python modules are imported and configured.\n        Also the groundwork application object is ready and contains functions and objects, which were added\n        by patterns, like app.commands from GwCommandsPattern.\n\n        The class of a given plugin must already be registered in the :class:`.PluginClassManager`.\n\n        :param plugins: List of plugin names\n        :type plugins: list of strings\n        \"\"\"\n\n        if plugins is None:\n            plugins = []\n\n        self._log.debug(\"Plugins Initialisation started\")\n        if not isinstance(plugins, list):\n            raise AttributeError(\"plugins must be a list, not %s\" % type(plugins))\n\n        self._log.debug(\"Plugins to initialise: %s\" % \", \".join(plugins))\n        plugin_initialised = []\n        for plugin_name in plugins:\n            if not isinstance(plugin_name, str):\n                raise AttributeError(\"plugin name must be a str, not %s\" % type(plugin_name))\n\n            plugin_class = self.classes.get(plugin_name)\n            self.initialise(plugin_class.clazz, plugin_name)\n            plugin_initialised.append(plugin_name)\n\n        self._log.info(\"Plugins initialised: %s\" % \", \".join(plugin_initialised))", "label": 1}
{"code": "def end_at(x, y=nil)\n      use_two_cell_anchor unless @anchor.is_a?(TwoCellAnchor)\n      @anchor.end_at x, y\n      @anchor.to\n    end", "label": 4}
{"code": "public function setProgressDocuments($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\Admin\\V1\\Progress::class);\n        $this->progress_documents = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func (v VirtualMachine) SetBootOptions(ctx context.Context, options *types.VirtualMachineBootOptions) error {\n\tspec := types.VirtualMachineConfigSpec{}\n\n\tspec.BootOptions = options\n\n\ttask, err := v.Reconfigure(ctx, spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn task.Wait(ctx)\n}", "label": 5}
{"code": "func (s *Service) ServeSDK(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tbody, err := s.readAll(r.Body)\n\t_ = r.Body.Close()\n\tif err != nil {\n\t\tlog.Printf(\"error reading body: %s\", err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif Trace {\n\t\tfmt.Fprintf(os.Stderr, \"Request: %s\\n\", string(body))\n\t}\n\n\tctx := &Context{\n\t\treq: r,\n\t\tres: w,\n\t\tsvc: s,\n\n\t\tMap:     s.sdk[r.URL.Path],\n\t\tContext: context.Background(),\n\t}\n\tctx.Map.WithLock(s.sm, ctx.mapSession)\n\n\tvar res soap.HasFault\n\tvar soapBody interface{}\n\n\tmethod, err := UnmarshalBody(ctx.Map.typeFunc, body)\n\tif err != nil {\n\t\tres = serverFault(err.Error())\n\t} else {\n\t\tctx.Header = method.Header\n\t\tif method.Name == \"Fetch\" {\n\t\t\t// Redirect any Fetch method calls to the PropertyCollector singleton\n\t\t\tmethod.This = ctx.Map.content().PropertyCollector\n\t\t}\n\t\tres = s.call(ctx, method)\n\t}\n\n\tif f := res.Fault(); f != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\n\t\t// the generated method/*Body structs use the '*soap.Fault' type,\n\t\t// so we need our own Body type to use the modified '*soapFault' type.\n\t\tsoapBody = struct {\n\t\t\tFault *soapFault\n\t\t}{\n\t\t\t&soapFault{\n\t\t\t\tCode:   f.Code,\n\t\t\t\tString: f.String,\n\t\t\t\tDetail: struct {\n\t\t\t\t\tFault *faultDetail\n\t\t\t\t}{&faultDetail{f.Detail.Fault}},\n\t\t\t},\n\t\t}\n\t} else {\n\t\tw.WriteHeader(http.StatusOK)\n\n\t\tsoapBody = &response{ctx.Map.Namespace, res}\n\t}\n\n\tvar out bytes.Buffer\n\n\tfmt.Fprint(&out, xml.Header)\n\te := xml.NewEncoder(&out)\n\terr = e.Encode(&soapEnvelope{\n\t\tEnc:  \"http://schemas.xmlsoap.org/soap/encoding/\",\n\t\tEnv:  \"http://schemas.xmlsoap.org/soap/envelope/\",\n\t\tXSD:  \"http://www.w3.org/2001/XMLSchema\",\n\t\tXSI:  \"http://www.w3.org/2001/XMLSchema-instance\",\n\t\tBody: soapBody,\n\t})\n\tif err == nil {\n\t\terr = e.Flush()\n\t}\n\n\tif err != nil {\n\t\tlog.Printf(\"error encoding %s response: %s\", method.Name, err)\n\t\treturn\n\t}\n\n\tif Trace {\n\t\tfmt.Fprintf(os.Stderr, \"Response: %s\\n\", out.String())\n\t}\n\n\t_, _ = w.Write(out.Bytes())\n}", "label": 5}
{"code": "def load(filename):\n        \"\"\"\"Load yaml file with specific include loader.\"\"\"\n        if os.path.isfile(filename):\n            with open(filename) as handle:\n                return yaml_load(handle, Loader=Loader)  # nosec\n        raise RuntimeError(\"File %s doesn't exist!\" % filename)", "label": 1}
{"code": "def element_not_focused(step, id):\n    \"\"\"\n    Check if the element is not focused\n    \"\"\"\n\n    elem = world.browser.find_element_by_xpath(str('id(\"{id}\")'.format(id=id)))\n    focused = world.browser.switch_to_active_element()\n\n    assert_false(step, elem == focused)", "label": 1}
{"code": "def filterMotifs(memeFile,outFile, minSites):\n    \"\"\"\n    Selectes motifs from a meme file based on the number of sites.\n\n    :param memeFile: MEME file to be read\n    :param outFile: MEME file to be written\n    :param minSites: minimum number of sites each motif needs to have to be valid\n\n    :returns: nothing\n    \"\"\"\n\n    with open(memeFile, \"r\") as mF:\n        oldMEME=mF.readlines()\n        newMEME=oldMEME[:7]\n        i=7\n        while i < len(oldMEME):\n            if oldMEME[i].split(\" \")[0] == \"MOTIF\":\n                print(oldMEME[i].split(\"\\n\")[0], int(oldMEME[i+2].split(\"nsites= \")[1].split(\" \")[0]))\n                sys.stdout.flush()\n                if int(oldMEME[i+2].split(\"nsites= \")[1].split(\" \")[0]) > minSites:\n                    newMEME.append(oldMEME[i])\n                    f=i+1\n                    while oldMEME[f].split(\" \")[0] != \"MOTIF\":\n                        newMEME.append(oldMEME[f])\n                        f=f+1\n                    i=i+1\n                else:\n                    i=i+1\n            else:\n                i=i+1\n    with open(outFile, \"w+\") as out:\n        out.write(\"\".join(newMEME) )\n\n    return newMEME", "label": 1}
{"code": "def deep_merge(hash_one, hash_two)\n      merged = hash_one.dup\n      hash_two.each do |key, value|\n        merged[key] = case\n        when hash_one[key].is_a?(Hash) && value.is_a?(Hash)\n          deep_merge(hash_one[key], value)\n        when hash_one[key].is_a?(Array) && value.is_a?(Array)\n          (hash_one[key] + value).uniq\n        else\n          value\n        end\n      end\n      merged\n    end", "label": 4}
{"code": "public static inatparam get(nitro_service service) throws Exception{\n\t\tinatparam obj = new inatparam();\n\t\tinatparam[] response = (inatparam[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "public function store(Collection $entries)\n    {\n        if ($entries->isEmpty()) {\n            return;\n        }\n\n        [$exceptions, $entries] = $entries->partition->isException();\n\n        $this->storeExceptions($exceptions);\n\n        $table = $this->table('telescope_entries');\n\n        $entries->chunk($this->chunkSize)->each(function ($chunked) use ($table) {\n            $table->insert($chunked->map(function ($entry) {\n                $entry->content = json_encode($entry->content);\n\n                return $entry->toArray();\n            })->toArray());\n        });\n\n        $this->storeTags($entries->pluck('tags', 'uuid'));\n    }", "label": 2}
{"code": "def decrypt(attribute, encrypted_value)\n      encrypted_attributes[attribute.to_sym][:operation] = :decrypting\n      encrypted_attributes[attribute.to_sym][:value_present] = self.class.not_empty?(encrypted_value)\n      self.class.decrypt(attribute, encrypted_value, evaluated_attr_encrypted_options_for(attribute))\n    end", "label": 4}
{"code": "public function setRules($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\InspectionRule::class);\n        $this->rules = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def url(self, name):\n        \"\"\"\n        Ask blobstore api for an url to directly serve the file\n        \"\"\"\n        key = blobstore.create_gs_key('/gs' + name)\n        return images.get_serving_url(key)", "label": 1}
{"code": "public function setPropertyFilter($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Datastore\\V1\\PropertyFilter::class);\n        $this->writeOneof(2, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "function addLeadingZeros(numField, length) {\n\t\twhile (numField.toString().length < length) {\n\t\t\tnumField = '0' + numField.toString();\n\t\t}\n\n\t\treturn numField;\n\t}", "label": 3}
{"code": "def receive_discovery_reply\n      # Wait for a UDP message\n      message = @socket.recv(70)\n      ip = message[4..-3].delete(\"\\0\")\n      port = message[-2..-1].to_i\n      [ip, port]\n    end", "label": 4}
{"code": "func (l *Lease) GetManifest(ctx context.Context) error {\n\treq := types.HttpNfcLeaseGetManifest{\n\t\tThis: l.Reference(),\n\t}\n\n\t_, err := methods.HttpNfcLeaseGetManifest(ctx, l.c, &req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def declared_attributes\n      instance_values.select do |key, value|\n        value != nil && self.class.xml_attributes.include?(key.to_sym)\n      end\n    end", "label": 4}
{"code": "def load_from_file_object(cls, fd, format=None):\n        \"\"\" Load the object from a given file like object in the given format.\n        \"\"\"\n        format = 'pickle' if format is None else format\n        load = getattr(cls, \"load_%s\" % format, None)\n        if load is None:\n            raise ValueError(\"Unknown format '%s'.\" % format)\n        return load(fd)", "label": 1}
{"code": "function isObjectLiteralType(type) {\n            return type.symbol && (type.symbol.flags & (4096 /* ObjectLiteral */ | 2048 /* TypeLiteral */)) !== 0 &&\n                getSignaturesOfType(type, 0 /* Call */).length === 0 &&\n                getSignaturesOfType(type, 1 /* Construct */).length === 0;\n        }", "label": 3}
{"code": "func OptionDNSOptions(options string) SandboxOption {\n\treturn func(sb *sandbox) {\n\t\tsb.config.dnsOptionsList = append(sb.config.dnsOptionsList, options)\n\t}\n}", "label": 5}
{"code": "public float DistanceTo(IntPoint anotherPoint) {\r\n        float dx = this.x - anotherPoint.x;\r\n        float dy = this.y - anotherPoint.y;\r\n\r\n        return (float) Math.sqrt(dx * dx + dy * dy);\r\n    }", "label": 0}
{"code": "public function getMessages($locale = null)\n    {\n        return $locale === null ? $this->messages : $this->messages[$locale];\n    }", "label": 2}
{"code": "private function validateArrayType($value): bool\n    {\n        if (is_array($value) === false) {\n            return false;\n        }\n        $count = 0;\n        foreach ($value as $i => $item) {\n            //not a array, but a hash/map\n            if ($count !== $i) {\n                return false;\n            }\n            $count++;\n        }\n        return true;\n    }", "label": 2}
{"code": "function combine(shares) {\n  const chunks = []\n  const x = []\n  const y = []\n  const t = shares.length\n\n  for (let i = 0; i < t; ++i) {\n    const share = parse(shares[i])\n\n    if (-1 === x.indexOf(share.id)) {\n      x.push(share.id)\n\n      const bin = codec.bin(share.data, 16)\n      const parts = codec.split(bin, 0, 2)\n\n      for (let j = 0; j < parts.length; ++j) {\n        if (!y[j]) { y[j] = [] }\n        y[j][x.length - 1] = parts[j]\n      }\n    }\n  }\n\n  for (let i = 0; i < y.length; ++i) {\n    const p = lagrange(0, [x, y[i]])\n    chunks.unshift(codec.pad(p.toString(2)))\n  }\n\n  const string = chunks.join('')\n  const bin = string.slice(1 + string.indexOf('1')) // >= 0\n  const hex = codec.hex(bin, BIN_ENCODING)\n  const value = codec.decode(hex)\n\n  return Buffer.from(value)\n}", "label": 3}
{"code": "def redirect(pattern, to, permanent=True, locale_prefix=True, anchor=None, name=None,\n             query=None, vary=None, cache_timeout=12, decorators=None, re_flags=None,\n             to_args=None, to_kwargs=None, prepend_locale=True, merge_query=False):\n    \"\"\"\n    Return a url matcher suited for urlpatterns.\n\n    pattern: the regex against which to match the requested URL.\n    to: either a url name that `reverse` will find, a url that will simply be returned,\n        or a function that will be given the request and url captures, and return the\n        destination.\n    permanent: boolean whether to send a 301 or 302 response.\n    locale_prefix: automatically prepend `pattern` with a regex for an optional locale\n        in the url. This locale (or None) will show up in captured kwargs as 'locale'.\n    anchor: if set it will be appended to the destination url after a '#'.\n    name: if used in a `urls.py` the redirect URL will be available as the name\n        for use in calls to `reverse()`. Does _NOT_ work if used in a `redirects.py` file.\n    query: a dict of query params to add to the destination url.\n    vary: if you used an HTTP header to decide where to send users you should include that\n        header's name in the `vary` arg.\n    cache_timeout: number of hours to cache this redirect. just sets the proper `cache-control`\n        and `expires` headers.\n    decorators: a callable (or list of callables) that will wrap the view used to redirect\n        the user. equivalent to adding a decorator to any other view.\n    re_flags: a string of any of the characters: \"iLmsux\". Will modify the `pattern` regex\n        based on the documented meaning of the flags (see python re module docs).\n    to_args: a tuple or list of args to pass to reverse if `to` is a url name.\n    to_kwargs: a dict of keyword args to pass to reverse if `to` is a url name.\n    prepend_locale: if true the redirect URL will be prepended with the locale from the\n        requested URL.\n    merge_query: merge the requested query params from the `query` arg with any query params\n        from the request.\n\n    Usage:\n    urlpatterns = [\n        redirect(r'projects/$', 'mozorg.product'),\n        redirect(r'^projects/seamonkey$', 'mozorg.product', locale_prefix=False),\n        redirect(r'apps/$', 'https://marketplace.firefox.com'),\n        redirect(r'firefox/$', 'firefox.new', name='firefox'),\n        redirect(r'the/dude$', 'abides', query={'aggression': 'not_stand'}),\n    ]\n    \"\"\"\n    if permanent:\n        redirect_class = HttpResponsePermanentRedirect\n    else:\n        redirect_class = HttpResponseRedirect\n\n    if locale_prefix:\n        pattern = pattern.lstrip('^/')\n        pattern = LOCALE_RE + pattern\n\n    if re_flags:\n        pattern = '(?{})'.format(re_flags) + pattern\n\n    view_decorators = []\n    if cache_timeout is not None:\n        view_decorators.append(cache_control_expires(cache_timeout))\n\n    if vary:\n        if isinstance(vary, basestring):\n            vary = [vary]\n        view_decorators.append(vary_on_headers(*vary))\n\n    if decorators:\n        if callable(decorators):\n            view_decorators.append(decorators)\n        else:\n            view_decorators.extend(decorators)\n\n    def _view(request, *args, **kwargs):\n        # don't want to have 'None' in substitutions\n        kwargs = {k: v or '' for k, v in kwargs.items()}\n        args = [x or '' for x in args]\n\n        # If it's a callable, call it and get the url out.\n        if callable(to):\n            to_value = to(request, *args, **kwargs)\n        else:\n            to_value = to\n\n        if to_value.startswith('/') or HTTP_RE.match(to_value):\n            redirect_url = to_value\n        else:\n            try:\n                redirect_url = reverse(to_value, args=to_args, kwargs=to_kwargs)\n            except NoReverseMatch:\n                # Assume it's a URL\n                redirect_url = to_value\n\n        if prepend_locale and redirect_url.startswith('/') and kwargs.get('locale'):\n            redirect_url = '/{locale}' + redirect_url.lstrip('/')\n\n        # use info from url captures.\n        if args or kwargs:\n            redirect_url = strip_tags(force_text(redirect_url).format(*args, **kwargs))\n\n        if query:\n            if merge_query:\n                req_query = parse_qs(request.META.get('QUERY_STRING'))\n                req_query.update(query)\n                querystring = urlencode(req_query, doseq=True)\n            else:\n                querystring = urlencode(query, doseq=True)\n        elif query is None:\n            querystring = request.META.get('QUERY_STRING')\n        else:\n            querystring = ''\n\n        if querystring:\n            redirect_url = '?'.join([redirect_url, querystring])\n\n        if anchor:\n            redirect_url = '#'.join([redirect_url, anchor])\n\n        if PROTOCOL_RELATIVE_RE.match(redirect_url):\n            redirect_url = '/' + redirect_url.lstrip('/')\n\n        return redirect_class(redirect_url)\n\n    # Apply decorators\n    try:\n        # Decorators should be applied in reverse order so that input\n        # can be sent in the order your would write nested decorators\n        # e.g. dec1(dec2(_view)) -> [dec1, dec2]\n        for decorator in reversed(view_decorators):\n            _view = decorator(_view)\n    except TypeError:\n        log.exception('decorators not iterable or does not contain '\n                      'callable items')\n\n    return url(pattern, _view, name=name)", "label": 1}
{"code": "function getReferencedDeclarationWithCollidingName(node) {\n            var symbol = getReferencedValueSymbol(node);\n            return symbol && isSymbolOfDeclarationWithCollidingName(symbol) ? symbol.valueDeclaration : undefined;\n        }", "label": 3}
{"code": "func (s *remoteSite) updateCertAuthorities() error {\n\t// update main cluster cert authorities on the remote side\n\t// remote side makes sure that only relevant fields\n\t// are updated\n\thostCA, err := s.localClient.GetCertAuthority(services.CertAuthID{\n\t\tType:       services.HostCA,\n\t\tDomainName: s.srv.ClusterName,\n\t}, false)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\terr = s.remoteClient.RotateExternalCertAuthority(hostCA)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\tuserCA, err := s.localClient.GetCertAuthority(services.CertAuthID{\n\t\tType:       services.UserCA,\n\t\tDomainName: s.srv.ClusterName,\n\t}, false)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\terr = s.remoteClient.RotateExternalCertAuthority(userCA)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\t// update remote cluster's host cert authoritiy on a local cluster\n\t// local proxy is authorized to perform this operation only for\n\t// host authorities of remote clusters.\n\tremoteCA, err := s.remoteClient.GetCertAuthority(services.CertAuthID{\n\t\tType:       services.HostCA,\n\t\tDomainName: s.domainName,\n\t}, false)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\tif remoteCA.GetClusterName() != s.domainName {\n\t\treturn trace.BadParameter(\n\t\t\t\"remote cluster sent different cluster name %v instead of expected one %v\",\n\t\t\tremoteCA.GetClusterName(), s.domainName)\n\t}\n\terr = s.localClient.UpsertCertAuthority(remoteCA)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn s.compareAndSwapCertAuthority(remoteCA)\n}", "label": 5}
{"code": "func (c *controller) getKeys(subsys string) ([][]byte, []uint64) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tsort.Sort(ByTime(c.keys))\n\n\tkeys := [][]byte{}\n\ttags := []uint64{}\n\tfor _, key := range c.keys {\n\t\tif key.Subsystem == subsys {\n\t\t\tkeys = append(keys, key.Key)\n\t\t\ttags = append(tags, key.LamportTime)\n\t\t}\n\t}\n\n\tkeys[0], keys[1] = keys[1], keys[0]\n\ttags[0], tags[1] = tags[1], tags[0]\n\treturn keys, tags\n}", "label": 5}
{"code": "def _var_and_skew(self, catchments, as_rural=False):\n        \"\"\"\n        Calculate L-CV and L-SKEW from a single catchment or a pooled group of catchments.\n\n        Methodology source: Science Report SC050050, para. 6.4.1-6.4.2\n        \"\"\"\n        if not hasattr(catchments, '__getitem__'):  # In case of a single catchment\n            l_cv, l_skew = self._l_cv_and_skew(self.catchment)\n            self.results_log['donors'] = []\n        else:\n            # Prepare arrays for donor L-CVs and L-SKEWs and their weights\n            n = len(catchments)\n            l_cvs = np.empty(n)\n            l_skews = np.empty(n)\n            l_cv_weights = np.empty(n)\n            l_skew_weights = np.empty(n)\n\n            # Fill arrays\n            for index, donor in enumerate(catchments):\n                l_cvs[index], l_skews[index] = self._l_cv_and_skew(donor)\n                l_cv_weights[index] = self._l_cv_weight(donor)\n                l_skew_weights[index] = self._l_skew_weight(donor)\n\n            # Weighted averages of L-CV and l-SKEW\n            l_cv_weights /= sum(l_cv_weights)  # Weights sum to 1\n            # Special case if the first donor is the subject catchment itself, assumed if similarity distance == 0.\n            if self._similarity_distance(self.catchment, catchments[0]) == 0:\n                l_cv_weights *= self._l_cv_weight_factor()  # Reduce weights of all donor catchments\n                l_cv_weights[0] += 1 - sum(l_cv_weights)    # But increase the weight of the subject catchment\n            l_cv_rural = sum(l_cv_weights * l_cvs)\n            l_skew_weights /= sum(l_skew_weights)  # Weights sum to 1\n            l_skew_rural = sum(l_skew_weights * l_skews)\n            self.results_log['l_cv_rural'] = l_cv_rural\n            self.results_log['l_skew_rural'] = l_skew_rural\n\n            if as_rural:\n                l_cv = l_cv_rural\n                l_skew = l_skew_rural\n            else:\n                # Method source: eqns. 10 and 11, Kjeldsen 2010\n                l_cv = l_cv_rural * 0.5547 ** self.catchment.descriptors.urbext(self.year)\n                l_skew = (l_skew_rural + 1) * 1.1545 ** self.catchment.descriptors.urbext(self.year) - 1\n\n            # Record intermediate results (donors)\n            self.results_log['donors'] = catchments\n            total_record_length = 0\n            for index, donor in enumerate(self.results_log['donors']):\n                donor.l_cv = l_cvs[index]\n                donor.l_cv_weight = l_cv_weights[index]\n                donor.l_skew = l_skews[index]\n                donor.l_skew_weight = l_skew_weights[index]\n                total_record_length += donor.record_length\n            self.results_log['donors_record_length'] = total_record_length\n\n        # Record intermediate results\n        self.results_log['l_cv'] = l_cv\n        self.results_log['l_skew'] = l_skew\n        return l_cv, l_skew", "label": 1}
{"code": "def query_symbols query\n      result = []\n      source_map_hash.values.each do |s|\n        result.concat s.query_symbols(query)\n      end\n      result\n    end", "label": 4}
{"code": "def _vec_b(self, donor_catchments):\n        \"\"\"\n        Return vector ``b`` of model error covariances to estimate weights\n\n        Methodology source: Kjeldsen, Jones and Morris, 2009, eqs 3 and 10\n\n        :param donor_catchments: Catchments to use as donors\n        :type donor_catchments: list of :class:`Catchment`\n        :return: Model error covariance vector\n        :rtype: :class:`numpy.ndarray`\n        \"\"\"\n        p = len(donor_catchments)\n        b = 0.1175 * np.ones(p)\n        for i in range(p):\n            b[i] *= self._model_error_corr(self.catchment, donor_catchments[i])\n        return b", "label": 1}
{"code": "public function update(array $options = [])\n    {\n        if (isset($options['lifecycle']) && $options['lifecycle'] instanceof Lifecycle) {\n            $options['lifecycle'] = $options['lifecycle']->toArray();\n        }\n\n        return $this->info = $this->connection->patchBucket($options + $this->identity);\n    }", "label": 2}
{"code": "function getFormFiles(metaDataFilePath) {\n  var formsZipMetaData = require(metaDataFilePath);\n  if (formsZipMetaData && formsZipMetaData.files) {\n    var formFiles = formsZipMetaData.files;\n    return _.map(formFiles, function(formDetails) {\n      return formDetails.path;\n    });\n  } else {\n    return [];\n  }\n}", "label": 3}
{"code": "private boolean containsCollectionAndMapsToDifferentTable(CollectionDescriptorDef origCollDef, TableDef origTableDef, ClassDescriptorDef classDef)\r\n    {\r\n        if (classDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_GENERATE_TABLE_INFO, true) &&\r\n            !origTableDef.getName().equals(classDef.getProperty(PropertyHelper.OJB_PROPERTY_TABLE)))\r\n        {\r\n            CollectionDescriptorDef curCollDef = classDef.getCollection(origCollDef.getName());\r\n\r\n            if ((curCollDef != null) &&\r\n                !curCollDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_IGNORE, false))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }", "label": 0}
{"code": "public function insertBatch($table, array $dataSet, array $options = [])\n    {\n        $mutations = [];\n        foreach ($dataSet as $data) {\n            $mutations[] = $this->operation->mutation(Operation::OP_INSERT, $table, $data);\n        }\n\n        return $this->commitInSingleUseTransaction($mutations, $options);\n    }", "label": 2}
{"code": "def installed_packages(device_serial)\n      packages = run_adb_command(\"adb -s #{device_serial} shell pm list packages\",\n                                 print_all: true,\n                                 print_command: true)\n      packages.split(\"\\n\").map { |package| package.gsub(\"package:\", \"\") }\n    end", "label": 4}
{"code": "def occurs_between?(begin_time, closing_time, options = {})\n      enumerate_occurrences(begin_time, closing_time, options).next\n      true\n    rescue StopIteration\n      false\n    end", "label": 4}
{"code": "public static dnsaddrec[] get(nitro_service service, dnsaddrec_args args) throws Exception{\n\t\tdnsaddrec obj = new dnsaddrec();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tdnsaddrec[] response = (dnsaddrec[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function lookForBinary(binary, pathList) {\n  let envPath = _.toArrayIfNeeded(pathList);\n  if (_.isEmpty(envPath)) {\n    envPath = (process.env.PATH || '').split(path.delimiter);\n  }\n  const foundPath = _.first(_.filter(envPath, (dir) => {\n    return fileExists(path.join(dir, binary));\n  }));\n  return foundPath ? path.join(foundPath, binary) : null;\n}", "label": 3}
{"code": "function Diagram(index, options, question) {\n\n  this.index    = index;\n  this.options  = options;\n  this.question = question;\n\n  this.element = createElement(h('li.list-group-item', {\n    style: {\n      width: '100%',\n      height: '500px'\n    }\n  }));\n\n  this.viewer;\n\n  if (options.xml) {\n\n    // Load XML\n    this.xml = options.xml;\n\n  } else if (options.url) {\n\n    var that = this;\n\n    // Load XML via AJAX\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState == 4 && xhr.status == 200) {\n\n        that.xml = xhr.responseText;\n\n      }\n    };\n\n    xhr.open(\"GET\", options.url, true);\n    xhr.send();\n\n  } else {\n    throw new Error('Unable to load diagram, no resource specified');\n  }\n\n  this.initState = Immutable({\n    selected: []\n  });\n\n  this.state = this.initState.asMutable({deep: true});\n\n}", "label": 3}
{"code": "def update_category(location_id, category_id, body, opts = {})\n      data, _status_code, _headers = update_category_with_http_info(location_id, category_id, body, opts)\n      return data\n    end", "label": 4}
{"code": "function isDomEventTarget (obj) {\n\tif (!(obj && obj.nodeName)) {\n\t\treturn obj === window;\n\t}\n\tvar nodeType = obj.nodeType;\n\treturn (\n\t\tnodeType === 1 || // Node.ELEMENT_NODE\n\t\tnodeType === 9 || // Node.DOCUMENT_NODE\n\t\tnodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE\n\t);\n}", "label": 3}
{"code": "function () {\n        return ServerHeartbeatModel.find({\n            status: _statusActive\n        }).then(function (cursor) {\n            return Q.ninvoke(cursor, 'toArray').then(function (servers) {\n                var serverIds = [];\n                servers.map(function (value) {\n                    serverIds.push(value._id);\n                });\n                return _removeAllJobsOfUnknownServer(serverIds);\n            });\n        });\n    }", "label": 3}
{"code": "func (f *file) imports(importPath string) bool {\n\tall := astutil.Imports(f.fset, f.f)\n\tfor _, p := range all {\n\t\tfor _, i := range p {\n\t\t\tuq, err := strconv.Unquote(i.Path.Value)\n\t\t\tif err == nil && importPath == uq {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}", "label": 5}
{"code": "function preparePartials(options) {\n  return Promise.all([\n    registerPartials(options.src.templates, options), // Partials as partials\n    registerPartials(options.src.patterns, options, 'patterns') // Patterns\n  ]).then(() => options, error => DrizzleError.error(error, options.debug));\n}", "label": 3}
{"code": "private function extractStatus(\n        $name,\n        ResponseInterface $response,\n        array &$result\n    ) {\n        $result[$name] = (int) $response->getStatusCode();\n    }", "label": 2}
{"code": "public static int cudnnSetTensor4dDescriptorEx(\n        cudnnTensorDescriptor tensorDesc, \n        int dataType, /** image data type */\n        int n, /** number of inputs (batch size) */\n        int c, /** number of input feature maps */\n        int h, /** height of input section */\n        int w, /** width of input section */\n        int nStride, \n        int cStride, \n        int hStride, \n        int wStride)\n    {\n        return checkResult(cudnnSetTensor4dDescriptorExNative(tensorDesc, dataType, n, c, h, w, nStride, cStride, hStride, wStride));\n    }", "label": 0}
{"code": "def find_best_plan(self):\n        \"\"\"\n        try each strategy with different amounts\n        \"\"\"\n        for plan in self.plans:\n            for strat in self.strategy:\n                self.run_plan(plan, strat)", "label": 1}
{"code": "public static lbsipparameters get(nitro_service service) throws Exception{\n\t\tlbsipparameters obj = new lbsipparameters();\n\t\tlbsipparameters[] response = (lbsipparameters[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def _path_from_module(module):\n        \"\"\"Attempt to determine bot's filesystem path from its module.\"\"\"\n        # Convert paths to list because Python's _NamespacePath doesn't support\n        # indexing.\n        paths = list(getattr(module, '__path__', []))\n        if len(paths) != 1:\n            filename = getattr(module, '__file__', None)\n            if filename is not None:\n                paths = [os.path.dirname(filename)]\n            else:\n                # For unknown reasons, sometimes the list returned by __path__\n                # contains duplicates that must be removed.\n                paths = list(set(paths))\n        if len(paths) > 1:\n            raise ImproperlyConfigured(\n                \"The bot module %r has multiple filesystem locations (%r); \"\n                \"you must configure this bot with an AppConfig subclass \"\n                \"with a 'path' class attribute.\" % (module, paths))\n        elif not paths:\n            raise ImproperlyConfigured(\n                \"The bot module %r has no filesystem location, \"\n                \"you must configure this bot with an AppConfig subclass \"\n                \"with a 'path' class attribute.\" % (module,))\n        return paths[0]", "label": 1}
{"code": "func getExitStatuses(p *pkgPod.Pod) (map[string]int, error) {\n\t_, manifest, err := p.PodManifest()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstats := make(map[string]int)\n\tfor _, app := range manifest.Apps {\n\t\texitCode, err := p.AppExitCode(app.Name.String())\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tstats[app.Name.String()] = exitCode\n\t}\n\treturn stats, nil\n}", "label": 5}
{"code": "def update_request_headers(req)\n      req.headers[\"X-Apple-Id-Session-Id\"] = @x_apple_id_session_id\n      req.headers[\"X-Apple-Widget-Key\"] = self.itc_service_key\n      req.headers[\"Accept\"] = \"application/json\"\n      req.headers[\"scnt\"] = @scnt\n    end", "label": 4}
{"code": "def reset(self):\n        \"\"\" Resets the readonly variables for all of the case components.\n        \"\"\"\n        for bus in self.buses:\n            bus.reset()\n        for branch in self.branches:\n            branch.reset()\n        for generator in self.generators:\n            generator.reset()", "label": 1}
{"code": "def consumer(\n        group_id:,\n        session_timeout: 30,\n        offset_commit_interval: 10,\n        offset_commit_threshold: 0,\n        heartbeat_interval: 10,\n        offset_retention_time: nil,\n        fetcher_max_queue_size: 100\n    )\n      cluster = initialize_cluster\n\n      instrumenter = DecoratingInstrumenter.new(@instrumenter, {\n        group_id: group_id,\n      })\n\n      # The Kafka protocol expects the retention time to be in ms.\n      retention_time = (offset_retention_time && offset_retention_time * 1_000) || -1\n\n      group = ConsumerGroup.new(\n        cluster: cluster,\n        logger: @logger,\n        group_id: group_id,\n        session_timeout: session_timeout,\n        retention_time: retention_time,\n        instrumenter: instrumenter,\n      )\n\n      fetcher = Fetcher.new(\n        cluster: initialize_cluster,\n        group: group,\n        logger: @logger,\n        instrumenter: instrumenter,\n        max_queue_size: fetcher_max_queue_size\n      )\n\n      offset_manager = OffsetManager.new(\n        cluster: cluster,\n        group: group,\n        fetcher: fetcher,\n        logger: @logger,\n        commit_interval: offset_commit_interval,\n        commit_threshold: offset_commit_threshold,\n        offset_retention_time: offset_retention_time\n      )\n\n      heartbeat = Heartbeat.new(\n        group: group,\n        interval: heartbeat_interval,\n        instrumenter: instrumenter\n      )\n\n      Consumer.new(\n        cluster: cluster,\n        logger: @logger,\n        instrumenter: instrumenter,\n        group: group,\n        offset_manager: offset_manager,\n        fetcher: fetcher,\n        session_timeout: session_timeout,\n        heartbeat: heartbeat,\n      )\n    end", "label": 4}
{"code": "def current_ts?(time)\n      (current_version.time <= time) &&\n        (next_version.nil? || (next_version.time < time))\n    end", "label": 4}
{"code": "def remaining(self):\n        \"\"\"\n        Get the remaining time-to-live of this lease.\n\n        :returns: TTL in seconds.\n        :rtype: int\n        \"\"\"\n        if self._expired:\n            raise Expired()\n\n        obj = {\n            u'ID': self.lease_id,\n        }\n        data = json.dumps(obj).encode('utf8')\n\n        url = u'{}/v3alpha/kv/lease/timetolive'.format(self._client._url).encode()\n        response = yield treq.post(url, data, headers=self._client._REQ_HEADERS)\n\n        obj = yield treq.json_content(response)\n\n        ttl = obj.get(u'TTL', None)\n        if not ttl:\n            self._expired = True\n            raise Expired()\n\n        # grantedTTL = int(obj[u'grantedTTL'])\n        # header = Header._parse(obj[u'header']) if u'header' in obj else None\n\n        returnValue(ttl)", "label": 1}
{"code": "def main_component_url(component)\n      current_params = try(:params) || {}\n      EngineRouter.main_proxy(component).root_url(locale: current_params[:locale])\n    end", "label": 4}
{"code": "def cleanup\n      if @main_loop_thread\n        @main_loop_thread_lock.synchronize do\n          @graceful_termination_pipe[1].close rescue nil\n        end\n        @main_loop_thread.join\n      end\n      @server_sockets.each_value do |info|\n        socket = info[:socket]\n        type = get_socket_address_type(info[:address])\n\n        begin\n          socket.close if !socket.closed?\n        rescue Exception => e\n          # Ignore \"stream closed\" error, which occurs in some unit tests.\n          # We catch Exception here instead of IOError because of a Ruby 1.8.7 bug.\n          if e.to_s !~ /stream closed/ && e.message.to_s !~ /stream closed/\n            raise e\n          end\n        end\n        if type == :unix\n          filename = info[:address].sub(/^unix:/, '')\n          File.unlink(filename) rescue nil\n        end\n      end\n      @owner_pipe.close rescue nil\n    end", "label": 4}
{"code": "public function setFalseFilter($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\V2\\RowFilter::class);\n        $this->false_filter = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static responderhtmlpage get(nitro_service service) throws Exception{\n\t\tresponderhtmlpage obj = new responderhtmlpage();\n\t\tresponderhtmlpage[] response = (responderhtmlpage[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "function (CurrentEntity) {\n  return function (entity) {\n    expect(arguments).to.have.length(\n      1,\n      'Invalid arguments length when getting an Entity specialization (it ' +\n      'has to be passed 1 argument)'\n    );\n\n    expect(entity).to.be.a(\n      'string',\n      'Invalid argument when creating a new Entity function (it has to be ' +\n      'a string'\n    );\n\n    var entities = CurrentEntity.specializations;\n\n    try {\n      expect(entities).to.have.ownProperty(entity);\n    } catch (e) {\n      throw new errors.EntityNotFoundError(\n        entity,\n        e\n      );\n    }\n\n    return entities[entity];\n  };\n}", "label": 3}
{"code": "function (entry) {\n\t\tif (typeof entry === 'number' && entry < entryServers.length) {\n\t\t\tentryServers.splice(entry, 1);\n\t\t\treturn true;\n\t\t}\n\t\telse if (typeof entry === 'string') {\t\n\t\t\tfor (var i=0; i < entryServers.length; i++) {\n\t\t\t\tif (entryServers[i] === entry) {\n\t\t\t\t\tentryServers.splice(i, 1);\n\t\t\t\t\tSR.Log('remove entry: ' + entry + '. entries left: ' + entryServers.length);\t\t\t\t\t\t\n\t\t\t\t\treturn true;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "label": 3}
{"code": "protected boolean isTransient(ClassDescriptor cld, Object obj, Identity oid)\r\n    {\r\n        // if the Identity is transient we assume a non-persistent object\r\n        boolean isNew = oid != null && oid.isTransient();\r\n        /*\r\n        detection of new objects is costly (select of ID in DB to check if object\r\n        already exists) we do:\r\n        a. check if the object has nullified PK field\r\n        b. check if the object is already registered\r\n        c. lookup from cache and if not found, last option select on DB\r\n        */\r\n        if(!isNew)\r\n        {\r\n            final PersistenceBroker pb = getBroker();\r\n            if(cld == null)\r\n            {\r\n                cld = pb.getClassDescriptor(obj.getClass());\r\n            }\r\n            isNew = pb.serviceBrokerHelper().hasNullPKField(cld, obj);\r\n            if(!isNew)\r\n            {\r\n                if(oid == null)\r\n                {\r\n                    oid = pb.serviceIdentity().buildIdentity(cld, obj);\r\n                }\r\n                final ObjectEnvelope mod = objectEnvelopeTable.getByIdentity(oid);\r\n                if(mod != null)\r\n                {\r\n                    // already registered object, use current state\r\n                    isNew = mod.needsInsert();\r\n                }\r\n                else\r\n                {\r\n                    // if object was found cache, assume it's old\r\n                    // else make costly check against the DB\r\n                    isNew = pb.serviceObjectCache().lookup(oid) == null\r\n                            && !pb.serviceBrokerHelper().doesExist(cld, oid, obj);\r\n                }\r\n            }\r\n        }\r\n        return isNew;\r\n    }", "label": 0}
{"code": "def save_as(pathname, prefix = nil)\n      if File.exist?(pathname)\n        return if Config.new(pathname) == self\n      end\n\n      pathname.open('w') { |file| file << to_s(prefix) }\n    end", "label": 4}
{"code": "function(session, args, callback) {\n        session.stdout().write('Hello, ' + session.env('me').bold + '\\n');\n        return callback();\n    }", "label": 3}
{"code": "def log_level=(level)\n      if level.is_a?(Integer)\n        @logger.level = level\n      else\n        @logger.level = Logger.const_get(level.to_s.upcase)\n      end\n    end", "label": 4}
{"code": "function getWeight(labels, labelWeight) {\n  const places = labels.map(label => labelWeight.indexOf(label.name));\n  let binary = '';\n  for (let i = 0; i < labelWeight.length; i++) {\n    binary += places.includes(i) ? '1' : '0';\n  }\n  return parseInt(binary, 2);\n}", "label": 3}
{"code": "public static base_responses delete(nitro_service client, route6 resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\troute6 deleteresources[] = new route6[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tdeleteresources[i] = new route6();\n\t\t\t\tdeleteresources[i].network = resources[i].network;\n\t\t\t\tdeleteresources[i].gateway = resources[i].gateway;\n\t\t\t\tdeleteresources[i].vlan = resources[i].vlan;\n\t\t\t\tdeleteresources[i].td = resources[i].td;\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "protected function cleanup_error_handler()\n    {\n        restore_error_handler();\n\n        if ($this->last_error !== null) {\n            throw new \\ErrorException(\n                $this->last_error['errstr'],\n                0,\n                $this->last_error['errno'],\n                $this->last_error['errfile'],\n                $this->last_error['errline']\n            );\n        }\n    }", "label": 2}
{"code": "def get_range_around(range_value, current_item, padding):\n    \"\"\"\n    Returns a range of numbers around the given number.\n\n    This is useful for pagination, where you might want to show something\n    like this::\n\n        << < ... 4 5 (6) 7 8 .. > >>\n\n    In this example `6` would be the current page and we show 2 items around\n    that page (including the page itself).\n\n    Usage::\n\n        {% load libs_tags %}\n        {% get_range_around page_obj.paginator.num_pages page_obj.number 5\n          as pages %}\n\n    :param range_amount: Number of total items in your range (1 indexed)\n    :param current_item: The item around which the result should be centered\n      (1 indexed)\n    :param padding: Number of items to show left and right from the current\n      item.\n\n    \"\"\"\n    total_items = 1 + padding * 2\n    left_bound = padding\n    right_bound = range_value - padding\n    if range_value <= total_items:\n        range_items = range(1, range_value + 1)\n        return {\n            'range_items': range_items,\n            'left_padding': False,\n            'right_padding': False,\n        }\n    if current_item <= left_bound:\n        range_items = range(1, range_value + 1)[:total_items]\n        return {\n            'range_items': range_items,\n            'left_padding': range_items[0] > 1,\n            'right_padding': range_items[-1] < range_value,\n        }\n\n    if current_item >= right_bound:\n        range_items = range(1, range_value + 1)[-total_items:]\n        return {\n            'range_items': range_items,\n            'left_padding': range_items[0] > 1,\n            'right_padding': range_items[-1] < range_value,\n        }\n\n    range_items = range(current_item - padding, current_item + padding + 1)\n    return {\n        'range_items': range_items,\n        'left_padding': True,\n        'right_padding': True,\n    }", "label": 1}
{"code": "function(config){\n            app.showDialog = function(obj, activationData, context) {\n                return dialog.show(obj, activationData, context);\n            };\n\n            app.showMessage = function(message, title, options) {\n                return dialog.showMessage(message, title, options);\n            };\n\n            if(config.messageBox){\n                dialog.MessageBox = config.messageBox;\n            }\n\n            if(config.messageBoxView){\n                dialog.MessageBox.prototype.getView = function(){\n                    return config.messageBoxView;\n                };\n            }\n        }", "label": 3}
{"code": "public function setNotificationChannels($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Monitoring\\V3\\NotificationChannel::class);\n        $this->notification_channels = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def normalize_urls(urls):\n    \"\"\"Overload urls and make list of lists of urls.\"\"\"\n    _urls = []\n    if isinstance(urls, list):\n        if urls:\n            if isinstance(urls[0], list):\n                # multiple connections (list of the lists)\n                _urls = urls\n            elif isinstance(urls[0], str):\n                # single connections (make it list of the lists)\n                _urls = [urls]\n        else:\n            raise RuntimeError(\"No target host url provided.\")\n    elif isinstance(urls, str):\n        _urls = [[urls]]\n    return _urls", "label": 1}
{"code": "def property_key(prop)\n      prop_key = prop.name.join\n      prop_value = value_as_string(prop.value.first)\n\n      # Differentiate between values for different vendor prefixes\n      prop_value.to_s.scan(/^(-[^-]+-.+)/) do |vendor_keyword|\n        prop_key << vendor_keyword.first\n      end\n\n      prop_key\n    end", "label": 4}
{"code": "public function formatEncryptionHeaders(array $options)\n    {\n        $encryptionHeaders = [];\n        $useCopySourceHeaders = isset($options['useCopySourceHeaders']) ? $options['useCopySourceHeaders'] : false;\n        $key = isset($options['encryptionKey']) ? $options['encryptionKey'] : null;\n        $keySHA256 = isset($options['encryptionKeySHA256']) ? $options['encryptionKeySHA256'] : null;\n        $destinationKey = isset($options['destinationEncryptionKey']) ? $options['destinationEncryptionKey'] : null;\n        $destinationKeySHA256 = isset($options['destinationEncryptionKeySHA256'])\n            ? $options['destinationEncryptionKeySHA256']\n            : null;\n\n        unset($options['useCopySourceHeaders']);\n        unset($options['encryptionKey']);\n        unset($options['encryptionKeySHA256']);\n        unset($options['destinationEncryptionKey']);\n        unset($options['destinationEncryptionKeySHA256']);\n\n        $encryptionHeaders = $this->buildHeaders($key, $keySHA256, $useCopySourceHeaders)\n            + $this->buildHeaders($destinationKey, $destinationKeySHA256, false);\n\n        if (!empty($encryptionHeaders)) {\n            if (isset($options['restOptions']['headers'])) {\n                $options['restOptions']['headers'] += $encryptionHeaders;\n            } else {\n                $options['restOptions']['headers'] = $encryptionHeaders;\n            }\n        }\n\n        return $options;\n    }", "label": 2}
{"code": "public function BatchGetAssetsHistory(\\Google\\Cloud\\Asset\\V1\\BatchGetAssetsHistoryRequest $argument,\n      $metadata = [], $options = []) {\n        return $this->_simpleRequest('/google.cloud.asset.v1.AssetService/BatchGetAssetsHistory',\n        $argument,\n        ['\\Google\\Cloud\\Asset\\V1\\BatchGetAssetsHistoryResponse', 'decode'],\n        $metadata, $options);\n    }", "label": 2}
{"code": "def del_instance(self, obj):\n        \"\"\"Remove any stored instance methods that belong to an object\n\n        Args:\n            obj: The instance object to remove\n        \"\"\"\n        to_remove = set()\n        for wrkey, _obj in self.iter_instances():\n            if obj is _obj:\n                to_remove.add(wrkey)\n        for wrkey in to_remove:\n            del self[wrkey]", "label": 1}
{"code": "protected static String createDotStoryName(String scenarioName) {\n        String[] words = scenarioName.trim().split(\" \");\n        String result = \"\";\n        for (int i = 0; i < words.length; i++) {\n            String word1 = words[i];\n            String word2 = word1.toLowerCase();\n            if (!word1.equals(word2)) {\n                String finalWord = \"\";\n                for (int j = 0; j < word1.length(); j++) {\n                    if (i != 0) {\n                        char c = word1.charAt(j);\n                        if (Character.isUpperCase(c)) {\n                            if (j==0) {\n                                finalWord += Character.toLowerCase(c);\n                            } else {\n                                finalWord += \"_\" + Character.toLowerCase(c);   \n                            }\n                        } else {\n                            finalWord += c;\n                        }\n                    } else {\n                        finalWord = word2;\n                        break;\n                    }\n                }\n\n                result += finalWord;\n            } else {\n                result += word2;\n            }\n            // I don't add the '_' to the last word.\n            if (!(i == words.length - 1))\n                result += \"_\";\n        }\n        return result;\n    }", "label": 0}
{"code": "func (s *Server) CloseClientConnections() {\n\ts.mu.Lock()\n\tnconn := len(s.conns)\n\tch := make(chan struct{}, nconn)\n\tfor c := range s.conns {\n\t\tgo s.closeConnChan(c, ch)\n\t}\n\ts.mu.Unlock()\n\n\t// Wait for outstanding closes to finish.\n\t//\n\t// Out of paranoia for making a late change in Go 1.6, we\n\t// bound how long this can wait, since golang.org/issue/14291\n\t// isn't fully understood yet. At least this should only be used\n\t// in tests.\n\ttimer := time.NewTimer(5 * time.Second)\n\tdefer timer.Stop()\n\tfor i := 0; i < nconn; i++ {\n\t\tselect {\n\t\tcase <-ch:\n\t\tcase <-timer.C:\n\t\t\t// Too slow. Give up.\n\t\t\treturn\n\t\t}\n\t}\n}", "label": 5}
{"code": "public function update(array $metadata, array $options = [])\n    {\n        $options += $metadata;\n        $options += $this->info($options);\n\n        return $this->info = $this->connection->updateMetric($options + [\n            'metricName' => $this->formattedName\n        ]);\n    }", "label": 2}
{"code": "def type_regex(data, type)\n      regex = [data[type]]\n      if Phonelib.parse_special && data[Core::SHORT] && data[Core::SHORT][type]\n        regex << data[Core::SHORT][type]\n      end\n      regex.join('|')\n    end", "label": 4}
{"code": "def system_address\n      ::Socket.ip_address_list.find { |address|\n        address.ipv4? && !address.ipv4_loopback?\n      }.ip_address rescue nil\n    end", "label": 4}
{"code": "func MySchema(args *internal.ArgType) (string, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT SCHEMA()`\n\n\tvar schema string\n\n\t// run query\n\tmodels.XOLog(sqlstr)\n\terr = args.DB.QueryRow(sqlstr).Scan(&schema)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn schema, nil\n}", "label": 5}
{"code": "public static dospolicy[] get(nitro_service service) throws Exception{\n\t\tdospolicy obj = new dospolicy();\n\t\tdospolicy[] response = (dospolicy[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function(win, elems) {\n\t\t\t\tvar mode = svgCanvas.getMode();\n\t\t\t\tvar elem = elems[0];\n\n\t\t\t\tif (!elem) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmultiselected = (elems.length >= 2 && elems[1] != null);\n\t\t\t\t// Only updating fields for single elements for now\n\t\t\t\tif (!multiselected) {\n\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tvar ang = svgCanvas.getRotationAngle(elem);\n\t\t\t\t\t\t\t$('#angle').val(ang);\n\t\t\t\t\t\t\t$('#tool_reorient').toggleClass('disabled', ang === 0);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// TODO: Update values that change on move/resize, etc\n//\t\t\t\t\t\tcase \"select\":\n//\t\t\t\t\t\tcase \"resize\":\n//\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsvgCanvas.runExtensions('elementTransition', {\n\t\t\t\t\telems: elems\n\t\t\t\t});\n\t\t\t}", "label": 3}
{"code": "def add_workflow_responsibilities(role, agents)\n        Hyrax::Workflow::PermissionGenerator.call(roles: role,\n                                                  workflow: self,\n                                                  agents: agents)\n      end", "label": 4}
{"code": "def close(self):\n        \"\"\" Closes the connection to the serial port and ensure no pending\n        operatoin are left \"\"\"\n        self._serial.write(b\"@c\")\n        self._serial.read()\n        self._serial.close()", "label": 1}
{"code": "function getNumTargets() {\n    if (numTargets) {\n      return numTargets\n    }\n    var targets = grunt.config('npmcopy')\n    if (targets) {\n      delete targets.options\n      numTargets = Object.keys(targets).length\n    }\n    return numTargets\n  }", "label": 3}
{"code": "public function setKind($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\DevTools\\Source\\V1\\AliasContext_Kind::class);\n        $this->kind = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function sendAsync(RequestInterface $request, array $options = [])\n    {\n        // Unfortunately, the current ExponentialBackoff implementation doesn't\n        // play nicely with promises.\n        $retryAttempt = 0;\n        $fn = function ($retryAttempt) use (&$fn, $request, $options) {\n            $asyncHttpHandler = $this->asyncHttpHandler;\n            $retryOptions = $this->getRetryOptions($options);\n            if (!$retryOptions['calcDelayFunction']) {\n                $retryOptions['calcDelayFunction'] = [ExponentialBackoff::class, 'calculateDelay'];\n            }\n\n            return $asyncHttpHandler(\n                $this->applyHeaders($request),\n                $this->getRequestOptions($options)\n            )->then(null, function (\\Exception $ex) use ($fn, $retryAttempt, $retryOptions) {\n                $shouldRetry = $retryOptions['retryFunction']($ex);\n\n                if ($shouldRetry === false || $retryAttempt >= $retryOptions['retries']) {\n                    throw $this->convertToGoogleException($ex);\n                }\n\n                $delay = $retryOptions['calcDelayFunction']($retryAttempt);\n                $retryOptions['delayFunction']($delay);\n                $retryAttempt++;\n\n                return $fn($retryAttempt);\n            });\n        };\n\n        return $fn($retryAttempt);\n    }", "label": 2}
{"code": "function getDefaultedValue ({inputValue, previousValue, bunsenId, renderModel, mergeDefaults}) {\n  const isInputValueEmpty = isEmptyValue(inputValue)\n\n  if (previousValue !== undefined) {\n    return inputValue\n  }\n\n  const resolveRef = schemaFromRef(renderModel.definitions)\n  const defaultValue = getDefaults(inputValue, bunsenId, renderModel, resolveRef)\n  const hasDefaults = defaultValue !== undefined\n  const isUpdatingAll = bunsenId === null\n\n  const shouldApplyDefaults = isInputValueEmpty && hasDefaults ||\n    !isInputValueEmpty && hasDefaults && isUpdatingAll && mergeDefaults\n  const shouldClear = isInputValueEmpty && isUpdatingAll && !hasDefaults\n\n  if (shouldApplyDefaults) {\n    const schema = findSchema(renderModel, bunsenId, resolveRef)\n    return schema.type === 'object' ? _.defaults({}, inputValue, defaultValue) : defaultValue\n  } else if (shouldClear) {\n    return {}\n  }\n\n  return inputValue\n}", "label": 3}
{"code": "def decode_uvarint(data):\n    '''Decode a variable-length integer.\n\n    Reads a sequence of unsigned integer byte and decodes them into an integer\n    in variable-length format and returns it and the length read.\n    '''\n    n = 0\n    shift = 0\n    length = 0\n    for b in data:\n        if not isinstance(b, int):\n            b = six.byte2int(b)\n        n |= (b & 0x7f) << shift\n        length += 1\n        if (b & 0x80) == 0:\n            break\n        shift += 7\n    return n, length", "label": 1}
{"code": "public void createAgent(String agent_name, String path) {\n        IComponentIdentifier agent = cmsService.createComponent(agent_name,\n                path, null, null).get(new ThreadSuspendable());\n        createdAgents.put(agent_name, agent);\n    }", "label": 0}
{"code": "func LookupPath(bin string, paths string) (string, error) {\n\tpathsArr := filepath.SplitList(paths)\n\tfor _, path := range pathsArr {\n\t\tbinPath := filepath.Join(path, bin)\n\t\tbinAbsPath, err := filepath.Abs(binPath)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"unable to find absolute path for %s\", binPath)\n\t\t}\n\t\tif fileutil.IsExecutable(binAbsPath) {\n\t\t\treturn binAbsPath, nil\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"unable to find %q in %q\", bin, paths)\n}", "label": 5}
{"code": "public function setSentimentAnalysisResult($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\SentimentAnalysisResult::class);\n        $this->sentiment_analysis_result = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func (o *OIDCConnectorV2) GetClaims() []string {\n\tvar out []string\n\tfor _, mapping := range o.Spec.ClaimsToRoles {\n\t\tout = append(out, mapping.Claim)\n\t}\n\treturn utils.Deduplicate(out)\n}", "label": 5}
{"code": "func getDBVersion(tx *sql.Tx) (int, error) {\n\tvar version int\n\trows, err := tx.Query(\"SELECT version FROM version\")\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tdefer rows.Close()\n\tfound := false\n\tfor rows.Next() {\n\t\tif err := rows.Scan(&version); err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\tfound = true\n\t\tbreak\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn -1, err\n\t}\n\tif !found {\n\t\treturn -1, fmt.Errorf(\"db version table empty\")\n\t}\n\treturn version, nil\n}", "label": 5}
{"code": "def remove_by_id(clazz, *ids)\n      class_name =\n        if clazz.is_a?(Class)\n          clazz.name\n        else\n          clazz.to_s\n        end\n      indexer.remove_by_id(class_name, ids)\n    end", "label": 4}
{"code": "def text(x, y, text)\n      Kernel.raise ArgumentError, 'missing text argument' if text.to_s.empty?\n      if text.length > 2 && /\\A(?:\\\"[^\\\"]+\\\"|\\'[^\\']+\\'|\\{[^\\}]+\\})\\z/.match(text)\n      # text already quoted\n      elsif !text['\\'']\n        text = '\\'' + text + '\\''\n      elsif !text['\"']\n        text = '\"' + text + '\"'\n      elsif !(text['{'] || text['}'])\n        text = '{' + text + '}'\n      else\n        # escape existing braces, surround with braces\n        text = '{' + text.gsub(/[}]/) { |b| '\\\\' + b } + '}'\n      end\n      primitive \"text #{x},#{y} #{text}\"\n    end", "label": 4}
{"code": "function Types() {\n    this.binary = specs.ABinary;\n    this.string = specs.AString;\n    this.bool = specs.ABoolean;\n    this.byte = specs.AByte;\n    this.i16 = specs.AInt16;\n    this.i32 = specs.AInt32;\n    this.i64 = specs.AInt64;\n    this.double = specs.ADouble;\n}", "label": 3}
{"code": "def get_bot(self, bot_label):\n        \"\"\"\n        Import all bots and returns a bot class for the given label.\n        Raise LookupError if no bot exists with this label.\n        \"\"\"\n        self.check_bots_ready()\n        try:\n            return self.bots[bot_label]\n        except KeyError:\n            message = \"No installed bot with label '%s'.\" % bot_label\n            for bot_cls in self.get_bots():\n                if bot_cls.name == bot_label:\n                    message += \" Did you mean '%s'?\" % bot_cls.label\n                    break\n            raise LookupError(message)", "label": 1}
{"code": "def check_types(parameters, parameter_types, strict_floats):\n    \"\"\"Checks that the given parameters have the correct types.\n\n    :param parameters: List of (name, value) pairs of the given parameters\n    :type parameters: dict[str, object]\n    :param parameter_types: Parameter type by name.\n    :type parameter_types: dict[str, type]\n    :param strict_floats: If False, treat integers as floats\n    :type strict_floats: bool\n    \"\"\"\n    for name, parameter_type in parameter_types.items():\n        if name not in parameters:\n            raise InvalidParamsError(\"Parameter '{}' is missing.\".format(name))\n        if not _is_instance(parameters[name], parameter_type, strict_floats):\n            raise InvalidParamsError(\"Value '{}' for parameter '{}' is not of expected type {}.\"\n                                     .format(parameters[name], name, parameter_type))", "label": 1}
{"code": "function projects(req, res, next) {\n  var params = {\n    \"formId\": req.params.id\n  };\n\n  logger.debug(\"Middleware: form projects: \", {params: params});\n\n  forms.getFormApps(_.extend(req.connectionOptions, params), formsResultHandlers(constants.resultTypes.formProjects, req, next));\n}", "label": 3}
{"code": "def reset(self):\n        \"\"\"\n        Restore the default configuration and remove the user's config file.\n        \"\"\"\n\n        # Delete user config file\n        try:\n            os.remove(self._user_config_file)\n        except FileNotFoundError:\n            pass\n\n        # Empty and refill the config object\n        for section_name in self.sections():\n            self.remove_section(section_name)\n        self.read_defaults()", "label": 1}
{"code": "public function setRecordTransformations($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\RecordTransformations::class);\n        $this->writeOneof(2, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public function setSiteControl($permittedCrossDomainPolicies = 'all') {\n        if (!$this->validateSiteControl($permittedCrossDomainPolicies)) {\n            throw new \\UnexpectedValueException('Invalid site control set');\n        }\n\n        $this->_siteControl = $permittedCrossDomainPolicies;\n        $this->_cacheValid  = false;\n\n        return $this;\n    }", "label": 2}
{"code": "private void addModuleToGraph(final DbModule module, final AbstractGraph graph, final int depth) {\n        if (graph.isTreated(graph.getId(module))) {\n            return;\n        }\n\n        final String moduleElementId = graph.getId(module);\n        graph.addElement(moduleElementId, module.getVersion(), depth == 0);\n\n        if (filters.getDepthHandler().shouldGoDeeper(depth)) {\n            for (final DbDependency dep : DataUtils.getAllDbDependencies(module)) {\n                if(filters.shouldBeInReport(dep)){\n                    addDependencyToGraph(dep, graph, depth + 1, moduleElementId);\n                }\n            }\n        }\n    }", "label": 0}
{"code": "def resource_title(resource)\n      title = resource.try(:title) || resource.try(:name) || resource.try(:subject) || \"#{resource.model_name.human} ##{resource.id}\"\n      title = translated_attribute(title) if title.is_a?(Hash)\n      title\n    end", "label": 4}
{"code": "def deserialize(job_data)\n      self.job_id               = job_data[\"job_id\"]\n      self.provider_job_id      = job_data[\"provider_job_id\"]\n      self.queue_name           = job_data[\"queue_name\"]\n      self.priority             = job_data[\"priority\"]\n      self.serialized_arguments = job_data[\"arguments\"]\n      self.executions           = job_data[\"executions\"]\n      self.exception_executions = job_data[\"exception_executions\"]\n      self.locale               = job_data[\"locale\"] || I18n.locale.to_s\n      self.timezone             = job_data[\"timezone\"] || Time.zone.try(:name)\n      self.enqueued_at          = job_data[\"enqueued_at\"]\n    end", "label": 4}
{"code": "def list_users(self):\n        \"\"\"\n        Runs the ``\\\\du`` command and returns a list of column values with\n        information about all user roles.\n        \"\"\"\n        lines = output_lines(self.exec_psql('\\\\du'))\n        return [line.split('|') for line in lines]", "label": 1}
{"code": "public void remove(Identity oid)\r\n    {\r\n        if (oid == null) return;\r\n\r\n        ObjectCache cache = getCache(oid, null, METHOD_REMOVE);\r\n        if (cache != null)\r\n        {\r\n            cache.remove(oid);\r\n        }\r\n    }", "label": 0}
{"code": "def load_plan(self, fname):    \n        \"\"\" read the list of thoughts from a text file \"\"\"\n        with open(fname, \"r\") as f:\n            for line in f:\n                if line != '': \n                    tpe, txt = self.parse_plan_from_string(line)\n                    #print('tpe= \"' + tpe + '\"', txt)\n                    if tpe == 'name':\n                        self.name = txt\n                    elif tpe == 'version':\n                        self.plan_version = txt\n                    elif tpe == 'belief':\n                        self.beliefs.add(txt)\n                    elif tpe == 'desire':\n                        self.desires.add(txt)\n                    elif tpe == 'intention':\n                        self.intentions.add(txt)", "label": 1}
{"code": "def inspect\n      # We check defined?(@attributes) not to issue warnings if the object is\n      # allocated but not initialized.\n      inspection = if defined?(@attributes) && @attributes\n        self.class.attribute_names.collect do |name|\n          if has_attribute?(name)\n            attr = _read_attribute(name)\n            value = if attr.nil?\n              attr.inspect\n            else\n              attr = format_for_inspect(attr)\n              inspection_filter.filter_param(name, attr)\n            end\n            \"#{name}: #{value}\"\n          end\n        end.compact.join(\", \")\n      else\n        \"not initialized\"\n      end\n\n      \"#<#{self.class} #{inspection}>\"\n    end", "label": 4}
{"code": "public static String slurpFile(String filename, String encoding)\r\n  throws IOException {\r\n    Reader r = new InputStreamReader(new FileInputStream(filename), encoding);\r\n    return IOUtils.slurpReader(r);\r\n  }", "label": 0}
{"code": "function(submission) {\n  return _.flatten(submission.formFields.map(function(field) {\n    return field.fieldValues.filter(hasGroupId);\n  }).map(function(fieldValue) {\n    return fieldValue.map(extractGroupId);\n  }));\n}", "label": 3}
{"code": "public static function routes()\n    {\n        $middleware = [ CreateDefaultFolder::class, MultiUser::class ];\n        $as = 'unisharp.lfm.';\n        $namespace = '\\\\UniSharp\\\\LaravelFilemanager\\\\Controllers\\\\';\n\n        Route::group(compact('middleware', 'as', 'namespace'), function () {\n\n            // display main layout\n            Route::get('/', [\n                'uses' => 'LfmController@show',\n                'as' => 'show',\n            ]);\n\n            // display integration error messages\n            Route::get('/errors', [\n                'uses' => 'LfmController@getErrors',\n                'as' => 'getErrors',\n            ]);\n\n            // upload\n            Route::any('/upload', [\n                'uses' => 'UploadController@upload',\n                'as' => 'upload',\n            ]);\n\n            // list images & files\n            Route::get('/jsonitems', [\n                'uses' => 'ItemsController@getItems',\n                'as' => 'getItems',\n            ]);\n\n            Route::get('/move', [\n                'uses' => 'ItemsController@move',\n                'as' => 'move',\n            ]);\n\n            Route::get('/domove', [\n                'uses' => 'ItemsController@domove',\n                'as' => 'domove'\n            ]);\n\n            // folders\n            Route::get('/newfolder', [\n                'uses' => 'FolderController@getAddfolder',\n                'as' => 'getAddfolder',\n            ]);\n\n            // list folders\n            Route::get('/folders', [\n                'uses' => 'FolderController@getFolders',\n                'as' => 'getFolders',\n            ]);\n\n            // crop\n            Route::get('/crop', [\n                'uses' => 'CropController@getCrop',\n                'as' => 'getCrop',\n            ]);\n            Route::get('/cropimage', [\n                'uses' => 'CropController@getCropimage',\n                'as' => 'getCropimage',\n            ]);\n            Route::get('/cropnewimage', [\n                'uses' => 'CropController@getNewCropimage',\n                'as' => 'getCropimage',\n            ]);\n\n            // rename\n            Route::get('/rename', [\n                'uses' => 'RenameController@getRename',\n                'as' => 'getRename',\n            ]);\n\n            // scale/resize\n            Route::get('/resize', [\n                'uses' => 'ResizeController@getResize',\n                'as' => 'getResize',\n            ]);\n            Route::get('/doresize', [\n                'uses' => 'ResizeController@performResize',\n                'as' => 'performResize',\n            ]);\n\n            // download\n            Route::get('/download', [\n                'uses' => 'DownloadController@getDownload',\n                'as' => 'getDownload',\n            ]);\n\n            // delete\n            Route::get('/delete', [\n                'uses' => 'DeleteController@getDelete',\n                'as' => 'getDelete',\n            ]);\n\n            Route::get('/demo', 'DemoController@index');\n        });\n    }", "label": 2}
{"code": "def elements(name, tag=:element, identifier={:index => 0}, &block)\n      #\n      # sets tag as element if not defined\n      #\n      if tag.is_a?(Hash)\n        identifier = tag\n        tag        = :element\n      end\n\n      define_method(\"#{name}_elements\") do\n        return call_block(&block) if block_given?\n        platform.elements_for(tag, identifier.clone)\n      end\n    end", "label": 4}
{"code": "public static double[][] toDouble(int[][] array) {\n        double[][] n = new double[array.length][array[0].length];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[0].length; j++) {\n                n[i][j] = (double) array[i][j];\n            }\n        }\n        return n;\n    }", "label": 0}
{"code": "def handleResponse(self, resp):\n        \"\"\"handles a response by fireing the response event for the response coming in\"\"\"\n        id=resp[\"id\"]\n        evt = self.respEvents[id]\n        del(self.respEvents[id])\n        evt.handleResponse(resp)", "label": 1}
{"code": "func (c *NodeClient) dynamicListenAndForward(ctx context.Context, ln net.Listener) {\n\tdefer ln.Close()\n\tdefer c.Close()\n\n\tfor {\n\t\t// Accept connection from the client. Here the client is typically\n\t\t// something like a web browser or other SOCKS5 aware application.\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Dynamic port forwarding (SOCKS5) failed: %v.\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Perform the SOCKS5 handshake with the client to find out the remote\n\t\t// address to proxy.\n\t\tremoteAddr, err := socks.Handshake(conn)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"SOCKS5 handshake failed: %v.\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Debugf(\"SOCKS5 proxy forwarding requests to %v.\", remoteAddr)\n\n\t\t// Proxy the connection to the remote address.\n\t\tgo func() {\n\t\t\terr := c.proxyConnection(ctx, conn, remoteAddr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warnf(\"Failed to proxy connection: %v.\", err)\n\t\t\t}\n\t\t}()\n\t}\n}", "label": 5}
{"code": "public function setTeamMembers($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->team_members = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (c *Client) Get(u string, params url.Values) (*roundtrip.Response, error) {\n\treturn httplib.ConvertResponse(c.Client.Get(context.TODO(), u, params))\n}", "label": 5}
{"code": "func NewExecRequest(ctx *ServerContext, command string) (Exec, error) {\n\t// It doesn't matter what mode the cluster is in, if this is a Teleport node\n\t// return a local *localExec.\n\tif ctx.srv.Component() == teleport.ComponentNode {\n\t\treturn &localExec{\n\t\t\tCtx:     ctx,\n\t\t\tCommand: command,\n\t\t}, nil\n\t}\n\n\t// When in recording mode, return an *remoteExec which will execute the\n\t// command on a remote host. This is used by in-memory forwarding nodes.\n\tif ctx.ClusterConfig.GetSessionRecording() == services.RecordAtProxy {\n\t\treturn &remoteExec{\n\t\t\tctx:     ctx,\n\t\t\tcommand: command,\n\t\t\tsession: ctx.RemoteSession,\n\t\t}, nil\n\t}\n\n\t// Otherwise return a *localExec which will execute locally on the server.\n\t// used by the regular Teleport nodes.\n\treturn &localExec{\n\t\tCtx:     ctx,\n\t\tCommand: command,\n\t}, nil\n}", "label": 5}
{"code": "public final List<MtasSolrStatus> checkForExceptions() {\n    List<MtasSolrStatus> statusWithException = null;\n    for (MtasSolrStatus item : data) {\n      if (item.checkResponseForException()) {\n        if (statusWithException == null) {\n          statusWithException = new ArrayList<>();\n        }\n        statusWithException.add(item);\n      }\n    }\n    return statusWithException;\n  }", "label": 0}
{"code": "public function delete($table, KeySet $keySet)\n    {\n        $this->enqueue(Operation::OP_DELETE, $table, [$keySet]);\n\n        return $this;\n    }", "label": 2}
{"code": "public void forAllIndices(String template, Properties attributes) throws XDocletException\r\n    {\r\n        boolean processUnique = TypeConversionUtil.stringToBoolean(attributes.getProperty(ATTRIBUTE_UNIQUE), false);\r\n\r\n        // first the default index\r\n        _curIndexDef = _curTableDef.getIndex(null);\r\n        if ((_curIndexDef != null) && (processUnique == _curIndexDef.isUnique()))\r\n        {\r\n            generate(template);\r\n        }\r\n        for (Iterator it = _curTableDef.getIndices(); it.hasNext(); )\r\n        {\r\n            _curIndexDef = (IndexDef)it.next();\r\n            if (!_curIndexDef.isDefault() && (processUnique == _curIndexDef.isUnique()))\r\n            {    \r\n                generate(template);\r\n            }\r\n        }\r\n        _curIndexDef = null;\r\n    }", "label": 0}
{"code": "def add(username, password)\n      CredentialsManager::AccountManager.new(\n        user: username,\n        password: password\n      ).add_to_keychain\n    end", "label": 4}
{"code": "func (*ArchiveHandler) Stat(u *url.URL) (os.FileInfo, error) {\n\tswitch u.Query().Get(\"format\") {\n\tcase \"\", \"tar\", \"tgz\":\n\t\t// ok\n\tdefault:\n\t\tlog.Printf(\"unknown archive format: %q\", u)\n\t\treturn nil, vix.Error(vix.InvalidArg)\n\t}\n\n\treturn &archive{\n\t\tname: u.Path,\n\t\tsize: math.MaxInt64,\n\t}, nil\n}", "label": 5}
{"code": "public function setImageClassificationDatasetMetadata($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\AutoMl\\V1beta1\\ImageClassificationDatasetMetadata::class);\n        $this->writeOneof(24, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def platform(self, with_prompt, platforms=None):\n        \"\"\"Return the platform name based on the prompt matching.\"\"\"\n        if platforms is None:\n            platforms = self._dict['generic']['prompt_detection']\n\n        for platform in platforms:\n            pattern = self.pattern(platform, 'prompt')\n            result = re.search(pattern, with_prompt)\n            if result:\n                return platform\n        return None", "label": 1}
{"code": "public static filterpolicy[] get(nitro_service service, String name[]) throws Exception{\n\t\tif (name !=null && name.length>0) {\n\t\t\tfilterpolicy response[] = new filterpolicy[name.length];\n\t\t\tfilterpolicy obj[] = new filterpolicy[name.length];\n\t\t\tfor (int i=0;i<name.length;i++) {\n\t\t\t\tobj[i] = new filterpolicy();\n\t\t\t\tobj[i].set_name(name[i]);\n\t\t\t\tresponse[i] = (filterpolicy) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "async function confirmResetPassword(form) {\n  await client.connect();\n  try {\n    console.log(\"token : \", sessionStorage.getItem(\"token\"));\n    await api.confirmResetPassword(\n      {\n        token: sessionStorage.getItem(\"token\"),\n        firstPassword: form.firstPassword.value,\n        secondPassword: form.secondPassword.value\n      },\n      \"user\"\n    );\n    displayMessage(\"Reset password\", \"Password changed\", \"is-success\");\n    goTo(\"login\");\n    sessionStorage.clear();\n  } catch (e) {\n    displayMessage(\n      \"Reset password\",\n      `Failed to reset the password. Cause: ${e.message}`,\n      \"is-danger\"\n    );\n  }\n}", "label": 3}
{"code": "public function commit(Session $session, array $mutations, array $options = [])\n    {\n        $options += [\n            'transactionId' => null\n        ];\n\n        $res = $this->connection->commit($this->arrayFilterRemoveNull([\n            'mutations' => $mutations,\n            'session' => $session->name(),\n            'database' => $session->info()['database']\n        ]) + $options);\n\n        $time = $this->parseTimeString($res['commitTimestamp']);\n        return new Timestamp($time[0], $time[1]);\n    }", "label": 2}
{"code": "func (tc *TeleportClient) runCommand(\n\tctx context.Context, siteName string, nodeAddresses []string, proxyClient *ProxyClient, command []string) error {\n\n\tresultsC := make(chan error, len(nodeAddresses))\n\tfor _, address := range nodeAddresses {\n\t\tgo func(address string) {\n\t\t\tvar (\n\t\t\t\terr         error\n\t\t\t\tnodeSession *NodeSession\n\t\t\t)\n\t\t\tdefer func() {\n\t\t\t\tresultsC <- err\n\t\t\t}()\n\t\t\tvar nodeClient *NodeClient\n\t\t\tnodeClient, err = proxyClient.ConnectToNode(ctx, address+\"@\"+tc.Namespace+\"@\"+siteName, tc.Config.HostLogin, false)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintln(tc.Stderr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer nodeClient.Close()\n\n\t\t\t// run the command on one node:\n\t\t\tif len(nodeAddresses) > 1 {\n\t\t\t\tfmt.Printf(\"Running command on %v:\\n\", address)\n\t\t\t}\n\t\t\tnodeSession, err = newSession(nodeClient, nil, tc.Config.Env, tc.Stdin, tc.Stdout, tc.Stderr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer nodeSession.Close()\n\t\t\tif err = nodeSession.runCommand(ctx, command, tc.OnShellCreated, tc.Config.Interactive); err != nil {\n\t\t\t\toriginErr := trace.Unwrap(err)\n\t\t\t\texitErr, ok := originErr.(*ssh.ExitError)\n\t\t\t\tif ok {\n\t\t\t\t\ttc.ExitStatus = exitErr.ExitStatus()\n\t\t\t\t} else {\n\t\t\t\t\t// if an error occurs, but no exit status is passed back, GoSSH returns\n\t\t\t\t\t// a generic error like this. in this case the error message is printed\n\t\t\t\t\t// to stderr by the remote process so we have to quietly return 1:\n\t\t\t\t\tif strings.Contains(originErr.Error(), \"exited without exit status\") {\n\t\t\t\t\t\ttc.ExitStatus = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}(address)\n\t}\n\tvar lastError error\n\tfor range nodeAddresses {\n\t\tif err := <-resultsC; err != nil {\n\t\t\tlastError = err\n\t\t}\n\t}\n\treturn trace.Wrap(lastError)\n}", "label": 5}
{"code": "def put_auth_tune(path, config = {})\n      json = client.put(\"/v1/sys/auth/#{encode_path(path)}/tune\", JSON.fast_generate(config))\n      if json.nil?\n        return true\n      else\n        return Secret.decode(json)\n      end\n    end", "label": 4}
{"code": "public static rewritepolicylabel_policybinding_binding[] get(nitro_service service, String labelname) throws Exception{\n\t\trewritepolicylabel_policybinding_binding obj = new rewritepolicylabel_policybinding_binding();\n\t\tobj.set_labelname(labelname);\n\t\trewritepolicylabel_policybinding_binding response[] = (rewritepolicylabel_policybinding_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static <T> Collection<T> diff(Collection<T> list1, Collection<T> list2) {\r\n    Collection<T> diff = new ArrayList<T>();\r\n    for (T t : list1) {\r\n      if (!list2.contains(t)) {\r\n        diff.add(t);\r\n      }\r\n    }\r\n    return diff;\r\n  }", "label": 0}
{"code": "public static base_responses delete(nitro_service client, String filename[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (filename != null && filename.length > 0) {\n\t\t\tsystembackup deleteresources[] = new systembackup[filename.length];\n\t\t\tfor (int i=0;i<filename.length;i++){\n\t\t\t\tdeleteresources[i] = new systembackup();\n\t\t\t\tdeleteresources[i].filename = filename[i];\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "func NewClient(c *vim25.Client) *Client {\n\tsc := c.Client.NewServiceClient(internal.Path, \"\")\n\n\treturn &Client{sc}\n}", "label": 5}
{"code": "def page_sections(name, section_class, identifier)\n      define_method(name) do\n        platform.pages_for(identifier, section_class)\n      end\n    end", "label": 4}
{"code": "def apply\n      first_cell, last_cell = range.split(':')\n      start_point = Axlsx::name_to_indices(first_cell)\n      end_point = Axlsx::name_to_indices(last_cell)\n      # The +1 is so we skip the header row with the filter drop downs\n      rows = worksheet.rows[(start_point.last+1)..end_point.last] || []\n\n      column_offset = start_point.first\n      columns.each do |column|\n        rows.each do |row|\n          next if row.hidden\n          column.apply(row, column_offset)\n        end\n      end\n    end", "label": 4}
{"code": "def _normalize_options(options)\n        options = super(options)\n        if options[:partial] == true\n          options[:partial] = action_name\n        end\n\n        if (options.keys & [:partial, :file, :template]).empty?\n          options[:prefixes] ||= _prefixes\n        end\n\n        options[:template] ||= (options[:action] || action_name).to_s\n        options\n      end", "label": 4}
{"code": "function getPythonExecutable(options, platform) {\n    if (options.virtualenv) {\n      var isWin = /^win/.test(platform);\n      var pythonExec = isWin ?\n        path.join(options.virtualenv, 'Scripts', 'python.exe') :\n        path.join(options.virtualenv, 'bin', 'python');\n      delete options.virtualenv;\n      return pythonExec;\n    } else {\n      return 'python';\n    }\n  }", "label": 3}
{"code": "function logout(logoutOptions) {\n    if (logoutOptions === void 0) { logoutOptions = {}; }\n    var serverUrl = urls.resolveServer('/', logoutOptions);\n    var serverObj = server.Server.getInstance(serverUrl);\n    // process options\n    var currentOptions = serverObj.applyOptions({\n        serverUrl: serverUrl,\n        agentOptions: logoutOptions.agentOptions || init.initOptions.agentOptions,\n        agentClass: logoutOptions.agentClass || init.initOptions.agentClass,\n    });\n    return ajax(_.defaults({\n        serverUrl: serverUrl,\n        method: 'POST',\n        url: '/gofer/security/rest/auth/logout',\n        body: {}\n    }, currentOptions)).catch(function (error) {\n        if (error.statusCode === 422) {\n            // REST-based logout URL currently is broken reporting a 422 in all cases\n            return ajax(_.defaults({\n                serverUrl: serverUrl,\n                method: 'GET',\n                url: '/gofer/security-logout'\n            }, currentOptions)).then(function (result) {\n                diag.debug.warn('BUG: resorted to classic PATH-based logout as REST-based logout failed:', error);\n                return result;\n            }, function (error2) {\n                return Q.reject(error2.statusCode === 422 ? error : error2);\n            });\n        }\n        return Q.reject(error);\n    }).catch(function (error) {\n        // ignore network failures on timeout, server forgets on session timeout anyways\n        if (!error.statusCode) {\n            return Q.resolve(undefined);\n        }\n        return Q.reject(error);\n    }).finally(function () {\n        // eventually erase offline login data\n        if (logoutOptions.offlineCapable) {\n            // requested to erase login data\n            return offline.clearOfflineLogin(serverObj.credentials, currentOptions).catch(function (offlineError) {\n                diag.debug.warn('failed erasing offline login data', offlineError);\n                return Q.resolve(undefined);\n            });\n        }\n    }).finally(function () {\n        // forget everything about it\n        serverObj.credentials = null;\n        serverObj.authorization = auth.ANONYMOUS_AUTHORIZATION;\n        serverObj.organization = null;\n        serverObj.user = null;\n        serverObj.sessionUserUuid = null;\n    });\n}", "label": 3}
{"code": "public static base_response update(nitro_service client, filteraction resource) throws Exception {\n\t\tfilteraction updateresource = new filteraction();\n\t\tupdateresource.name = resource.name;\n\t\tupdateresource.servicename = resource.servicename;\n\t\tupdateresource.value = resource.value;\n\t\tupdateresource.respcode = resource.respcode;\n\t\tupdateresource.page = resource.page;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function trigger(eventsInput, args)\n  {\n    try\n    {\n      var events = toArray( eventsInput, ' ' );\n\n      for (var i = 0; i < events.length; i++)\n      {\n        triggerListeners( this.$$on, events[ i ], args );\n      }\n    }\n    catch (ex)\n    {\n      Rekord.trigger( Rekord.Events.Error, [ex] );\n    }\n\n    return this;\n  }", "label": 3}
{"code": "def wrap_unmerge(job, strelka_out, chromosomes, strelka_options, univ_options):\n    \"\"\"\n    A wwrapper to unmerge the strelka snvs and indels\n\n    :param dict strelka_out: Results from run_strelka\n    :param list chromosomes: List of chromosomes to retain\n    :param dict strelka_options: Options specific to strelka\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :return: Dict of dicts containing the fsIDs for the per-chromosome snv and indel calls\n             output:\n               |- 'snvs':\n               |      |- 'chr1': fsID\n               |      |- 'chr2': fsID\n               |      |- ...\n               |      +- 'chrM': fsID\n               +- 'indels':\n                      |- 'chr1': fsID\n                      |- 'chr2': fsID\n                      |- ...\n                      +- 'chrM': fsID\n    :rtype: dict\n    \"\"\"\n    return {'snvs': job.addChildJobFn(unmerge, strelka_out['snvs'], 'strelka/snv', chromosomes,\n                                      strelka_options, univ_options).rv(),\n            'indels': job.addChildJobFn(unmerge, strelka_out['indels'], 'strelka/indel',\n                                        chromosomes, strelka_options, univ_options).rv()}", "label": 1}
{"code": "function userError (details = [], code) {\n  const err = new Error('User error');\n  err.userError = true;\n  err.code = code;\n  err.details = details;\n  return err;\n}", "label": 3}
{"code": "function _handshake(handshakeProps, handshakeCallback) {\n        if (_isFunction(handshakeProps)) {\n            handshakeCallback = handshakeProps;\n            handshakeProps = undefined;\n        }\n\n        _clientId = null;\n\n        _clearSubscriptions();\n\n        // Reset the transports if we're not retrying the handshake\n        if (_isDisconnected()) {\n            _transports.reset(true);\n            _updateAdvice(_config.advice);\n        } else {\n            // We are retrying the handshake, either because another handshake failed\n            // and we're backing off, or because the server timed us out and asks us to\n            // re-handshake: in both cases, make sure that if the handshake succeeds\n            // the next action is a connect.\n            _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));\n        }\n\n        _batch = 0;\n\n        // Mark the start of an internal batch.\n        // This is needed because handshake and connect are async.\n        // It may happen that the application calls init() then subscribe()\n        // and the subscribe message is sent before the connect message, if\n        // the subscribe message is not held until the connect message is sent.\n        // So here we start a batch to hold temporarily any message until\n        // the connection is fully established.\n        _internalBatch = true;\n\n        // Save the properties provided by the user, so that\n        // we can reuse them during automatic re-handshake\n        _handshakeProps = handshakeProps;\n        _handshakeCallback = handshakeCallback;\n\n        var version = '1.0';\n\n        // Figure out the transports to send to the server\n        var url = _cometd.getURL();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            version: version,\n            minimumVersion: version,\n            channel: '/meta/handshake',\n            supportedConnectionTypes: transportTypes,\n            advice: {\n                timeout: _advice.timeout,\n                interval: _advice.interval\n            }\n        };\n        // Do not allow the user to override important fields.\n        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, handshakeCallback);\n\n        // Pick up the first available transport as initial transport\n        // since we don't know if the server supports it\n        if (!_transport) {\n            _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n            if (!_transport) {\n                var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n                _cometd._warn(failure);\n                throw failure;\n            }\n        }\n\n        _cometd._debug('Initial transport is', _transport.getType());\n\n        // We started a batch to hold the application messages,\n        // so here we must bypass it and send immediately.\n        _setStatus('handshaking');\n        _cometd._debug('Handshake sent', message);\n        _send(false, [message], false, 'handshake');\n    }", "label": 3}
{"code": "public static function sort(CommandInterface $command, $prefix)\n    {\n        if ($arguments = $command->getArguments()) {\n            $arguments[0] = \"$prefix{$arguments[0]}\";\n\n            if (($count = count($arguments)) > 1) {\n                for ($i = 1; $i < $count; ++$i) {\n                    switch (strtoupper($arguments[$i])) {\n                        case 'BY':\n                        case 'STORE':\n                            $arguments[$i] = \"$prefix{$arguments[++$i]}\";\n                            break;\n\n                        case 'GET':\n                            $value = $arguments[++$i];\n                            if ($value !== '#') {\n                                $arguments[$i] = \"$prefix$value\";\n                            }\n                            break;\n\n                        case 'LIMIT';\n                            $i += 2;\n                            break;\n                    }\n                }\n            }\n\n            $command->setRawArguments($arguments);\n        }\n    }", "label": 2}
{"code": "def set_current(current)\n      if length.zero?\n        self.scene = nil\n        return\n      # Don't bother looking for current image\n      elsif scene.nil? || scene >= length\n        self.scene = length - 1\n        return\n      elsif !current.nil?\n        # Find last instance of \"current\" in the list.\n        # If \"current\" isn't in the list, set current to last image.\n        self.scene = length - 1\n        each_with_index do |f, i|\n          self.scene = i if f.__id__ == current\n        end\n        return\n      end\n      self.scene = length - 1\n    end", "label": 4}
{"code": "private function convertArrayToEntityValue(array $value)\n    {\n        $excludes = $this->pluck(Entity::EXCLUDE_FROM_INDEXES, $value, false) ?: [];\n\n        $properties = [];\n        foreach ($value as $key => $val) {\n            $properties[$key] = $this->valueObject(\n                $val,\n                in_array($key, $excludes)\n            );\n        }\n\n        if (!$properties) {\n            $properties = (object) $properties;\n        }\n\n        return [\n            'entityValue' => [\n                'properties' => $properties\n            ]\n        ];\n    }", "label": 2}
{"code": "def remount(from, to)\n      client.post(\"/v1/sys/remount\", JSON.fast_generate(\n        from: from,\n        to:   to,\n      ))\n      return true\n    end", "label": 4}
{"code": "func (cfg *TestTLSServerConfig) CheckAndSetDefaults() error {\n\tif cfg.APIConfig == nil {\n\t\treturn trace.BadParameter(\"missing parameter APIConfig\")\n\t}\n\tif cfg.AuthServer == nil {\n\t\treturn trace.BadParameter(\"missing parameter AuthServer\")\n\t}\n\t// use very permissive limiter configuration by default\n\tif cfg.Limiter == nil {\n\t\tcfg.Limiter = &limiter.LimiterConfig{\n\t\t\tMaxConnections:   1000,\n\t\t\tMaxNumberOfUsers: 1000,\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def passed_country(country)\n      code = country_prefix(country)\n      if Core::PLUS_SIGN == @original[0] && code && !sanitized.start_with?(code)\n        # in case number passed with + but it doesn't start with passed\n        # country prefix\n        country = nil\n      end\n      country\n    end", "label": 4}
{"code": "func (r *infoResult) vmPaths() (map[string]string, error) {\n\tctx := context.TODO()\n\tpaths := make(map[string]string)\n\tfor _, info := range r.mhas.Config.PowerInfo {\n\t\tmes, err := mo.Ancestors(ctx, r.client, r.client.ServiceContent.PropertyCollector, info.Key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpath := \"\"\n\t\tfor _, me := range mes {\n\t\t\t// Skip root entity in building inventory path.\n\t\t\tif me.Parent == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpath += \"/\" + me.Name\n\t\t}\n\n\t\tpaths[info.Key.Value] = path\n\t}\n\n\treturn paths, nil\n}", "label": 5}
{"code": "function process(advertiserData) {\n  var data = advertiserData.manufacturerSpecificData.data;\n  var cursor = 0;\n\n  // Apple sometimes includes more than one service data\n  while(cursor < data.length) {\n    var appleType = data.substr(cursor,2);\n\n    switch(appleType) {\n      case '01':\n        return; // TODO: decipher this type (one bit set in fixed length?)\n      case '02':\n        cursor = ibeacon.process(advertiserData, cursor);\n        break;\n      case '05':\n        cursor = airdrop.process(advertiserData, cursor);\n        break;\n      case '07':\n        cursor = airpods.process(advertiserData, cursor);\n        break;\n      case '08':\n        cursor = service.process(advertiserData, cursor); // TODO: decipher\n        break;\n      case '09':\n        cursor = airplay.process(advertiserData, cursor); \n        break;\n      case '0a':\n        cursor = airplay.process(advertiserData, cursor);\n        break;\n      case '0b':\n        cursor = service.process(advertiserData, cursor); // TODO: decipher\n        break;\n      case '0c':\n        cursor = handoff.process(advertiserData, cursor);\n        break;\n      case '10':\n        cursor = nearby.process(advertiserData, cursor);\n        break;\n      default:\n        return; // Don't trust types that haven't yet been observed\n    }\n  }\n}", "label": 3}
{"code": "public Query getPKQuery(Identity oid)\r\n    {\r\n        Object[] values = oid.getPrimaryKeyValues();\r\n        ClassDescriptor cld = pb.getClassDescriptor(oid.getObjectsTopLevelClass());\r\n        FieldDescriptor[] fields = cld.getPkFields();\r\n        Criteria criteria = new Criteria();\r\n\r\n        for (int i = 0; i < fields.length; i++)\r\n        {\r\n            FieldDescriptor fld = fields[i];\r\n            criteria.addEqualTo(fld.getAttributeName(), values[i]);\r\n        }\r\n        return QueryFactory.newQuery(cld.getClassOfObject(), criteria);\r\n    }", "label": 0}
{"code": "public static appflowpolicy_binding get(nitro_service service, String name) throws Exception{\n\t\tappflowpolicy_binding obj = new appflowpolicy_binding();\n\t\tobj.set_name(name);\n\t\tappflowpolicy_binding response = (appflowpolicy_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def url\n      easy = EasyFactory.new(self).get\n      url = easy.url\n      Typhoeus::Pool.release(easy)\n      url\n    end", "label": 4}
{"code": "public function getSeederNames($name)\n    {\n        $name = Str::studly($name);\n\n        $seederPath = GenerateConfigReader::read('seeder');\n        $seederPath = str_replace('/', '\\\\', $seederPath->getPath());\n\n        $foundModules = [];\n        foreach ($this->laravel['modules']->config('scan.paths') as $path) {\n            $namespace = array_slice(explode('/', $path), -1)[0];\n            $foundModules[] = $namespace . '\\\\' . $name . '\\\\' . $seederPath . '\\\\' . $name . 'DatabaseSeeder';\n        }\n\n        return $foundModules;\n    }", "label": 2}
{"code": "function prepareData(items, with_timestamps, with_ns) {\n    var data = {\n        request: 'sender data',\n        data: items\n    };\n\n    if (with_timestamps) {\n        var ts = Date.now() / 1000;\n        data.clock = ts | 0;\n\n        if (with_ns) {\n            data.ns = (ts % 1) * 1000 * 1000000 | 0;\n        }\n    }\n\n    var payload = new Buffer(JSON.stringify(data), 'utf8'),\n        header  = new Buffer(5 + 4); // ZBXD\\1 + packed payload.length\n\n    header.write('ZBXD\\x01');\n    header.writeInt32LE(payload.length, 5);\n    return Buffer.concat([header, new Buffer('\\x00\\x00\\x00\\x00'), payload]);\n}", "label": 3}
{"code": "def refresh(self):\n        \"\"\"\n        Keeps the lease alive by streaming keep alive requests from the client\n        to the server and streaming keep alive responses from the server to\n        the client.\n\n        :returns: Response header.\n        :rtype: instance of :class:`txaioetcd.Header`\n        \"\"\"\n        if self._expired:\n            raise Expired()\n\n        obj = {\n            # ID is the lease ID for the lease to keep alive.\n            u'ID': self.lease_id,\n        }\n        data = json.dumps(obj).encode('utf8')\n\n        url = u'{}/v3alpha/lease/keepalive'.format(self._client._url).encode()\n        response = yield treq.post(url, data, headers=self._client._REQ_HEADERS)\n\n        obj = yield treq.json_content(response)\n\n        if u'result' not in obj:\n            raise Exception('bogus lease refresh response (missing \"result\") in {}'.format(obj))\n\n        ttl = obj[u'result'].get(u'TTL', None)\n        if not ttl:\n            self._expired = True\n            raise Expired()\n\n        header = Header._parse(obj[u'result'][u'header']) if u'header' in obj[u'result'] else None\n\n        self._expired = False\n\n        returnValue(header)", "label": 1}
{"code": "def zero_to_one(table, option):\n    \"\"\"\n    normalize from zero to one for row or table\n    \"\"\"\n    if option == 'table':\n        m = min(min(table))\n        ma = max(max(table))\n    t = []\n    for row in table:\n        t_row = []\n        if option != 'table':\n            m, ma = min(row), max(row)\n        for i in row:\n            if ma == m:\n                t_row.append(0)\n            else:\n                t_row.append((i - m)/(ma - m))\n        t.append(t_row)\n    return t", "label": 1}
{"code": "def as_knock(self, created=False):\n        \"\"\"\n        Returns a dictionary with the knock data built from _knocker_data\n        \"\"\"\n        knock = {}\n        if self.should_knock(created):\n            for field, data in self._retrieve_data(None, self._knocker_data):\n                knock[field] = data\n        return knock", "label": 1}
{"code": "public static base_response update(nitro_service client, aaacertparams resource) throws Exception {\n\t\taaacertparams updateresource = new aaacertparams();\n\t\tupdateresource.usernamefield = resource.usernamefield;\n\t\tupdateresource.groupnamefield = resource.groupnamefield;\n\t\tupdateresource.defaultauthenticationgroup = resource.defaultauthenticationgroup;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function autoSubscribe() {\n    //re-add pending subscribers\n    if (_pendingSubscribers.length > 0) {\n      async.each(_pendingSubscribers, function(sub, callback) {\n        debug('Add pending subscriber', sub);\n        self.subscribeToTopic(sub.exchange, sub.queue, sub.filter, sub.subscriber, sub.opts, function(err) {\n          if (err) {\n            debug('Failed to add subscriber, keep it', sub);\n          } else {\n            //done, remove the item from the pending subscribers\n            var idx = _pendingSubscribers.indexOf(sub);\n            _pendingSubscribers.splice(idx, 1);\n            debug('pending subsriber added, now there are ' + _pendingSubscribers.length + ' left');\n          }\n          return callback();\n        });\n      }, function() {\n        debug('pending subscribers are added');\n      });\n    }\n  }", "label": 3}
{"code": "def type_selection\n      klasses = klass._types\n      if klasses.size > 1\n        { _type: { \"$in\" => klass._types }}\n      else\n        { _type: klass._types[0] }\n      end\n    end", "label": 4}
{"code": "def unregister(self, document):\n        \"\"\"\n        Unregisters an existing document, so that this document is no longer available.\n\n        This function is mainly used during plugin deactivation.\n\n        :param document: Name of the document\n        \"\"\"\n        if document not in self.documents.keys():\n            self.log.warning(\"Can not unregister document %s\" % document)\n        else:\n            del (self.documents[document])\n            self.__log.debug(\"Document %s got unregistered\" % document)", "label": 1}
{"code": "private void harvestReturnValue(\r\n        Object obj,\r\n        CallableStatement callable,\r\n        FieldDescriptor fmd,\r\n        int index)\r\n        throws PersistenceBrokerSQLException\r\n    {\r\n\r\n        try\r\n        {\r\n            // If we have a field descriptor, then we can harvest\r\n            // the return value.\r\n            if ((callable != null) && (fmd != null) && (obj != null))\r\n            {\r\n                // Get the value and convert it to it's appropriate\r\n                // java type.\r\n                Object value = fmd.getJdbcType().getObjectFromColumn(callable, index);\r\n\r\n                // Set the value of the persistent field.\r\n                fmd.getPersistentField().set(obj, fmd.getFieldConversion().sqlToJava(value));\r\n\r\n            }\r\n        }\r\n        catch (SQLException e)\r\n        {\r\n            String msg = \"SQLException during the execution of harvestReturnValue\"\r\n                + \" class=\"\r\n                + obj.getClass().getName()\r\n                + \",\"\r\n                + \" field=\"\r\n                + fmd.getAttributeName()\r\n                + \" : \"\r\n                + e.getMessage();\r\n            logger.error(msg,e);\r\n            throw new PersistenceBrokerSQLException(msg, e);\r\n        }\r\n    }", "label": 0}
{"code": "@Programmatic\n    public <T> List<T> fromExcel(\n            final Blob excelBlob,\n            final Class<T> cls,\n            final String sheetName) throws ExcelService.Exception {\n        return fromExcel(excelBlob, new WorksheetSpec(cls, sheetName));\n    }", "label": 0}
{"code": "public function setMqttEnabledState($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Iot\\V1\\MqttState::class);\n        $this->mqtt_enabled_state = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static vlan get(nitro_service service, Long id) throws Exception{\n\t\tvlan obj = new vlan();\n\t\tobj.set_id(id);\n\t\tvlan response = (vlan) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func CreateSharedVolumesPath(root string) (string, error) {\n\tsharedVolPath := SharedVolumesPath(root)\n\n\tif err := os.MkdirAll(sharedVolPath, SharedVolumePerm); err != nil {\n\t\treturn \"\", errwrap.Wrap(errors.New(\"could not create shared volumes directory\"), err)\n\t}\n\t// In case it already existed and we didn't make it, ensure permissions are\n\t// what the caller expects them to be.\n\tif err := os.Chmod(sharedVolPath, SharedVolumePerm); err != nil {\n\t\treturn \"\", errwrap.Wrap(fmt.Errorf(\"could not change permissions of %q\", sharedVolPath), err)\n\t}\n\n\treturn sharedVolPath, nil\n}", "label": 5}
{"code": "@Deprecated\r\n  @SuppressWarnings(\"unchecked\")\r\n  private static <E extends LogRecordHandler> E getHandler(Class<E> clazz){\r\n    for(LogRecordHandler cand : handlers){\r\n      if(clazz == cand.getClass()){\r\n        return (E) cand;\r\n      }\r\n    }\r\n    return null;\r\n  }", "label": 0}
{"code": "public function setRuleSet($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\InspectionRuleSet::class);\n        $this->rule_set = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def analysis2working(self,a):\n        \"Convert back from the analysis color space to the working space.\"\n        a = self.swap_polar_HSVorder[self.analysis_space](a)\n        return self.colorspace.convert(self.analysis_space, self.working_space, a)", "label": 1}
{"code": "func (ww *WidgetWatchers) Watch(handler tcell.EventHandler) {\n\tif ww.watchers == nil {\n\t\tww.watchers = make(map[tcell.EventHandler]struct{})\n\t}\n\tww.watchers[handler] = struct{}{}\n}", "label": 5}
{"code": "def delete_channel(data)\n      channel = Channel.new(data, self)\n      server = channel.server\n\n      # Handle normal and private channels separately\n      if server\n        @channels.delete(channel.id)\n        server.delete_channel(channel.id)\n      elsif channel.pm?\n        @pm_channels.delete(channel.recipient.id)\n      elsif channel.group?\n        @channels.delete(channel.id)\n      end\n    end", "label": 4}
{"code": "public static String determineMutatorName(@Nonnull final String fieldName) {\n\t\tCheck.notEmpty(fieldName, \"fieldName\");\n\t\tfinal Matcher m = PATTERN.matcher(fieldName);\n\t\tCheck.stateIsTrue(m.find(), \"passed field name '%s' is not applicable\", fieldName);\n\t\tfinal String name = m.group();\n\t\treturn METHOD_SET_PREFIX + name.substring(0, 1).toUpperCase() + name.substring(1);\n\t}", "label": 0}
{"code": "function(next) {\n            core.allowPackages.forEach(function(pkg) {\n                try {\n                    var mod = path.dirname(require.resolve(pkg)).replace(/\\/lib$/, \"\");\n                    core.packages[pkg] = { path: mod };\n                    if (lib.statSync(mod + \"/etc\").isDirectory()) {\n                        core.packages[pkg].etc = 1;\n                        var cfg = lib.readFileSync(mod + \"/etc/config\");\n                        if (cfg) {\n                            config = cfg + \"\\n\" + config;\n                            core.packages[pkg].config = 1;\n                            core.parseConfig(cfg, 1);\n                        }\n                    }\n                    [\"modules\",\"locales\",\"views\",\"web\"].forEach(function(x) {\n                        if (lib.statSync(mod + \"/\" + x).isDirectory()) {\n                            core.path[x].unshift(mod + \"/\" + x);\n                            core.packages[pkg][x] = 1;\n                        }\n                    });\n                    logger.debug(\"init:\", \"npm package:\", pkg, core.packages[pkg]);\n                } catch(e) {\n                    logger.error(\"init:\", \"npm package:\", pkg, e);\n                }\n            });\n            next();\n        }", "label": 3}
{"code": "public static Map<String, Object> with(Object... params) {\n        Map<String, Object> map = new HashMap<>();\n        for (int i = 0; i < params.length; i++) {\n            map.put(String.valueOf(i), params[i]);\n        }\n        return map;\n    }", "label": 0}
{"code": "def register_system_role(self, system_role):\n        \"\"\"Register a system role.\n\n        .. note:: A system role can't be registered two times. If it happens,\n        then an assert exception will be raised.\n\n        :param system_role: The system role to be registered.\n        \"\"\"\n        assert system_role.value not in self.system_roles\n        self.system_roles[system_role.value] = system_role", "label": 1}
{"code": "public static base_response disable(nitro_service client, String trapname) throws Exception {\n\t\tsnmpalarm disableresource = new snmpalarm();\n\t\tdisableresource.trapname = trapname;\n\t\treturn disableresource.perform_operation(client,\"disable\");\n\t}", "label": 0}
{"code": "function (a, b) {\n        var pending;\n        if (this._neverCompared(a, b)) {\n            pending = this._pending;\n            pending.push(a);\n            pending.push(b);\n        }\n    }", "label": 3}
{"code": "def symbolize_hash(hash)\n      return hash unless hash.is_a?(Hash)\n\n      hash.inject({}){ |memo,(key,value)| memo[key.to_sym] = symbolize_hash(value); memo }\n    end", "label": 4}
{"code": "def _process_channels(self,p,**params_to_override):\n        \"\"\"\n        Add the channel information to the channel_data attribute.\n        \"\"\"\n        orig_image = self._image\n\n        for i in range(len(self._channel_data)):\n            self._image = self._original_channel_data[i]\n            self._channel_data[i] = self._reduced_call(**params_to_override)\n        self._image = orig_image\n        return self._channel_data", "label": 1}
{"code": "func readTrustedClusters(clusters []TrustedCluster, conf *service.Config) error {\n\tif len(clusters) == 0 {\n\t\treturn nil\n\t}\n\t// go over all trusted clusters:\n\tfor i := range clusters {\n\t\ttc := &clusters[i]\n\t\t// parse \"allow_logins\"\n\t\tvar allowedLogins []string\n\t\tfor _, login := range strings.Split(tc.AllowedLogins, \",\") {\n\t\t\tlogin = strings.TrimSpace(login)\n\t\t\tif login != \"\" {\n\t\t\t\tallowedLogins = append(allowedLogins, login)\n\t\t\t}\n\t\t}\n\t\t// open the key file for this cluster:\n\t\tlog.Debugf(\"reading trusted cluster key file %s\", tc.KeyFile)\n\t\tif tc.KeyFile == \"\" {\n\t\t\treturn trace.Errorf(\"key_file is missing for a trusted cluster\")\n\t\t}\n\t\tf, err := os.Open(tc.KeyFile)\n\t\tif err != nil {\n\t\t\treturn trace.Errorf(\"reading trusted cluster keys: %v\", err)\n\t\t}\n\t\tdefer f.Close()\n\t\t// read the keyfile for this cluster and get trusted CA keys:\n\t\tvar authorities []services.CertAuthority\n\t\tvar roles []services.Role\n\t\tscanner := bufio.NewScanner(f)\n\t\tfor line := 0; scanner.Scan(); {\n\t\t\tca, role, err := parseCAKey(scanner.Bytes(), allowedLogins)\n\t\t\tif err != nil {\n\t\t\t\treturn trace.BadParameter(\"%s:L%d. %v\", tc.KeyFile, line, err)\n\t\t\t}\n\t\t\tif ca.GetType() == services.UserCA && len(allowedLogins) == 0 && len(tc.TunnelAddr) > 0 {\n\t\t\t\treturn trace.BadParameter(\"trusted cluster '%s' needs allow_logins parameter\",\n\t\t\t\t\tca.GetClusterName())\n\t\t\t}\n\t\t\tauthorities = append(authorities, ca)\n\t\t\tif role != nil {\n\t\t\t\troles = append(roles, role)\n\t\t\t}\n\t\t}\n\t\tconf.Auth.Authorities = append(conf.Auth.Authorities, authorities...)\n\t\tconf.Auth.Roles = append(conf.Auth.Roles, roles...)\n\t\tclusterName := authorities[0].GetClusterName()\n\t\t// parse \"tunnel_addr\"\n\t\tvar tunnelAddresses []string\n\t\tfor _, ta := range strings.Split(tc.TunnelAddr, \",\") {\n\t\t\tta := strings.TrimSpace(ta)\n\t\t\tif ta == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\taddr, err := utils.ParseHostPortAddr(ta, defaults.SSHProxyTunnelListenPort)\n\t\t\tif err != nil {\n\t\t\t\treturn trace.Wrap(err,\n\t\t\t\t\t\"Invalid tunnel address '%s' for cluster '%s'. Expect host:port format\",\n\t\t\t\t\tta, clusterName)\n\t\t\t}\n\t\t\ttunnelAddresses = append(tunnelAddresses, addr.FullAddress())\n\t\t}\n\t\tif len(tunnelAddresses) > 0 {\n\t\t\tconf.ReverseTunnels = append(conf.ReverseTunnels, services.NewReverseTunnel(clusterName, tunnelAddresses))\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function search(req, res, next) {\n  var queryParams = req.body;\n\n  logger.debug(\"Middleware Submission Search \", {params: queryParams});\n\n  forms.submissionSearch(req.connectionOptions, queryParams, _getSubmissionsResultHandler(req, next));\n}", "label": 3}
{"code": "func PgEnums(db XODB, schema string) ([]*Enum, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`t.typname ` + // ::varchar AS enum_name\n\t\t`FROM pg_type t ` +\n\t\t`JOIN ONLY pg_namespace n ON n.oid = t.typnamespace ` +\n\t\t`JOIN ONLY pg_enum e ON t.oid = e.enumtypid ` +\n\t\t`WHERE n.nspname = $1`\n\n\t// run query\n\tXOLog(sqlstr, schema)\n\tq, err := db.Query(sqlstr, schema)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer q.Close()\n\n\t// load results\n\tres := []*Enum{}\n\tfor q.Next() {\n\t\te := Enum{}\n\n\t\t// scan\n\t\terr = q.Scan(&e.EnumName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres = append(res, &e)\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "def localized_locales(collection = Decidim.available_locales)\n      klass = Class.new do\n        def initialize(locale)\n          @locale = locale\n        end\n\n        def id\n          @locale.to_s\n        end\n\n        def name\n          I18n.with_locale(@locale) { I18n.t(\"name\", scope: \"locale\") }\n        end\n      end\n\n      collection.map { |locale| klass.new(locale) }\n    end", "label": 4}
{"code": "public function whitelist_package( $url, $group, $slug, $version, $ttl = null ) {\n\t\t$ext = pathinfo( Utils\\parse_url( $url, PHP_URL_PATH ), PATHINFO_EXTENSION );\n\t\t$key = \"$group/$slug-$version.$ext\";\n\t\t$this->whitelist_url( $url, $key, $ttl );\n\t\twp_update_plugins();\n\t}", "label": 2}
{"code": "def week_schedule(index, on_time=None, off_time=None, off_days=None):\n    \"\"\" Return boolean time series following given week schedule.\n\n    Parameters\n    ----------\n    index : pandas.DatetimeIndex\n        Datetime index\n    on_time : str or datetime.time\n        Daily opening time. Default: '09:00'\n    off_time : str or datetime.time\n        Daily closing time. Default: '17:00'\n    off_days : list of str\n        List of weekdays. Default: ['Sunday', 'Monday']\n\n    Returns\n    -------\n    pandas.Series of bool\n        True when on, False otherwise for given datetime index\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> from opengrid.library.utils import week_schedule\n    >>> index = pd.date_range('20170701', '20170710', freq='H')\n    >>> week_schedule(index)\n    \"\"\"\n    if on_time is None:\n        on_time = '9:00'\n    if off_time is None:\n        off_time = '17:00'\n    if off_days is None:\n        off_days = ['Sunday', 'Monday']\n    if not isinstance(on_time, datetime.time):\n        on_time = pd.to_datetime(on_time, format='%H:%M').time()\n    if not isinstance(off_time, datetime.time):\n        off_time = pd.to_datetime(off_time, format='%H:%M').time()\n    times = (index.time >= on_time) & (index.time < off_time) & (~index.weekday_name.isin(off_days))\n    return pd.Series(times, index=index)", "label": 1}
{"code": "public static crvserver_filterpolicy_binding[] get(nitro_service service, String name) throws Exception{\n\t\tcrvserver_filterpolicy_binding obj = new crvserver_filterpolicy_binding();\n\t\tobj.set_name(name);\n\t\tcrvserver_filterpolicy_binding response[] = (crvserver_filterpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def parse_catalytic(insertion, gff):\n    \"\"\"\n    parse catalytic RNAs to gff format\n    \"\"\"\n    offset = insertion['offset']\n    GeneStrand = insertion['strand']\n    if type(insertion['intron']) is not str:\n        return gff\n    for intron in parse_fasta(insertion['intron'].split('|')):\n        ID, annot, strand, pos = intron[0].split('>')[1].split()\n        Start, End = [int(i) for i in pos.split('-')]\n        if strand != GeneStrand:\n            if strand == '+':\n                strand = '-'\n            else:\n                strand = '+'\n            Start, End = End - 2, Start - 2\n        Start, End = abs(Start + offset) - 1, abs(End + offset) - 1\n        gff['#seqname'].append(insertion['ID'])\n        gff['source'].append('Rfam')\n        gff['feature'].append('Catalytic RNA')\n        gff['start'].append(Start)\n        gff['end'].append(End)\n        gff['score'].append('.')\n        gff['strand'].append(strand)\n        gff['frame'].append('.')\n        gff['attribute'].append('ID=%s; Name=%s' % (ID, annot))\n    return gff", "label": 1}
{"code": "func (t *SimpleStyledText) LookupStyle(r rune) tcell.Style {\n\treturn t.styles[r]\n}", "label": 5}
{"code": "def pull_request_url(env)\n      url = env[\"CI_PULL_REQUEST\"]\n\n      if url.nil? && !env[\"CIRCLE_PROJECT_USERNAME\"].nil? && !env[\"CIRCLE_PROJECT_REPONAME\"].nil?\n        repo_slug = env[\"CIRCLE_PROJECT_USERNAME\"] + \"/\" + env[\"CIRCLE_PROJECT_REPONAME\"]\n        if !env[\"CIRCLE_PR_NUMBER\"].nil?\n          host = env[\"DANGER_GITHUB_HOST\"] || \"github.com\"\n          url = \"https://\" + host + \"/\" + repo_slug + \"/pull/\" + env[\"CIRCLE_PR_NUMBER\"]\n        else\n          token = env[\"DANGER_CIRCLE_CI_API_TOKEN\"]\n          url = fetch_pull_request_url(repo_slug, env[\"CIRCLE_BUILD_NUM\"], token)\n        end\n      end\n      url\n    end", "label": 4}
{"code": "public static authenticationldappolicy_authenticationvserver_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauthenticationldappolicy_authenticationvserver_binding obj = new authenticationldappolicy_authenticationvserver_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationldappolicy_authenticationvserver_binding response[] = (authenticationldappolicy_authenticationvserver_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def leaveoneout(self):\n        \"\"\"Train & Test using leave one out\"\"\"\n        traintestfile = self.fileprefix + '.train'\n        options = \"-F \" + self.format + \" \" +  self.timbloptions + \" -t leave_one_out\"\n        if sys.version < '3':\n            self.api = timblapi.TimblAPI(b(options), b\"\")\n        else:\n            self.api = timblapi.TimblAPI(options, \"\")\n        if self.debug:\n            print(\"Enabling debug for timblapi\",file=stderr)\n            self.api.enableDebug()\n        print(\"Calling Timbl API : \" + options,file=stderr)\n        if sys.version < '3':\n            self.api.learn(b(traintestfile))\n            self.api.test(b(traintestfile), b(self.fileprefix + '.out'),b'')\n        else:\n            self.api.learn(u(traintestfile))\n            self.api.test(u(traintestfile), u(self.fileprefix + '.out'),'')\n        return self.api.getAccuracy()", "label": 1}
{"code": "func (c *Client) UploadFile(ctx context.Context, file string, u *url.URL, param *Upload) error {\n\tif param == nil {\n\t\tp := DefaultUpload // Copy since we set ContentLength\n\t\tparam = &p\n\t}\n\n\ts, err := os.Stat(file)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf, err := os.Open(filepath.Clean(file))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tparam.ContentLength = s.Size()\n\n\treturn c.Upload(ctx, f, u, param)\n}", "label": 5}
{"code": "function makeArray( obj ) {\n  var ary = [];\n  if ( isArray( obj ) ) {\n    // use object if already an array\n    ary = obj;\n  } else if ( typeof obj.length === 'number' ) {\n    // convert nodeList to array\n    for ( var i=0, len = obj.length; i < len; i++ ) {\n      ary.push( obj[i] );\n    }\n  } else {\n    // array of single index\n    ary.push( obj );\n  }\n  return ary;\n}", "label": 3}
{"code": "function checkAsyncFunctionReturnType(node) {\n            if (languageVersion >= 2 /* ES6 */) {\n                var returnType = getTypeFromTypeNode(node.type);\n                return checkCorrectPromiseType(returnType, node.type);\n            }\n            var globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType();\n            if (globalPromiseConstructorLikeType === emptyObjectType) {\n                // If we couldn't resolve the global PromiseConstructorLike type we cannot verify\n                // compatibility with __awaiter.\n                return unknownType;\n            }\n            // As part of our emit for an async function, we will need to emit the entity name of\n            // the return type annotation as an expression. To meet the necessary runtime semantics\n            // for __awaiter, we must also check that the type of the declaration (e.g. the static\n            // side or \"constructor\" of the promise type) is compatible `PromiseConstructorLike`.\n            //\n            // An example might be (from lib.es6.d.ts):\n            //\n            //  interface Promise<T> { ... }\n            //  interface PromiseConstructor {\n            //      new <T>(...): Promise<T>;\n            //  }\n            //  declare var Promise: PromiseConstructor;\n            //\n            // When an async function declares a return type annotation of `Promise<T>`, we\n            // need to get the type of the `Promise` variable declaration above, which would\n            // be `PromiseConstructor`.\n            //\n            // The same case applies to a class:\n            //\n            //  declare class Promise<T> {\n            //      constructor(...);\n            //      then<U>(...): Promise<U>;\n            //  }\n            //\n            // When we get the type of the `Promise` symbol here, we get the type of the static\n            // side of the `Promise` class, which would be `{ new <T>(...): Promise<T> }`.\n            var promiseType = getTypeFromTypeNode(node.type);\n            if (promiseType === unknownType && compilerOptions.isolatedModules) {\n                // If we are compiling with isolatedModules, we may not be able to resolve the\n                // type as a value. As such, we will just return unknownType;\n                return unknownType;\n            }\n            var promiseConstructor = getNodeLinks(node.type).resolvedSymbol;\n            if (!promiseConstructor || !symbolIsValue(promiseConstructor)) {\n                var typeName = promiseConstructor\n                    ? symbolToString(promiseConstructor)\n                    : typeToString(promiseType);\n                error(node, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type, typeName);\n                return unknownType;\n            }\n            // If the Promise constructor, resolved locally, is an alias symbol we should mark it as referenced.\n            checkReturnTypeAnnotationAsExpression(node);\n            // Validate the promise constructor type.\n            var promiseConstructorType = getTypeOfSymbol(promiseConstructor);\n            if (!checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, node, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type)) {\n                return unknownType;\n            }\n            // Verify there is no local declaration that could collide with the promise constructor.\n            var promiseName = ts.getEntityNameFromTypeNode(node.type);\n            var promiseNameOrNamespaceRoot = getFirstIdentifier(promiseName);\n            var rootSymbol = getSymbol(node.locals, promiseNameOrNamespaceRoot.text, 107455 /* Value */);\n            if (rootSymbol) {\n                error(rootSymbol.valueDeclaration, ts.Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, promiseNameOrNamespaceRoot.text, getFullyQualifiedName(promiseConstructor));\n                return unknownType;\n            }\n            // Get and return the awaited type of the return type.\n            return checkAwaitedType(promiseType, node, ts.Diagnostics.An_async_function_or_method_must_have_a_valid_awaitable_return_type);\n        }", "label": 3}
{"code": "def load(name)\n      name = name.to_sym\n      raise \"Could not find SimpleCov Profile called '#{name}'\" unless key?(name)\n      SimpleCov.configure(&self[name])\n    end", "label": 4}
{"code": "def producer(\n      compression_codec: nil,\n      compression_threshold: 1,\n      ack_timeout: 5,\n      required_acks: :all,\n      max_retries: 2,\n      retry_backoff: 1,\n      max_buffer_size: 1000,\n      max_buffer_bytesize: 10_000_000,\n      idempotent: false,\n      transactional: false,\n      transactional_id: nil,\n      transactional_timeout: 60\n    )\n      cluster = initialize_cluster\n      compressor = Compressor.new(\n        codec_name: compression_codec,\n        threshold: compression_threshold,\n        instrumenter: @instrumenter,\n      )\n\n      transaction_manager = TransactionManager.new(\n        cluster: cluster,\n        logger: @logger,\n        idempotent: idempotent,\n        transactional: transactional,\n        transactional_id: transactional_id,\n        transactional_timeout: transactional_timeout,\n      )\n\n      Producer.new(\n        cluster: cluster,\n        transaction_manager: transaction_manager,\n        logger: @logger,\n        instrumenter: @instrumenter,\n        compressor: compressor,\n        ack_timeout: ack_timeout,\n        required_acks: required_acks,\n        max_retries: max_retries,\n        retry_backoff: retry_backoff,\n        max_buffer_size: max_buffer_size,\n        max_buffer_bytesize: max_buffer_bytesize,\n      )\n    end", "label": 4}
{"code": "func fileExist(filename string) (ok bool) {\n\tinfo, err := os.Stat(filename)\n\tif err == nil {\n\t\tif ^os.ModePerm&info.Mode() == 0 {\n\t\t\tok = true\n\t\t}\n\t}\n\treturn ok\n}", "label": 5}
{"code": "public static ComplexNumber Function2D(int x, int y, double wavelength, double orientation, double phaseOffset, double gaussVariance, double aspectRatio) {\n\n        double X = x * Math.cos(orientation) + y * Math.sin(orientation);\n        double Y = -x * Math.sin(orientation) + y * Math.cos(orientation);\n\n        double envelope = Math.exp(-((X * X + aspectRatio * aspectRatio * Y * Y) / (2 * gaussVariance * gaussVariance)));\n        double real = Math.cos(2 * Math.PI * (X / wavelength) + phaseOffset);\n        double imaginary = Math.sin(2 * Math.PI * (X / wavelength) + phaseOffset);\n\n        return new ComplexNumber(envelope * real, envelope * imaginary);\n    }", "label": 0}
{"code": "final public void addOffset(Integer start, Integer end) {\n    if (tokenOffset == null) {\n      setOffset(start, end);\n    } else if ((start == null) || (end == null)) {\n      // do nothing\n    } else if (start > end) {\n      throw new IllegalArgumentException(\"Start offset after end offset\");\n    } else {\n      tokenOffset.add(start, end);\n    }\n  }", "label": 0}
{"code": "func (f *AutostartFlag) VirtualMachines(args []string) ([]*object.VirtualMachine, error) {\n\tctx := context.TODO()\n\tif len(args) == 0 {\n\t\treturn nil, errors.New(\"no argument\")\n\t}\n\n\tfinder, err := f.Finder()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar out []*object.VirtualMachine\n\tfor _, arg := range args {\n\t\tvms, err := finder.VirtualMachineList(ctx, arg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tout = append(out, vms...)\n\t}\n\n\treturn out, nil\n}", "label": 5}
{"code": "public function setListAssetsResults($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\SecurityCenter\\V1\\ListAssetsResponse\\ListAssetsResult::class);\n        $this->list_assets_results = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (f *PropertyFilter) matches(ctx *Context, ref types.ManagedObjectReference, change *types.PropertyChange) bool {\n\tvar kind reflect.Type\n\n\tfor _, p := range f.Spec.PropSet {\n\t\tif p.Type != ref.Type {\n\t\t\tif kind == nil {\n\t\t\t\tkind = getManagedObject(ctx.Map.Get(ref)).Type()\n\t\t\t}\n\t\t\t// e.g. ManagedEntity, ComputeResource\n\t\t\tfield, ok := kind.FieldByName(p.Type)\n\t\t\tif !(ok && field.Anonymous) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif isTrue(p.All) {\n\t\t\treturn true\n\t\t}\n\n\t\tfor _, name := range p.PathSet {\n\t\t\tif name == change.Name {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\t// strings.HasPrefix(\"runtime.powerState\", \"runtime\") == parent field matches\n\t\t\tif strings.HasPrefix(change.Name, name) {\n\t\t\t\tif obj := ctx.Map.Get(ref); obj != nil { // object may have since been deleted\n\t\t\t\t\tchange.Name = name\n\t\t\t\t\tchange.Val, _ = fieldValue(reflect.ValueOf(obj), name)\n\t\t\t\t}\n\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}", "label": 5}
{"code": "public function isEntityScheduled($entity)\n    {\n        $oid = spl_object_id($entity);\n\n        return isset($this->entityInsertions[$oid])\n            || isset($this->entityUpdates[$oid])\n            || isset($this->entityDeletions[$oid]);\n    }", "label": 2}
{"code": "def surfplot(self, z, titletext):\n    \"\"\"\n    Plot if you want to - for troubleshooting - 1 figure\n    \"\"\"\n    if self.latlon:\n      plt.imshow(z, extent=(0, self.dx*z.shape[0], self.dy*z.shape[1], 0)) #,interpolation='nearest'\n      plt.xlabel('longitude [deg E]', fontsize=12, fontweight='bold')\n      plt.ylabel('latitude [deg N]', fontsize=12, fontweight='bold')\n    else:\n      plt.imshow(z, extent=(0, self.dx/1000.*z.shape[0], self.dy/1000.*z.shape[1], 0)) #,interpolation='nearest'\n      plt.xlabel('x [km]', fontsize=12, fontweight='bold')\n      plt.ylabel('y [km]', fontsize=12, fontweight='bold')\n    plt.colorbar()\n\n    plt.title(titletext,fontsize=16)", "label": 1}
{"code": "public function setImageLocation($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\ImageLocation::class);\n        $this->writeOneof(3, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public function to($url)\n    {\n        $params = ['url' => (string) $url];\n        $this->executor->execute(DriverCommand::GET, $params);\n\n        return $this;\n    }", "label": 2}
{"code": "public static final void setPosition(UIObject o, Rect pos) {\n        Style style = o.getElement().getStyle();\n        style.setPropertyPx(\"left\", pos.x);\n        style.setPropertyPx(\"top\", pos.y);\n    }", "label": 0}
{"code": "def update(*args)\n      arguments(args, required: [:user, :repo, :id]) do\n        assert_required REQUIRED_COMMENT_OPTIONS\n      end\n\n      patch_request(\"/repos/#{arguments.user}/#{arguments.repo}/comments/#{arguments.id}\", arguments.params)\n    end", "label": 4}
{"code": "def _bulk_op(self, record_id_iterator, op_type, index=None, doc_type=None):\n        \"\"\"Index record in Elasticsearch asynchronously.\n\n        :param record_id_iterator: Iterator that yields record UUIDs.\n        :param op_type: Indexing operation (one of ``index``, ``create``,\n            ``delete`` or ``update``).\n        :param index: The Elasticsearch index. (Default: ``None``)\n        :param doc_type: The Elasticsearch doc_type. (Default: ``None``)\n        \"\"\"\n        with self.create_producer() as producer:\n            for rec in record_id_iterator:\n                producer.publish(dict(\n                    id=str(rec),\n                    op=op_type,\n                    index=index,\n                    doc_type=doc_type\n                ))", "label": 1}
{"code": "func (fs *FlagSet) Out() io.Writer {\n\tif fs.output == nil {\n\t\treturn os.Stderr\n\t}\n\treturn fs.output\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, responderaction resource) throws Exception {\n\t\tresponderaction addresource = new responderaction();\n\t\taddresource.name = resource.name;\n\t\taddresource.type = resource.type;\n\t\taddresource.target = resource.target;\n\t\taddresource.htmlpage = resource.htmlpage;\n\t\taddresource.bypasssafetycheck = resource.bypasssafetycheck;\n\t\taddresource.comment = resource.comment;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "func (s *APIServer) getSignupTokenData(auth ClientI, w http.ResponseWriter, r *http.Request, p httprouter.Params, version string) (interface{}, error) {\n\ttoken := p.ByName(\"token\")\n\n\tuser, otpQRCode, err := auth.GetSignupTokenData(token)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn &getSignupTokenDataResponse{\n\t\tUser:  user,\n\t\tQRImg: otpQRCode,\n\t}, nil\n}", "label": 5}
{"code": "public function has( $key, $ttl = null ) {\n\t\tif ( ! $this->enabled ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$filename = $this->filename( $key );\n\n\t\tif ( ! file_exists( $filename ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// use ttl param or global ttl\n\t\tif ( null === $ttl ) {\n\t\t\t$ttl = $this->ttl;\n\t\t} elseif ( $this->ttl > 0 ) {\n\t\t\t$ttl = min( (int) $ttl, $this->ttl );\n\t\t} else {\n\t\t\t$ttl = (int) $ttl;\n\t\t}\n\n\t\t//\n\t\tif ( $ttl > 0 && ( filemtime( $filename ) + $ttl ) < time() ) {\n\t\t\tif ( $this->ttl > 0 && $ttl >= $this->ttl ) {\n\t\t\t\tunlink( $filename );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $filename;\n\t}", "label": 2}
{"code": "def strip_units_from_lines(lines):\n    \"\"\"\n    Removes all units from the ends of the lines.\n    \"\"\"\n    for line in lines:\n        for unit in ALL_UNITS:\n            if line.endswith(\" %s\" % unit):\n                line = line[:-1-len(unit)]\n        yield line", "label": 1}
{"code": "function getCMAP4($unicode_cmap_offset, &$glyphToChar, &$charToGlyph)\n\t{\n\t\t$this->maxUniChar = 0;\n\t\t$this->seek($unicode_cmap_offset + 2);\n\t\t$length = $this->read_ushort();\n\t\t$limit = $unicode_cmap_offset + $length;\n\t\t$this->skip(2);\n\n\t\t$segCount = $this->read_ushort() / 2;\n\t\t$this->skip(6);\n\t\t$endCount = [];\n\t\tfor ($i = 0; $i < $segCount; $i++) {\n\t\t\t$endCount[] = $this->read_ushort();\n\t\t}\n\t\t$this->skip(2);\n\t\t$startCount = [];\n\t\tfor ($i = 0; $i < $segCount; $i++) {\n\t\t\t$startCount[] = $this->read_ushort();\n\t\t}\n\t\t$idDelta = [];\n\t\tfor ($i = 0; $i < $segCount; $i++) {\n\t\t\t$idDelta[] = $this->read_short();\n\t\t}  // ???? was unsigned short\n\t\t$idRangeOffset_start = $this->_pos;\n\t\t$idRangeOffset = [];\n\t\tfor ($i = 0; $i < $segCount; $i++) {\n\t\t\t$idRangeOffset[] = $this->read_ushort();\n\t\t}\n\n\t\tfor ($n = 0; $n < $segCount; $n++) {\n\t\t\t$endpoint = ($endCount[$n] + 1);\n\t\t\tfor ($unichar = $startCount[$n]; $unichar < $endpoint; $unichar++) {\n\t\t\t\tif ($idRangeOffset[$n] == 0) {\n\t\t\t\t\t$glyph = ($unichar + $idDelta[$n]) & 0xFFFF;\n\t\t\t\t} else {\n\t\t\t\t\t$offset = ($unichar - $startCount[$n]) * 2 + $idRangeOffset[$n];\n\t\t\t\t\t$offset = $idRangeOffset_start + 2 * $n + $offset;\n\t\t\t\t\tif ($offset >= $limit) {\n\t\t\t\t\t\t$glyph = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$glyph = $this->get_ushort($offset);\n\t\t\t\t\t\tif ($glyph != 0) {\n\t\t\t\t\t\t\t$glyph = ($glyph + $idDelta[$n]) & 0xFFFF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$charToGlyph[$unichar] = $glyph;\n\t\t\t\tif ($unichar < 196608) {\n\t\t\t\t\t$this->maxUniChar = max($unichar, $this->maxUniChar);\n\t\t\t\t}\n\t\t\t\t$glyphToChar[$glyph][] = $unichar;\n\t\t\t}\n\t\t}\n\t}", "label": 2}
{"code": "func IPNetLast(in *net.IPNet) (last net.IP) {\n\tn := len(in.IP)\n\tif n != len(in.Mask) {\n\t\tpanic(\"wat\")\n\t}\n\tlast = make(net.IP, n)\n\tfor i := 0; i < n; i++ {\n\t\tlast[i] = in.IP[i] | ^in.Mask[i]\n\t}\n\treturn\n}", "label": 5}
{"code": "public function update(EntityInterface $entity, array $options = [])\n    {\n        $res = $this->updateBatch([$entity], $options);\n        return $this->parseSingleMutationResult($res);\n    }", "label": 2}
{"code": "public static clusternodegroup get(nitro_service service, String name) throws Exception{\n\t\tclusternodegroup obj = new clusternodegroup();\n\t\tobj.set_name(name);\n\t\tclusternodegroup response = (clusternodegroup) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def select_options(access = :deposit)\n      @service.search_results(access).map do |admin_set|\n        [admin_set.to_s, admin_set.id, data_attributes(admin_set)]\n      end\n    end", "label": 4}
{"code": "public static aaauser_authorizationpolicy_binding[] get(nitro_service service, String username) throws Exception{\n\t\taaauser_authorizationpolicy_binding obj = new aaauser_authorizationpolicy_binding();\n\t\tobj.set_username(username);\n\t\taaauser_authorizationpolicy_binding response[] = (aaauser_authorizationpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function Conrec(drawContour) {\n    if (!drawContour) {\n      var c = this;\n      c.contours = {};\n      /**\n       * drawContour - interface for implementing the user supplied method to\n       * render the countours.\n       *\n       * Draws a line between the start and end coordinates.\n       *\n       * @param startX    - start coordinate for X\n       * @param startY    - start coordinate for Y\n       * @param endX      - end coordinate for X\n       * @param endY      - end coordinate for Y\n       * @param contourLevel - Contour level for line.\n       */\n      this.drawContour = function(startX, startY, endX, endY, contourLevel, k) {\n        var cb = c.contours[k];\n        if (!cb) {\n          cb = c.contours[k] = new ContourBuilder(contourLevel);\n        }\n        cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});\n      }\n      this.contourList = function() {\n        var l = [];\n        var a = c.contours;\n        for (var k in a) {\n          var s = a[k].s;\n          var level = a[k].level;\n          while (s) {\n            var h = s.head;\n            var l2 = [];\n            l2.level = level;\n            l2.k = k;\n            while (h && h.p) {\n              l2.push(h.p);\n              h = h.next;\n            }\n            l.push(l2);\n            s = s.next;\n          }\n        }\n        l.sort(function(a, b) { return a.k - b.k });\n        return l;\n      }\n    } else {\n      this.drawContour = drawContour;\n    }\n    this.h  = new Array(5);\n    this.sh = new Array(5);\n    this.xh = new Array(5);\n    this.yh = new Array(5);\n  }", "label": 3}
{"code": "function getDefaults (value, path, model, resolveRef) {\n  const schema = findSchema(model, path, resolveRef)\n  const schemaDefault = _.clone(schema.default)\n\n  if (model.type === 'object') {\n    const subSchemaDefaults = {}\n    _.forIn(schema.properties, function (subSchema, propName) {\n      const defaults = getDefaults(\n        value && value[propName],\n        null,\n        subSchema,\n        resolveRef\n      )\n      if (defaults !== undefined) {\n        subSchemaDefaults[propName] = defaults\n      }\n    })\n\n    if (Object.keys(subSchemaDefaults).length > 0) {\n      return _.defaults({}, schemaDefault, subSchemaDefaults)\n    }\n    return schemaDefault\n  } else if (value !== undefined) {\n    return value\n  }\n  return schemaDefault\n}", "label": 3}
{"code": "public function error(string $message)\n    {\n        $this->relay->send(\n            $message,\n            Relay::PAYLOAD_CONTROL | Relay::PAYLOAD_RAW | Relay::PAYLOAD_ERROR\n        );\n    }", "label": 2}
{"code": "function buildSingleFilterQueryObject(paginationFilter) {\n  return function(submissionQueryField) {\n    var fieldQuery = {\n    };\n\n    //formId and _id fields are ObjectIds. They must be valid in order to search for them.\n    if (submissionQueryField === 'formId' || submissionQueryField === '_id') {\n      if (mongoose.Types.ObjectId.isValid(paginationFilter)) {\n        //Cannot use $regex when searching for ObjectIDs\n        fieldQuery[submissionQueryField] = new mongoose.Types.ObjectId(paginationFilter);\n      } else {\n        //not a valid objectId, don't want to search for it.\n        return null;\n      }\n    } else {\n      fieldQuery[submissionQueryField] = {$regex: paginationFilter, $options: 'i'};\n    }\n\n    return fieldQuery;\n  };\n}", "label": 3}
{"code": "def lint(plugin)\n      hooks = before_hooks(plugin) + around_hooks(plugin) + after_hooks(plugin)\n\n      hooks.each do |hook|\n        if hook.to_s.end_with?(\"perform\")\n          raise LintError, \"#{plugin}.#{hook} is not namespaced\"\n        end\n      end\n\n      failure_hooks(plugin).each do |hook|\n        if hook.to_s.end_with?(\"failure\")\n          raise LintError, \"#{plugin}.#{hook} is not namespaced\"\n        end\n      end\n    end", "label": 4}
{"code": "func (c *Client) ChangePassword(req services.ChangePasswordReq) error {\n\t_, err := c.PutJSON(c.Endpoint(\"users\", req.User, \"web\", \"password\"), req)\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "def freeze\n      self.normalized_scheme\n      self.normalized_user\n      self.normalized_password\n      self.normalized_userinfo\n      self.normalized_host\n      self.normalized_port\n      self.normalized_authority\n      self.normalized_site\n      self.normalized_path\n      self.normalized_query\n      self.normalized_fragment\n      self.hash\n      super\n    end", "label": 4}
{"code": "func (s *remoteSite) addConn(conn net.Conn, sconn ssh.Conn) (*remoteConn, error) {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tcn, err := s.localAccessPoint.GetClusterName()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\trconn := newRemoteConn(&connConfig{\n\t\tconn:        conn,\n\t\tsconn:       sconn,\n\t\taccessPoint: s.localAccessPoint,\n\t\ttunnelID:    cn.GetClusterName(),\n\t\ttunnelType:  string(services.ProxyTunnel),\n\t\tproxyName:   s.connInfo.GetProxyName(),\n\t\tclusterName: s.domainName,\n\t})\n\n\ts.connections = append(s.connections, rconn)\n\ts.lastUsed = 0\n\treturn rconn, nil\n}", "label": 5}
{"code": "def update_ip_info(self, since_days=10, save=False, force=False):\n        \"\"\"\n        Update the IP info.\n\n        Args:\n            since_days (int): if checked less than this number of days ago,\n                don't check again (default to 10 days).\n            save (bool): whether to save anyway or not.\n            force (bool): whether to update ip_info to last checked one.\n\n        Returns:\n            bool: check was run. IPInfo might not have been updated.\n        \"\"\"\n        # If ip already checked\n        try:\n            last_check = IPInfoCheck.objects.get(\n                ip_address=self.client_ip_address)\n\n            # If checked less than since_days ago, don't check again\n            since_last = datetime.date.today() - last_check.date\n            if since_last <= datetime.timedelta(days=since_days):\n                if not self.ip_info or (\n                        self.ip_info != last_check.ip_info and force):\n                    self.ip_info = last_check.ip_info\n                    self.save()\n                    return True\n                elif save:\n                    self.save()\n                return False\n\n            # Get or create ip_info object\n            ip_info, created = IPInfo.get_or_create_from_ip(\n                self.client_ip_address)\n\n            # Update check time\n            last_check.date = datetime.date.today()\n            last_check.save()\n\n            # Maybe data changed\n            if created:\n                last_check.ip_info = ip_info\n                self.ip_info = ip_info\n                self.save()\n                return True\n            elif save:\n                self.save()\n\n            return False\n\n        except IPInfoCheck.DoesNotExist:\n            # Else if ip never checked, check it and set ip_info\n            self.ip_info = IPInfoCheck.check_ip(self.client_ip_address)\n            self.save()\n\n            return True", "label": 1}
{"code": "def quote_phrase( str )\n      if str.respond_to?(:force_encoding)\n        original_encoding = str.encoding\n        ascii_str = str.to_s.dup.force_encoding('ASCII-8BIT')\n        if Constants::PHRASE_UNSAFE === ascii_str\n          dquote(ascii_str).force_encoding(original_encoding)\n        else\n          str\n        end\n      else\n        Constants::PHRASE_UNSAFE === str ? dquote(str) : str\n      end\n    end", "label": 4}
{"code": "public static csvserver_spilloverpolicy_binding[] get(nitro_service service, String name) throws Exception{\n\t\tcsvserver_spilloverpolicy_binding obj = new csvserver_spilloverpolicy_binding();\n\t\tobj.set_name(name);\n\t\tcsvserver_spilloverpolicy_binding response[] = (csvserver_spilloverpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static base_response clear(nitro_service client) throws Exception {\n\t\tnssimpleacl clearresource = new nssimpleacl();\n\t\treturn clearresource.perform_operation(client,\"clear\");\n\t}", "label": 0}
{"code": "function(data) {\n        var SAMI_BODY = '',\n            captions = data;\n\n        SAMI_BODY += SAMI.header.join('\\n') + '\\n';\n        captions.forEach(function(caption) {\n            if (caption.text === '') {\n                caption.text = '&nbsp;';\n            }\n            SAMI_BODY += SAMI.lineTemplate.replace('{startTime}', Math.floor(caption.startTimeMicro / 1000))\n                .replace('{text}', module.exports.renderMacros(caption.text)) + '\\n';\n        });\n\n        return SAMI_BODY + SAMI.footer.join('\\n') + '\\n';\n    }", "label": 3}
{"code": "def content_type\n      return nil unless response.headers\n      ((response.headers.values_at('content-type', 'Content-Type').compact.first || '').split(';').first || '').strip\n    end", "label": 4}
{"code": "func (s *PresenceService) UpsertTrustedCluster(trustedCluster services.TrustedCluster) (services.TrustedCluster, error) {\n\tif err := trustedCluster.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvalue, err := services.GetTrustedClusterMarshaler().Marshal(trustedCluster)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\t_, err = s.Put(context.TODO(), backend.Item{\n\t\tKey:     backend.Key(trustedClustersPrefix, trustedCluster.GetName()),\n\t\tValue:   value,\n\t\tExpires: trustedCluster.Expiry(),\n\t\tID:      trustedCluster.GetResourceID(),\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn trustedCluster, nil\n}", "label": 5}
{"code": "def send_packet(opcode, packet)\n      data = {\n        op: opcode,\n        d: packet\n      }\n\n      send(data.to_json)\n    end", "label": 4}
{"code": "protected function createParameters($parameters)\n    {\n        if (is_string($parameters)) {\n            $parameters = Parameters::parse($parameters);\n        } else {\n            $parameters = $parameters ?: array();\n        }\n\n        if ($this->defaults) {\n            $parameters += $this->defaults;\n        }\n\n        return new Parameters($parameters);\n    }", "label": 2}
{"code": "public static long randomLongBetween(long min, long max) {\n    Random rand = new Random();\n    return min + (long) (rand.nextDouble() * (max - min));\n  }", "label": 0}
{"code": "def _assert_link_secret(self, action: str):\n        \"\"\"\n        Raise AbsentLinkSecret if link secret is not set.\n\n        :param action: action requiring link secret\n        \"\"\"\n\n        if self._link_secret is None:\n            LOGGER.debug('HolderProver._assert_link_secret: action %s requires link secret but it is not set', action)\n            raise AbsentLinkSecret('Action {} requires link secret but it is not set'.format(action))", "label": 1}
{"code": "def validate_version(version)\n      return if SemanticPuppet::Version.valid?(version)\n\n      err = _(\"version string cannot be parsed as a valid Semantic Version\")\n      raise ArgumentError, _(\"Invalid 'version' field in metadata.json: %{err}\") % { err: err }\n    end", "label": 4}
{"code": "public static base_response add(nitro_service client, cmppolicylabel resource) throws Exception {\n\t\tcmppolicylabel addresource = new cmppolicylabel();\n\t\taddresource.labelname = resource.labelname;\n\t\taddresource.type = resource.type;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public static SPIProviderResolver getInstance(ClassLoader cl)\n   {\n      SPIProviderResolver resolver = (SPIProviderResolver)ServiceLoader.loadService(SPIProviderResolver.class.getName(), DEFAULT_SPI_PROVIDER_RESOLVER, cl);\n      return resolver;\n   }", "label": 0}
{"code": "def enable_paging\n      return unless $stdout.tty?\n      return unless Process.respond_to? :fork\n      read, write = IO.pipe\n\n      # Kernel.fork is not supported on all platforms and configurations.\n      # As of Ruby 1.9, `Process.respond_to? :fork` should return false on\n      # configurations that don't support it, but versions before 1.9 don't\n      # seem to do this reliably and instead raise a NotImplementedError\n      # (which is rescued below).\n\n      if Kernel.fork\n        $stdin.reopen read\n        write.close\n        read.close\n        Kernel.select [$stdin]\n        ENV['LESS'] = 'FSRX' unless ENV.key? 'LESS'\n        pager = ENV['PAGER'] || 'less'\n        exec pager rescue exec '/bin/sh', '-c', pager\n      else\n        # subprocess\n        $stdout.reopen write\n        $stderr.reopen write if $stderr.tty?\n        write.close\n        read.close\n      end\n    rescue NotImplementedError\n    ensure\n      write.close if write && !write.closed?\n      read.close if read && !read.closed?\n    end", "label": 4}
{"code": "function validateField(field, cb) {\n        if (_.isArray(field.validation)) {\n            async.each(field.validation, performValidation(field), function(err) {\n                cb(err);\n            });\n        } else {\n            cb();\n        }\n    }", "label": 3}
{"code": "function basicIdentityIsSet(){\n        return _.has(user, 'identities') && _.has(user.identities, 'basic') && !_.isEmpty(user.identities.basic);\n    }", "label": 3}
{"code": "def run_experiment(experiment, roleouts, episodes, in_cloud=False,\n                   dynProfile=None):\n    \"\"\" Runs the given experiment and returns the results.\n    \"\"\"\n    def run():\n        if dynProfile is None:\n            maxsteps = len(experiment.profile) # episode length\n        else:\n            maxsteps = dynProfile.shape[1]\n        na = len(experiment.agents)\n        ni = roleouts * episodes * maxsteps\n\n        all_action = zeros((na, 0))\n        all_reward = zeros((na, 0))\n        epsilon = zeros((na, ni)) # exploration rate\n\n        # Converts to action vector in percentage markup values.\n        vmarkup = vectorize(get_markup)\n\n        for roleout in range(roleouts):\n            if dynProfile is not None:\n                # Apply new load profile before each roleout (week).\n                i = roleout * episodes # index of first profile value\n                experiment.profile = dynProfile[i:i + episodes, :]\n\n#            print \"PROFILE:\", experiment.profile, episodes\n\n            experiment.doEpisodes(episodes) # number of samples per learning step\n\n            nei = episodes * maxsteps # num interactions per role\n            epi_action = zeros((0, nei))\n            epi_reward = zeros((0, nei))\n\n            for i, (task, agent) in \\\n            enumerate(zip(experiment.tasks, experiment.agents)):\n                action = copy(agent.history[\"action\"])\n                reward = copy(agent.history[\"reward\"])\n\n                for j in range(nei):\n                    if isinstance(agent.learner, DirectSearchLearner):\n                        action[j, :] = task.denormalize(action[j, :])\n                        k = nei * roleout\n                        epsilon[i, k:k + nei] = agent.learner.explorer.sigma[0]\n                    elif isinstance(agent.learner, ValueBasedLearner):\n                        action[j, :] = vmarkup(action[j, :], task)\n                        k = nei * roleout\n                        epsilon[i, k:k + nei] = agent.learner.explorer.epsilon\n                    else:\n                        action = vmarkup(action, task)\n\n                # FIXME: Only stores action[0] for all interactions.\n                epi_action = c_[epi_action.T, action[:, 0].flatten()].T\n                epi_reward = c_[epi_reward.T, reward.flatten()].T\n\n                if hasattr(agent, \"module\"):\n                    print \"PARAMS:\", agent.module.params\n\n                agent.learn()\n                agent.reset()\n\n            all_action = c_[all_action, epi_action]\n            all_reward = c_[all_reward, epi_reward]\n\n        return all_action, all_reward, epsilon\n\n    if in_cloud:\n        import cloud\n        job_id = cloud.call(run, _high_cpu=False)\n        result = cloud.result(job_id)\n        all_action, all_reward, epsilon = result\n    else:\n        all_action, all_reward, epsilon = run()\n\n    return all_action, all_reward, epsilon", "label": 1}
{"code": "function normalizePaths(opts) {\n  for (var srcKey in opts.src) {\n    if (!path.isAbsolute(opts.src[srcKey].glob)) {\n      opts.src[srcKey].glob = path.resolve(opts.src[srcKey].glob);\n    }\n    if (!path.isAbsolute(opts.src[srcKey].basedir)) {\n      opts.src[srcKey].basedir = path.resolve(opts.src[srcKey].basedir);\n    }\n  }\n}", "label": 3}
{"code": "def find_location\n      locations = caller\n      i = 0\n      while locations[i]\n        return locations[i + 1] if locations[i] =~ /rake\\/dsl_definition.rb/\n        i += 1\n      end\n      nil\n    end", "label": 4}
{"code": "func completeRotation(clock clockwork.Clock, ca services.CertAuthority) error {\n\trotation := ca.GetRotation()\n\tsigningKeys := ca.GetSigningKeys()\n\tcheckingKeys := ca.GetCheckingKeys()\n\tkeyPairs := ca.GetTLSKeyPairs()\n\n\tsigningKeys = signingKeys[:1]\n\tcheckingKeys = checkingKeys[:1]\n\tkeyPairs = keyPairs[:1]\n\n\trotation.Started = time.Time{}\n\trotation.State = services.RotationStateStandby\n\trotation.Phase = services.RotationPhaseStandby\n\trotation.LastRotated = clock.Now()\n\trotation.Mode = \"\"\n\trotation.Schedule = services.RotationSchedule{}\n\n\tca.SetSigningKeys(signingKeys)\n\tca.SetCheckingKeys(checkingKeys)\n\tca.SetTLSKeyPairs(keyPairs)\n\tca.SetRotation(rotation)\n\treturn nil\n}", "label": 5}
{"code": "def controller_callback(which, type, axis, value, button)\n      # All controller events\n      @events[:controller].each do |id, e|\n        e.call(ControllerEvent.new(which, type, axis, value, button))\n      end\n\n      case type\n      # When controller axis motion, like analog sticks\n      when :axis\n        @events[:controller_axis].each do |id, e|\n          e.call(ControllerAxisEvent.new(which, axis, value))\n        end\n      # When controller button is pressed\n      when :button_down\n        @events[:controller_button_down].each do |id, e|\n          e.call(ControllerButtonEvent.new(which, button))\n        end\n      # When controller button is released\n      when :button_up\n        @events[:controller_button_up].each do |id, e|\n          e.call(ControllerButtonEvent.new(which, button))\n        end\n      end\n    end", "label": 4}
{"code": "func (i *Handle) Flush() error {\n\t_, err := i.doCmdWithoutAttr(ipvsCmdFlush)\n\treturn err\n}", "label": 5}
{"code": "private function getSize()\n    {\n        $size = $this->body->getSize();\n\n        return $size !== null ? $size : $this->size;\n    }", "label": 2}
{"code": "def formatted\n      list = element.addresses.map { |a| a.format }\n      Mail::AddressContainer.new(self, list)\n    end", "label": 4}
{"code": "function listSubscribers(req, res, next) {\n  var listSubscribersParams = {\n    _id: req.params.id\n  };\n\n  logger.debug(\"Middleware: listSubscribers: \", {params: listSubscribersParams});\n\n  forms.getNotifications(_.extend(req.connectionOptions, listSubscribersParams), formsResultHandlers(constants.resultTypes.forms, req, next));\n}", "label": 3}
{"code": "def generate_atomic_updates(mods, doc)\n      mods.unset(doc.atomic_unsets)\n      mods.pull(doc.atomic_pulls)\n      mods.set(doc.atomic_sets)\n      mods.set(doc.delayed_atomic_sets)\n      mods.push(doc.atomic_pushes)\n      mods.push(doc.atomic_array_pushes)\n      mods.add_to_set(doc.atomic_array_add_to_sets)\n      mods.pull_all(doc.atomic_array_pulls)\n    end", "label": 4}
{"code": "function _arrayCopy(dest, src) {\n    if (Array.isArray(src)) {\n        src.forEach(function (item) {\n            dest.push(item);\n        });\n    }\n}", "label": 3}
{"code": "def delete(filename, identifier):\n    \"\"\"\n    Delete an entry in a BibTeX file.\n\n    :param filename: The name of the BibTeX file to edit.\n    :param identifier: The id of the entry to delete, in the BibTeX file.\n    \"\"\"\n    # Get current bibtex\n    with open(filename, 'r') as fh:\n        bibtex = bibtexparser.load(fh)\n\n    # Delete the bibtex entry\n    # TODO: Not working\n    try:\n        del bibtex.entries_dict[identifier]\n    except KeyError:\n        pass\n\n    # Write the resulting BibTeX\n    write(filename, bibtex)", "label": 1}
{"code": "def rate_limited?(thing, rate_limit_time = nil, increment: 1)\n      key = resolve_key thing\n      limit_hash = @bucket[key]\n\n      # First case: limit_hash doesn't exist yet\n      unless limit_hash\n        @bucket[key] = {\n          last_time: Time.now,\n          set_time: Time.now,\n          count: increment\n        }\n\n        return false\n      end\n\n      # Define the time at which we're being rate limited once so it doesn't get inaccurate\n      rate_limit_time ||= Time.now\n\n      if @limit && (limit_hash[:count] + increment) > @limit\n        # Second case: Count is over the limit and the time has not run out yet\n        return (limit_hash[:set_time] + @time_span) - rate_limit_time if @time_span && rate_limit_time < (limit_hash[:set_time] + @time_span)\n\n        # Third case: Count is over the limit but the time has run out\n        # Don't return anything here because there may still be delay-based limiting\n        limit_hash[:set_time] = rate_limit_time\n        limit_hash[:count] = 0\n      end\n\n      if @delay && rate_limit_time < (limit_hash[:last_time] + @delay)\n        # Fourth case: we're being delayed\n        (limit_hash[:last_time] + @delay) - rate_limit_time\n      else\n        # Fifth case: no rate limiting at all! Increment the count, set the last_time, and return false\n        limit_hash[:last_time] = rate_limit_time\n        limit_hash[:count] += increment\n        false\n      end\n    end", "label": 4}
{"code": "def fetch_build(repo_slug, build_number, token)\n      url = \"project/#{repo_slug}/#{build_number}\"\n      params = { \"circle-token\" => token }\n      response = client.get url, params, accept: \"application/json\"\n      json = JSON.parse(response.body, symbolize_names: true)\n      json\n    end", "label": 4}
{"code": "func (c *githubAPIClient) get(url string) ([]byte, string, error) {\n\trequest, err := http.NewRequest(\"GET\", fmt.Sprintf(\"%v%v\", GithubAPIURL, url), nil)\n\tif err != nil {\n\t\treturn nil, \"\", trace.Wrap(err)\n\t}\n\trequest.Header.Set(\"Authorization\", fmt.Sprintf(\"token %v\", c.token))\n\tresponse, err := http.DefaultClient.Do(request)\n\tif err != nil {\n\t\treturn nil, \"\", trace.Wrap(err)\n\t}\n\tdefer response.Body.Close()\n\tbytes, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn nil, \"\", trace.Wrap(err)\n\t}\n\tif response.StatusCode != 200 {\n\t\treturn nil, \"\", trace.AccessDenied(\"bad response: %v %v\",\n\t\t\tresponse.StatusCode, string(bytes))\n\t}\n\n\t// Parse web links header to extract any pagination links. This is used to\n\t// return the next link which can be used in a loop to pull back all data.\n\twls := utils.ParseWebLinks(response)\n\n\treturn bytes, wls.NextPage, nil\n}", "label": 5}
{"code": "def DoxySourceScan(node, env, path):\n   \"\"\"\n   Doxygen Doxyfile source scanner.  This should scan the Doxygen file and add\n   any files used to generate docs to the list of source files.\n   \"\"\"\n   default_file_patterns = [\n      '*.c', '*.cc', '*.cxx', '*.cpp', '*.c++', '*.java', '*.ii', '*.ixx',\n      '*.ipp', '*.i++', '*.inl', '*.h', '*.hh ', '*.hxx', '*.hpp', '*.h++',\n      '*.idl', '*.odl', '*.cs', '*.php', '*.php3', '*.inc', '*.m', '*.mm',\n      '*.py',\n   ]\n\n   default_exclude_patterns = [\n      '*~',\n   ]\n\n   sources = []\n\n   data = DoxyfileParse(node.get_contents())\n\n   if data.get(\"RECURSIVE\", \"NO\") == \"YES\":\n      recursive = True\n   else:\n      recursive = False\n\n   file_patterns = data.get(\"FILE_PATTERNS\", default_file_patterns)\n   exclude_patterns = data.get(\"EXCLUDE_PATTERNS\", default_exclude_patterns)\n\n   # We're running in the top-level directory, but the doxygen\n   # configuration file is in the same directory as node; this means\n   # that relative pathnames in node must be adjusted before they can\n   # go onto the sources list\n   conf_dir = os.path.dirname(str(node))\n   \n   for node in data.get(\"INPUT\", []):\n      if not os.path.isabs(node):\n         node = os.path.join(conf_dir, node)\n      if os.path.isfile(node):\n         sources.append(node)\n      elif os.path.isdir(node):\n         if recursive:\n            for root, dirs, files in os.walk(node):\n               for f in files:\n                  filename = os.path.join(root, f)\n\n                  pattern_check = reduce(lambda x, y: x or bool(fnmatch(filename, y)), file_patterns, False)\n                  exclude_check = reduce(lambda x, y: x and fnmatch(filename, y), exclude_patterns, True)\n\n                  if pattern_check and not exclude_check:\n                     sources.append(filename)\n         else:\n            for pattern in file_patterns:\n               sources.extend(glob.glob(\"/\".join([node, pattern])))\n\n   # Add tagfiles to the list of source files:\n   for node in data.get(\"TAGFILES\", []):\n      file = node.split(\"=\")[0]\n      if not os.path.isabs(file):\n         file = os.path.join(conf_dir, file)\n      sources.append(file)\n   \n   # Add additional files to the list of source files:\n   def append_additional_source(option):\n      file = data.get(option, \"\")\n      if file != \"\":\n         if not os.path.isabs(file):\n            file = os.path.join(conf_dir, file)\n         if os.path.isfile(file):\n            sources.append(file)\n\n   append_additional_source(\"HTML_STYLESHEET\")\n   append_additional_source(\"HTML_HEADER\")\n   append_additional_source(\"HTML_FOOTER\")\n\n   sources = map( lambda path: env.File(path), sources )\n   return sources", "label": 1}
{"code": "def count_mismatches_after_variant(reference_suffix, cdna_suffix):\n    \"\"\"\n    Computes the number of mismatching nucleotides between two cDNA sequences after a variant locus.\n\n    Parameters\n    ----------\n    reference_suffix : str\n        cDNA sequence of a reference transcript after a variant locus\n\n    cdna_suffix : str\n        cDNA sequence detected from RNAseq after a variant locus\n    \"\"\"\n\n    len_diff = len(cdna_suffix) - len(reference_suffix)\n\n    # if the reference is shorter than the read, the read runs into the intron - these count as\n    # mismatches\n    return sum(xi != yi for (xi, yi) in zip(reference_suffix, cdna_suffix)) + max(0, len_diff)", "label": 1}
{"code": "function eachLine(file, lineProcessFn, finallyFn, options) {\n  if (arguments.length === 2) {\n    if (_.isFunction(lineProcessFn)) {\n      finallyFn = null;\n      options = {};\n    } else {\n      options = lineProcessFn;\n      lineProcessFn = null;\n    }\n  } else if (arguments.length === 3) {\n    if (_.isFunction(finallyFn)) {\n      options = {};\n    } else {\n      finallyFn = null;\n      options = finallyFn;\n    }\n  }\n  options = _.sanitize(options, {reverse: false, eachLine: null, finally: null, encoding: 'utf-8'});\n  finallyFn = finallyFn || options.finally;\n  lineProcessFn = lineProcessFn || options.eachLine;\n\n  const data = read(file, _.pick(options, 'encoding'));\n  const lines = data.split('\\n');\n  if (options.reverse) lines.reverse();\n\n  const newLines = [];\n  _.each(lines, (line, index) => {\n    const res = lineProcessFn(line, index);\n    newLines.push(res);\n    // Returning false from lineProcessFn will allow us early aborting the loop\n    return res;\n  });\n  if (options.reverse) newLines.reverse();\n  if (finallyFn !== null) finallyFn(newLines.join('\\n'));\n}", "label": 3}
{"code": "public function setWorkspaceId($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\DevTools\\Source\\V1\\CloudWorkspaceId::class);\n        $this->workspace_id = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static nsacl_stats get(nitro_service service, String aclname) throws Exception{\n\t\tnsacl_stats obj = new nsacl_stats();\n\t\tobj.set_aclname(aclname);\n\t\tnsacl_stats response = (nsacl_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function resolve(array $shapeRef)\n    {\n        $shape = $shapeRef['shape'];\n\n        if (!isset($this->definitions[$shape])) {\n            throw new \\InvalidArgumentException('Shape not found: ' . $shape);\n        }\n\n        $isSimple = count($shapeRef) == 1;\n        if ($isSimple && isset($this->simple[$shape])) {\n            return $this->simple[$shape];\n        }\n\n        $definition = $shapeRef + $this->definitions[$shape];\n        $definition['name'] = $definition['shape'];\n        unset($definition['shape']);\n\n        $result = Shape::create($definition, $this);\n\n        if ($isSimple) {\n            $this->simple[$shape] = $result;\n        }\n\n        return $result;\n    }", "label": 2}
{"code": "func (l *localFileSystem) SetChmod(path string, mode int) error {\n\tchmode := os.FileMode(mode & int(os.ModePerm))\n\tif err := os.Chmod(path, chmode); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "protected static boolean numericEquals(Field vector1, Field vector2) {\n\t\tif (vector1.size() != vector2.size())\n\t\t\treturn false;\n\t\tif (vector1.isEmpty())\n\t\t\treturn true;\n\n\t\tIterator<Object> it1 = vector1.iterator();\n\t\tIterator<Object> it2 = vector2.iterator();\n\n\t\twhile (it1.hasNext()) {\n\t\t\tObject obj1 = it1.next();\n\t\t\tObject obj2 = it2.next();\n\n\t\t\tif (!(obj1 instanceof Number && obj2 instanceof Number))\n\t\t\t\treturn false;\n\n\t\t\tif (((Number) obj1).doubleValue() != ((Number) obj2).doubleValue())\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}", "label": 0}
{"code": "def estimate_threshold(in1, edge_excl=0, int_excl=0):\n    \"\"\"\n    This function estimates the noise using the MAD estimator.\n\n    INPUTS:\n    in1             (no default):   The array from which the noise is estimated\n\n    OUTPUTS:\n    out1                            An array of per-scale noise estimates.\n    \"\"\"\n\n    out1 = np.empty([in1.shape[0]])\n    mid = in1.shape[1]/2\n\n    if (edge_excl!=0) | (int_excl!=0):\n\n        if edge_excl!=0:\n            mask = np.zeros([in1.shape[1], in1.shape[2]])\n            mask[edge_excl:-edge_excl, edge_excl:-edge_excl] = 1\n        else:\n            mask = np.ones([in1.shape[1], in1.shape[2]])\n\n        if int_excl!=0:\n            mask[mid-int_excl:mid+int_excl, mid-int_excl:mid+int_excl] = 0\n\n    else:\n        mask = np.ones([in1.shape[1], in1.shape[2]])\n\n    for i in range(in1.shape[0]):\n        out1[i] = np.median(np.abs(in1[i,mask==1]))/0.6745\n\n    return out1", "label": 1}
{"code": "func (v VirtualMachine) QueryConfigTarget(ctx context.Context) (*types.ConfigTarget, error) {\n\tvar vm mo.VirtualMachine\n\n\terr := v.Properties(ctx, v.Reference(), []string{\"environmentBrowser\"}, &vm)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq := types.QueryConfigTarget{\n\t\tThis: vm.EnvironmentBrowser,\n\t}\n\n\tres, err := methods.QueryConfigTarget(ctx, v.Client(), &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res.Returnval, nil\n}", "label": 5}
{"code": "func (c *Client) UpsertPassword(user string, password []byte) error {\n\t_, err := c.PostJSON(\n\t\tc.Endpoint(\"users\", user, \"web\", \"password\"),\n\t\tupsertPasswordReq{\n\t\t\tPassword: string(password),\n\t\t})\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def commit_check(self, commands=\"\", req_format=\"text\"):\n        \"\"\" Execute a commit check operation.\n\n        Purpose: This method will take in string of multiple commands,\n               | and perform and 'commit check' on the device to ensure\n               | the commands are syntactically correct. The response can\n               | be formatted as text or as xml.\n\n        @param commands: A string, filepath, or list of multiple commands\n                       | that the device will compare with.\n        @type commands: str or list\n        @param req_format: The desired format of the response, defaults to\n                         | 'text', but also accepts 'xml'\n        @type req_format: str\n\n        @returns: The reply from the device.\n        @rtype: str\n        \"\"\"\n        if not commands:\n            raise InvalidCommandError('No commands specified')\n        clean_cmds = []\n        for cmd in clean_lines(commands):\n            clean_cmds.append(cmd)\n        self.lock()\n        self._session.load_configuration(action='set', config=clean_cmds)\n        # conn.validate() DOES NOT return a parse-able xml tree, so we\n        # convert it to an ElementTree xml tree.\n        results = ET.fromstring(self._session.validate(\n            source='candidate').tostring)\n        # release the candidate configuration\n        self.unlock()\n        if req_format == \"xml\":\n            return ET.tostring(results)\n        out = \"\"\n        # we have to parse the elementTree object, and get the text\n        # from the xml.\n        for i in results.iter():\n            # the success message is just a tag, so we need to get it\n            # specifically.\n            if i.tag == 'commit-check-success':\n                out += 'configuration check succeeds\\n'\n            # this is for normal output with a tag and inner text, it will\n            # strip the inner text and add it to the output.\n            elif i.text is not None:\n                if i.text.strip() + '\\n' != '\\n':\n                    out += i.text.strip() + '\\n'\n            # this is for elements that don't have inner text, it will add the\n            # tag to the output.\n            elif i.text is None:\n                if i.tag + '\\n' != '\\n':\n                    out += i.tag + '\\n'\n        return out", "label": 1}
{"code": "def resume_pry\n      new_binding = frame._binding\n\n      run do\n        if defined?(@pry) && @pry\n          @pry.repl(new_binding)\n        else\n          @pry = Pry.start_without_pry_byebug(new_binding)\n        end\n      end\n    end", "label": 4}
{"code": "func (s *APIServer) keepAliveNode(auth ClientI, w http.ResponseWriter, r *http.Request, p httprouter.Params, version string) (interface{}, error) {\n\tvar handle services.KeepAlive\n\tif err := httplib.ReadJSON(r, &handle); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tif err := auth.KeepAliveNode(r.Context(), handle); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn message(\"ok\"), nil\n}", "label": 5}
{"code": "def add_target_topics(topics)\n      topics = Set.new(topics)\n      unless topics.subset?(@target_topics)\n        new_topics = topics - @target_topics\n\n        unless new_topics.empty?\n          @logger.info \"New topics added to target list: #{new_topics.to_a.join(', ')}\"\n\n          @target_topics.merge(new_topics)\n\n          refresh_metadata!\n        end\n      end\n    end", "label": 4}
{"code": "function hideLoading() {\n  var innerParams = privateProps.innerParams.get(this);\n  var domCache = privateProps.domCache.get(this);\n\n  if (!innerParams.showConfirmButton) {\n    hide(domCache.confirmButton);\n\n    if (!innerParams.showCancelButton) {\n      hide(domCache.actions);\n    }\n  }\n\n  removeClass([domCache.popup, domCache.actions], swalClasses.loading);\n  domCache.popup.removeAttribute('aria-busy');\n  domCache.popup.removeAttribute('data-loading');\n  domCache.confirmButton.disabled = false;\n  domCache.cancelButton.disabled = false;\n}", "label": 3}
{"code": "function addPropertyToModelMeta(modelName, property, meta) {\n    if (!exports.propertiesByModel[modelName]) {\n        exports.propertiesByModel[modelName] = {};\n    }\n    // TODO: investigate why we need to genericize to model (from <T>)\n    exports.propertiesByModel[modelName][property] = meta;\n}", "label": 3}
{"code": "func strIf(cnd bool, aStr, bStr string) string {\n\tif cnd {\n\t\treturn aStr\n\t}\n\treturn bStr\n}", "label": 5}
{"code": "private function enqueue($op, $table, array $dataSet)\n    {\n        foreach ($dataSet as $data) {\n            if ($op === Operation::OP_DELETE) {\n                $this->mutations[] = $this->operation->deleteMutation($table, $data);\n            } else {\n                $this->mutations[] = $this->operation->mutation($op, $table, $data);\n            }\n        }\n    }", "label": 2}
{"code": "def is_valid(arxiv_id):\n    \"\"\"\n    Check that a given arXiv ID is a valid one.\n\n    :param arxiv_id: The arXiv ID to be checked.\n    :returns: Boolean indicating whether the arXiv ID is valid or not.\n\n    >>> is_valid('1506.06690')\n    True\n\n    >>> is_valid('1506.06690v1')\n    True\n\n    >>> is_valid('arXiv:1506.06690')\n    True\n\n    >>> is_valid('arXiv:1506.06690v1')\n    True\n\n    >>> is_valid('arxiv:1506.06690')\n    True\n\n    >>> is_valid('arxiv:1506.06690v1')\n    True\n\n    >>> is_valid('math.GT/0309136')\n    True\n\n    >>> is_valid('abcdf')\n    False\n\n    >>> is_valid('bar1506.06690foo')\n    False\n\n    >>> is_valid('mare.GG/0309136')\n    False\n    \"\"\"\n    match = REGEX.match(arxiv_id)\n    return  (match is not None) and (match.group(0) == arxiv_id)", "label": 1}
{"code": "function () {\n            var series = this,\n              options = series.options,\n              dataOptions = options.data,\n              data = series.data,\n              dataLength,\n              processedXData = series.processedXData,\n              processedYData = series.processedYData,\n              pointClass = series.pointClass,\n              processedDataLength = processedXData.length,\n              cropStart = series.cropStart || 0,\n              cursor,\n              hasGroupedData = series.hasGroupedData,\n              point,\n              points = [],\n              i;\n\n            if (!data && !hasGroupedData) {\n                var arr = [];\n                arr.length = dataOptions.length;\n                data = series.data = arr;\n            }\n\n            for (i = 0; i < processedDataLength; i++) {\n                cursor = cropStart + i;\n                if (!hasGroupedData) {\n                    if (data[cursor]) {\n                        point = data[cursor];\n                    } else if (dataOptions[cursor] !== UNDEFINED) { // #970\n                        data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n                    }\n                    points[i] = point;\n                } else {\n                    // splat the y data in case of ohlc data array\n                    points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n                }\n                points[i].index = cursor; // For faster access in Point.update\n            }\n\n            // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n            // swithching view from non-grouped data to grouped data (#637)\n            if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n                for (i = 0; i < dataLength; i++) {\n                    if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n                        i += processedDataLength;\n                    }\n                    if (data[i]) {\n                        data[i].destroyElements();\n                        data[i].plotX = UNDEFINED; // #1003\n                    }\n                }\n            }\n\n            series.data = data;\n            series.points = points;\n        }", "label": 3}
{"code": "def top_hits(hits, num, column, reverse):\n    \"\"\"\n    get top hits after sorting by column number\n    \"\"\"\n    hits.sort(key = itemgetter(column), reverse = reverse)\n    for hit in hits[0:num]:\n        yield hit", "label": 1}
{"code": "func InitACL() (*ACL, error) {\n\th, err := getHandle()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ACL{lib: h}, nil\n}", "label": 5}
{"code": "function(revision)\n  {\n    if ( isFunction( revision ) )\n    {\n      this.revisionFunction = revision;\n    }\n    else if ( isString( revision ) )\n    {\n      this.revisionFunction = function(a, b)\n      {\n        var ar = isObject( a ) && revision in a ? a[ revision ] : undefined;\n        var br = isObject( b ) && revision in b ? b[ revision ] : undefined;\n\n        return ar === undefined || br === undefined ? false : compare( ar, br ) > 0;\n      };\n    }\n    else\n    {\n      this.revisionFunction = function(a, b)\n      {\n        return false;\n      };\n    }\n  }", "label": 3}
{"code": "function (url, query, callbackParam) {\n            if (url.indexOf('=?') == -1) {\n                callbackParam = callbackParam || this.callbackParam;\n\n                if (url.indexOf('?') == -1) {\n                    url += '?';\n                } else {\n                    url += '&';\n                }\n\n                url += callbackParam + '=?';\n            }\n\n            return $.ajax({\n                url: url,\n                dataType:'jsonp',\n                data:query\n            });\n        }", "label": 3}
{"code": "def filterrific_sorting_link_reverse_order(filterrific, new_sort_key, opts)\n      # current sort column, toggle search_direction\n      new_sort_direction = 'asc' == opts[:current_sort_direction] ? 'desc' : 'asc'\n      new_sorting = safe_join([new_sort_key, new_sort_direction], '_')\n      css_classes = safe_join([\n        opts[:active_column_class],\n        opts[:html_attrs].delete(:class)\n      ].compact, ' ')\n      new_filterrific_params = filterrific.to_hash\n                                          .with_indifferent_access\n                                          .merge(opts[:sorting_scope_name] => new_sorting)\n      url_for_attrs = opts[:url_for_attrs].merge(:filterrific => new_filterrific_params)\n      link_to(\n        safe_join([opts[:label], opts[:current_sort_direction_indicator]], ' '),\n        url_for(url_for_attrs),\n        opts[:html_attrs].reverse_merge(:class => css_classes, :method => :get, :remote => true)\n      )\n    end", "label": 4}
{"code": "public function free($deep = false, $position = 0)\n    {\n        // WARNING! Use this method with care. It resets the scanner!\n        $this->lexer->resetPosition($position);\n\n        // Deep = true cleans peek and also any previously defined errors\n        if ($deep) {\n            $this->lexer->resetPeek();\n        }\n\n        $this->lexer->token     = null;\n        $this->lexer->lookahead = null;\n    }", "label": 2}
{"code": "def send_status(code = OK, details = '', assert_finished = false,\n                    metadata: {})\n      send_initial_metadata\n      ops = {\n        SEND_STATUS_FROM_SERVER => Struct::Status.new(code, details, metadata)\n      }\n      ops[RECV_CLOSE_ON_SERVER] = nil if assert_finished\n      @call.run_batch(ops)\n      set_output_stream_done\n\n      nil\n    end", "label": 4}
{"code": "def run\n      # We can't just rescue exception because Firefox automatically closes alert when exception raised\n      return unless @after_hooks.any? && !@browser.alert.exists?\n\n      each { |after_hook| after_hook.call(@browser) }\n    rescue Selenium::WebDriver::Error::NoSuchWindowError => ex\n      Watir.logger.info \"Could not execute After Hooks because browser window was closed #{ex}\"\n    end", "label": 4}
{"code": "func ForAuth(cfg Config) Config {\n\tcfg.Watches = []services.WatchKind{\n\t\t{Kind: services.KindCertAuthority, LoadSecrets: true},\n\t\t{Kind: services.KindClusterName},\n\t\t{Kind: services.KindClusterConfig},\n\t\t{Kind: services.KindStaticTokens},\n\t\t{Kind: services.KindToken},\n\t\t{Kind: services.KindUser},\n\t\t{Kind: services.KindRole},\n\t\t{Kind: services.KindNamespace},\n\t\t{Kind: services.KindNode},\n\t\t{Kind: services.KindProxy},\n\t\t{Kind: services.KindReverseTunnel},\n\t\t{Kind: services.KindTunnelConnection},\n\t}\n\tcfg.QueueSize = defaults.AuthQueueSize\n\treturn cfg\n}", "label": 5}
{"code": "private function handleControl(string $body = null, &$header = null, int $flags = 0): bool\n    {\n        $header = $body;\n        if (is_null($body) || $flags & Relay::PAYLOAD_RAW) {\n            // empty or raw prefix\n            return true;\n        }\n\n        $p = json_decode($body, true);\n        if ($p === false) {\n            throw new RoadRunnerException(\"invalid task context, JSON payload is expected\");\n        }\n\n        // PID negotiation (socket connections only)\n        if (!empty($p['pid'])) {\n            $this->relay->send(\n                sprintf('{\"pid\":%s}', getmypid()), Relay::PAYLOAD_CONTROL\n            );\n        }\n\n        // termination request\n        if (!empty($p['stop'])) {\n            return false;\n        }\n\n        // parsed header\n        $header = $p;\n\n        return true;\n    }", "label": 2}
{"code": "function() {\n      _.each(this.__currentUpdateEvents, function(eventConfig) {\n        this.stopListening(eventConfig.model, eventConfig.eventName);\n      }, this);\n      this.__currentUpdateEvents = [];\n    }", "label": 3}
{"code": "private D createAndRegisterDeclaration(Map<String, Object> metadata) {\n        D declaration;\n        if (klass.equals(ImportDeclaration.class)) {\n            declaration = (D) ImportDeclarationBuilder.fromMetadata(metadata).build();\n        } else if (klass.equals(ExportDeclaration.class)) {\n            declaration = (D) ExportDeclarationBuilder.fromMetadata(metadata).build();\n        } else {\n            throw new IllegalStateException(\"\");\n        }\n        declarationRegistrationManager.registerDeclaration(declaration);\n        return declaration;\n    }", "label": 0}
{"code": "def merge(base_hash, derived_hash, **opts)\n      result = base_hash.merge(derived_hash)\n      keys_appearing_in_both = base_hash.keys & derived_hash.keys\n      keys_appearing_in_both.each do |key|\n        if opts[:unset_nil] && derived_hash[key].nil?\n          result.delete(key)\n        elsif base_hash[key].is_a?(Hash)\n          result[key] = merge(base_hash[key], derived_hash[key], **opts)\n        elsif should_union?(base_hash, key, opts[:inherit_mode])\n          result[key] = base_hash[key] | derived_hash[key]\n        elsif opts[:debug]\n          warn_on_duplicate_setting(base_hash, derived_hash, key, opts)\n        end\n      end\n      result\n    end", "label": 4}
{"code": "def write_generator_data(self, file):\n        \"\"\" Write generator data as CSV.\n        \"\"\"\n        writer = self._get_writer(file)\n        writer.writerow([\"bus\"] + GENERATOR_ATTRS)\n\n        for g in self.case.generators:\n            i = g.bus._i\n            writer.writerow([i] + [getattr(g,a) for a in GENERATOR_ATTRS])", "label": 1}
{"code": "public static File writeStringToTempFileNoExceptions(String contents, String path, String encoding) {\r\n\t\tOutputStream writer = null;\r\n\t\tFile tmp = null;\r\n\t\ttry{\r\n\t\t\ttmp = File.createTempFile(path,\".tmp\");\r\n\t\t\tif (path.endsWith(\".gz\")) {\r\n\t\t\t\twriter = new GZIPOutputStream(new FileOutputStream(tmp));\r\n\t\t\t} else {\r\n\t\t\t\twriter = new BufferedOutputStream(new FileOutputStream(tmp));\r\n\t\t\t}\r\n\t\t\twriter.write(contents.getBytes(encoding));\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} finally {\r\n\t\t\tif(writer != null){ closeIgnoringExceptions(writer); }\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}", "label": 0}
{"code": "func (c *EventHistoryCollector) fillPage(size int) {\n\tc.pos = 0\n\tl := c.page.Len()\n\tdelta := size - l\n\n\tif delta < 0 {\n\t\t// Shrink ring size\n\t\tc.page = c.page.Unlink(-delta)\n\t\treturn\n\t}\n\n\tmatches := 0\n\tmpage := c.m.page\n\tpage := c.page\n\n\tif delta != 0 {\n\t\t// Grow ring size\n\t\tc.page = c.page.Link(ring.New(delta))\n\t}\n\n\tfor i := 0; i < maxPageSize; i++ {\n\t\tevent, ok := mpage.Value.(types.BaseEvent)\n\t\tmpage = mpage.Prev()\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.eventMatches(event) {\n\t\t\tpage.Value = event\n\t\t\tpage = page.Prev()\n\t\t\tmatches++\n\t\t\tif matches == size {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}", "label": 5}
{"code": "func (a *LocalKeyAgent) DeleteKey() error {\n\t// remove key from key store\n\terr := a.keyStore.DeleteKey(a.proxyHost, a.username)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\t// remove any keys that are loaded for this user from the teleport and\n\t// system agents\n\terr = a.UnloadKey()\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "protected static FileWriter createFileWriter(String scenarioName,\n            String aux_package_path, String dest_dir) throws BeastException {\n        try {\n            return new FileWriter(new File(createFolder(aux_package_path,\n                    dest_dir), scenarioName + \".story\"));\n        } catch (IOException e) {\n            String message = \"ERROR writing the \" + scenarioName\n                    + \".story file: \" + e.toString();\n            logger.severe(message);\n            throw new BeastException(message, e);\n        }\n    }", "label": 0}
{"code": "def group_attributes_by_key(attributes)\n      Hash[attributes.group_by(&:first).map { |k, v| [k, v.map(&:last).tap(&:compact!).join(', ')] }]\n    end", "label": 4}
{"code": "def run_muse(job, tumor_bam, normal_bam, univ_options, muse_options):\n    \"\"\"\n    Spawn a MuSE job for each chromosome on the DNA bams.\n\n    :param dict tumor_bam: Dict of bam and bai for tumor DNA-Seq\n    :param dict normal_bam: Dict of bam and bai for normal DNA-Seq\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict muse_options: Options specific to MuSE\n    :return: Dict of results from running MuSE on every chromosome\n             perchrom_muse:\n                 |- 'chr1': fsID\n                 |- 'chr2' fsID\n                 |\n                 |-...\n                 |\n                 +- 'chrM': fsID\n    :rtype: dict\n    \"\"\"\n    # Get a list of chromosomes to handle\n    if muse_options['chromosomes']:\n        chromosomes = muse_options['chromosomes']\n    else:\n        chromosomes = sample_chromosomes(job, muse_options['genome_fai'])\n    perchrom_muse = defaultdict()\n    for chrom in chromosomes:\n        call = job.addChildJobFn(run_muse_perchrom, tumor_bam, normal_bam, univ_options,\n                                 muse_options, chrom, disk=PromisedRequirement(\n                                     muse_disk,\n                                     tumor_bam['tumor_dna_fix_pg_sorted.bam'],\n                                     normal_bam['normal_dna_fix_pg_sorted.bam'],\n                                     muse_options['genome_fasta']),\n                                 memory='6G')\n        sump = call.addChildJobFn(run_muse_sump_perchrom, call.rv(), univ_options, muse_options,\n                                  chrom,\n                                  disk=PromisedRequirement(muse_sump_disk,\n                                                           muse_options['dbsnp_vcf']),\n                                  memory='6G')\n        perchrom_muse[chrom] = sump.rv()\n    return perchrom_muse", "label": 1}
{"code": "public static java.sql.Time newTime() {\n        return new java.sql.Time(System.currentTimeMillis() % DAY_MILLIS);\n    }", "label": 0}
{"code": "private function generate_ssh_command( $bits, $wp_command ) {\n\t\t$escaped_command = '';\n\n\t\t// Set default values.\n\t\tforeach ( array( 'scheme', 'user', 'host', 'port', 'path' ) as $bit ) {\n\t\t\tif ( ! isset( $bits[ $bit ] ) ) {\n\t\t\t\t$bits[ $bit ] = null;\n\t\t\t}\n\n\t\t\tWP_CLI::debug( 'SSH ' . $bit . ': ' . $bits[ $bit ], 'bootstrap' );\n\t\t}\n\n\t\t$is_tty = function_exists( 'posix_isatty' ) && posix_isatty( STDOUT );\n\n\t\tif ( 'docker' === $bits['scheme'] ) {\n\t\t\t$command = 'docker exec %s%s%s sh -c %s';\n\n\t\t\t$escaped_command = sprintf(\n\t\t\t\t$command,\n\t\t\t\t$bits['user'] ? '--user ' . escapeshellarg( $bits['user'] ) . ' ' : '',\n\t\t\t\t$is_tty ? '-t ' : '',\n\t\t\t\tescapeshellarg( $bits['host'] ),\n\t\t\t\tescapeshellarg( $wp_command )\n\t\t\t);\n\t\t}\n\n\t\tif ( 'docker-compose' === $bits['scheme'] ) {\n\t\t\t$command = 'docker-compose exec %s%s%s sh -c %s';\n\n\t\t\t$escaped_command = sprintf(\n\t\t\t\t$command,\n\t\t\t\t$bits['user'] ? '--user ' . escapeshellarg( $bits['user'] ) . ' ' : '',\n\t\t\t\t$is_tty ? '' : '-T ',\n\t\t\t\tescapeshellarg( $bits['host'] ),\n\t\t\t\tescapeshellarg( $wp_command )\n\t\t\t);\n\t\t}\n\n\t\t// Vagrant ssh-config.\n\t\tif ( 'vagrant' === $bits['scheme'] ) {\n\t\t\t$command = 'vagrant ssh -c %s %s';\n\n\t\t\t$escaped_command = sprintf(\n\t\t\t\t$command,\n\t\t\t\tescapeshellarg( $wp_command ),\n\t\t\t\tescapeshellarg( $bits['host'] )\n\t\t\t);\n\t\t}\n\n\t\t// Default scheme is SSH.\n\t\tif ( 'ssh' === $bits['scheme'] || null === $bits['scheme'] ) {\n\t\t\t$command = 'ssh -q %s%s %s %s';\n\n\t\t\tif ( $bits['user'] ) {\n\t\t\t\t$bits['host'] = $bits['user'] . '@' . $bits['host'];\n\t\t\t}\n\n\t\t\t$escaped_command = sprintf(\n\t\t\t\t$command,\n\t\t\t\t$bits['port'] ? '-p ' . (int) $bits['port'] . ' ' : '',\n\t\t\t\tescapeshellarg( $bits['host'] ),\n\t\t\t\t$is_tty ? '-t' : '-T',\n\t\t\t\tescapeshellarg( $wp_command )\n\t\t\t);\n\t\t}\n\n\t\tWP_CLI::debug( 'Running SSH command: ' . $escaped_command, 'bootstrap' );\n\n\t\treturn $escaped_command;\n\t}", "label": 2}
{"code": "def capitalize_field( str )\n      str.to_s.split(\"-\").map { |v| v.capitalize }.join(\"-\")\n    end", "label": 4}
{"code": "def print_licences(params, metadata):\n    \"\"\"Print licenses.\n\n    :param argparse.Namespace params: parameter\n    :param bootstrap_py.classifier.Classifiers metadata: package metadata\n    \"\"\"\n    if hasattr(params, 'licenses'):\n        if params.licenses:\n            _pp(metadata.licenses_desc())\n        sys.exit(0)", "label": 1}
{"code": "def object_to_pdf(object)\n      if object.nil?\n        return 'null'\n      elsif object.is_a?(String)\n        return format_string_to_pdf object\n      elsif object.is_a?(Symbol)\n        return format_name_to_pdf object\n      elsif object.is_a?(Array)\n        return format_array_to_pdf object\n      elsif object.is_a?(Integer) || object.is_a?(TrueClass) || object.is_a?(FalseClass)\n        return object.to_s\n      elsif object.is_a?(Numeric) # Float or other non-integer\n        return sprintf('%f', object)\n      elsif object.is_a?(Hash)\n        return format_hash_to_pdf object\n      else\n        return ''\n      end\n    end", "label": 4}
{"code": "protected ValueContainer[] getAllValues(ClassDescriptor cld, Object obj) throws PersistenceBrokerException\r\n    {\r\n        return m_broker.serviceBrokerHelper().getAllRwValues(cld, obj);\r\n    }", "label": 0}
{"code": "def file_needs_update?(filename: nil)\n      # looking for something like: FastlaneRunnerAPIVersion [0.9.1]\n      regex_to_use = API_VERSION_REGEX\n\n      source = File.join(self.source_swift_code_file_folder_path, \"/#{filename}\")\n      target = File.join(self.target_swift_code_file_folder_path, \"/#{filename}\")\n\n      # target doesn't have the file yet, so ya, I'd say it needs to be updated\n      return true unless File.exist?(target)\n\n      source_file_content = File.read(source)\n      target_file_content = File.read(target)\n\n      bundled_version = source_file_content.match(regex_to_use)[1]\n      target_version = target_file_content.match(regex_to_use)[1]\n      file_versions_are_different = bundled_version != target_version\n\n      UI.verbose(\"#{filename} FastlaneRunnerAPIVersion (bundled/target): #{bundled_version}/#{target_version}\")\n      files_are_different = source_file_content != target_file_content\n\n      if files_are_different && !file_versions_are_different\n        UI.verbose(\"File versions are the same, but the two files are not equal, so that's a problem, setting needs update to 'true'\")\n      end\n\n      needs_update = file_versions_are_different || files_are_different\n\n      return needs_update\n    end", "label": 4}
{"code": "func (g *GRPCServer) WatchEvents(watch *proto.Watch, stream proto.AuthService_WatchEventsServer) error {\n\tauth, err := g.authenticate(stream.Context())\n\tif err != nil {\n\t\treturn trail.ToGRPC(err)\n\t}\n\tservicesWatch := services.Watch{\n\t\tName: auth.User.GetName(),\n\t}\n\tfor _, kind := range watch.Kinds {\n\t\tservicesWatch.Kinds = append(servicesWatch.Kinds, services.WatchKind{\n\t\t\tName:        kind.Name,\n\t\t\tKind:        kind.Kind,\n\t\t\tLoadSecrets: kind.LoadSecrets,\n\t\t})\n\t}\n\twatcher, err := auth.NewWatcher(stream.Context(), servicesWatch)\n\tif err != nil {\n\t\treturn trail.ToGRPC(err)\n\t}\n\tdefer watcher.Close()\n\n\tfor {\n\t\tselect {\n\t\tcase <-stream.Context().Done():\n\t\t\treturn nil\n\t\tcase <-watcher.Done():\n\t\t\treturn trail.ToGRPC(watcher.Error())\n\t\tcase event := <-watcher.Events():\n\t\t\tout, err := eventToGRPC(event)\n\t\t\tif err != nil {\n\t\t\t\treturn trail.ToGRPC(err)\n\t\t\t}\n\t\t\tif err := stream.Send(out); err != nil {\n\t\t\t\treturn trail.ToGRPC(err)\n\t\t\t}\n\t\t}\n\t}\n}", "label": 5}
{"code": "protected function sendMessageNode($to, $node, $id = null, $plaintextNode = null)\n    {\n        $msgId = ($id == null) ? $this->createMsgId() : $id;\n        $to = $this->getJID($to);\n\n        if ($node->getTag() == 'body' || $node->getTag() == 'enc') {\n            $type = 'text';\n        } else {\n            $type = 'media';\n        }\n\n        $messageNode = new ProtocolNode('message', [\n            'to'      => $to,\n            'type'    => $type,\n            'id'      => $msgId,\n            't'       => time(),\n            'notify'  => $this->name,\n        ], [$node], '');\n\n        $this->sendNode($messageNode);\n\n        if ($node->getTag() == 'enc') {\n            $node = $plaintextNode;\n        }\n\n        $this->logFile('info', '{type} message with id {id} sent to {to}', ['type' => $type, 'id' => $msgId, 'to' => ExtractNumber($to)]);\n        $this->eventManager()->fire('onSendMessage',\n            [\n                $this->phoneNumber,\n                $to,\n                $msgId,\n                $node,\n            ]);\n\n       // $this->waitForServer($msgId);\n\n        return $msgId;\n    }", "label": 2}
{"code": "def create\n      admin_set.creator = [creating_user.user_key] if creating_user\n      admin_set.save.tap do |result|\n        if result\n          ActiveRecord::Base.transaction do\n            permission_template = create_permission_template\n            workflow = create_workflows_for(permission_template: permission_template)\n            create_default_access_for(permission_template: permission_template, workflow: workflow) if admin_set.default_set?\n          end\n        end\n      end\n    end", "label": 4}
{"code": "public function setEndDate($date, $inclusive = null)\n    {\n        if (!is_null($date) && !$date = call_user_func([$this->dateClass, 'make'], $date)) {\n            throw new InvalidArgumentException('Invalid end date.');\n        }\n\n        if (!$date) {\n            return $this->removeFilter(static::END_DATE_FILTER);\n        }\n\n        $this->endDate = $date;\n\n        if ($inclusive !== null) {\n            $this->toggleOptions(static::EXCLUDE_END_DATE, !$inclusive);\n        }\n\n        if (!$this->hasFilter(static::END_DATE_FILTER)) {\n            return $this->addFilter(static::END_DATE_FILTER);\n        }\n\n        $this->handleChangedParameters();\n\n        return $this;\n    }", "label": 2}
{"code": "def analyze_query(query, analyzers, multiplex_states: [])\n      query.trace(\"analyze_query\", { query: query }) do\n        analyzers_to_run = analyzers.select do |analyzer|\n          if analyzer.respond_to?(:analyze?)\n            analyzer.analyze?(query)\n          else\n            true\n          end\n        end\n\n        reducer_states = analyzers_to_run.map { |r| ReducerState.new(r, query) } + multiplex_states\n\n        irep = query.internal_representation\n\n        irep.operation_definitions.each do |name, op_node|\n          reduce_node(op_node, reducer_states)\n        end\n\n        reducer_states.map(&:finalize_reducer)\n      end\n    end", "label": 4}
{"code": "public static function spanName($project, $trace, $span)\n    {\n        return self::getSpanNameTemplate()->render([\n            'project' => $project,\n            'trace' => $trace,\n            'span' => $span,\n        ]);\n    }", "label": 2}
{"code": "function signatureRelatedTo(source, target, reportErrors) {\n                return compareSignaturesRelated(source, target, /*ignoreReturnTypes*/ false, reportErrors, reportError, isRelatedTo);\n            }", "label": 3}
{"code": "def make_request_body(opts, headers)\n      case\n      when opts.body\n        opts.body\n      when opts.form\n        form = HTTP::FormData.create opts.form\n        headers[Headers::CONTENT_TYPE] ||= form.content_type\n        form\n      when opts.json\n        body = MimeType[:json].encode opts.json\n        headers[Headers::CONTENT_TYPE] ||= \"application/json; charset=#{body.encoding.name}\"\n        body\n      end\n    end", "label": 4}
{"code": "def import(error, override_options = {})\n      [:attribute, :type].each do |key|\n        if override_options.key?(key)\n          override_options[key] = override_options[key].to_sym\n        end\n      end\n      @errors.append(NestedError.new(@base, error, override_options))\n    end", "label": 4}
{"code": "func (mod *OpenweathermapBee) TriggerWeatherInformationEvent(v *owm.Weather) {\n\tweather := bees.Event{\n\t\tBee:  mod.Name(),\n\t\tName: \"main_weather\",\n\t\tOptions: []bees.Placeholder{\n\t\t\t{\n\t\t\t\tName:  \"id\",\n\t\t\t\tType:  \"int\",\n\t\t\t\tValue: v.ID,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"main\",\n\t\t\t\tType:  \"string\",\n\t\t\t\tValue: v.Main,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"description\",\n\t\t\t\tType:  \"string\",\n\t\t\t\tValue: v.Description,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:  \"icon\",\n\t\t\t\tType:  \"string\",\n\t\t\t\tValue: v.Icon,\n\t\t\t},\n\t\t},\n\t}\n\tmod.evchan <- weather\n}", "label": 5}
{"code": "async def read_reply(self):\n        \"\"\"\n        Reads a reply from the server.\n\n        Raises:\n            ConnectionResetError: If the connection with the server is lost\n                (we can't read any response anymore). Or if the server\n                replies without a proper return code.\n\n        Returns:\n            (int, str): A (code, full_message) 2-tuple consisting of:\n\n                - server response code ;\n                - server response string corresponding to response code\n                  (multiline responses are returned in a single string).\n        \"\"\"\n        code = 500\n        messages = []\n        go_on = True\n\n        while go_on:\n            try:\n                line = await self.readline()\n            except ValueError as e:\n                # ValueError is raised when limit is reached before we could\n                # get an entire line.\n                # We return what we got with a 500 code and we stop to read\n                # the reply to avoid being flooded.\n                code = 500\n                go_on = False\n            else:\n                try:\n                    code = int(line[:3])\n                except ValueError as e:\n                    # We either:\n                    # - Got an empty line (connection is probably down),\n                    # - Got a line without a valid return code.\n                    # In both case, it shouldn't happen, hence:\n                    raise ConnectionResetError(\"Connection lost.\") from e\n                else:\n                    # Check is we have a multiline response:\n                    go_on = line[3:4] == b\"-\"\n\n            message = line[4:].strip(b\" \\t\\r\\n\").decode(\"ascii\")\n            messages.append(message)\n\n        full_message = \"\\n\".join(messages)\n\n        return code, full_message", "label": 1}
{"code": "protected void addLoadError(PdfContext context, ImageException e) {\n\t\tBbox imageBounds = e.getRasterImage().getBounds();\n\t\tfloat scaleFactor = (float) (72 / getMap().getRasterResolution());\n\t\tfloat width = (float) imageBounds.getWidth() * scaleFactor;\n\t\tfloat height = (float) imageBounds.getHeight() * scaleFactor;\n\t\t// subtract screen position of lower-left corner\n\t\tfloat x = (float) (imageBounds.getX() - rasterScale * bbox.getMinX()) * scaleFactor;\n\t\t// shift y to lower left corner, flip y to user space and subtract\n\t\t// screen position of lower-left\n\t\t// corner\n\t\tfloat y = (float) (-imageBounds.getY() - imageBounds.getHeight() - rasterScale * bbox.getMinY()) * scaleFactor;\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"adding failed message=\" + width + \",height=\" + height + \",x=\" + x + \",y=\" + y);\n\t\t}\n\t\tfloat textHeight = context.getTextSize(\"failed\", ERROR_FONT).getHeight() * 3f;\n\t\tRectangle rec = new Rectangle(x, y, x + width, y + height);\n\t\tcontext.strokeRectangle(rec, Color.RED, 0.5f);\n\t\tcontext.drawText(getNlsString(\"RasterLayerComponent.loaderror.line1\"), ERROR_FONT, new Rectangle(x, y\n\t\t\t\t+ textHeight, x + width, y + height), Color.RED);\n\t\tcontext.drawText(getNlsString(\"RasterLayerComponent.loaderror.line2\"), ERROR_FONT, rec, Color.RED);\n\t\tcontext.drawText(getNlsString(\"RasterLayerComponent.loaderror.line3\"), ERROR_FONT, new Rectangle(x, y\n\t\t\t\t- textHeight, x + width, y + height), Color.RED);\n\t}", "label": 0}
{"code": "function(i, value, delaySort)\n  {\n    AP.splice.call( this, i, 0, value );\n\n    this.trigger( Collection.Events.Add, [this, value, i] );\n\n    if ( !delaySort )\n    {\n      this.sort( undefined, undefined, true );\n    }\n\n    return this;\n  }", "label": 3}
{"code": "func (process *TeleportProcess) onExit(serviceName string, callback func(interface{})) {\n\tprocess.RegisterFunc(serviceName, func() error {\n\t\teventC := make(chan Event)\n\t\tprocess.WaitForEvent(context.TODO(), TeleportExitEvent, eventC)\n\t\tselect {\n\t\tcase event := <-eventC:\n\t\t\tcallback(event.Payload)\n\t\t}\n\t\treturn nil\n\t})\n}", "label": 5}
{"code": "function (parameters, result) {\n                var\n                    len,\n                    idx,\n                    parameter,\n                    name,\n                    value;\n                len = parameters.length;\n                for (idx = 0; idx < len; ++idx) {\n                    parameter = parameters[idx];\n                    name = parameter._name;\n                    if (undefined === result[name]) {\n                        if (parameter._required) {\n                            gpf.Error.paramsRequiredMissing({\n                                name: name\n                            });\n                        }\n                        value = parameter._defaultValue;\n                        if (undefined !== value) {\n                            if (parameter._multiple) {\n                                value = [value];\n                            }\n                            result[name] = value;\n                        } else if (parameter._multiple) {\n                            result[name] = [];\n                        }\n                    }\n                }\n            }", "label": 3}
{"code": "func (k Key) Seal(plaintext []byte) ([]byte, error) {\n\tblock, err := aes.NewCipher([]byte(k))\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\taesgcm, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tnonce := make([]byte, aesgcm.NonceSize())\n\t_, err = io.ReadFull(rand.Reader, nonce)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tciphertext, err := json.Marshal(&sealedData{\n\t\tCiphertext: aesgcm.Seal(nil, nonce, plaintext, nil),\n\t\tNonce:      nonce,\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn ciphertext, nil\n}", "label": 5}
{"code": "public function iam()\n    {\n        if (!$this->iam) {\n            $this->iam = new Iam(\n                new IamBucket($this->connection),\n                $this->identity['bucket'],\n                [\n                    'parent' => null,\n                    'args' => $this->identity\n                ]\n            );\n        }\n\n        return $this->iam;\n    }", "label": 2}
{"code": "public function setMask($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Firestore\\V1\\DocumentMask::class);\n        $this->mask = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def clean(plugins, **opts)\n      @logger.debug(\"Cleaning Vagrant plugins of stale gems.\")\n      # Generate dependencies for all registered plugins\n      plugin_deps = plugins.map do |name, info|\n        gem_version = info['installed_gem_version']\n        gem_version = info['gem_version'] if gem_version.to_s.empty?\n        gem_version = \"> 0\" if gem_version.to_s.empty?\n        Gem::Dependency.new(name, gem_version)\n      end\n\n      @logger.debug(\"Current plugin dependency list: #{plugin_deps}\")\n\n      # Load dependencies into a request set for resolution\n      request_set = Gem::RequestSet.new(*plugin_deps)\n      # Never allow dependencies to be remotely satisfied during cleaning\n      request_set.remote = false\n\n      # Sets that we can resolve our dependencies from. Note that we only\n      # resolve from the current set as all required deps are activated during\n      # init.\n      current_set = generate_vagrant_set\n\n      # Collect all plugin specifications\n      plugin_specs = Dir.glob(plugin_gem_path.join('specifications/*.gemspec').to_s).map do |spec_path|\n        Gem::Specification.load(spec_path)\n      end\n\n      # Include environment specific specification if enabled\n      if env_plugin_gem_path\n        plugin_specs += Dir.glob(env_plugin_gem_path.join('specifications/*.gemspec').to_s).map do |spec_path|\n          Gem::Specification.load(spec_path)\n        end\n      end\n\n      @logger.debug(\"Generating current plugin state solution set.\")\n\n      # Resolve the request set to ensure proper activation order\n      solution = request_set.resolve(current_set)\n      solution_specs = solution.map(&:full_spec)\n      solution_full_names = solution_specs.map(&:full_name)\n\n      # Find all specs installed to plugins directory that are not\n      # found within the solution set.\n      plugin_specs.delete_if do |spec|\n        solution_full_names.include?(spec.full_name)\n      end\n\n      if env_plugin_gem_path\n        # If we are cleaning locally, remove any global specs. If\n        # not, remove any local specs\n        if opts[:env_local]\n          @logger.debug(\"Removing specifications that are not environment local\")\n          plugin_specs.delete_if do |spec|\n            spec.full_gem_path.to_s.include?(plugin_gem_path.realpath.to_s)\n          end\n        else\n          @logger.debug(\"Removing specifications that are environment local\")\n          plugin_specs.delete_if do |spec|\n            spec.full_gem_path.to_s.include?(env_plugin_gem_path.realpath.to_s)\n          end\n        end\n      end\n\n      @logger.debug(\"Specifications to be removed - #{plugin_specs.map(&:full_name)}\")\n\n      # Now delete all unused specs\n      plugin_specs.each do |spec|\n        @logger.debug(\"Uninstalling gem - #{spec.full_name}\")\n        Gem::Uninstaller.new(spec.name,\n          version: spec.version,\n          install_dir: plugin_gem_path,\n          all: true,\n          executables: true,\n          force: true,\n          ignore: true,\n        ).uninstall_gem(spec)\n      end\n\n      solution.find_all do |spec|\n        plugins.keys.include?(spec.name)\n      end\n    end", "label": 4}
{"code": "def fetch_open_orders(self, limit: int) -> List[Order]:\n        \"\"\"Fetch latest open orders, must provide a limit.\"\"\"\n        return self._fetch_orders_limit(self._open_orders, limit)", "label": 1}
{"code": "private function unmix_assoc_args( $mixed_args, $global_assoc = array(), $local_assoc = array() ) {\n\t\t$assoc_args     = array();\n\t\t$runtime_config = array();\n\n\t\tif ( getenv( 'WP_CLI_STRICT_ARGS_MODE' ) ) {\n\t\t\tforeach ( $global_assoc as $tmp ) {\n\t\t\t\tlist( $key, $value ) = $tmp;\n\t\t\t\tif ( isset( $this->spec[ $key ] ) && false !== $this->spec[ $key ]['runtime'] ) {\n\t\t\t\t\t$this->assoc_arg_to_runtime_config( $key, $value, $runtime_config );\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach ( $local_assoc as $tmp ) {\n\t\t\t\t$assoc_args[ $tmp[0] ] = $tmp[1];\n\t\t\t}\n\t\t} else {\n\t\t\tforeach ( $mixed_args as $tmp ) {\n\t\t\t\tlist( $key, $value ) = $tmp;\n\n\t\t\t\tif ( isset( $this->spec[ $key ] ) && false !== $this->spec[ $key ]['runtime'] ) {\n\t\t\t\t\t$this->assoc_arg_to_runtime_config( $key, $value, $runtime_config );\n\t\t\t\t} else {\n\t\t\t\t\t$assoc_args[ $key ] = $value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn array( $assoc_args, $runtime_config );\n\t}", "label": 2}
{"code": "def list_discounts(location_id, opts = {})\n      data, _status_code, _headers = list_discounts_with_http_info(location_id, opts)\n      return data\n    end", "label": 4}
{"code": "func (sink *influxdbSink) stringListQueryCol(q, colName string, errStr string) ([]string, error) {\n\tsink.RLock()\n\tdefer sink.RUnlock()\n\n\tresp, err := sink.runQuery(q)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(errStr)\n\t}\n\n\tif len(resp[0].Series) < 1 {\n\t\treturn nil, fmt.Errorf(errStr)\n\t}\n\n\tcolInd := -1\n\tfor i, col := range resp[0].Series[0].Columns {\n\t\tif col == colName {\n\t\t\tcolInd = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif colInd == -1 {\n\t\tglog.Errorf(\"%s: results did not contain the %q column\", errStr, core.LabelPodName.Key)\n\t\treturn nil, fmt.Errorf(errStr)\n\t}\n\n\tres := make([]string, len(resp[0].Series[0].Values))\n\tfor i, rv := range resp[0].Series[0].Values {\n\t\tres[i] = rv[colInd].(string)\n\t}\n\treturn res, nil\n}", "label": 5}
{"code": "def extract_noindex\n      noindex_name, noindex_value = extract_noindex_attribute(:noindex)\n      index_name, index_value = extract_noindex_attribute(:index)\n\n      nofollow_name, nofollow_value = extract_noindex_attribute(:nofollow)\n      follow_name, follow_value = extract_noindex_attribute(:follow)\n\n      noindex_attributes = if noindex_name == follow_name && (noindex_value || follow_value)\n                             # noindex has higher priority than index and follow has higher priority than nofollow\n                             [\n                               [noindex_name, noindex_value || index_value],\n                               [follow_name, follow_value || nofollow_value],\n                             ]\n                           else\n                             [\n                               [index_name, index_value],\n                               [follow_name, follow_value],\n                               [noindex_name, noindex_value],\n                               [nofollow_name, nofollow_value],\n                             ]\n                           end\n      append_noarchive_attribute group_attributes_by_key noindex_attributes\n    end", "label": 4}
{"code": "public static base_response delete(nitro_service client, String neighbor) throws Exception {\n\t\tnd6 deleteresource = new nd6();\n\t\tdeleteresource.neighbor = neighbor;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "function createShader(\n    gl\n  , vertSource\n  , fragSource\n  , uniforms\n  , attributes) {\n  \n  //Compile vertex shader\n  var vertShader = gl.createShader(gl.VERTEX_SHADER)\n  gl.shaderSource(vertShader, vertSource)\n  gl.compileShader(vertShader)\n  if(!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {\n    var errLog = gl.getShaderInfoLog(vertShader)\n    console.error('gl-shader: Error compling vertex shader:', errLog)\n    throw new Error('gl-shader: Error compiling vertex shader:' + errLog)\n  }\n  \n  //Compile fragment shader\n  var fragShader = gl.createShader(gl.FRAGMENT_SHADER)\n  gl.shaderSource(fragShader, fragSource)\n  gl.compileShader(fragShader)\n  if(!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {\n    var errLog = gl.getShaderInfoLog(fragShader)\n    console.error('gl-shader: Error compiling fragment shader:', errLog)\n    throw new Error('gl-shader: Error compiling fragment shader:' + errLog)\n  }\n  \n  //Link program\n  var program = gl.createProgram()\n  gl.attachShader(program, fragShader)\n  gl.attachShader(program, vertShader)\n\n  //Optional default attriubte locations\n  attributes.forEach(function(a) {\n    if (typeof a.location === 'number') \n      gl.bindAttribLocation(program, a.location, a.name)\n  })\n\n  gl.linkProgram(program)\n  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    var errLog = gl.getProgramInfoLog(program)\n    console.error('gl-shader: Error linking shader program:', errLog)\n    throw new Error('gl-shader: Error linking shader program:' + errLog)\n  }\n  \n  //Return final linked shader object\n  var shader = new Shader(\n    gl,\n    program,\n    vertShader,\n    fragShader\n  )\n  shader.updateExports(uniforms, attributes)\n\n  return shader\n}", "label": 3}
{"code": "function(inputs, delaySort)\n  {\n    var map = this.map;\n    var removed = [];\n    var removedIndices = [];\n\n    for (var i = 0; i < inputs.length; i++)\n    {\n      var key = this.buildKeyFromInput( inputs[ i ] );\n      var removing = map.get( key );\n\n      if ( removing )\n      {\n        removedIndices.push( map.indices[ key ] );\n        removed.push( removing );\n      }\n    }\n\n    removedIndices.sort();\n\n    for (var i = removedIndices.length - 1; i >= 0; i--)\n    {\n      map.removeAt( removedIndices[ i ] );\n    }\n\n    this.trigger( Collection.Events.Removes, [this, removed, removedIndices] );\n\n    if ( !delaySort )\n    {\n      this.sort();\n    }\n\n    return removed;\n  }", "label": 3}
{"code": "func (c *Client) Login(ctx context.Context, user *url.Userinfo) error {\n\treq := internal.URL(c, internal.SessionPath).Request(http.MethodPost)\n\n\tif user != nil {\n\t\tif password, ok := user.Password(); ok {\n\t\t\treq.SetBasicAuth(user.Username(), password)\n\t\t}\n\t}\n\n\treturn c.Do(ctx, req, nil)\n}", "label": 5}
{"code": "public function display_item( $item, $ascii_pre_colorized = false ) {\n\t\tif ( isset( $this->args['field'] ) ) {\n\t\t\t$item  = (object) $item;\n\t\t\t$key   = $this->find_item_key( $item, $this->args['field'] );\n\t\t\t$value = $item->$key;\n\t\t\tif ( in_array( $this->args['format'], array( 'table', 'csv' ), true ) && ( is_object( $value ) || is_array( $value ) ) ) {\n\t\t\t\t$value = json_encode( $value );\n\t\t\t}\n\t\t\t\\WP_CLI::print_value(\n\t\t\t\t$value,\n\t\t\t\tarray(\n\t\t\t\t\t'format' => $this->args['format'],\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\t$this->show_multiple_fields( $item, $this->args['format'], $ascii_pre_colorized );\n\t\t}\n\t}", "label": 2}
{"code": "function update(req, res, next) {\n  var params = {\n    appId: req.params.id || req.body._id,\n    forms: req.body.forms || []\n  };\n  forms.updateAppForms(req.connectionOptions, params, formsResultHandlers(constants.resultTypes.formProjects, req, next));\n}", "label": 3}
{"code": "public function setCreate($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Bigtable\\Admin\\V2\\ColumnFamily::class);\n        $this->writeOneof(2, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def members_entries(self, all_are_optional: bool=False) -> List[Tuple[str, str]]:\n        \"\"\" Return an ordered list of elements for the _members section\n\n        :param all_are_optional: True means we're in a choice situation so everything is optional\n        :return:\n        \"\"\"\n        rval = []\n        if self._members:\n            for member in self._members:\n                rval += member.members_entries(all_are_optional)\n        elif self._choices:\n            for choice in self._choices:\n                rval += self._context.reference(choice).members_entries(True)\n        else:\n            return []\n        return rval", "label": 1}
{"code": "def has_update?(version=nil, download_options: {})\n      if !@metadata_url\n        raise Errors::BoxUpdateNoMetadata, name: @name\n      end\n\n      if download_options.delete(:automatic_check) && !automatic_update_check_allowed?\n        @logger.info(\"Skipping box update check\")\n        return\n      end\n\n      version += \", \" if version\n      version ||= \"\"\n      version += \"> #{@version}\"\n      md      = self.load_metadata(download_options)\n      newer   = md.version(version, provider: @provider)\n      return nil if !newer\n\n      [md, newer, newer.provider(@provider)]\n    end", "label": 4}
{"code": "func (s *v1AlphaAPIServer) GetInfo(context.Context, *v1alpha.GetInfoRequest) (*v1alpha.GetInfoResponse, error) {\n\treturn &v1alpha.GetInfoResponse{\n\t\tInfo: &v1alpha.Info{\n\t\t\tRktVersion:  version.Version,\n\t\t\tAppcVersion: schema.AppContainerVersion.String(),\n\t\t\tApiVersion:  supportedAPIVersion,\n\t\t\tGlobalFlags: &v1alpha.GlobalFlags{\n\t\t\t\tDir:                getDataDir(),\n\t\t\t\tSystemConfigDir:    globalFlags.SystemConfigDir,\n\t\t\t\tLocalConfigDir:     globalFlags.LocalConfigDir,\n\t\t\t\tUserConfigDir:      globalFlags.UserConfigDir,\n\t\t\t\tInsecureFlags:      globalFlags.InsecureFlags.String(),\n\t\t\t\tTrustKeysFromHttps: globalFlags.TrustKeysFromHTTPS,\n\t\t\t},\n\t\t},\n\t}, nil\n}", "label": 5}
{"code": "public function getRepoUrl()\n    {\n        switch ($this->type) {\n            case 'github':\n                return \"git@github.com:{$this->name}.git\";\n\n            case 'github-https':\n                return \"https://github.com/{$this->name}.git\";\n\n            case 'gitlab':\n                return \"git@gitlab.com:{$this->name}.git\";\n                break;\n\n            case 'bitbucket':\n                return \"git@bitbucket.org:{$this->name}.git\";\n\n            default:\n\n                // Check of type 'scheme://host/path'\n                if (filter_var($this->type, FILTER_VALIDATE_URL)) {\n                    return $this->type;\n                }\n\n                // Check of type 'user@host'\n                if (filter_var($this->type, FILTER_VALIDATE_EMAIL)) {\n                    return \"{$this->type}:{$this->name}.git\";\n                }\n\n                return;\n                break;\n        }\n    }", "label": 2}
{"code": "def newline_before_nonwhitespace(string)\n      offset = -2\n      while /\\S/.match(string[offset]).nil?\n        return true if string[offset] == \"\\n\"\n        offset -= 1\n      end\n      false\n    end", "label": 4}
{"code": "def run_mutect_perchrom(job, tumor_bam, normal_bam, univ_options, mutect_options, chrom):\n    \"\"\"\n    Run MuTect call on a single chromosome in the input bams.\n\n    :param dict tumor_bam: Dict of bam and bai for tumor DNA-Seq\n    :param dict normal_bam: Dict of bam and bai for normal DNA-Seq\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict mutect_options: Options specific to MuTect\n    :param str chrom: Chromosome to process\n    :return: fsID for the chromsome vcf\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    work_dir = os.getcwd()\n    input_files = {\n        'tumor.bam': tumor_bam['tumor_dna_fix_pg_sorted.bam'],\n        'tumor.bam.bai': tumor_bam['tumor_dna_fix_pg_sorted.bam.bai'],\n        'normal.bam': normal_bam['normal_dna_fix_pg_sorted.bam'],\n        'normal.bam.bai': normal_bam['normal_dna_fix_pg_sorted.bam.bai'],\n        'genome.fa.tar.gz': mutect_options['genome_fasta'],\n        'genome.fa.fai.tar.gz': mutect_options['genome_fai'],\n        'genome.dict.tar.gz': mutect_options['genome_dict'],\n        'cosmic.vcf.tar.gz': mutect_options['cosmic_vcf'],\n        'cosmic.vcf.idx.tar.gz': mutect_options['cosmic_idx'],\n        'dbsnp.vcf.gz': mutect_options['dbsnp_vcf'],\n        'dbsnp.vcf.idx.tar.gz': mutect_options['dbsnp_idx']}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n    # dbsnp.vcf should be bgzipped, but all others should be tar.gz'd\n    input_files['dbsnp.vcf'] = gunzip(input_files['dbsnp.vcf.gz'])\n    for key in ('genome.fa', 'genome.fa.fai', 'genome.dict', 'cosmic.vcf', 'cosmic.vcf.idx',\n                'dbsnp.vcf.idx'):\n        input_files[key] = untargz(input_files[key + '.tar.gz'], work_dir)\n    input_files = {key: docker_path(path) for key, path in input_files.items()}\n\n    mutout = ''.join([work_dir, '/', chrom, '.out'])\n    mutvcf = ''.join([work_dir, '/', chrom, '.vcf'])\n    parameters = ['-R', input_files['genome.fa'],\n                  '--cosmic', input_files['cosmic.vcf'],\n                  '--dbsnp', input_files['dbsnp.vcf'],\n                  '--input_file:normal', input_files['normal.bam'],\n                  '--input_file:tumor', input_files['tumor.bam'],\n                  # '--tumor_lod', str(10),\n                  # '--initial_tumor_lod', str(4.0),\n                  '-L', chrom,\n                  '--out', docker_path(mutout),\n                  '--vcf', docker_path(mutvcf)\n                  ]\n    java_xmx = mutect_options['java_Xmx'] if mutect_options['java_Xmx'] \\\n        else univ_options['java_Xmx']\n    docker_call(tool='mutect', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], java_xmx=java_xmx,\n                tool_version=mutect_options['version'])\n    output_file = job.fileStore.writeGlobalFile(mutvcf)\n    export_results(job, output_file, mutvcf, univ_options, subfolder='mutations/mutect')\n    job.fileStore.logToMaster('Ran MuTect on %s:%s successfully' % (univ_options['patient'], chrom))\n    return output_file", "label": 1}
{"code": "function checkZipFile(zipFilePath, cb) {\n  //Checking that it is a ZIP file\n  mimeInspector.detectFile(zipFilePath, function(err, fileMimetype) {\n    var errMessage;\n    if (err) {\n      logger.error(\"Error detecting ZIP file\", err);\n      return cb(err);\n    }\n\n    if (fileMimetype !== 'application/zip') {\n      errMessage = \"Expected the file MIME type to be application/zip but was \" + fileMimetype;\n      logger.error(errMessage);\n    }\n\n    return cb(errMessage);\n  });\n}", "label": 3}
{"code": "func isHTTPS(u string) error {\n\tearl, err := url.Parse(u)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\tif earl.Scheme != \"https\" {\n\t\treturn trace.BadParameter(\"expected scheme https, got %q\", earl.Scheme)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "func errorStatus(err error) uint32 {\n\tif x, ok := err.(*Status); ok {\n\t\treturn x.Code\n\t}\n\n\tswitch {\n\tcase os.IsNotExist(err):\n\t\treturn StatusNoSuchFileOrDir\n\tcase os.IsExist(err):\n\t\treturn StatusFileExists\n\tcase os.IsPermission(err):\n\t\treturn StatusOperationNotPermitted\n\t}\n\n\treturn StatusGenericError\n}", "label": 5}
{"code": "public double totalCount() {\r\n    if (depth() == 1) {\r\n      return total; // I think this one is always OK.  Not very principled here, though.\r\n    } else {\r\n      double result = 0.0;\r\n      for (K o: topLevelKeySet()) {\r\n        result += conditionalizeOnce(o).totalCount();\r\n      }\r\n      return result;\r\n    }\r\n  }", "label": 0}
{"code": "private void ensureLength(FieldDescriptorDef fieldDef, String checkLevel)\r\n    {\r\n        if (!fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_LENGTH))\r\n        {\r\n            String defaultLength = JdbcTypeHelper.getDefaultLengthFor(fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_JDBC_TYPE));\r\n\r\n            if (defaultLength != null)\r\n            {\r\n                LogHelper.warn(true,\r\n                               FieldDescriptorConstraints.class,\r\n                               \"ensureLength\",\r\n                               \"The field \"+fieldDef.getName()+\" in class \"+fieldDef.getOwner().getName()+\" has no length setting though its jdbc type requires it (in most databases); using default length of \"+defaultLength);\r\n                fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_LENGTH, defaultLength);\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n            var axis = this,\n              sign = 1,\n              cvsOffset = 0,\n              localA = old ? axis.oldTransA : axis.transA,\n              localMin = old ? axis.oldMin : axis.min,\n              returnValue,\n              minPixelPadding = axis.minPixelPadding,\n              postTranslate = (axis.options.ordinal || (axis.isLog && handleLog)) && axis.lin2val;\n\n            if (!localA) {\n                localA = axis.transA;\n            }\n\n            // In vertical axes, the canvas coordinates start from 0 at the top like in\n            // SVG.\n            if (cvsCoord) {\n                sign *= -1; // canvas coordinates inverts the value\n                cvsOffset = axis.len;\n            }\n\n            // Handle reversed axis\n            if (axis.reversed) {\n                sign *= -1;\n                cvsOffset -= sign * (axis.sector || axis.len);\n            }\n\n            // From pixels to value\n            if (backwards) { // reverse translation\n\n                val = val * sign + cvsOffset;\n                val -= minPixelPadding;\n                returnValue = val / localA + localMin; // from chart pixel to value\n                if (postTranslate) { // log and ordinal axes\n                    returnValue = axis.lin2val(returnValue);\n                }\n\n                // From value to pixels\n            } else {\n                if (postTranslate) { // log and ordinal axes\n                    val = axis.val2lin(val);\n                }\n                if (pointPlacement === 'between') {\n                    pointPlacement = 0.5;\n                }\n                returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +\n                  (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);\n            }\n\n            return returnValue;\n        }", "label": 3}
{"code": "function (req, res) {\n        let groupId = req.params.id;\n        if (Utils.isNullOrEmpty(server.state.get('groups[' + groupId + ']'))) {\n            log.error('Invalid Group Id:', groupId);\n            Utils.sendMessage(res, HttpStatus.BAD_REQUEST, JSON.stringify({ error: 'invalid group id' }));\n        } else {\n            log.debug('Successfully read configuration for group id:', groupId);\n            Utils.sendMessage(res, HttpStatus.OK, JSON.stringify(server.state.get('groups[' + groupId + ']')));\n        }\n    }", "label": 3}
{"code": "func (l VirtualDeviceList) AssignController(device types.BaseVirtualDevice, c types.BaseVirtualController) {\n\td := device.GetVirtualDevice()\n\td.ControllerKey = c.GetVirtualController().Key\n\td.UnitNumber = new(int32)\n\t*d.UnitNumber = l.newUnitNumber(c)\n\tif d.Key == 0 {\n\t\td.Key = -1\n\t}\n}", "label": 5}
{"code": "def attach(*attachables)\n      if record.persisted? && !record.changed?\n        record.update(name => blobs + attachables.flatten)\n      else\n        record.public_send(\"#{name}=\", blobs + attachables.flatten)\n      end\n    end", "label": 4}
{"code": "function TrailingBlock(opts) {\n    opts       = opts || {};\n    opts.type  = opts.type || 'paragraph';\n    opts.match = opts.match || (node => node.type === opts.type);\n\n    return {\n        validateNode: (node) => {\n            if (node.object !== 'document') {\n                return undefined;\n            }\n\n            const lastNode = node.nodes.last();\n            if (lastNode && opts.match(lastNode)) {\n                return undefined;\n            }\n\n            const lastIndex = node.nodes.count();\n            const block = Slate.Block.create({\n                type: opts.type,\n                nodes: [Slate.Text.create()]\n            });\n\n            return (change) => change.insertNodeByKey(node.key, lastIndex, block);\n        },\n\n        changes: {\n            focusAtEnd\n        }\n    };\n}", "label": 3}
{"code": "function contextualTypeIsTupleLikeType(type) {\n            return !!(type.flags & 524288 /* Union */ ? ts.forEach(type.types, isTupleLikeType) : isTupleLikeType(type));\n        }", "label": 3}
{"code": "func (c *CachePolicy) GetRecentTTL() time.Duration {\n\tif c.RecentTTL == nil {\n\t\treturn defaults.RecentCacheTTL\n\t}\n\treturn *c.RecentTTL\n}", "label": 5}
{"code": "func (s *ServicesTestSuite) ClusterConfig(c *check.C, opts ...SuiteOption) {\n\tconfig, err := services.NewClusterConfig(services.ClusterConfigSpecV3{\n\t\tClientIdleTimeout:     services.NewDuration(17 * time.Second),\n\t\tDisconnectExpiredCert: services.NewBool(true),\n\t\tClusterID:             \"27\",\n\t\tSessionRecording:      services.RecordAtProxy,\n\t\tAudit: services.AuditConfig{\n\t\t\tRegion:           \"us-west-1\",\n\t\t\tType:             \"dynamodb\",\n\t\t\tAuditSessionsURI: \"file:///home/log\",\n\t\t\tAuditTableName:   \"audit_table_name\",\n\t\t\tAuditEventsURI:   []string{\"dynamodb://audit_table_name\", \"file:///home/log\"},\n\t\t},\n\t})\n\tc.Assert(err, check.IsNil)\n\n\terr = s.ConfigS.SetClusterConfig(config)\n\tc.Assert(err, check.IsNil)\n\n\tgotConfig, err := s.ConfigS.GetClusterConfig()\n\tc.Assert(err, check.IsNil)\n\tconfig.SetResourceID(gotConfig.GetResourceID())\n\tfixtures.DeepCompare(c, config, gotConfig)\n\n\t// Some parts (e.g. auth server) will not function\n\t// without cluster name or cluster config\n\tif CollectOptions(opts...).SkipDelete {\n\t\treturn\n\t}\n\terr = s.ConfigS.DeleteClusterConfig()\n\tc.Assert(err, check.IsNil)\n\n\t_, err = s.ConfigS.GetClusterConfig()\n\tfixtures.ExpectNotFound(c, err)\n\n\tclusterName, err := services.NewClusterName(services.ClusterNameSpecV2{\n\t\tClusterName: \"example.com\",\n\t})\n\tc.Assert(err, check.IsNil)\n\n\terr = s.ConfigS.SetClusterName(clusterName)\n\tc.Assert(err, check.IsNil)\n\n\tgotName, err := s.ConfigS.GetClusterName()\n\tc.Assert(err, check.IsNil)\n\tclusterName.SetResourceID(gotName.GetResourceID())\n\tfixtures.DeepCompare(c, clusterName, gotName)\n\n\terr = s.ConfigS.DeleteClusterName()\n\tc.Assert(err, check.IsNil)\n\n\t_, err = s.ConfigS.GetClusterName()\n\tfixtures.ExpectNotFound(c, err)\n\n\terr = s.ConfigS.UpsertClusterName(clusterName)\n\tc.Assert(err, check.IsNil)\n\n\tgotName, err = s.ConfigS.GetClusterName()\n\tc.Assert(err, check.IsNil)\n\tclusterName.SetResourceID(gotName.GetResourceID())\n\tfixtures.DeepCompare(c, clusterName, gotName)\n}", "label": 5}
{"code": "def resource_manager scope: nil, retries: nil, timeout: nil\n      Google::Cloud.resource_manager @keyfile, scope: scope,\n                                               retries: (retries || @retries),\n                                               timeout: (timeout || @timeout)\n    end", "label": 4}
{"code": "def __getVariables(self):\n        \"\"\"Parses the P4 env vars using 'set p4'\"\"\"\n        try:\n            startupinfo = None\n            if os.name == 'nt':\n                startupinfo = subprocess.STARTUPINFO()\n                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            output = subprocess.check_output(['p4', 'set'], startupinfo=startupinfo)\n            if six.PY3:\n                output = str(output, 'utf8')\n        except subprocess.CalledProcessError as err:\n            LOGGER.error(err)\n            return\n\n        p4vars = {}\n        for line in output.splitlines():\n            if not line:\n                continue\n            try:\n                k, v = line.split('=', 1)\n            except ValueError:\n                continue\n            p4vars[k.strip()] = v.strip().split(' (')[0]\n            if p4vars[k.strip()].startswith('(config'):\n                del p4vars[k.strip()]\n\n        self._port = self._port or os.getenv('P4PORT', p4vars.get('P4PORT'))\n        self._user = self._user or os.getenv('P4USER', p4vars.get('P4USER'))\n        self._client = self._client or os.getenv('P4CLIENT', p4vars.get('P4CLIENT'))", "label": 1}
{"code": "public void checkpoint(ObjectEnvelope mod) throws PersistenceBrokerException\r\n    {\r\n        mod.doInsert();\r\n        mod.setModificationState(StateOldClean.getInstance());\r\n    }", "label": 0}
{"code": "public function refreshLastPost()\n    {\n        /** @var Post $lastPost */\n        if ($lastPost = $this->comments()->latest()->first()) {\n            $this->setLastPost($lastPost);\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "private function imbCrc11Fcs($codeArray)\n\t{\n\t\t$genpoly = 0x0F35; // generator polynomial\n\t\t$fcs = 0x07FF; // Frame Check Sequence\n\n\t\t// do most significant byte skipping the 2 most significant bits\n\t\t$data = hexdec($codeArray[0]) << 5;\n\t\tfor ($bit = 2; $bit < 8; ++$bit) {\n\t\t\tif (($fcs ^ $data) & 0x400) {\n\t\t\t\t$fcs = ($fcs << 1) ^ $genpoly;\n\t\t\t} else {\n\t\t\t\t$fcs = ($fcs << 1);\n\t\t\t}\n\t\t\t$fcs &= 0x7FF;\n\t\t\t$data <<= 1;\n\t\t}\n\t\t// do rest of bytes\n\t\tfor ($byte = 1; $byte < 13; ++$byte) {\n\t\t\t$data = hexdec($codeArray[$byte]) << 3;\n\t\t\tfor ($bit = 0; $bit < 8; ++$bit) {\n\t\t\t\tif (($fcs ^ $data) & 0x400) {\n\t\t\t\t\t$fcs = ($fcs << 1) ^ $genpoly;\n\t\t\t\t} else {\n\t\t\t\t\t$fcs = ($fcs << 1);\n\t\t\t\t}\n\t\t\t\t$fcs &= 0x7FF;\n\t\t\t\t$data <<= 1;\n\t\t\t}\n\t\t}\n\t\treturn $fcs;\n\t}", "label": 2}
{"code": "func GetIdentitySchema() string {\n\treturn fmt.Sprintf(services.V2SchemaTemplate, services.MetadataSchema, IdentitySpecV2Schema, services.DefaultDefinitions)\n}", "label": 5}
{"code": "@Override\r\n  public boolean containsKey(Object key) {\r\n    // key could be not in original or in deltaMap\r\n    // key could be not in original but in deltaMap\r\n    // key could be in original but removed from deltaMap\r\n    // key could be in original but mapped to something else in deltaMap\r\n    Object value = deltaMap.get(key);\r\n    if (value == null) {\r\n      return originalMap.containsKey(key);\r\n    }\r\n    if (value == removedValue) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }", "label": 0}
{"code": "public static double Taneja(double[] p, double[] q) {\n        double r = 0;\n        for (int i = 0; i < p.length; i++) {\n            if (p[i] != 0 && q[i] != 0) {\n                double pq = p[i] + q[i];\n                r += (pq / 2) * Math.log(pq / (2 * Math.sqrt(p[i] * q[i])));\n            }\n        }\n        return r;\n    }", "label": 0}
{"code": "public function info()\n    {\n        $data = [\n            'id' => $this->id,\n            'type' => $this->type\n        ];\n\n        if ($this->uncompressedSizeBytes) {\n            $data['uncompressedSizeBytes'] = $this->uncompressedSizeBytes;\n        }\n        if ($this->compressedSizeBytes) {\n            $data['compressedSizeBytes'] = $this->compressedSizeBytes;\n        }\n\n        return [\n            'time' => $this->time,\n            'messageEvent' => $data\n        ];\n    }", "label": 2}
{"code": "func (a *ACL) AddBaseEntries(path string) error {\n\tfi, err := os.Lstat(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmode := fi.Mode().Perm()\n\tvar r, w, x bool\n\n\t// set USER_OBJ entry\n\tr = mode&userRead == userRead\n\tw = mode&userWrite == userWrite\n\tx = mode&userExec == userExec\n\tif err := a.addBaseEntryFromMode(TagUserObj, r, w, x); err != nil {\n\t\treturn err\n\t}\n\n\t// set GROUP_OBJ entry\n\tr = mode&groupRead == groupRead\n\tw = mode&groupWrite == groupWrite\n\tx = mode&groupExec == groupExec\n\tif err := a.addBaseEntryFromMode(TagGroupObj, r, w, x); err != nil {\n\t\treturn err\n\t}\n\n\t// set OTHER entry\n\tr = mode&otherRead == otherRead\n\tw = mode&otherWrite == otherWrite\n\tx = mode&otherExec == otherExec\n\tif err := a.addBaseEntryFromMode(TagOther, r, w, x); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "private static function absolutize( &$path, $base ) {\n\t\tif ( ! empty( $path ) && ! \\WP_CLI\\Utils\\is_path_absolute( $path ) ) {\n\t\t\t$path = $base . DIRECTORY_SEPARATOR . $path;\n\t\t}\n\t}", "label": 2}
{"code": "def debugger service_name: nil, service_version: nil, scope: nil,\n                 timeout: nil, client_config: nil\n      Google::Cloud.debugger @project, @keyfile,\n                             service_name: service_name,\n                             service_version: service_version,\n                             scope: scope,\n                             timeout: (timeout || @timeout),\n                             client_config: client_config\n    end", "label": 4}
{"code": "public static function presenceOfAllElementsLocatedBy(WebDriverBy $by)\n    {\n        return new static(\n            function (WebDriver $driver) use ($by) {\n                $elements = $driver->findElements($by);\n\n                return count($elements) > 0 ? $elements : null;\n            }\n        );\n    }", "label": 2}
{"code": "def finalize_properties!(props)\n      handler = full_handler(props)\n      runtime = get_runtime(props)\n      managed = {\n        handler: handler,\n        runtime: runtime,\n        description: description,\n      }\n      managed[:function_name] = function_name if function_name\n      layers = get_layers(runtime)\n      managed[:layers] = layers if layers\n      props.merge!(managed)\n    end", "label": 4}
{"code": "public function set_ack_handler($callback)\n    {\n        if (!is_callable($callback)) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Given callback \"%s\" should be callable. %s type was given.',\n                $callback,\n                gettype($callback)\n            ));\n        }\n\n        $this->ack_handler = $callback;\n    }", "label": 2}
{"code": "function _validateArray (path, model, validateModelType) {\n  const results = []\n  let subPath = `${path}/items`\n  if (_.isPlainObject(model.items)) {\n    if (model.items.type === 'object') {\n      results.push(validateSubModel(subPath, model.items, validateModelType))\n    }\n  } else if (Array.isArray(model.items)) {\n    _.forEach(model.items, (item, index) => {\n      const itemSubPath = `${subPath}/${index}`\n      results.push(validateSubModel(itemSubPath, item, validateModelType))\n    })\n  }\n\n  return aggregateResults(results)\n}", "label": 3}
{"code": "def windows_worker_pids\n      tasklist_output = `tasklist /FI \"IMAGENAME eq ruby.exe\" /FO list`.encode(\"UTF-8\", Encoding.locale_charmap)\n      tasklist_output.split($/).select { |line| line =~ /^PID:/ }.collect { |line| line.gsub(/PID:\\s+/, '') }\n    end", "label": 4}
{"code": "protected PersistenceBrokerInternal createNewBrokerInstance(PBKey key) throws PBFactoryException\r\n    {\r\n        if (key == null) throw new PBFactoryException(\"Could not create new broker with PBkey argument 'null'\");\r\n        // check if the given key really exists\r\n        if (MetadataManager.getInstance().connectionRepository().getDescriptor(key) == null)\r\n        {\r\n            throw new PBFactoryException(\"Given PBKey \" + key + \" does not match in metadata configuration\");\r\n        }\r\n        if (log.isEnabledFor(Logger.INFO))\r\n        {\r\n            // only count created instances when INFO-Log-Level\r\n            log.info(\"Create new PB instance for PBKey \" + key +\r\n                    \", already created persistence broker instances: \" + instanceCount);\r\n            // useful for testing\r\n            ++this.instanceCount;\r\n        }\r\n\r\n        PersistenceBrokerInternal instance = null;\r\n        Class[] types = {PBKey.class, PersistenceBrokerFactoryIF.class};\r\n        Object[] args = {key, this};\r\n        try\r\n        {\r\n            instance = (PersistenceBrokerInternal) ClassHelper.newInstance(implementationClass, types, args);\r\n            OjbConfigurator.getInstance().configure(instance);\r\n            instance = (PersistenceBrokerInternal) InterceptorFactory.getInstance().createInterceptorFor(instance);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            log.error(\"Creation of a new PB instance failed\", e);\r\n            throw new PBFactoryException(\"Creation of a new PB instance failed\", e);\r\n        }\r\n        return instance;\r\n    }", "label": 0}
{"code": "def reformat_star_fusion_output(job,\n                                fusion_annot,\n                                fusion_file,\n                                transcript_file,\n                                transcript_gff_file,\n                                univ_options):\n    \"\"\"\n    Writes STAR-Fusion results in Transgene BEDPE format\n\n    :param toil.fileStore.FileID fusion_annot: Fusion annotation\n    :param toil.fileStore.FileID fusion_file: STAR-fusion prediction file\n    :param toil.fileStore.FileID transcript_file: Fusion transcript FASTA file\n    :param toil.fileStore.FileID transcript_gff_file: Fusion transcript GFF file\n    :param dict univ_options: universal arguments used by almost all tools\n    :return: Transgene BEDPE file\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    input_files = {'results.tsv': fusion_file,\n                   'fusion.bed': fusion_annot}\n\n    if transcript_file and transcript_gff_file:\n        input_files['transcripts.fa'] = transcript_file\n        input_files['transcripts.gff'] = transcript_gff_file\n\n    work_dir = job.fileStore.getLocalTempDir()\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=False)\n\n    # Pull in assembled transcript file\n    hugo_to_gene_ids = get_gene_ids(input_files['fusion.bed'])\n\n    if transcript_file and transcript_gff_file:\n        transcripts = get_transcripts(input_files['transcripts.fa'])\n        five_pr_splits, three_pr_splits = split_fusion_transcript(input_files['transcripts.gff'],\n                                                                  transcripts)\n\n    else:\n        five_pr_splits = collections.defaultdict(dict)\n        three_pr_splits = collections.defaultdict(dict)\n\n    # Pull in assembled transcript annotation\n\n    # Header for BEDPE file\n    header = ['# chr1', 'start1', 'end1',\n              'chr2', 'start2', 'end2',\n              'name', 'score',\n              'strand1', 'strand2',\n              'junctionSeq1', 'junctionSeq2',\n              'hugo1', 'hugo2']\n\n    output_path = os.path.join(work_dir, 'fusion_results.bedpe')\n    with open(input_files['results.tsv'], 'r') as in_f, open(output_path, 'w') as out_f:\n        writer = csv.writer(out_f, delimiter='\\t')\n        writer.writerow(header)\n        for record in parse_star_fusion(in_f):\n\n            left_chr, left_break, left_strand = record.LeftBreakpoint.split(':')\n\n            right_chr, right_break, right_strand = record.RightBreakpoint.split(':')\n\n            fusion = ''.join([record.LeftGene, '--', record.RightGene])\n            name = '-'.join([hugo_to_gene_ids[record.LeftGene], hugo_to_gene_ids[record.RightGene]])\n            score = 'Junction:%s-Spanning:%s' % (record.JunctionReadCount, record.SpanningFragCount)\n\n            # Add empty sequences in case Trinity doesn't output one\n            if len(five_pr_splits[fusion].keys()) == 0:\n                five_pr_splits[fusion]['N/A'] = '.'\n\n            if len(three_pr_splits[fusion].keys()) == 0:\n                three_pr_splits[fusion]['N/A'] = '.'\n\n            for transcript_id in five_pr_splits[fusion].keys():\n                five_prime_seq = five_pr_splits[fusion][transcript_id]\n                three_prime_seq = three_pr_splits[fusion][transcript_id]\n\n                writer.writerow([left_chr,\n                                 '.',  # Donor start position is not necessary\n                                 left_break,\n                                 right_chr,\n                                 right_break,\n                                 '.',  # Acceptor end position is not necessary\n                                 name,\n                                 score,\n                                 left_strand,\n                                 right_strand,\n                                 five_prime_seq,\n                                 three_prime_seq,\n                                 record.LeftGene,\n                                 record.RightGene])\n\n    bedpe_id = job.fileStore.writeGlobalFile(output_path)\n    export_results(job, bedpe_id, 'fusion.bedpe', univ_options, subfolder='mutations/fusions')\n    job.fileStore.logToMaster('Reformatted STAR-Fusion output for %s successfully'\n                              % univ_options['patient'])\n    return bedpe_id", "label": 1}
{"code": "def verification_level=(level)\n      level = VERIFICATION_LEVELS[level] if level.is_a?(Symbol)\n\n      update_server_data(verification_level: level)\n    end", "label": 4}
{"code": "def restore_working_tree\n      result = Overcommit::Utils.execute(%w[git stash pop --index --quiet])\n      unless result.success?\n        raise Overcommit::Exceptions::HookCleanupFailed,\n              \"Unable to restore working tree after #{hook_script_name} hooks run:\" \\\n              \"\\nSTDOUT:#{result.stdout}\\nSTDERR:#{result.stderr}\"\n      end\n    end", "label": 4}
{"code": "func (a *AuthServer) DeleteTrustedCluster(name string) error {\n\terr := a.DeleteCertAuthority(services.CertAuthID{Type: services.HostCA, DomainName: name})\n\tif err != nil {\n\t\tif !trace.IsNotFound(err) {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\n\terr = a.DeleteCertAuthority(services.CertAuthID{Type: services.UserCA, DomainName: name})\n\tif err != nil {\n\t\tif !trace.IsNotFound(err) {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\n\terr = a.DeleteReverseTunnel(name)\n\tif err != nil {\n\t\tif !trace.IsNotFound(err) {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\n\terr = a.Presence.DeleteTrustedCluster(name)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def primary_characterization_values(term)\n      values = values_for(term)\n      values.slice!(Hyrax.config.fits_message_length, (values.length - Hyrax.config.fits_message_length))\n      truncate_all(values)\n    end", "label": 4}
{"code": "def attribute_to_html(field, options = {})\n      unless respond_to?(field)\n        Rails.logger.warn(\"#{self.class} attempted to render #{field}, but no method exists with that name.\")\n        return\n      end\n\n      if options[:html_dl]\n        renderer_for(field, options).new(field, send(field), options).render_dl_row\n      else\n        renderer_for(field, options).new(field, send(field), options).render\n      end\n    end", "label": 4}
{"code": "protected function setNodeKey(NodeValue $nodeValue): void\n    {\n        if ($nodeValue->getCacheKey()) {\n            return;\n        }\n\n        $fields = data_get($nodeValue->getTypeDefinition(), 'fields', []);\n        $nodeKey = (new Collection($fields))->reduce(function (?string $key, FieldDefinitionNode $field): ?string {\n            if ($key) {\n                return $key;\n            }\n\n            $hasCacheKey = (new Collection($field->directives))\n                ->contains(function (DirectiveNode $directive): bool {\n                    return $directive->name->value === 'cacheKey';\n                });\n\n            return $hasCacheKey\n                ? $field->name->value\n                : $key;\n        });\n\n        if (! $nodeKey) {\n            $nodeKey = (new Collection($fields))->reduce(function (?string $key, FieldDefinitionNode $field): ?string {\n                if ($key) {\n                    return $key;\n                }\n\n                $typeName = ASTHelper::getUnderlyingTypeName($field);\n\n                return $typeName === 'ID'\n                    ? $field->name->value\n                    : $key;\n            });\n        }\n\n        if (! $nodeKey && $nodeValue->getTypeDefinitionName() !== 'Query') {\n            throw new DirectiveException(\n                \"No @cacheKey or ID field defined on {$nodeValue->getTypeDefinitionName()}\"\n            );\n        }\n\n        $nodeValue->setCacheKey($nodeKey);\n    }", "label": 2}
{"code": "public function setProperties($var)\n    {\n        $arr = GPBUtil::checkMapField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->properties = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function () {\n      var isNewProject = (this.composerOrig == undefined);\n      if (!isNewProject) {\n        // Use original composer file if project already generated.\n        this.composer = this.composerOrig;\n      }\n\n      this.composer.name = 'organization/' + options.projectName;\n      this.composer.description = options.projectDescription;\n      // Allow distros to modify the composer.json.\n      if (typeof options.drupalDistro.modifyComposer == 'function') {\n        var done = this.async();\n        options.drupalDistro.modifyComposer(options, this.composer, isNewProject, done, function(err, result, done) {\n          if (!err && result) {\n            this.composer = result;\n          }\n          else {\n            this.log.warning(\"Could not retrieve Octane's composer.json: \"  + err);\n            return done(err);\n          }\n          done();\n        }.bind(this));\n      }\n    }", "label": 3}
{"code": "func New(config Config) (*Cache, error) {\n\tif err := config.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\twrapper := backend.NewWrapper(config.Backend)\n\tctx, cancel := context.WithCancel(config.Context)\n\tcs := &Cache{\n\t\twrapper:            wrapper,\n\t\tctx:                ctx,\n\t\tcancel:             cancel,\n\t\tConfig:             config,\n\t\ttrustCache:         local.NewCAService(wrapper),\n\t\tclusterConfigCache: local.NewClusterConfigurationService(wrapper),\n\t\tprovisionerCache:   local.NewProvisioningService(wrapper),\n\t\tusersCache:         local.NewIdentityService(wrapper),\n\t\taccessCache:        local.NewAccessService(wrapper),\n\t\tpresenceCache:      local.NewPresenceService(wrapper),\n\t\teventsCache:        local.NewEventsService(config.Backend),\n\t\tEntry: log.WithFields(log.Fields{\n\t\t\ttrace.Component: config.Component,\n\t\t}),\n\t}\n\tcollections, err := setupCollections(cs, config.Watches)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tcs.collections = collections\n\n\terr = cs.fetch()\n\tif err != nil {\n\t\t// \"only recent\" behavior does not tolerate\n\t\t// stale data, so it has to initialize itself\n\t\t// with recent data on startup or fail\n\t\tif cs.OnlyRecent.Enabled {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t}\n\tgo cs.update()\n\treturn cs, nil\n}", "label": 5}
{"code": "func (c *Client) GenerateUserCert(key []byte, user string, ttl time.Duration, compatibility string) ([]byte, error) {\n\tout, err := c.PostJSON(c.Endpoint(\"ca\", \"user\", \"certs\"),\n\t\tgenerateUserCertReq{\n\t\t\tKey:           key,\n\t\t\tUser:          user,\n\t\t\tTTL:           ttl,\n\t\t\tCompatibility: compatibility,\n\t\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvar cert string\n\tif err := json.Unmarshal(out.Bytes(), &cert); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn []byte(cert), nil\n}", "label": 5}
{"code": "public void setValue(String constantValue)\r\n    {\r\n        this.fieldSource = SOURCE_VALUE;\r\n        this.fieldRefName = null;\r\n        this.returnedByProcedure = false;\r\n        this.constantValue = constantValue;\r\n    }", "label": 0}
{"code": "func (r *route) URLWith(args []string) string {\n\tif len(args) > 0 {\n\t\targCount := len(args)\n\t\ti := 0\n\t\turl := urlReg.ReplaceAllStringFunc(r.pattern, func(m string) string {\n\t\t\tvar val interface{}\n\t\t\tif i < argCount {\n\t\t\t\tval = args[i]\n\t\t\t} else {\n\t\t\t\tval = m\n\t\t\t}\n\t\t\ti += 1\n\t\t\treturn fmt.Sprintf(`%v`, val)\n\t\t})\n\n\t\treturn url\n\t}\n\treturn r.pattern\n}", "label": 5}
{"code": "def distinct(field_name, filter = nil, options = {})\n      View.new(self, filter || {}, options).distinct(field_name, options)\n    end", "label": 4}
{"code": "def next_migration_number(number)\n      if ActiveRecord::Base.timestamped_migrations\n        [Time.now.utc.strftime(\"%Y%m%d%H%M%S\"), \"%.14d\" % number].max\n      else\n        SchemaMigration.normalize_migration_number(number)\n      end\n    end", "label": 4}
{"code": "public static function createFromValues($year, $month, $day)\n    {\n        $value = sprintf('%s-%s-%s', $year, $month, $day);\n        $dt = \\DateTimeImmutable::createFromFormat(self::FORMAT, $value);\n\n        return new static($dt);\n    }", "label": 2}
{"code": "public static base_response add(nitro_service client, policymap resource) throws Exception {\n\t\tpolicymap addresource = new policymap();\n\t\taddresource.mappolicyname = resource.mappolicyname;\n\t\taddresource.sd = resource.sd;\n\t\taddresource.su = resource.su;\n\t\taddresource.td = resource.td;\n\t\taddresource.tu = resource.tu;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public function setPartitions($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Spanner\\V1\\Partition::class);\n        $this->partitions = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "protected static function parseIso8601($iso)\n    {\n        $result = [];\n\n        $interval = null;\n        $start = null;\n        $end = null;\n\n        foreach (explode('/', $iso) as $key => $part) {\n            if ($key === 0 && preg_match('/^R([0-9]*)$/', $part, $match)) {\n                $parsed = strlen($match[1]) ? (int) $match[1] : null;\n            } elseif ($interval === null && $parsed = CarbonInterval::make($part)) {\n                $interval = $part;\n            } elseif ($start === null && $parsed = Carbon::make($part)) {\n                $start = $part;\n            } elseif ($end === null && $parsed = Carbon::make(static::addMissingParts($start, $part))) {\n                $end = $part;\n            } else {\n                throw new InvalidArgumentException(\"Invalid ISO 8601 specification: $iso.\");\n            }\n\n            $result[] = $parsed;\n        }\n\n        return $result;\n    }", "label": 2}
{"code": "private Envelope getLayerEnvelope(ProxyLayerSupport layer) {\n\t\tBbox bounds = layer.getLayerInfo().getMaxExtent();\n\t\treturn new Envelope(bounds.getX(), bounds.getMaxX(), bounds.getY(), bounds.getMaxY());\n\t}", "label": 0}
{"code": "def __construct_from_components(self, ns_uri, prefix=None, schema_location=None):\n        \"\"\"Initialize this instance from a namespace URI, and optional\n        prefix and schema location URI.\"\"\"\n\n        assert ns_uri  # other fields are optional\n\n        self.uri = ns_uri\n        self.schema_location = schema_location or None\n        self.prefixes = OrderedSet()\n\n        if prefix:\n            self.prefixes.add(prefix)\n        self.preferred_prefix = prefix or None", "label": 1}
{"code": "func (f *Fpdf) GetAlpha() (alpha float64, blendModeStr string) {\n\treturn f.alpha, f.blendMode\n}", "label": 5}
{"code": "public static pqbinding[] get(nitro_service service, pqbinding_args args) throws Exception{\n\t\tpqbinding obj = new pqbinding();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tpqbinding[] response = (pqbinding[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def compile(*args)\n      unless environment\n        raise Error, \"manifest requires environment for compilation\"\n      end\n\n      filenames            = []\n      concurrent_exporters = []\n\n      assets_to_export = Concurrent::Array.new\n      find(*args) do |asset|\n        assets_to_export << asset\n      end\n\n      assets_to_export.each do |asset|\n        mtime = Time.now.iso8601\n        files[asset.digest_path] = {\n          'logical_path' => asset.logical_path,\n          'mtime'        => mtime,\n          'size'         => asset.bytesize,\n          'digest'       => asset.hexdigest,\n\n          # Deprecated: Remove beta integrity attribute in next release.\n          # Callers should DigestUtils.hexdigest_integrity_uri to compute the\n          # digest themselves.\n          'integrity'    => DigestUtils.hexdigest_integrity_uri(asset.hexdigest)\n        }\n        assets[asset.logical_path] = asset.digest_path\n\n        filenames << asset.filename\n\n        promise      = nil\n        exporters_for_asset(asset) do |exporter|\n          next if exporter.skip?(logger)\n\n          if promise.nil?\n            promise = Concurrent::Promise.new(executor: executor) { exporter.call }\n            concurrent_exporters << promise.execute\n          else\n            concurrent_exporters << promise.then { exporter.call }\n          end\n        end\n      end\n\n      # make sure all exporters have finished before returning the main thread\n      concurrent_exporters.each(&:wait!)\n      save\n\n      filenames\n    end", "label": 4}
{"code": "def owncloud():\n    '''Set up owncloud.\n\n    Package 'owncloud' pulls package 'mysql' which asks for a password.\n    '''\n    hostname = re.sub(r'^[^@]+@', '', env.host)  # without username if any\n    sitename = query_input(\n                   question='\\nEnter site-name of Your Owncloud web service',\n                   default=flo('owncloud.{hostname}'), color=cyan)\n    username = env.user\n\n    fabfile_data_dir = FABFILE_DATA_DIR\n\n    print(magenta(' install owncloud'))\n    repository = ''.join([\n        'http://download.opensuse.org/repositories/',\n        'isv:/ownCloud:/community/Debian_7.0/',\n    ])\n    with hide('output'):\n        sudo(flo('wget -O - {repository}Release.key | apt-key add -'))\n        filename = '/etc/apt/sources.list.d/owncloud.list'\n        sudo(flo(\"echo 'deb {repository} /' > {filename}\"))\n        sudo('apt-get update')\n    install_packages([\n        'owncloud',\n        'php5-fpm',\n        'php-apc',\n        'memcached',\n        'php5-memcache',\n    ])\n\n    # This server uses nginx. owncloud pulls apache2 => Disable apache2\n    print(magenta(' disable apache'))\n    with hide('output'):\n        sudo('service apache2 stop')\n        sudo('update-rc.d apache2 disable')\n\n    print(magenta(' nginx setup for owncloud'))\n    filename = 'owncloud_site_config.template'\n    path = flo('{fabfile_data_dir}/files/etc/nginx/sites-available/{filename}')\n    from_str = filled_out_template(path, username=username, sitename=sitename,\n                                   hostname=hostname)\n    with tempfile.NamedTemporaryFile(prefix=filename) as tmp_file:\n        with open(tmp_file.name, 'w') as fp:\n            fp.write(from_str)\n        put(tmp_file.name, flo('/tmp/{filename}'))\n    to = flo('/etc/nginx/sites-available/{sitename}')\n    sudo(flo('mv /tmp/{filename} {to}'))\n    sudo(flo('chown root.root {to}'))\n    sudo(flo('chmod 644 {to}'))\n    sudo(flo(' '.join([\n            'ln -snf ../sites-available/{sitename}',\n            '/etc/nginx/sites-enabled/{sitename}',\n    ])))\n\n    # php5 fpm fast-cgi config\n\n    template = 'www.conf'\n    to = flo('/etc/php5/fpm/pool.d/{template}')\n    from_ = flo('{fabfile_data_dir}/files{to}')\n    put(from_, '/tmp/')\n    sudo(flo('mv /tmp/{template} {to}'))\n    sudo(flo('chown root.root {to}'))\n    sudo(flo('chmod 644 {to}'))\n\n    template = 'php.ini'\n    to = flo('/etc/php5/fpm/{template}')\n    from_ = flo('{fabfile_data_dir}/files{to}')\n    put(from_, '/tmp/')\n    sudo(flo('mv /tmp/{template} {to}'))\n    sudo(flo('chown root.root {to}'))\n    sudo(flo('chmod 644 {to}'))\n\n    sudo('service php5-fpm restart')\n\n    sudo('service nginx reload')", "label": 1}
{"code": "public static String format(final String code, final Properties options, final LineEnding lineEnding) {\n\t\tCheck.notEmpty(code, \"code\");\n\t\tCheck.notEmpty(options, \"options\");\n\t\tCheck.notNull(lineEnding, \"lineEnding\");\n\n\t\tfinal CodeFormatter formatter = ToolFactory.createCodeFormatter(options);\n\t\tfinal String lineSeparator = LineEnding.find(lineEnding, code);\n\t\tTextEdit te = null;\n\t\ttry {\n\t\t\tte = formatter.format(CodeFormatter.K_COMPILATION_UNIT, code, 0, code.length(), 0, lineSeparator);\n\t\t} catch (final Exception formatFailed) {\n\t\t\tLOG.warn(\"Formatting failed\", formatFailed);\n\t\t}\n\n\t\tString formattedCode = code;\n\t\tif (te == null) {\n\t\t\tLOG.info(\"Code cannot be formatted. Possible cause is unmatched source/target/compliance version.\");\n\t\t} else {\n\n\t\t\tfinal IDocument doc = new Document(code);\n\t\t\ttry {\n\t\t\t\tte.apply(doc);\n\t\t\t} catch (final Exception e) {\n\t\t\t\tLOG.warn(e.getLocalizedMessage(), e);\n\t\t\t}\n\t\t\tformattedCode = doc.get();\n\t\t}\n\t\treturn formattedCode;\n\t}", "label": 0}
{"code": "def []=(name, value)\n      name = name.to_s\n      if name.include?(Constants::COLON)\n        raise ArgumentError, \"Header names may not contain a colon: #{name.inspect}\"\n      end\n\n      name = Utilities.dasherize(name)\n\n      # Assign nil to delete the field\n      if value.nil?\n        fields.delete_field name\n      else\n        fields.add_field Field.new(name.to_s, value, charset)\n\n        # Update charset if specified in Content-Type\n        if name == 'content-type'\n          params = self[:content_type].parameters rescue nil\n          @charset = params[:charset] if params && params[:charset]\n        end\n      end\n    end", "label": 4}
{"code": "function () {\n            var me = this;\n            if (me._readNotWriting) {\n                me._readNotWriting = false;\n                me._readWriteToOutput().then(undefined, function (reason) {\n                    me._readReject(reason);\n                });\n            }\n        }", "label": 3}
{"code": "public static Document readDocumentFromString(String s) throws Exception {\r\n    InputSource in = new InputSource(new StringReader(s));\r\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n    factory.setNamespaceAware(false);\r\n    return factory.newDocumentBuilder().parse(in);\r\n  }", "label": 0}
{"code": "def process_complaint(message, notification):\n    \"\"\"Function to process a complaint notification\"\"\"\n    mail = message['mail']\n    complaint = message['complaint']\n\n    if 'arrivalDate' in complaint:\n        arrival_date = clean_time(complaint['arrivalDate'])\n    else:\n        arrival_date = None\n\n    complaints = []\n    for recipient in complaint['complainedRecipients']:\n        # Create each Complaint. Save in a list for reference later.\n        complaints += [Complaint.objects.create(\n            sns_topic=notification['TopicArn'],\n            sns_messageid=notification['MessageId'],\n            mail_timestamp=clean_time(mail['timestamp']),\n            mail_id=mail['messageId'],\n            mail_from=mail['source'],\n            address=recipient['emailAddress'],\n            feedback_id=complaint['feedbackId'],\n            feedback_timestamp=clean_time(complaint['timestamp']),\n            useragent=complaint.get('userAgent'),\n            feedback_type=complaint.get('complaintFeedbackType'),\n            arrival_date=arrival_date\n        )]\n\n    # Send signals for each complaint.\n    for complaint in complaints:\n        signals.feedback.send(\n            sender=Complaint,\n            instance=complaint,\n            message=message,\n            notification=notification\n        )\n\n    logger.info('Logged %s Complaint(s)', str(len(complaints)))\n\n    return HttpResponse('Complaint Processed')", "label": 1}
{"code": "public static dnsaddrec get(nitro_service service, String hostname) throws Exception{\n\t\tdnsaddrec obj = new dnsaddrec();\n\t\tobj.set_hostname(hostname);\n\t\tdnsaddrec response = (dnsaddrec) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def get(*args)\n      raise_authentication_error unless authenticated?\n      arguments(args, required: [:id])\n\n      get_request(\"/authorizations/#{arguments.id}\", arguments.params)\n    end", "label": 4}
{"code": "func (c *Client) GetUser(name string) (services.User, error) {\n\tif name == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing username\")\n\t}\n\tout, err := c.Get(c.Endpoint(\"users\", name), url.Values{})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tuser, err := services.GetUserMarshaler().UnmarshalUser(out.Bytes(), services.SkipValidation())\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn user, nil\n}", "label": 5}
{"code": "public function setCloudStoragePath($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\CloudStoragePath::class);\n        $this->writeOneof(3, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public ObjectReferenceDescriptor getObjectReferenceDescriptorByName(String name)\r\n    {\r\n        ObjectReferenceDescriptor ord = (ObjectReferenceDescriptor)\r\n            getObjectReferenceDescriptorsNameMap().get(name);\r\n\r\n        //\r\n        // BRJ: if the ReferenceDescriptor is not found\r\n        // look in the ClassDescriptor referenced by 'super' for it\r\n        //\r\n        if (ord == null)\r\n        {\r\n            ClassDescriptor superCld = getSuperClassDescriptor();\r\n            if (superCld != null)\r\n            {\r\n                ord = superCld.getObjectReferenceDescriptorByName(name);\r\n            }\r\n        }\r\n        return ord;\r\n    }", "label": 0}
{"code": "public static base_response update(nitro_service client, nstimeout resource) throws Exception {\n\t\tnstimeout updateresource = new nstimeout();\n\t\tupdateresource.zombie = resource.zombie;\n\t\tupdateresource.client = resource.client;\n\t\tupdateresource.server = resource.server;\n\t\tupdateresource.httpclient = resource.httpclient;\n\t\tupdateresource.httpserver = resource.httpserver;\n\t\tupdateresource.tcpclient = resource.tcpclient;\n\t\tupdateresource.tcpserver = resource.tcpserver;\n\t\tupdateresource.anyclient = resource.anyclient;\n\t\tupdateresource.anyserver = resource.anyserver;\n\t\tupdateresource.halfclose = resource.halfclose;\n\t\tupdateresource.nontcpzombie = resource.nontcpzombie;\n\t\tupdateresource.reducedfintimeout = resource.reducedfintimeout;\n\t\tupdateresource.newconnidletimeout = resource.newconnidletimeout;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "function prepareElement() {\n\n        $ELEMENT.\n\n            // Store the picker data by component name.\n            data(NAME, P).\n\n            // Add the \u201cinput\u201d class name.\n            addClass(CLASSES.input).\n\n            // Remove the tabindex.\n            attr('tabindex', -1).\n\n            // If there\u2019s a `data-value`, update the value of the element.\n            val( $ELEMENT.data('value') ?\n                P.get('select', SETTINGS.format) :\n                ELEMENT.value\n            )\n\n\n        // Only bind keydown events if the element isn\u2019t editable.\n        if ( !SETTINGS.editable ) {\n\n            $ELEMENT.\n\n                // On focus/click, focus onto the root to open it up.\n                on( 'focus.' + STATE.id + ' click.' + STATE.id, function( event ) {\n                    event.preventDefault()\n                    P.$root[0].focus()\n                }).\n\n                // Handle keyboard event based on the picker being opened or not.\n                on( 'keydown.' + STATE.id, handleKeydownEvent )\n        }\n\n\n        // Update the aria attributes.\n        aria(ELEMENT, {\n            haspopup: true,\n            expanded: false,\n            readonly: false,\n            owns: ELEMENT.id + '_root'\n        })\n    }", "label": 3}
{"code": "def teardown(self):\n        \"\"\"\n        Stop and remove the container if it exists.\n        \"\"\"\n        while self._http_clients:\n            self._http_clients.pop().close()\n        if self.created:\n            self.halt()", "label": 1}
{"code": "function reduceSet(set) {\n  return set.map(member => member && member.uri).filter(Boolean)\n}", "label": 3}
{"code": "def trackable?(uri)\n      uri && uri.absolute? && %w(http https).include?(uri.scheme)\n    end", "label": 4}
{"code": "public function GetIamPolicy(\\Google\\Cloud\\Iam\\V1\\GetIamPolicyRequest $argument,\n      $metadata = [], $options = []) {\n        return $this->_simpleRequest('/google.spanner.admin.database.v1.DatabaseAdmin/GetIamPolicy',\n        $argument,\n        ['\\Google\\Cloud\\Iam\\V1\\Policy', 'decode'],\n        $metadata, $options);\n    }", "label": 2}
{"code": "function checkIfSentvaluesAreSufficient(req,dbField) {\n    if(dbField.Default == 'FILE') {\n        //For 'File' fields just return the link ot the file\n        if(req.files.hasOwnProperty(dbField.Field)) {\n\n            var file = req.files[dbField.Field].hasOwnProperty('name') ? req.files[dbField.Field] : req.files[dbField.Field][0];\n\n            if(settings.maxFileSize !== -1 && file.size > settings.maxFileSize) {\n                return false;\n            }\n\n            return file.name;\n\n        } else {\n            return false;\n        }\n    } else {\n        if (req.body[dbField.Field] === null || typeof req.body[dbField.Field] == \"undefined\") {\n            return dbField.Null == \"YES\" ? null : false;\n        }\n        //Normle Werte\n        if((dbField.Type.indexOf(\"int\") != -1 || dbField.Type.indexOf(\"float\") != -1 || dbField.Type.indexOf(\"double\") != -1 )) {\n            return !isNaN(req.body[dbField.Field]) ? req.body[dbField.Field] : false;\n        } else if(typeof req.body[dbField.Field] === 'string') {\n            return escape(req.body[dbField.Field]);\n        }\n        return false;\n    }\n}", "label": 3}
{"code": "public function setState($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Dataproc\\V1\\WorkflowMetadata_State::class);\n        $this->state = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function setState($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Vision\\V1\\OperationMetadata_State::class);\n        $this->state = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def update_catalogs_if_needed(catalogs, templates)\n      needs_update = templates.any? {|template| template.type == TemplateDeclarationType::CATALOG_TEMPLATE}\n\n      return unless needs_update\n\n      terminator = CatalogTerminator.new\n      terminator.remove_all_catalogs\n      puts('Updating shared generamba-catalog specs...')\n      @catalog_downloader.download_catalog(GENERAMBA_CATALOG_NAME, RAMBLER_CATALOG_REPO)\n\n      return unless catalogs != nil && catalogs.count > 0\n\n      catalogs.each do |catalog_url|\n        catalog_name = catalog_url.split('://').last\n        catalog_name = catalog_name.gsub('/', '-');\n        puts(\"Updating #{catalog_name} specs...\")\n        @catalog_downloader.download_catalog(catalog_name, catalog_url)\n      end\n    end", "label": 4}
{"code": "public function createFolder()\n    {\n        if ($this->storage->exists($this)) {\n            return false;\n        }\n\n        $this->storage->makeDirectory(0777, true, true);\n    }", "label": 2}
{"code": "public function setMasterAuth($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Container\\V1\\MasterAuth::class);\n        $this->master_auth = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function dispatch(Request $request)\n    {\n        $this->currentRoute = null;\n\n        $this->container->instance(Request::class, $request);\n\n        $this->routesDispatched++;\n\n        try {\n            $response = $this->adapter->dispatch($request, $request->version());\n        } catch (Exception $exception) {\n            if ($request instanceof InternalRequest) {\n                throw $exception;\n            }\n\n            $this->exception->report($exception);\n\n            $response = $this->exception->handle($exception);\n        }\n\n        return $this->prepareResponse($response, $request, $request->format());\n    }", "label": 2}
{"code": "def _prepare_defaults(self):\n\t\t\"\"\"Trigger assignment of default values.\"\"\"\n\t\t\n\t\tfor name, field in self.__fields__.items():\n\t\t\tif field.assign:\n\t\t\t\tgetattr(self, name)", "label": 1}
{"code": "public static nsacl6_stats[] get(nitro_service service) throws Exception{\n\t\tnsacl6_stats obj = new nsacl6_stats();\n\t\tnsacl6_stats[] response = (nsacl6_stats[])obj.stat_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function setOriginalMediaType($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Speech\\V1p1beta1\\RecognitionMetadata_OriginalMediaType::class);\n        $this->original_media_type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def opf(wobj)\n      s = @epub.opf\n      if !s.nil? && !wobj.nil?\n        wobj.puts s\n      end\n    end", "label": 4}
{"code": "func (c *crontime) nextValidDay(baseTime time.Time) {\n\tfor _, dom := range c.dom {\n\t\tif dom >= c.calculatedTime.Day() {\n\t\t\tfor _, dow := range c.dow {\n\t\t\t\tif monthHasDow(dow, dom, int(c.calculatedTime.Month()), c.calculatedTime.Year()) {\n\t\t\t\t\tc.calculatedTime = setDay(c.calculatedTime, dom)\n\t\t\t\t\t//log.Println(\"Cronbee: Day-INS-1:\", c.calculatedTime)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} /* else {\n\t\tfor _, dow := range c.dow {\n\t\t\tif monthHasDow(dow, dom, int(c.calculatedTime.Month()), c.calculatedTime.Year()){\n\t\t\t\tc.calculatedTime = setDay(c.calculatedTime, dom)\n\t\t\t\tlog.Println(\"Cronbee: Day-INS-2:\", c.calculatedTime)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}*/\n\t// If no result was found try it again in the following month.\n\tc.calculatedTime = c.calculatedTime.AddDate(0, 1, 0)\n\tc.calculatedTime = setDay(c.calculatedTime, c.dom[0])\n\t//log.Println(\"Cronbee: Day\", c.calculatedTime, baseTime)\n\tc.nextValidMonth(baseTime)\n\tc.nextValidDay(baseTime)\n}", "label": 5}
{"code": "func (l *localFileSystem) MkDir(path string, mode int) error {\n\tfileMode := os.FileMode(mode & int(os.ModePerm))\n\terr := os.MkdirAll(path, fileMode)\n\tif err != nil && !os.IsExist(err) {\n\t\treturn trace.ConvertSystemError(err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public static <IN extends CoreMap> CRFClassifier<IN> getClassifier(File file) throws IOException, ClassCastException,\r\n      ClassNotFoundException {\r\n    CRFClassifier<IN> crf = new CRFClassifier<IN>();\r\n    crf.loadClassifier(file);\r\n    return crf;\r\n  }", "label": 0}
{"code": "func RelAppRootfsPath(appName types.ACName) string {\n\treturn filepath.Join(RelAppPath(appName), aci.RootfsDir)\n}", "label": 5}
{"code": "func RetrieveProperties(ctx context.Context, r soap.RoundTripper, pc, obj types.ManagedObjectReference, dst interface{}) error {\n\treq := types.RetrieveProperties{\n\t\tThis: pc,\n\t\tSpecSet: []types.PropertyFilterSpec{\n\t\t\t{\n\t\t\t\tObjectSet: []types.ObjectSpec{\n\t\t\t\t\t{\n\t\t\t\t\t\tObj:  obj,\n\t\t\t\t\t\tSkip: types.NewBool(false),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPropSet: []types.PropertySpec{\n\t\t\t\t\t{\n\t\t\t\t\t\tAll:  types.NewBool(true),\n\t\t\t\t\t\tType: obj.Type,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\treturn RetrievePropertiesForRequest(ctx, r, req, dst)\n}", "label": 5}
{"code": "def list_tables(self):\n        \"\"\"\n        Runs the ``\\\\dt`` command and returns a list of column values with\n        information about all tables in the database.\n        \"\"\"\n        lines = output_lines(self.exec_psql('\\\\dt'))\n        return [line.split('|') for line in lines]", "label": 1}
{"code": "def normalized_query(*flags)\n      return nil unless self.query\n      return @normalized_query if defined?(@normalized_query)\n      @normalized_query ||= begin\n        modified_query_class = Addressable::URI::CharacterClasses::QUERY.dup\n        # Make sure possible key-value pair delimiters are escaped.\n        modified_query_class.sub!(\"\\\\&\", \"\").sub!(\"\\\\;\", \"\")\n        pairs = (self.query || \"\").split(\"&\", -1)\n        pairs.sort! if flags.include?(:sorted)\n        component = pairs.map do |pair|\n          Addressable::URI.normalize_component(pair, modified_query_class, \"+\")\n        end.join(\"&\")\n        component == \"\" ? nil : component\n      end\n      # All normalized values should be UTF-8\n      @normalized_query.force_encoding(Encoding::UTF_8) if @normalized_query\n      @normalized_query\n    end", "label": 4}
{"code": "public function UpdateJob(\\Google\\Cloud\\Talent\\V4beta1\\UpdateJobRequest $argument,\n      $metadata = [], $options = []) {\n        return $this->_simpleRequest('/google.cloud.talent.v4beta1.JobService/UpdateJob',\n        $argument,\n        ['\\Google\\Cloud\\Talent\\V4beta1\\Job', 'decode'],\n        $metadata, $options);\n    }", "label": 2}
{"code": "def put(path, options = {}, &block)\n      perform_request Net::HTTP::Put, path, options, &block\n    end", "label": 4}
{"code": "function(str, opt_obj) {\n    var dst = opt_obj || {};\n    try {\n      var q = str.indexOf(\"?\");\n      var e = str.indexOf(\"#\");\n      if (e < 0) {\n        e = str.length;\n      }\n      var query = str.substring(q + 1, e);\n      searchStringToObject(query, dst);\n    } catch (e) {\n      console.error(e);\n    }\n    return dst;\n  }", "label": 3}
{"code": "private void parseResponse(InputStream inputStream) {\n\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputStream);\n            doc.getDocumentElement().normalize();\n\n            NodeList nodes = doc.getElementsByTagName(\"place\");\n\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element element = (Element) node;\n                    _woeid = getValue(\"woeid\", element);\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }", "label": 0}
{"code": "def literal_key(key)\n      case key\n      when TrueClass  then \"'t'\"\n      when FalseClass then \"'f'\"\n      when Numeric    then key\n      else\n        key = key.to_s\n        key.start_with?(\"'\") && key.end_with?(\"'\") ? key : \"'#{key}'\"\n      end\n    end", "label": 4}
{"code": "public static aaauser_auditsyslogpolicy_binding[] get(nitro_service service, String username) throws Exception{\n\t\taaauser_auditsyslogpolicy_binding obj = new aaauser_auditsyslogpolicy_binding();\n\t\tobj.set_username(username);\n\t\taaauser_auditsyslogpolicy_binding response[] = (aaauser_auditsyslogpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static base_responses disable(nitro_service client, String acl6name[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (acl6name != null && acl6name.length > 0) {\n\t\t\tnsacl6 disableresources[] = new nsacl6[acl6name.length];\n\t\t\tfor (int i=0;i<acl6name.length;i++){\n\t\t\t\tdisableresources[i] = new nsacl6();\n\t\t\t\tdisableresources[i].acl6name = acl6name[i];\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, disableresources,\"disable\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "private function findRootAlias($alias, $parentAlias)\n    {\n        $rootAlias = null;\n\n        if (in_array($parentAlias, $this->getRootAliases(), true)) {\n            $rootAlias = $parentAlias;\n        } elseif (isset($this->joinRootAliases[$parentAlias])) {\n            $rootAlias = $this->joinRootAliases[$parentAlias];\n        } else {\n            // Should never happen with correct joining order. Might be\n            // thoughtful to throw exception instead.\n            $rootAlias = $this->getRootAlias();\n        }\n\n        $this->joinRootAliases[$alias] = $rootAlias;\n\n        return $rootAlias;\n    }", "label": 2}
{"code": "function (options, cb, wd, params) {\n      // if no cb is given, generate a body with the `desiredCapabilities` object\n      if (!cb) {\n        // check if we have parameters set up\n        if (Object.keys(params).length > 0) {\n          return JSON.stringify(params);\n        }\n        return '';\n      }\n\n      // invoke the given callback & stringify\n      var data = cb.call(wd, params);\n      return data === null ? '{}' : JSON.stringify(data);\n    }", "label": 3}
{"code": "func (self *Queue) WritePacket(pkt av.Packet) (err error) {\n\tself.lock.Lock()\n\n\tself.buf.Push(pkt)\n\tif pkt.Idx == int8(self.videoidx) && pkt.IsKeyFrame {\n\t\tself.curgopcount++\n\t}\n\n\tfor self.curgopcount >= self.maxgopcount && self.buf.Count > 1 {\n\t\tpkt := self.buf.Pop()\n\t\tif pkt.Idx == int8(self.videoidx) && pkt.IsKeyFrame {\n\t\t\tself.curgopcount--\n\t\t}\n\t\tif self.curgopcount < self.maxgopcount {\n\t\t\tbreak\n\t\t}\n\t}\n\t//println(\"shrink\", self.curgopcount, self.maxgopcount, self.buf.Head, self.buf.Tail, \"count\", self.buf.Count, \"size\", self.buf.Size)\n\n\tself.cond.Broadcast()\n\n\tself.lock.Unlock()\n\treturn\n}", "label": 5}
{"code": "function getStatusUpdater(connections, isAsync) {\n  return function updateExportStatus(statusUpdate, cb) {\n    cb = cb || _.noop;\n    if (isAsync) {\n      updateCSVExportStatus(connections, statusUpdate, cb);\n    } else {\n      return cb();\n    }\n  };\n}", "label": 3}
{"code": "def run_validators(self, values):\n        \"\"\"Run validators for each item separately.\"\"\"\n        for val in values:\n            super(CommaSepFloatField, self).run_validators(val)", "label": 1}
{"code": "public static <T extends InterconnectObject> T fromJson(String data, Class<T> clazz) throws IOException {\n        return InterconnectMapper.mapper.readValue(data, clazz);\n    }", "label": 0}
{"code": "public function componentsExtra($componentId = null)\n    {\n        $components = $this->components ?: $this->loadComponents();\n\n        array_walk($components, function (&$component) {\n            $name = $component['composer']['name'];\n            $component = $component['composer']['extra']['component'];\n            $component['displayName'] = $name;\n        });\n\n        return $componentId\n            ? [$componentId => $components[$componentId]]\n            : $components;\n    }", "label": 2}
{"code": "func calculateCAPin(client auth.ClientI) (string, error) {\n\tlocalCA, err := client.GetClusterCACert()\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\ttlsCA, err := tlsca.ParseCertificatePEM(localCA.TLSCA)\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\n\treturn utils.CalculateSPKI(tlsCA), nil\n}", "label": 5}
{"code": "public static function wildcardString($str, $wildcard, $lowercase = true)\n    {\n        $wild  = $wildcard;\n        $chars = preg_split('//u', $str, -1, PREG_SPLIT_NO_EMPTY);\n\n        if (count($chars) > 0) {\n            foreach ($chars as $char) {\n                $wild .= $char . $wildcard;\n            }\n        }\n\n        if ($lowercase) {\n            $wild = Str::lower($wild);\n        }\n\n        return $wild;\n    }", "label": 2}
{"code": "func asFloat(param string) float64 {\n\n\ti, err := strconv.ParseFloat(param, 64)\n\tpanicIf(err)\n\n\treturn i\n}", "label": 5}
{"code": "public void lock(Object obj, int lockMode) throws LockNotGrantedException\r\n    {\r\n        if (log.isDebugEnabled()) log.debug(\"lock object was called on tx \" + this + \", object is \" + obj.toString());\r\n        checkOpen();\r\n        RuntimeObject rtObject = new RuntimeObject(obj, this);\r\n        lockAndRegister(rtObject, lockMode, isImplicitLocking(), getRegistrationList());\r\n//        if(isImplicitLocking()) moveToLastInOrderList(rtObject.getIdentity());\r\n    }", "label": 0}
{"code": "function createVpcNetwork(mCb) {\n\t\t\tlet networksOptions = Object.assign({}, options);\n\t\t\tnetworksOptions.params = {\n\t\t\t\tname,\n\t\t\t\treturnGlobalOperation: true\n\t\t\t};\n\t\t\tnetworks.add(networksOptions, (error, globalOperationResponse) => {\n\t\t\t\tif (error) return cb(error);\n\t\t\t\t\n\t\t\t\t//assign network name to deployment entry\n\t\t\t\toneDeployment.options.network = name;\n\t\t\t\t\n\t\t\t\t//check if network is ready then update firewall rules\n\t\t\t\tcheckVpcNetwork(globalOperationResponse, mCb);\n\t\t\t});\n\t\t\t\n\t\t\tfunction checkVpcNetwork(globalOperationResponse, mCb) {\n\t\t\t\t\n\t\t\t\tfunction globalOperations(miniCB) {\n\t\t\t\t\toptions.soajs.log.debug(\"Checking network Create Status\");\n\t\t\t\t\t//Ref https://cloud.google.com/compute/docs/reference/latest/globalOperations/get\n\t\t\t\t\tlet request = getConnector(options.infra.api);\n\t\t\t\t\tdelete request.projectId;\n\t\t\t\t\trequest.operation = globalOperationResponse.name;\n\t\t\t\t\tv1Compute().globalOperations.get(request, (error, response) => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn miniCB(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!response || response.status !== \"DONE\") {\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tglobalOperations(miniCB);\n\t\t\t\t\t\t\t}, (process.env.SOAJS_CLOOSTRO_TEST) ? 1 : 5000);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn miniCB(null, response);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tglobalOperations(function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn mCb(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Ref: https://cloud.google.com/compute/docs/reference/latest/firewalls/insert\n\t\t\t\t\t\tlet firewallRules = getFirewallRules(oneDeployment.options.network);\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet request = getConnector(options.infra.api);\n\t\t\t\t\t\tasync.eachSeries(firewallRules, (oneRule, vCb) => {\n\t\t\t\t\t\t\toptions.soajs.log.debug(\"Registering new firewall rule:\", oneRule.name);\n\t\t\t\t\t\t\trequest.resource = oneRule;\n\t\t\t\t\t\t\tv1Compute().firewalls.insert(request, vCb);\n\t\t\t\t\t\t}, mCb);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}\n\t\t}", "label": 3}
{"code": "public static nd6ravariables get(nitro_service service, Long vlan) throws Exception{\n\t\tnd6ravariables obj = new nd6ravariables();\n\t\tobj.set_vlan(vlan);\n\t\tnd6ravariables response = (nd6ravariables) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "async def load_message(obj, msg_type, msg=None, field_archiver=None):\n    \"\"\"\n    Loads message if the given type from the object.\n    Supports reading directly to existing message.\n\n    :param obj:\n    :param msg_type:\n    :param msg:\n    :param field_archiver:\n    :return:\n    \"\"\"\n    msg = msg_type() if msg is None else msg\n\n    fields = msg_type.f_specs() if msg_type else msg.__class__.f_specs()\n    for field in fields:\n        await load_message_field(obj, msg, field, field_archiver=field_archiver)\n\n    return msg", "label": 1}
{"code": "public function reload(array $options = [])\n    {\n        return $this->info = $this->connection->getSubscription($options + [\n            'subscription' => $this->name\n        ]);\n    }", "label": 2}
{"code": "def smooth_rectangle(x, y, rec_w, rec_h, gaussian_width_x, gaussian_width_y):\n    \"\"\"\n    Rectangle with a solid central region, then Gaussian fall-off at the edges.\n    \"\"\"\n\n    gaussian_x_coord = abs(x)-rec_w/2.0\n    gaussian_y_coord = abs(y)-rec_h/2.0\n\n    box_x=np.less(gaussian_x_coord,0.0)\n    box_y=np.less(gaussian_y_coord,0.0)\n    sigmasq_x=gaussian_width_x*gaussian_width_x\n    sigmasq_y=gaussian_width_y*gaussian_width_y\n\n    with float_error_ignore():\n        falloff_x=x*0.0 if sigmasq_x==0.0 else \\\n            np.exp(np.divide(-gaussian_x_coord*gaussian_x_coord,2*sigmasq_x))\n        falloff_y=y*0.0 if sigmasq_y==0.0 else \\\n            np.exp(np.divide(-gaussian_y_coord*gaussian_y_coord,2*sigmasq_y))\n\n    return np.minimum(np.maximum(box_x,falloff_x), np.maximum(box_y,falloff_y))", "label": 1}
{"code": "public Class getPersistentFieldClass()\r\n    {\r\n        if (m_persistenceClass == null)\r\n        {\r\n            Properties properties = new Properties();\r\n            try\r\n            {\r\n                this.logWarning(\"Loading properties file: \" + getPropertiesFile());\r\n                properties.load(new FileInputStream(getPropertiesFile()));\r\n            }\r\n            catch (IOException e)\r\n            {\r\n                this.logWarning(\"Could not load properties file '\" + getPropertiesFile()\r\n                        + \"'. Using PersistentFieldDefaultImpl.\");\r\n                e.printStackTrace();\r\n            }\r\n            try\r\n            {\r\n                String className = properties.getProperty(\"PersistentFieldClass\");\r\n\r\n                m_persistenceClass = loadClass(className);\r\n            }\r\n            catch (ClassNotFoundException e)\r\n            {\r\n                e.printStackTrace();\r\n                m_persistenceClass = PersistentFieldPrivilegedImpl.class;\r\n            }\r\n            logWarning(\"PersistentFieldClass: \" + m_persistenceClass.toString());\r\n        }\r\n        return m_persistenceClass;\r\n    }", "label": 0}
{"code": "public String getPrefixStatsIntersectionPrefixAttribute(String field) {\n    if (intersectingPrefixes.containsKey(field)) {\n      return String.join(MtasToken.DELIMITER, intersectingPrefixes.get(field));\n    } else {\n      return \"\";\n    }\n  }", "label": 0}
{"code": "def draw_cell(self, row, col, val):\n        \"\"\"\n        draw a cell as position row, col containing val\n        \"\"\"\n        if val == 'T':\n            self.paint_target(row,col)\n        elif val == '#':\n            self.paint_block(row,col)\n        elif val == 'X':\n            self.paint_hill(row,col)\n        elif val == '.':\n            self.paint_land(row,col)\n        elif val in ['A']:\n            self.paint_agent_location(row,col)\n        elif val in ['1','2','3','4','5','6','7','8','9']:\n            self.paint_agent_trail(row,col, val)", "label": 1}
{"code": "private void doExecute(Connection conn) throws SQLException\r\n    {\r\n        PreparedStatement stmt;\r\n        int size;\r\n\r\n        size = _methods.size();\r\n        if ( size == 0 )\r\n        {\r\n            return;\r\n        }\r\n        stmt = conn.prepareStatement(_sql);\r\n        try\r\n        {\r\n            m_platform.afterStatementCreate(stmt);\r\n        }\r\n        catch ( PlatformException e )\r\n        {\r\n            if ( e.getCause() instanceof SQLException )\r\n            {\r\n                throw (SQLException)e.getCause();\r\n            }\r\n            else\r\n            {\r\n                throw new SQLException(e.getMessage());\r\n            }\r\n        }\r\n        try\r\n        {\r\n            m_platform.beforeBatch(stmt);\r\n        }\r\n        catch ( PlatformException e )\r\n        {\r\n            if ( e.getCause() instanceof SQLException )\r\n            {\r\n                throw (SQLException)e.getCause();\r\n            }\r\n            else\r\n            {\r\n                throw new SQLException(e.getMessage());\r\n            }\r\n        }\r\n        try\r\n        {\r\n            for ( int i = 0; i < size; i++ )\r\n            {\r\n                Method method = (Method) _methods.get(i);\r\n                try\r\n                {\r\n                    if ( method.equals(ADD_BATCH) )\r\n                    {\r\n                        /**\r\n                         * we invoke on the platform and pass the stmt as an arg.\r\n                         */\r\n                        m_platform.addBatch(stmt);\r\n                    }\r\n                    else\r\n                    {\r\n                        method.invoke(stmt, (Object[]) _params.get(i));\r\n                    }\r\n                }\r\n                catch (IllegalArgumentException ex)\r\n                {\r\n\t\t\t\t\tStringBuffer buffer = generateExceptionMessage(i, stmt, ex);\r\n\t\t\t\t\tthrow new SQLException(buffer.toString());\r\n                }\r\n                catch ( IllegalAccessException ex )\r\n                {\r\n\t\t\t\t\tStringBuffer buffer = generateExceptionMessage(i, stmt, ex);\r\n                    throw new SQLException(buffer.toString());\r\n                }\r\n                catch ( InvocationTargetException ex )\r\n                {\r\n                    Throwable th = ex.getTargetException();\r\n\r\n                    if ( th == null )\r\n                    {\r\n                        th = ex;\r\n                    }\r\n                    if ( th instanceof SQLException )\r\n                    {\r\n                        throw ((SQLException) th);\r\n                    }\r\n                    else\r\n                    {\r\n                        throw new SQLException(th.toString());\r\n                    }\r\n                }\r\n\t\t\t\tcatch (PlatformException e)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new SQLException(e.toString());\r\n\t\t\t\t}\r\n            }\r\n            try\r\n            {\r\n                /**\r\n                 * this will call the platform specific call\r\n                 */\r\n                m_platform.executeBatch(stmt);\r\n            }\r\n            catch ( PlatformException e )\r\n            {\r\n                if ( e.getCause() instanceof SQLException )\r\n                {\r\n                    throw (SQLException)e.getCause();\r\n                }\r\n                else\r\n                {\r\n                    throw new SQLException(e.getMessage());\r\n                }\r\n            }\r\n\r\n        }\r\n        finally\r\n        {\r\n            stmt.close();\r\n            _methods.clear();\r\n            _params.clear();\r\n        }\r\n    }", "label": 0}
{"code": "func (t *Torrent) onIncompletePiece(piece pieceIndex) {\n\tif t.pieceAllDirty(piece) {\n\t\tt.pendAllChunkSpecs(piece)\n\t}\n\tif !t.wantPieceIndex(piece) {\n\t\t// t.logger.Printf(\"piece %d incomplete and unwanted\", piece)\n\t\treturn\n\t}\n\t// We could drop any connections that we told we have a piece that we\n\t// don't here. But there's a test failure, and it seems clients don't care\n\t// if you request pieces that you already claim to have. Pruning bad\n\t// connections might just remove any connections that aren't treating us\n\t// favourably anyway.\n\n\t// for c := range t.conns {\n\t// \tif c.sentHave(piece) {\n\t// \t\tc.Drop()\n\t// \t}\n\t// }\n\tfor conn := range t.conns {\n\t\tif conn.PeerHasPiece(piece) {\n\t\t\tconn.updateRequests()\n\t\t}\n\t}\n}", "label": 5}
{"code": "def cache(key, options = {}, &block) # :doc:\n        if cache_configured?\n          cache_store.fetch(ActiveSupport::Cache.expand_cache_key(key, :controller), options, &block)\n        else\n          yield\n        end\n      end", "label": 4}
{"code": "def _advance_new_study_id(self):\n        \"\"\" ASSUMES the caller holds the _doc_counter_lock !\n        Returns the current numeric part of the next study ID, advances\n        the counter to the next value, and stores that value in the\n        file in case the server is restarted.\n        \"\"\"\n        c = self._next_study_id\n        self._next_study_id = 1 + c\n        content = u'{\"next_study_id\": %d}\\n' % self._next_study_id\n        # The content is JSON, but we hand-rolled the string above\n        #       so that we can use it as a commit_msg\n        self._write_master_branch_resource(content,\n                                           self._id_minting_file,\n                                           commit_msg=content,\n                                           is_json=False)\n        return c", "label": 1}
{"code": "func (*TeleportTunnelMarshaler) UnmarshalReverseTunnel(bytes []byte, opts ...MarshalOption) (ReverseTunnel, error) {\n\treturn UnmarshalReverseTunnel(bytes, opts...)\n}", "label": 5}
{"code": "public function keySetObject()\n    {\n        $ranges = [];\n        foreach ($this->ranges as $range) {\n            $ranges[] = $range->keyRangeObject();\n        }\n\n        $set = [];\n\n        if ($this->all) {\n            $set['all'] = true;\n        }\n\n        if ($this->keys) {\n            $set['keys'] = $this->keys;\n        }\n\n        if ($ranges) {\n            $set['ranges'] = $ranges;\n        }\n\n        return $set;\n    }", "label": 2}
{"code": "func (f *Fpdf) AddSpotColor(nameStr string, c, m, y, k byte) {\n\tif f.err == nil {\n\t\t_, ok := f.spotColorMap[nameStr]\n\t\tif !ok {\n\t\t\tid := len(f.spotColorMap) + 1\n\t\t\tf.spotColorMap[nameStr] = spotColorType{\n\t\t\t\tid: id,\n\t\t\t\tval: cmykColorType{\n\t\t\t\t\tc: byteBound(c),\n\t\t\t\t\tm: byteBound(m),\n\t\t\t\t\ty: byteBound(y),\n\t\t\t\t\tk: byteBound(k),\n\t\t\t\t},\n\t\t\t}\n\t\t} else {\n\t\t\tf.err = fmt.Errorf(\"name \\\"%s\\\" is already associated with a spot color\", nameStr)\n\t\t}\n\t}\n}", "label": 5}
{"code": "def create_item(location_id, body, opts = {})\n      data, _status_code, _headers = create_item_with_http_info(location_id, body, opts)\n      return data\n    end", "label": 4}
{"code": "def mtx_refl(nv, reps=1):\n    \"\"\" Generate block-diagonal reflection matrix about nv.\n\n    reps must be >=1 and indicates the number of times the reflection\n    matrix should be repeated along the block diagonal.  Typically this\n    will be the number of atoms in a geometry.\n\n    .. todo:: Complete mtx_refl docstring\n\n    \"\"\"\n\n    # Imports\n    import numpy as np\n    from scipy import linalg as spla\n    from ..const import PRM\n\n    # Ensure |nv| is large enough for confident directionality\n    if spla.norm(nv) < PRM.ZERO_VEC_TOL:\n        raise ValueError(\"Norm of 'nv' is too small.\")\n    ## end if\n\n    # Ensure nv is a normalized np.float64 3-vector\n    nv = make_nd_vec(nv, nd=3, t=np.float64, norm=True)\n\n    # Ensure reps is a positive scalar integer\n    if not np.isscalar(reps):\n        raise ValueError(\"'reps' must be scalar.\")\n    ## end if\n    if not np.issubdtype(type(reps), int):\n        raise ValueError(\"'reps' must be an integer.\")\n    ## end if\n    if not reps > 0:\n        raise ValueError(\"'reps' must be a positive integer.\")\n    ## end if\n\n    # Initialize the single-point reflection transform matrix\n    base_mtx = np.zeros(shape=(3,3), dtype=np.float64)\n\n    # Construct the single-point transform matrix\n    for i in range(3):\n        for j in range(i,3):\n            if i==j:\n                base_mtx[i,j] = 1 - 2*nv[i]**2\n            else:\n                base_mtx[i,j] = base_mtx[j,i] = -2*nv[i]*nv[j]\n            ## end if\n        ## next j\n    ## next i\n\n    # Construct the block-diagonal replicated reflection matrix\n    refl_mtx= spla.block_diag(*[base_mtx for i in range(reps)])\n\n    # Return the result\n    return refl_mtx", "label": 1}
{"code": "public static final boolean isMouseInside(NativeEvent event, Element element) {\n        return isInside(event.getClientX() + Window.getScrollLeft(), event.getClientY() + Window.getScrollTop(), getBounds(element));\n    }", "label": 0}
{"code": "def deny_access(flash_message = nil)\n      respond_to do |format|\n        format.any(:js, :json, :xml) { head :unauthorized }\n        format.any { redirect_request(flash_message) }\n      end\n    end", "label": 4}
{"code": "public function setApplications($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Talent\\V4beta1\\Application::class);\n        $this->applications = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function (member, memberValue) {\n        var attributeName = this._extractAttributeName(member);\n        if (!attributeName) {\n            return false;\n        }\n        this._addToDefinitionAttributes(attributeName, memberValue);\n        return true;\n    }", "label": 3}
{"code": "def writeFasta(sequence, sequence_name, output_file):\n    \"\"\"\n    Writes a fasta sequence into a file.\n\n    :param sequence: a string with the sequence to be written\n    :param sequence_name: name of the the fasta sequence\n    :param output_file: /path/to/file.fa to be written\n\n    :returns: nothing\n    \"\"\"\n    i=0\n    f=open(output_file,'w')\n    f.write(\">\"+str(sequence_name)+\"\\n\")\n    while i <= len(sequence):\n        f.write(sequence[i:i+60]+\"\\n\")\n        i=i+60\n    f.close()", "label": 1}
{"code": "function (patternFolder, cb) {\n    // read pattern folder\n    fs.readdir(patternFolder, function (err, contents) {\n      // check for errors\n      if (err !== null && err.code === 'ENOENT') {\n        grunt.log.error('Cannot find patterns folder:', patternFolder);\n        cb('Cannot find patterns folder: ' + patternFolder);\n        return;\n      }\n\n      // list all pattern files (that end with .html)\n      var files = [];\n      contents.forEach(function (content) {\n        if (content.substr(-5) === '.html') {\n          files.push(content);\n        }\n      });\n      // handle all the found pattern files\n      handleFiles(patternFolder, files, cb);\n    });\n  }", "label": 3}
{"code": "func getKernelBoolParam(path string) (bool, error) {\n\tenabled := false\n\tline, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif len(line) > 0 {\n\t\tenabled = line[0] == '1'\n\t}\n\treturn enabled, err\n}", "label": 5}
{"code": "def update_voice_server(data)\n      server_id = data['guild_id'].to_i\n      channel = @should_connect_to_voice[server_id]\n\n      debug(\"Voice server update received! chan: #{channel.inspect}\")\n      return unless channel\n\n      @should_connect_to_voice.delete(server_id)\n      debug('Updating voice server!')\n\n      token = data['token']\n      endpoint = data['endpoint']\n\n      unless endpoint\n        debug('VOICE_SERVER_UPDATE sent with nil endpoint! Ignoring')\n        return\n      end\n\n      debug('Got data, now creating the bot.')\n      @voices[server_id] = Discordrb::Voice::VoiceBot.new(channel, self, token, @session_id, endpoint, @should_encrypt_voice)\n    end", "label": 4}
{"code": "func Marshal(val interface{}) string {\n\tb, err := xml.Marshal(val)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn string(b)\n}", "label": 5}
{"code": "function _gpfProcessDefineParamsCheck (params) {\n    _gpfAsserts({\n        \"name is required (String)\": \"string\" === typeof params[_GPF_DEFINE_PARAM_NAME],\n        \"Super is required and must resolve to a Constructor\": params[_GPF_DEFINE_PARAM_SUPER] instanceof Function,\n        \"definition is required (Object)\": \"object\" === typeof params[_GPF_DEFINE_PARAM_DEFINITION]\n    });\n}", "label": 3}
{"code": "def _craft_s3_keys(self):\n        \"\"\"\n        We are putting stuff into S3, were supplied the bucket. Here we\n        craft the key of the elements we are putting up there in the\n        internet clouds.\n\n        Args:\n            None\n\n        Returns:\n            a tuple of teplate file key and property file key\n        \"\"\"\n        now = time.gmtime()\n        stub = \"templates/{stack_name}/{version}\".format(\n            stack_name=self._config.get('environment', {}).get('stack_name', None),\n            version=self._config.get('codeVersion')\n        )\n\n        stub = stub + \"/\" + str(now.tm_year)\n        stub = stub + \"/\" + str('%02d' % now.tm_mon)\n        stub = stub + \"/\" + str('%02d' % now.tm_mday)\n        stub = stub + \"/\" + str('%02d' % now.tm_hour)\n        stub = stub + \":\" + str('%02d' % now.tm_min)\n        stub = stub + \":\" + str('%02d' % now.tm_sec)\n\n        if self._yaml:\n            template_key = stub + \"/stack.yaml\"\n        else:\n            template_key = stub + \"/stack.json\"\n\n        property_key = stub + \"/stack.properties\"\n        return template_key, property_key", "label": 1}
{"code": "def get_patient_bams(job, patient_dict, sample_type, univ_options, bwa_options, mutect_options):\n    \"\"\"\n    Convenience function to return the bam and its index in the correct format for a sample type.\n\n    :param dict patient_dict: dict of patient info\n    :param str sample_type: 'tumor_rna', 'tumor_dna', 'normal_dna'\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict bwa_options: Options specific to bwa\n    :param dict bwa_options: Options specific to mutect\n    :return: formatted dict of bam and bai\n    :rtype: dict\n    \"\"\"\n    output_dict = {}\n    if 'dna' in sample_type:\n        sample_info = 'fix_pg_sorted'\n        prefix = sample_type + '_' + sample_info\n    else:\n        sample_info = 'genome_sorted'\n        prefix = 'rna_' + sample_info\n    if sample_type + '_bam' in patient_dict['gdc_inputs']:\n        output_dict[prefix + '.bam'] = patient_dict[sample_type + '_bam'][0]\n        output_dict[prefix + '.bam.bai'] = patient_dict[sample_type + '_bam'][1]\n    elif sample_type + '_bai' in patient_dict:\n        output_dict[prefix + '.bam'] = patient_dict[sample_type + '_bam']\n        output_dict[prefix + '.bam.bai'] = patient_dict[sample_type + '_bai']\n    else:\n        from protect.alignment.dna import index_bamfile, index_disk\n        output_job = job.wrapJobFn(index_bamfile, patient_dict[sample_type + '_bam'],\n                                   'rna' if sample_type == 'tumor_rna' else sample_type,\n                                   univ_options, bwa_options['samtools'],\n                                   sample_info=sample_info, export=False,\n                                   disk=PromisedRequirement(index_disk,\n                                                            patient_dict[sample_type + '_bam']))\n        job.addChild(output_job)\n        output_dict = output_job.rv()\n    if sample_type == 'tumor_rna':\n        if 'tumor_rna_transcriptome_bam' not in patient_dict:\n            patient_dict['tumor_rna_transcriptome_bam'] = None\n        return{'rna_genome': output_dict,\n               'rna_transcriptome.bam': patient_dict['tumor_rna_transcriptome_bam']}\n    else:\n        return output_dict", "label": 1}
{"code": "public ManageableCollection getCollectionByQuery(Class collectionClass, Query query)\n            throws PersistenceBrokerException\n    {\n        return referencesBroker.getCollectionByQuery(collectionClass, query, false);\n    }", "label": 0}
{"code": "func (r *reader) SetResponsive() {\n\tr.responsive = true\n\tr.t.cl.event.Broadcast()\n}", "label": 5}
{"code": "public function delete($id)\n    {\n        $entry = WinkAuthor::findOrFail($id);\n\n        if ($entry->posts()->count()) {\n            return response()->json(['message' => 'Please remove the author\\'s posts first.'], 402);\n        }\n\n        if ($entry->id == auth('wink')->user()->id) {\n            return response()->json(['message' => 'You cannot delete yourself.'], 402);\n        }\n\n        $entry->delete();\n    }", "label": 2}
{"code": "function (item) {\n        let x;\n        switch (item.type) {\n            case Type.STRING:\n            case Type.NUMBER:\n            case Type.BOOLEAN:\n            case Type.UNDEFINED:\n                return item.value;\n            case Type.ARRAY:\n                x = [];\n                item.value.forEach(function (e) {\n                    let key = e.key.substring(e.key.lastIndexOf('[') + 1, e.key.lastIndexOf(']'));\n                    x[parseInt(key, 10)] = _fromPersistable(e);\n                });\n                return x;\n            case Type.OBJECT:\n                x = {};\n                item.value.forEach(function (e) {\n                    let key = e.key.substring(e.key.lastIndexOf('[') + 1, e.key.lastIndexOf(']'));\n                    x[key] = _fromPersistable(e);\n                });\n                return x;\n            default:\n                _logUnknownType(item.type);\n        }\n    }", "label": 3}
{"code": "private function cellInProgress(CellChunk $chunk)\n    {\n        $this->validateCellInProgress($chunk);\n        if ($chunk->getResetRow()) {\n            $this->reset();\n            return;\n        }\n        $this->qualifierValue = $this->qualifierValue . $chunk->getValue();\n        $this->moveToNextState($chunk);\n    }", "label": 2}
{"code": "public static <T> T buildInstanceForMap(Class<T> clazz, Map<String, Object> values, MyReflectionDifferenceHandler differenceHandler)\n      throws InstantiationException, IllegalAccessException, IntrospectionException,\n      IllegalArgumentException, InvocationTargetException {\n\n    log.debug(\"Building new instance of Class \" + clazz.getName());\n\n    T instance = clazz.newInstance();\n\n    for (String key : values.keySet()) {\n      Object value = values.get(key);\n\n      if (value == null) {\n        log.debug(\"Value for field \" + key + \" is null, so ignoring it...\");\n        continue;\n      }\n      \n      log.debug(\n          \"Invoke setter for \" + key + \" (\" + value.getClass() + \" / \" + value.toString() + \")\");\n      Method setter = null;\n      try {\n        setter = new PropertyDescriptor(key.replace('.', '_'), clazz).getWriteMethod();\n      } catch (Exception e) {\n        throw new IllegalArgumentException(\"Setter for field \" + key + \" was not found\", e);\n      }\n\n      Class<?> argumentType = setter.getParameterTypes()[0];\n\n      if (argumentType.isAssignableFrom(value.getClass())) {\n        setter.invoke(instance, value);\n      } else {\n\n        Object newValue = differenceHandler.handleDifference(value, setter.getParameterTypes()[0]);\n        setter.invoke(instance, newValue);\n\n      }\n    }\n\n    return instance;\n  }", "label": 0}
{"code": "@Override\n    public ImageSource apply(ImageSource input) {\n        final int[][] pixelMatrix = new int[3][3];\n\n        int w = input.getWidth();\n        int h = input.getHeight();\n\n        int[][] output = new int[h][w];\n\n        for (int j = 1; j < h - 1; j++) {\n            for (int i = 1; i < w - 1; i++) {\n                pixelMatrix[0][0] = input.getR(i - 1, j - 1);\n                pixelMatrix[0][1] = input.getRGB(i - 1, j);\n                pixelMatrix[0][2] = input.getRGB(i - 1, j + 1);\n                pixelMatrix[1][0] = input.getRGB(i, j - 1);\n                pixelMatrix[1][2] = input.getRGB(i, j + 1);\n                pixelMatrix[2][0] = input.getRGB(i + 1, j - 1);\n                pixelMatrix[2][1] = input.getRGB(i + 1, j);\n                pixelMatrix[2][2] = input.getRGB(i + 1, j + 1);\n\n                int edge = (int) convolution(pixelMatrix);\n                int rgb = (edge << 16 | edge << 8 | edge);\n                output[j][i] = rgb;\n            }\n        }\n\n        MatrixSource source = new MatrixSource(output);\n        return source;\n    }", "label": 0}
{"code": "func (r *Registry) PutEntity(parent mo.Entity, item mo.Entity) mo.Entity {\n\te := item.Entity()\n\n\tif parent != nil {\n\t\te.Parent = &parent.Entity().Self\n\t}\n\n\tr.Put(item)\n\n\treturn item\n}", "label": 5}
{"code": "def add_object(o)\n      if !@objects.include?(o)\n        index = @objects.index do |object|\n          object.z > o.z\n        end\n        if index\n          @objects.insert(index, o)\n        else\n          @objects.push(o)\n        end\n        true\n      else\n        false\n      end\n    end", "label": 4}
{"code": "def occurring_at?(time)\n      time = TimeUtil.match_zone(time, start_time) or raise ArgumentError, \"Time required, got #{time.inspect}\"\n      if duration > 0\n        return false if exception_time?(time)\n        occurs_between?(time - duration + 1, time)\n      else\n        occurs_at?(time)\n      end\n    end", "label": 4}
{"code": "public static netbridge_vlan_binding[] get(nitro_service service, String name) throws Exception{\n\t\tnetbridge_vlan_binding obj = new netbridge_vlan_binding();\n\t\tobj.set_name(name);\n\t\tnetbridge_vlan_binding response[] = (netbridge_vlan_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (ss *StringSlice) Scan(src interface{}) error {\n\tbuf, ok := src.([]byte)\n\tif !ok {\n\t\treturn errors.New(\"invalid StringSlice\")\n\t}\n\n\t// change quote escapes for csv parser\n\tstr := quoteEscapeRegex.ReplaceAllString(string(buf), `$1\"\"`)\n\tstr = strings.Replace(str, `\\\\`, `\\`, -1)\n\n\t// remove braces\n\tstr = str[1 : len(str)-1]\n\n\t// bail if only one\n\tif len(str) == 0 {\n\t\t*ss = StringSlice([]string{})\n\t\treturn nil\n\t}\n\n\t// parse with csv reader\n\tcr := csv.NewReader(strings.NewReader(str))\n\tslice, err := cr.Read()\n\tif err != nil {\n\t\tfmt.Printf(\"exiting!: %v\\n\", err)\n\t\treturn err\n\t}\n\n\t*ss = StringSlice(slice)\n\n\treturn nil\n}", "label": 5}
{"code": "public void remove(Identity oid)\r\n    {\r\n        if(log.isDebugEnabled()) log.debug(\"Remove object \" + oid);\r\n        sessionCache.remove(oid);\r\n        getApplicationCache().remove(oid);\r\n    }", "label": 0}
{"code": "def __handle_variable(self, shell_entry, output):\n        \"\"\"\n        Saving output for configured variable name.\n\n        Args:\n            shell_entry(dict): shell based configuration (shell, docker container or Python).\n            output: list of strings representing output of last shell\n        \"\"\"\n        if 'variable' in shell_entry:\n            variable_name = shell_entry['variable']\n            self.pipeline.variables[variable_name] = \"\\n\".join(output)", "label": 1}
{"code": "function merge(obj1, obj2) {\n  var res = {}, attrname;\n\n  for (attrname in obj1) {\n    res[attrname] = obj1[attrname];\n  }\n  for (attrname in obj2) {\n    res[attrname] = obj2[attrname];\n  }\n  return res;\n}", "label": 3}
{"code": "public function loginWithPassword($password)\n    {\n        $this->password = $password;\n        if (is_readable($this->challengeFilename)) {\n            $challengeData = file_get_contents($this->challengeFilename);\n            if ($challengeData) {\n                $this->challengeData = $challengeData;\n            }\n        }\n        $login = new Login($this, $this->password);\n        $login->doLogin();\n    }", "label": 2}
{"code": "def file(cls, path, encoding=None, parser=None):\n        \"\"\"Set a file as a source.\n\n        File are parsed as literal python dicts by default, this behaviour\n        can be configured.\n\n        Args:\n            path: The path to the file to be parsed\n            encoding: The encoding of the file.\n                Defaults to 'raw'. Available built-in values: 'ini', 'json', 'yaml'.\n                Custom value can be used in conjunction with parser.\n            parser: A parser function for a custom encoder.\n                It is expected to return a dict containing the parsed values\n                when called with the contents of the file as an argument.\n        \"\"\"\n        cls.__hierarchy.append(file.File(path, encoding, parser))", "label": 1}
{"code": "def path_to(hash = nil)\n      @base_dir ||= File.join(Jekyll::Cache.cache_dir, @name)\n      return @base_dir if hash.nil?\n\n      File.join(@base_dir, hash[0..1], hash[2..-1]).freeze\n    end", "label": 4}
{"code": "def get_value(self, model, default=None):\n        \"\"\"Return field's value.\n\n        :param DomainModel model:\n        :param object default:\n        :rtype object:\n        \"\"\"\n        if default is not None:\n            default = self._converter(default)\n\n        value = getattr(model, self.storage_name)\n        return value if value is not None else default", "label": 1}
{"code": "public function setTransformationSummaries($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\TransformationSummary::class);\n        $this->transformation_summaries = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func createDummyLink(dummyName, truncNetID string) error {\n\t// create a parent interface since one was not specified\n\tparent := &netlink.Dummy{\n\t\tLinkAttrs: netlink.LinkAttrs{\n\t\t\tName: dummyName,\n\t\t},\n\t}\n\tif err := ns.NlHandle().LinkAdd(parent); err != nil {\n\t\treturn err\n\t}\n\tparentDummyLink, err := ns.NlHandle().LinkByName(dummyName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error occurred looking up the %s parent iface %s error: %s\", ipvlanType, dummyName, err)\n\t}\n\t// bring the new netlink iface up\n\tif err := ns.NlHandle().LinkSetUp(parentDummyLink); err != nil {\n\t\treturn fmt.Errorf(\"failed to enable %s the ipvlan parent link: %v\", dummyName, err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public void addCommandClass(ZWaveCommandClass commandClass)\n\t{\n\t\tZWaveCommandClass.CommandClass key = commandClass.getCommandClass();\n\t\t\n\t\tif (!supportedCommandClasses.containsKey(key)) {\n\t\t\tsupportedCommandClasses.put(key, commandClass);\n\t\t\t\n\t\t\tif (commandClass instanceof ZWaveEventListener)\n\t\t\t\tthis.controller.addEventListener((ZWaveEventListener)commandClass);\n\t\t\t\n\t\t\tthis.lastUpdated = Calendar.getInstance().getTime();\n\t\t}\n\t}", "label": 0}
{"code": "def line(start_x, start_y, end_x, end_y)\n      primitive 'line ' + format('%g,%g %g,%g', start_x, start_y, end_x, end_y)\n    end", "label": 4}
{"code": "public function exchange_delete(\n        $exchange,\n        $if_unused = false,\n        $nowait = false,\n        $ticket = null\n    ) {\n        $ticket = $this->getTicket($ticket);\n        list($class_id, $method_id, $args) = $this->protocolWriter->exchangeDelete(\n            $ticket,\n            $exchange,\n            $if_unused,\n            $nowait\n        );\n\n        $this->send_method_frame(array($class_id, $method_id), $args);\n\n        if ($nowait) {\n            return null;\n        }\n\n        return $this->wait(array(\n            $this->waitHelper->get_wait('exchange.delete_ok')\n        ), false, $this->channel_rpc_timeout);\n    }", "label": 2}
{"code": "func (s *Server) Serve(l net.Listener) error {\n\tif len(s.getCommandLabels()) > 0 {\n\t\ts.updateLabels()\n\t}\n\tgo s.heartbeat.Run()\n\treturn s.srv.Serve(l)\n}", "label": 5}
{"code": "public static bridgetable[] get(nitro_service service) throws Exception{\n\t\tbridgetable obj = new bridgetable();\n\t\tbridgetable[] response = (bridgetable[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static wisite_farmname_binding[] get(nitro_service service, String sitepath) throws Exception{\n\t\twisite_farmname_binding obj = new wisite_farmname_binding();\n\t\tobj.set_sitepath(sitepath);\n\t\twisite_farmname_binding response[] = (wisite_farmname_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (cn *connection) stopRequestingPiece(piece pieceIndex) bool {\n\treturn cn.pieceRequestOrder.Remove(bitmap.BitIndex(piece))\n}", "label": 5}
{"code": "public static sslfipskey[] get(nitro_service service) throws Exception{\n\t\tsslfipskey obj = new sslfipskey();\n\t\tsslfipskey[] response = (sslfipskey[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function generate($basePath, $pretty)\n    {\n        $fileReflectorRegister = new ReflectorRegister();\n\n        $rootPath = $this->executionPath;\n        foreach ($this->files as $file) {\n            $currentFileArr = $this->isComponent\n                ? explode(\"/$basePath/\", $file)\n                : explode(\"$rootPath\", $file);\n\n            if (isset($currentFileArr[1])) {\n                $currentFile = str_replace('src/', '', $currentFileArr[1]);\n            } else {\n                throw new \\Exception(\n                    sprintf('Failed to determine currentFile: %s', $file)\n                );\n            }\n\n            $isPhp = strrpos($file, '.php') == strlen($file) - strlen('.php');\n            $pathInfo = pathinfo($currentFile);\n            $servicePath = $pathInfo['dirname'] === '.'\n                ? strtolower($pathInfo['filename'])\n                : strtolower($pathInfo['dirname'] . '/' . $pathInfo['filename']);\n            $id = $this->isComponent\n                ? strtolower($basePath) . '/' . $servicePath\n                : $servicePath;\n\n            if ($isPhp) {\n                $parser = new CodeParser(\n                    $file,\n                    $fileReflectorRegister,\n                    $rootPath,\n                    $this->componentId,\n                    $this->manifestPath,\n                    $this->release,\n                    $this->output,\n                    $id,\n                    $this->isComponent\n                );\n            } else {\n                $content = file_get_contents($file);\n                $parser = new MarkdownParser($currentFile, $content, $id);\n            }\n\n            $document = $parser->parse();\n            if ($document) {\n                $writer = new Writer($document, $this->outputPath, $pretty);\n                $writer->write($currentFile);\n\n                $this->types->addType([\n                    'id' => $id,\n                    'title' => $document['title'],\n                    'contents' => $servicePath . '.json'\n                ]);\n            }\n        }\n    }", "label": 2}
{"code": "private static void initInstance(final TransactionLogger instance, final Logger logger, final Logger auditor) {\n    instance.logger = logger;\n    instance.auditor = auditor;\n    instance.components = new LinkedHashMap<>();\n    instance.properties = new LinkedHashMap<>();\n    instance.total = new Component(TOTAL_COMPONENT);\n    instance.total.startTimer();\n    instance.componentsMultiThread = new ComponentsMultiThread();\n    instance.flowContext = FlowContextFactory.serializeNativeFlowContext();\n  }", "label": 0}
{"code": "function verifyFormDataSourcesAndTargets(formData, cb) {\n    var formDataSourceIds = getFormDataSources(formData);\n    var dataTargets = formData.dataTargets || [];\n\n    async.series({\n      dataSources : function(cb) {\n        verifyDataSources(formDataSourceIds, cb);\n      },\n      dataTargets: function(cb) {\n        verifyDataTargets(dataTargets, cb);\n      }\n    }, cb);\n  }", "label": 3}
{"code": "@Override\n\tpublic ProxyAuthenticationMethod getMethod() {\n\t\tswitch (authenticationMethod) {\n\t\tcase BASIC:\n\t\t\treturn ProxyAuthenticationMethod.BASIC;\n\t\tcase DIGEST:\n\t\t\treturn ProxyAuthenticationMethod.DIGEST;\n\t\tcase URL:\n\t\t\treturn ProxyAuthenticationMethod.URL;\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}", "label": 0}
{"code": "protected function x_secure_ok($response)\n    {\n        $args = new AMQPWriter();\n        $args->write_longstr($response);\n        $this->send_method_frame(array(10, 21), $args);\n    }", "label": 2}
{"code": "func MyEnumValues(db XODB, schema string, enum string) (*MyEnumValue, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`SUBSTRING(column_type, 6, CHAR_LENGTH(column_type) - 6) AS enum_values ` +\n\t\t`FROM information_schema.columns ` +\n\t\t`WHERE data_type = 'enum' AND table_schema = ? AND column_name = ?`\n\n\t// run query\n\tXOLog(sqlstr, schema, enum)\n\tvar mev MyEnumValue\n\terr = db.QueryRow(sqlstr, schema, enum).Scan(&mev.EnumValues)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &mev, nil\n}", "label": 5}
{"code": "def get(self, name=None, plugin=None):\n        \"\"\"\n        Returns commands, which can be filtered by name or plugin.\n\n        :param name: name of the command\n        :type name: str\n        :param plugin: plugin object, which registers the commands\n        :type plugin: instance of GwBasePattern\n        :return: None, single command or dict of commands\n        \"\"\"\n        if plugin is not None:\n            if name is None:\n                command_list = {}\n                for key in self._commands.keys():\n                    if self._commands[key].plugin == plugin:\n                        command_list[key] = self._commands[key]\n                return command_list\n            else:\n                if name in self._commands.keys():\n                    if self._commands[name].plugin == plugin:\n                        return self._commands[name]\n                    else:\n                        return None\n                else:\n                    return None\n        else:\n            if name is None:\n                return self._commands\n            else:\n                if name in self._commands.keys():\n                    return self._commands[name]\n                else:\n                    return None", "label": 1}
{"code": "def list(path, params = {}, headers = {})\n      params = params.merge(list: true)\n      request(:get, path, params, headers)\n    end", "label": 4}
{"code": "func (cn *connection) ipv6() bool {\n\tip := cn.remoteAddr.IP\n\tif ip.To4() != nil {\n\t\treturn false\n\t}\n\treturn len(ip) == net.IPv6len\n}", "label": 5}
{"code": "func (sink *influxdbSink) GetNamespaces() ([]string, error) {\n\treturn sink.stringListQuery(fmt.Sprintf(\"SHOW TAG VALUES WITH KEY = %s\", core.LabelNamespaceName.Key), \"Unable to list all namespaces\")\n}", "label": 5}
{"code": "def print_tables\n      puts(\"\")\n      if self.certs.count > 0\n        rows = self.certs.collect do |cert|\n          cert_expiration = cert.expires.nil? ? \"Unknown\" : cert.expires.strftime(\"%Y-%m-%d\")\n          [cert.name, cert.id, cert.class.to_s.split(\"::\").last, cert_expiration]\n        end\n        puts(Terminal::Table.new({\n          title: \"Certificates that are going to be revoked\".green,\n          headings: [\"Name\", \"ID\", \"Type\", \"Expires\"],\n          rows: FastlaneCore::PrintTable.transform_output(rows)\n        }))\n        puts(\"\")\n      end\n\n      if self.profiles.count > 0\n        rows = self.profiles.collect do |p|\n          status = p.status == 'Active' ? p.status.green : p.status.red\n\n          # Expires is somtimes nil\n          expires = p.expires ? p.expires.strftime(\"%Y-%m-%d\") : nil\n          [p.name, p.id, status, p.type, expires]\n        end\n        puts(Terminal::Table.new({\n          title: \"Provisioning Profiles that are going to be revoked\".green,\n          headings: [\"Name\", \"ID\", \"Status\", \"Type\", \"Expires\"],\n          rows: FastlaneCore::PrintTable.transform_output(rows)\n        }))\n        puts(\"\")\n      end\n\n      if self.files.count > 0\n        rows = self.files.collect do |f|\n          components = f.split(File::SEPARATOR)[-3..-1]\n\n          # from \"...1o7xtmh/certs/distribution/8K38XUY3AY.cer\" to \"distribution cert\"\n          file_type = components[0..1].reverse.join(\" \")[0..-2]\n\n          [file_type, components[2]]\n        end\n\n        puts(Terminal::Table.new({\n          title: \"Files that are going to be deleted\".green + \"\\n\" + self.storage.human_readable_description,\n          headings: [\"Type\", \"File Name\"],\n          rows: rows\n        }))\n        puts(\"\")\n      end\n    end", "label": 4}
{"code": "def find_providers_for(attributes)\n      plugins = []\n      attributes.each do |attribute|\n        attrs = select_subtree(@map, attribute)\n        raise Ohai::Exceptions::AttributeNotFound, \"No such attribute: \\'#{attribute}\\'\" unless attrs\n        raise Ohai::Exceptions::ProviderNotFound, \"Cannot find plugin providing attribute: \\'#{attribute}\\'\" unless attrs[:_plugins]\n        plugins += attrs[:_plugins]\n      end\n      plugins.uniq\n    end", "label": 4}
{"code": "func (s Style) Dim(on bool) Style {\n\treturn s.setAttrs(Style(AttrDim), on)\n}", "label": 5}
{"code": "def allowed_to_promote?(emendation)\n      return unless emendation.amendment.rejected? && emendation.created_by?(current_user)\n      return if promoted?(emendation)\n\n      true\n    end", "label": 4}
{"code": "public static dnspolicy_dnspolicylabel_binding[] get(nitro_service service, String name) throws Exception{\n\t\tdnspolicy_dnspolicylabel_binding obj = new dnspolicy_dnspolicylabel_binding();\n\t\tobj.set_name(name);\n\t\tdnspolicy_dnspolicylabel_binding response[] = (dnspolicy_dnspolicylabel_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def find_package_data(packages):\n    \"\"\"\n    For a list of packages, find the package_data\n\n    This function scans the subdirectories of a package and considers all\n    non-submodule subdirectories as resources, including them in\n    the package_data\n\n    Returns a dictionary suitable for setup(package_data=<result>)\n    \"\"\"\n    package_data = {}\n    for package in packages:\n        package_data[package] = []\n        for subdir in find_subdirectories(package):\n            if '.'.join((package, subdir)) in packages: # skip submodules\n                logging.debug(\"skipping submodule %s/%s\" % (package, subdir))\n                continue\n            if skip_tests and (subdir == 'tests'): # skip tests\n                logging.debug(\"skipping tests %s/%s\" % (package, subdir))\n                continue\n            package_data[package] += subdir_findall(package_to_path(package), subdir)\n    return package_data", "label": 1}
{"code": "function(auth, password, options) {\n      if (isObject(auth)) options = password;\n      else auth = {email: auth, password: password}\n      options = opts(this, options);\n      options.applevel = true;\n\n      var config = {\n        action: 'account',\n        type: 'DELETE',\n        options: options,\n        processResponse: APICall.basicResponse\n      };\n\n      // Drop session if we are referring to ourselves.\n      if (auth.email == this.options.email) {\n        this.options.session_token = null;\n        this.options.email = null;\n\n        if (options.savelogin) {\n          store('email', null, this.options.appid);\n          store('username', null, this.options.appid);\n          store('session_token', null, this.options.appid);\n        }\n      }\n\n      if (auth.password) {\n        // Non-master key access\n        config.data = JSON.stringify({\n          email: auth.email,\n          username: auth.username,\n          password: auth.password\n        })\n      } else {\n        // Master key access\n        config.action += '/' + auth.email;\n      }\n\n      return new APICall(config);\n    }", "label": 3}
{"code": "def certificate_to_use\n      certificates = certificates_for_profile_and_platform\n\n      # Filter them\n      certificates = certificates.find_all do |c|\n        if Sigh.config[:cert_id]\n          next unless c.id == Sigh.config[:cert_id].strip\n        end\n\n        if Sigh.config[:cert_owner_name]\n          next unless c.owner_name.strip == Sigh.config[:cert_owner_name].strip\n        end\n\n        true\n      end\n\n      # verify certificates\n      if Helper.mac?\n        unless Sigh.config[:skip_certificate_verification]\n          certificates = certificates.find_all do |c|\n            file = Tempfile.new('cert')\n            file.write(c.download_raw)\n            file.close\n\n            FastlaneCore::CertChecker.installed?(file.path)\n          end\n        end\n      end\n\n      if certificates.count > 1 && !Sigh.config[:development]\n        UI.important(\"Found more than one code signing identity. Choosing the first one. Check out `fastlane sigh --help` to see all available options.\")\n        UI.important(\"Available Code Signing Identities for current filters:\")\n        certificates.each do |c|\n          str = [\"\\t- Name:\", c.owner_name, \"- ID:\", c.id + \" - Expires\", c.expires.strftime(\"%d/%m/%Y\")].join(\" \")\n          UI.message(str.green)\n        end\n      end\n\n      if certificates.count == 0\n        filters = \"\"\n        filters << \"Owner Name: '#{Sigh.config[:cert_owner_name]}' \" if Sigh.config[:cert_owner_name]\n        filters << \"Certificate ID: '#{Sigh.config[:cert_id]}' \" if Sigh.config[:cert_id]\n        UI.important(\"No certificates for filter: #{filters}\") if filters.length > 0\n        message = \"Could not find a matching code signing identity for type '#{profile_type.to_s.split(':').last}'. \"\n        message += \"It is recommended to use match to manage code signing for you, more information on https://codesigning.guide. \"\n        message += \"If you don't want to do so, you can also use cert to generate a new one: https://fastlane.tools/cert\"\n        UI.user_error!(message)\n      end\n\n      return certificates if Sigh.config[:development] # development profiles support multiple certificates\n      return certificates.first\n    end", "label": 4}
{"code": "private function isInheritanceSupported(ClassMetadata $metadata)\n    {\n        if ($metadata->inheritanceType === InheritanceType::SINGLE_TABLE\n            && in_array($metadata->getClassName(), $metadata->discriminatorMap, true)) {\n            return true;\n        }\n\n        return ! in_array($metadata->inheritanceType, [InheritanceType::SINGLE_TABLE, InheritanceType::JOINED], true);\n    }", "label": 2}
{"code": "func (cn *connection) postHandshakeStats(f func(*ConnStats)) {\n\tt := cn.t\n\tf(&t.stats)\n\tf(&t.cl.stats)\n}", "label": 5}
{"code": "def add_recipient(data)\n      channel_id = data['channel_id'].to_i\n      channel = self.channel(channel_id)\n\n      recipient_user = ensure_user(data['user'])\n      recipient = Recipient.new(recipient_user, channel, self)\n      channel.add_recipient(recipient)\n    end", "label": 4}
{"code": "func slicesEqual(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "label": 5}
{"code": "def get_full_filename(self, dataType, subjectArea):\n        \"\"\" \n        returns the file based on dataType and subjectArea \n        \"\"\"\n        return dataPath + os.sep + 'core' + os.sep + dataType + '_' + subjectArea + '.CSV'", "label": 1}
{"code": "public static base_response unset(nitro_service client, snmptrap resource, String[] args) throws Exception{\n\t\tsnmptrap unsetresource = new snmptrap();\n\t\tunsetresource.trapclass = resource.trapclass;\n\t\tunsetresource.trapdestination = resource.trapdestination;\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "func (o *listOutput) hasMultiplePaths() bool {\n\tif len(o.rs) == 0 {\n\t\treturn false\n\t}\n\n\tp := o.rs[0].FolderPath\n\n\t// Multiple paths if any entry is not equal to the first one.\n\tfor _, e := range o.rs {\n\t\tif e.FolderPath != p {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}", "label": 5}
{"code": "public function setIdentifyingFields($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\FieldId::class);\n        $this->identifying_fields = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def iter_list(self, id, *args, **kwargs):\n        \"\"\"Get a list of attachments.  Whereas ``list`` fetches a single page\n        of attachments according to its ``limit`` and ``page``\n        arguments, ``iter_list`` returns all attachments by internally\n        making successive calls to ``list``.\n\n        :param id: Device ID as an int.\n        :param args: Arguments that ``list`` takes.\n        :param kwargs: Optional arguments that ``list`` takes.\n        :return: :class:`attachments.Attachment <attachments.Attachment>` list\n\n        \"\"\"\n        l = partial(self.list, id)\n        return self.service.iter_list(l, *args, **kwargs)", "label": 1}
{"code": "func (f *file) lintImports() {\n\tfor i, is := range f.f.Imports {\n\t\t_ = i\n\t\tif is.Name != nil && is.Name.Name == \".\" && !f.isTest() {\n\t\t\tf.errorf(is, 1, link(styleGuideBase+\"#import-dot\"), category(\"imports\"), \"should not use dot imports\")\n\t\t}\n\n\t}\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, cachepolicylabel resource) throws Exception {\n\t\tcachepolicylabel addresource = new cachepolicylabel();\n\t\taddresource.labelname = resource.labelname;\n\t\taddresource.evaluates = resource.evaluates;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "func (s *AuthServer) checkTokenTTL(tok services.ProvisionToken) bool {\n\tnow := s.clock.Now().UTC()\n\tif tok.Expiry().Before(now) {\n\t\terr := s.DeleteToken(tok.GetName())\n\t\tif err != nil {\n\t\t\tif !trace.IsNotFound(err) {\n\t\t\t\tlog.Warnf(\"Unable to delete token from backend: %v.\", err)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\treturn true\n}", "label": 5}
{"code": "def move_app_thinning_size_report\n      if File.exist?(PackageCommandGenerator.app_thinning_size_report_path)\n        FileUtils.mv(PackageCommandGenerator.app_thinning_size_report_path, File.expand_path(Gym.config[:output_directory]), force: true)\n        app_thinning_size_report_path = File.join(File.expand_path(Gym.config[:output_directory]), File.basename(PackageCommandGenerator.app_thinning_size_report_path))\n\n        UI.success(\"Successfully exported the App Thinning Size Report.txt file:\")\n        UI.message(app_thinning_size_report_path)\n        app_thinning_size_report_path\n      end\n    end", "label": 4}
{"code": "function AttributeDictionary(attributes) {\n  expect(arguments).to.have.length.below(\n    2,\n    'Invalid arguments length when creating an AttributeDictionary (it has ' +\n    'to be passed less than 2 arguments)'\n  );\n\n  if (attributes) {\n    expect(typeof attributes).to.equal(\n      'object',\n      'Invalid argument type when creating an AttributeDictionary (it has to ' +\n      'be an object)'\n    );\n\n    if (attributes instanceof Array) {\n      for (var i = 0; i < attributes.length; i++) {\n        _addAttribute(this, attributes[i]);\n      }\n    } else {\n      for (var attribute in attributes) {\n        _addAttribute(this, attributes[attribute], attribute);\n      }\n    }\n  }\n\n  Object.preventExtensions(this);\n  Object.seal(this);\n}", "label": 3}
{"code": "def solarized():\n    '''Set solarized colors in urxvt, tmux, and vim.\n\n    More Infos:\n    * Getting solarized colors right with urxvt, st, tmux and vim:\n      https://bbs.archlinux.org/viewtopic.php?id=164108\n\n    * Creating ~/.Xresources:\n      https://wiki.archlinux.org/index.php/Rxvt-unicode#Creating_.7E.2F.Xresources\n\n    * Select a good font on Ubuntu:\n      https://michaelheap.com/getting-solarized-working-on-ubuntu/\n\n    * tmux and 256 colors:\n      http://unix.stackexchange.com/a/118903\n    '''\n    install_packages(['rxvt-unicode', 'tmux', 'vim'])\n    install_file_legacy('~/.Xresources')\n    if env.host_string == 'localhost':\n        run('xrdb  ~/.Xresources')\n\n    # install and call term_colors\n    run('mkdir -p  ~/bin')\n    install_file_legacy('~/bin/term_colors')\n    run('chmod 755 ~/bin/term_colors')\n    run('~/bin/term_colors')", "label": 1}
{"code": "func NewRPCClient(conn io.ReadWriteCloser, plugins map[string]Plugin) (*RPCClient, error) {\n\t// Create the yamux client so we can multiplex\n\tmux, err := yamux.Client(conn, nil)\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\t// Connect to the control stream.\n\tcontrol, err := mux.Open()\n\tif err != nil {\n\t\tmux.Close()\n\t\treturn nil, err\n\t}\n\n\t// Connect stdout, stderr streams\n\tstdstream := make([]net.Conn, 2)\n\tfor i, _ := range stdstream {\n\t\tstdstream[i], err = mux.Open()\n\t\tif err != nil {\n\t\t\tmux.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Create the broker and start it up\n\tbroker := newMuxBroker(mux)\n\tgo broker.Run()\n\n\t// Build the client using our broker and control channel.\n\treturn &RPCClient{\n\t\tbroker:  broker,\n\t\tcontrol: rpc.NewClient(control),\n\t\tplugins: plugins,\n\t\tstdout:  stdstream[0],\n\t\tstderr:  stdstream[1],\n\t}, nil\n}", "label": 5}
{"code": "public static base_responses add(nitro_service client, policyexpression resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tpolicyexpression addresources[] = new policyexpression[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new policyexpression();\n\t\t\t\taddresources[i].name = resources[i].name;\n\t\t\t\taddresources[i].value = resources[i].value;\n\t\t\t\taddresources[i].description = resources[i].description;\n\t\t\t\taddresources[i].comment = resources[i].comment;\n\t\t\t\taddresources[i].clientsecuritymessage = resources[i].clientsecuritymessage;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public function setValidNodeVersions($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->valid_node_versions = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public static systemgroup_systemcmdpolicy_binding[] get(nitro_service service, String groupname) throws Exception{\n\t\tsystemgroup_systemcmdpolicy_binding obj = new systemgroup_systemcmdpolicy_binding();\n\t\tobj.set_groupname(groupname);\n\t\tsystemgroup_systemcmdpolicy_binding response[] = (systemgroup_systemcmdpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private function transactionOptions(array &$options, array $previous = [])\n    {\n        $options += [\n            'begin' => false,\n            'transactionType' => SessionPoolInterface::CONTEXT_READWRITE,\n            'transactionId' => null,\n        ];\n\n        $type = null;\n\n        $context = $this->pluck('transactionType', $options);\n        $id = $this->pluck('transactionId', $options);\n\n        $begin = $this->pluck('begin', $options);\n        if ($id === null) {\n            if ($begin) {\n                $type = 'begin';\n            } else {\n                $type = 'singleUseTransaction';\n                $options['singleUse'] = true;\n            }\n        }\n\n        if ($id !== null) {\n            $type = 'transactionId';\n            $transactionOptions = $id;\n        } elseif ($context === SessionPoolInterface::CONTEXT_READ) {\n            $transactionOptions = $this->configureSnapshotOptions($options, $previous);\n        } elseif ($context === SessionPoolInterface::CONTEXT_READWRITE) {\n            $transactionOptions = $this->configureTransactionOptions();\n        } else {\n            throw new \\BadMethodCallException(sprintf(\n                'Invalid transaction context %s',\n                $context\n            ));\n        }\n\n        return [$transactionOptions, $type, $context];\n    }", "label": 2}
{"code": "def symbols():\n    \"\"\"Return a list of symbols.\"\"\"\n    symbols = []\n    for line in symbols_stream():\n        symbols.append(line.decode('utf-8').strip())\n    return symbols", "label": 1}
{"code": "public function setMood($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Language\\V1\\PartOfSpeech_Mood::class);\n        $this->mood = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_response unset(nitro_service client, nsappflowparam resource, String[] args) throws Exception{\n\t\tnsappflowparam unsetresource = new nsappflowparam();\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "func (s *PresenceService) UpsertAuthServer(server services.Server) error {\n\treturn s.upsertServer(authServersPrefix, server)\n}", "label": 5}
{"code": "function(obj, index) {\n    var funcKey = [];\n\n    for(var key in obj) {\n      if(obj.hasOwnProperty(key)) {\n\n        // If this is a function, generate it later.\n        if(typeof obj[key] === 'function') {\n          funcKey.push(key);\n          continue;\n        }\n        obj[key] = generate.call(obj, obj[key], index);\n      }\n    }\n\n    // parse function\n    funcKey.forEach(function(key) {\n      obj[key] = generate.call(obj, obj[key], index);\n    });\n\n    return obj;\n  }", "label": 3}
{"code": "func (s *ClusterConfigurationService) SetClusterConfig(c services.ClusterConfig) error {\n\tvalue, err := services.GetClusterConfigMarshaler().Marshal(c)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\titem := backend.Item{\n\t\tKey:   backend.Key(clusterConfigPrefix, generalPrefix),\n\t\tValue: value,\n\t\tID:    c.GetResourceID(),\n\t}\n\n\t_, err = s.Put(context.TODO(), item)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def if_page(page_class, params={:using_params => {}},&block)\n      page_class = class_from_string(page_class) if page_class.is_a? String\n      return @current_page unless @current_page.class == page_class\n      on_page(page_class, params, false, &block)\n    end", "label": 4}
{"code": "public function setTrueMutations($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Bigtable\\V2\\Mutation::class);\n        $this->true_mutations = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def via(*proxy)\n      proxy_hash = {}\n      proxy_hash[:proxy_address]  = proxy[0] if proxy[0].is_a?(String)\n      proxy_hash[:proxy_port]     = proxy[1] if proxy[1].is_a?(Integer)\n      proxy_hash[:proxy_username] = proxy[2] if proxy[2].is_a?(String)\n      proxy_hash[:proxy_password] = proxy[3] if proxy[3].is_a?(String)\n      proxy_hash[:proxy_headers]  = proxy[2] if proxy[2].is_a?(Hash)\n      proxy_hash[:proxy_headers]  = proxy[4] if proxy[4].is_a?(Hash)\n\n      raise(RequestError, \"invalid HTTP proxy: #{proxy_hash}\") unless (2..5).cover?(proxy_hash.keys.size)\n\n      branch default_options.with_proxy(proxy_hash)\n    end", "label": 4}
{"code": "protected function createStreamSocket(ParametersInterface $parameters, $address, $flags)\n    {\n        $timeout = (isset($parameters->timeout) ? (float) $parameters->timeout : 5.0);\n\n        if (!$resource = @stream_socket_client($address, $errno, $errstr, $timeout, $flags)) {\n            $this->onConnectionError(trim($errstr), $errno);\n        }\n\n        if (isset($parameters->read_write_timeout)) {\n            $rwtimeout = (float) $parameters->read_write_timeout;\n            $rwtimeout = $rwtimeout > 0 ? $rwtimeout : -1;\n            $timeoutSeconds = floor($rwtimeout);\n            $timeoutUSeconds = ($rwtimeout - $timeoutSeconds) * 1000000;\n            stream_set_timeout($resource, $timeoutSeconds, $timeoutUSeconds);\n        }\n\n        if (isset($parameters->tcp_nodelay) && function_exists('socket_import_stream')) {\n            $socket = socket_import_stream($resource);\n            socket_set_option($socket, SOL_TCP, TCP_NODELAY, (int) $parameters->tcp_nodelay);\n        }\n\n        return $resource;\n    }", "label": 2}
{"code": "function(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function() {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function() {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  }", "label": 3}
{"code": "function httpResponse (response) {\n  if (!response) {\n    throw new Error('Unable to parse response.')\n  }\n  const errorAttrs = response.Chyba && response.Chyba.attributes\n  if (errorAttrs) {\n    throw new Error(`${response.Chyba.$value} (${errorAttrs.kod})`)\n  }\n  const body = response.Potvrzeni && response.Potvrzeni.attributes\n  const header = response.Hlavicka && response.Hlavicka.attributes\n  if (!body || !header) {\n    throw new Error('Unable to read response.')\n  }\n}", "label": 3}
{"code": "function date (value) {\n  if (Object.prototype.toString.call(value) !== '[object Date]' || isNaN(value)) {\n    throw new Error(`Value '${value}' is not a date object.`)\n  }\n}", "label": 3}
{"code": "function loadData() {\n  var data = fs.readFileSync(__dirname + '/zip_codes.csv', 'utf8');\n  var lines = data.split('\\r\\n');\n  var trie = {};\n\n  lines.forEach(function(line) {\n    var parts = line.split(',');\n    var zip = parts[0], city = parts[1], state = parts[2];\n    var node = trie;\n  \n    for (var i = 0; i < zip.length; i++) {\n      var num = zip[i];\n      var pos = node[num];\n      if (pos == null)\n        node = node[num] = (i === zip.length - 1) ? [city, state] : {};\n      else\n        node = node[num];\n    }\n  });\n  \n  return trie;\n}", "label": 3}
{"code": "def BLASTquery(query,database,program,filter=None,\\\n               format_type=None, expect=None,\\\n               nucl_reward=None, nucl_penalty=None,\\\n               gapcosts=None, matrix=None,\\\n               hitlist_size=None, descriptions=None,\\\n               alignments=None,\\\n               ncbi_gi=None, threshold=None,\\\n               word_size=None, composition_based_statistics=None,\\\n               organism=None, others=None,\\\n               num_threads=None, baseURL=\"http://blast.ncbi.nlm.nih.gov\",\\\n              verbose=False):\n    \"\"\"\n    Performs a blast query online.\n\n    As in https://ncbi.github.io/blast-cloud/\n\n    :param query: Search query. Allowed values: Accession, GI, or FASTA.\n    :param database: BLAST database. Allowed values: nt, nr, refseq_rna, refseq_protein, swissprot, pdbaa, pdbnt\n    :param program: BLAST program. Allowed values:  blastn, megablast, blastp, blastx, tblastn, tblastx\n    :param filter: Low complexity filtering. Allowed values: F to disable. T or L to enable. Prepend \"m\" for mask at lookup (e.g., mL)\n    :param format_type: Report type. Allowed values: HTML, Text, XML, XML2, JSON2, or Tabular. HTML is the default.\n    :param expect: Expect value. Allowed values: Number greater than zero.\n    :param nucl_reward: Reward for matching bases (BLASTN and megaBLAST). Allowed values: Integer greater than zero.\n    :param nucl_penalty: Cost for mismatched bases (BLASTN and megaBLAST). Allowed values: Integer less than zero.\n    :param gapcosts: Gap existence and extension costs. Allowed values: Pair of positive integers separated by a space such as \"11 1\".\n    :param matrix: Scoring matrix name. Allowed values: One of BLOSUM45, BLOSUM50, BLOSUM62, BLOSUM80, BLOSUM90, PAM250, PAM30 or PAM70. Default: BLOSUM62 for all applicable programs.\n    :param hitlist_size: Number of databases sequences to keep. Allowed values: Integer greater than zero.\n    :param descriptions: Number of descriptions to print (applies to HTML and Text). Allowed values: Integer greater than zero.\n    :param alignments: Number of alignments to print (applies to HTML and Text). Allowed values: Integer greater than zero.\n    :param ncbi_gi: Show NCBI GIs in report. Allowed values: T or F.\n    :param threshold: Neighboring score for initial words. Allowed values: Positive integer (BLASTP default is 11). Does not apply to BLASTN or MegaBLAST).\n    :param word_size: Size of word for initial matches. Allowed values: Positive integer.\n    :param composition_based_statistics: Composition based statistics algorithm to use. Allowed values: One of 0, 1, 2, or 3. See comp_based_stats command line option in the BLAST+ user manual for details.\n    :param organism: an organism as in https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastn&PAGE_TYPE=BlastSearch&LINK_LOC=blasthome\n    :param others: here you can add other parameters as seen in a blast bookmarked page. Define you query in https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastn&PAGE_TYPE=BlastSearch&LINK_LOC=blasthome\n            Once your query is defined click on \"Bookmark\" on right upper side of the page. You can copy fragments of the URL\n            which define the query. Eg. For organism \"Homo sapiens (taxid:9606)\" you will see the string \"EQ_MENU=Homo%20sapiens%20%28taxid%3A9606%29\" - this is\n            the string you can use here in others.\n    :param num_threads: Number of virtual CPUs to use. Allowed values: Integer greater than zero (default is 1). Supported only on the cloud.\n    :param verbose: print more\n\n    :returns: BLAST search request identifier\n    \"\"\"\n\n    if organism:\n        organism=organism.replace(\" \", \"%20\").replace(\"(\", \"%28\").replace(\")\", \"%29\").replace(\":\", \"%3A\")\n        EQ_MENU=organism\n    else:\n        EQ_MENU=None\n\n    URL=baseURL+\"/Blast.cgi?\"\n    URL=URL+\"QUERY=\"+str(query)+\"&DATABASE=\"+str(database)+\"&PROGRAM=\"+str(program)\n    for o,varname in zip([filter, format_type, expect, nucl_reward, nucl_penalty,\\\n              gapcosts, matrix, hitlist_size, descriptions, alignments,\\\n              ncbi_gi, threshold, word_size, composition_based_statistics,\\\n              EQ_MENU, num_threads],\\\n              ['FILTER' , 'FORMAT_TYPE', 'EXPECT', 'NUCL_REWARD', 'NUCL_PENALTY',\\\n              'GAPCOSTS', 'MATRIX', 'HITLIST_SIZE', 'DESCRIPTIONS', 'ALIGNMENTS',\\\n              'NCBI_GI', 'THRESHOLD', 'WORD_SIZE', 'COMPOSITION_BASED_STATISTICS',\\\n              'EQ_MENU', 'NUM_THREADS']):\n        if o:\n            URL=URL+\"&\"+ varname +\"=\"+str(o)\n\n    if others:\n        URL=URL+\"&\"+others\n\n    URL=URL+\"&CMD=Put\"\n\n    if verbose:\n        print(URL)\n        sys.stdout.flush()\n\n    response=requests.get(url = URL)\n    r=response.content.split(\"\\n\")\n    RID=[ s for s in r if \"RID = \" in s ]\n    if len(RID) > 0:\n        RID=RID[0].split(\" \")[-1]\n    else:\n        print(\"Could not return an RID for this query.\")\n        RID=None\n    return RID", "label": 1}
{"code": "def increment_slug(s):\n    \"\"\"Generate next slug for a series.\n\n       Some docstore types will use slugs (see above) as document ids. To\n       support unique ids, we'll serialize them as follows:\n         TestUserA/my-test\n         TestUserA/my-test-2\n         TestUserA/my-test-3\n         ...\n    \"\"\"\n    slug_parts = s.split('-')\n    # advance (or add) the serial counter on the end of this slug\n    # noinspection PyBroadException\n    try:\n        # if it's an integer, increment it\n        slug_parts[-1] = str(1 + int(slug_parts[-1]))\n    except:\n        # there's no counter! add one now\n        slug_parts.append('2')\n    return '-'.join(slug_parts)", "label": 1}
{"code": "function get(req, res, next) {\n  var params = {\n    appId: req.params.projectid || req.params.id\n  };\n\n  forms.getAppFormsForApp(_.extend(req.connectionOptions, params), formsResultHandlers(constants.resultTypes.formProjects, req, next));\n}", "label": 3}
{"code": "public function create(array $fields = [], array $options = [])\n    {\n        return $this->writeResult(\n            $this->batchFactory()\n                ->create($this->name, $fields, $options)\n                ->commit($options)\n        );\n    }", "label": 2}
{"code": "function( dontGiveFocus ) {\n\n                // If it\u2019s already open, do nothing.\n                if ( STATE.open ) return P\n\n                // Add the \u201cactive\u201d class.\n                $ELEMENT.addClass( CLASSES.active )\n                aria( ELEMENT, 'expanded', true )\n\n                // * A Firefox bug, when `html` has `overflow:hidden`, results in\n                //   killing transitions :(. So add the \u201copened\u201d state on the next tick.\n                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289\n                setTimeout( function() {\n\n                    // Add the \u201copened\u201d class to the picker root.\n                    P.$root.addClass( CLASSES.opened )\n                    aria( P.$root[0], 'hidden', false )\n\n                }, 0 )\n\n                // If we have to give focus, bind the element and doc events.\n                if ( dontGiveFocus !== false ) {\n\n                    // Set it as open.\n                    STATE.open = true\n\n                    // Prevent the page from scrolling.\n                    if ( IS_DEFAULT_THEME ) {\n                        $html.\n                            css( 'overflow', 'hidden' ).\n                            css( 'padding-right', '+=' + getScrollbarWidth() )\n                    }\n\n                    // Pass focus to the root element\u2019s jQuery object.\n                    // * Workaround for iOS8 to bring the picker\u2019s root into view.\n                    P.$root[0].focus()\n\n                    // Bind the document events.\n                    $document.on( 'click.' + STATE.id + ' focusin.' + STATE.id, function( event ) {\n\n                        var target = event.target\n\n                        // If the target of the event is not the element, close the picker picker.\n                        // * Don\u2019t worry about clicks or focusins on the root because those don\u2019t bubble up.\n                        //   Also, for Firefox, a click on an `option` element bubbles up directly\n                        //   to the doc. So make sure the target wasn't the doc.\n                        // * In Firefox stopPropagation() doesn\u2019t prevent right-click events from bubbling,\n                        //   which causes the picker to unexpectedly close when right-clicking it. So make\n                        //   sure the event wasn\u2019t a right-click.\n                        if ( target != ELEMENT && target != document && event.which != 3 ) {\n\n                            // If the target was the holder that covers the screen,\n                            // keep the element focused to maintain tabindex.\n                            P.close( target === P.$root.children()[0] )\n                        }\n\n                    }).on( 'keydown.' + STATE.id, function( event ) {\n\n                        var\n                            // Get the keycode.\n                            keycode = event.keyCode,\n\n                            // Translate that to a selection change.\n                            keycodeToMove = P.component.key[ keycode ],\n\n                            // Grab the target.\n                            target = event.target\n\n\n                        // On escape, close the picker and give focus.\n                        if ( keycode == 27 ) {\n                            P.close( true )\n                        }\n\n\n                        // Check if there is a key movement or \u201center\u201d keypress on the element.\n                        else if ( target == P.$root[0] && ( keycodeToMove || keycode == 13 ) ) {\n\n                            // Prevent the default action to stop page movement.\n                            event.preventDefault()\n\n                            // Trigger the key movement action.\n                            if ( keycodeToMove ) {\n                                PickerConstructor._.trigger( P.component.key.go, P, [ PickerConstructor._.trigger( keycodeToMove ) ] )\n                            }\n\n                            // On \u201center\u201d, if the highlighted item isn\u2019t disabled, set the value and close.\n                            else if ( !P.$root.find( '.' + CLASSES.highlighted ).hasClass( CLASSES.disabled ) ) {\n                                P.set( 'select', P.component.item.highlight ).close()\n                            }\n                        }\n\n\n                        // If the target is within the root and \u201center\u201d is pressed,\n                        // prevent the default action and trigger a click on the target instead.\n                        else if ( $.contains( P.$root[0], target ) && keycode == 13 ) {\n                            event.preventDefault()\n                            target.click()\n                        }\n                    })\n                }\n\n                // Trigger the queued \u201copen\u201d events.\n                return P.trigger( 'open' )\n            }", "label": 3}
{"code": "func hostsWithDatastore(hosts []types.ManagedObjectReference, path string) []types.ManagedObjectReference {\n\tattached := hosts[:0]\n\tvar p object.DatastorePath\n\tp.FromString(path)\n\n\tfor _, host := range hosts {\n\t\th := Map.Get(host).(*HostSystem)\n\t\tif Map.FindByName(p.Datastore, h.Datastore) != nil {\n\t\t\tattached = append(attached, host)\n\t\t}\n\t}\n\n\treturn attached\n}", "label": 5}
{"code": "def _write_data(self, file):\n        \"\"\" Writes case data to file in ReStructuredText format.\n        \"\"\"\n        self.write_case_data(file)\n\n        file.write(\"Bus Data\\n\")\n        file.write(\"-\" * 8 + \"\\n\")\n        self.write_bus_data(file)\n        file.write(\"\\n\")\n\n        file.write(\"Branch Data\\n\")\n        file.write(\"-\" * 11 + \"\\n\")\n        self.write_branch_data(file)\n        file.write(\"\\n\")\n\n        file.write(\"Generator Data\\n\")\n        file.write(\"-\" * 14 + \"\\n\")\n        self.write_generator_data(file)\n        file.write(\"\\n\")", "label": 1}
{"code": "public function setAffectedServices($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\ErrorReporting\\V1beta1\\ServiceContext::class);\n        $this->affected_services = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function codeRegister($code)\n  {\n      if (!$phone = $this->dissectPhone()) {\n          throw new Exception('The provided phone number is not valid.');\n      }\n\n      $code = str_replace('-', '', $code);\n      $countryCode = ($phone['ISO3166'] != '') ? $phone['ISO3166'] : 'US';\n      $langCode = ($phone['ISO639'] != '') ? $phone['ISO639'] : 'en';\n\n      // Build the url.\n      $host = 'https://'.Constants::WHATSAPP_REGISTER_HOST;\n      $query = [\n      'cc'                 => $phone['cc'],\n      'in'                 => $phone['phone'],\n      'lg'                 => $langCode,\n      'lc'                 => $countryCode,\n      'id'                 => $this->identity,\n      'mistyped'           => '6',\n      'network_radio_type' => '1',\n      'simnum'             => '1',\n      's'                  => '',\n      'copiedrc'           => '1',\n      'hasinrc'            => '1',\n      'rcmatch'            => '1',\n      'pid'                => mt_rand(100, 9999),\n      'rchash'             => hash('sha256', openssl_random_pseudo_bytes(20)),\n      'anhash'             => md5(openssl_random_pseudo_bytes(20)),\n      'extexist'           => '1',\n      'extstate'           => '1',\n      'code'               => $code,\n      ];\n\n      $this->debugPrint($query);\n\n      $response = $this->getResponse($host, $query);\n\n      $this->debugPrint($response);\n      \n      if ($response->status != 'ok') {\n          $this->eventManager()->fire('onCodeRegisterFailed',\n            [\n                $this->phoneNumber,\n                $response->status,\n                $response->reason,\n                isset($response->retry_after) ? $response->retry_after : null,\n            ]);\n\n          if ($response->reason == 'old_version') {\n              $this->update();\n          }\n\n          throw new Exception(\"An error occurred registering the registration code from WhatsApp. Reason: $response->reason\");\n      } else {\n          $this->eventManager()->fire('onCodeRegister',\n            [\n                $this->phoneNumber,\n                $response->login,\n                $response->pw,\n                $response->type,\n                $response->expiration,\n                $response->kind,\n                $response->price,\n                $response->cost,\n                $response->currency,\n                $response->price_expiration,\n            ]);\n      }\n\n      return $response;\n  }", "label": 2}
{"code": "function buildScriptsAndStyleFiles(outputPath) {\n\tconst stylesRegex = /<style>|<\\/style>/gi,\n\t\tscriptsRegex = /<script type=\"text\\/javascript\">|<\\/script>/gi;\n\n\t// creates the report directory if it doesn't exist\n\tif (!fs.existsSync(outputPath)) {\n\t\tfs.mkdirSync(outputPath);\n\t}\n\n\t// create the styles.css and main.js files\n\twriteFile(`${outputPath}styles.css`, styles(), stylesRegex);\n\twriteFile(`${outputPath}main.js`, scripts(), scriptsRegex);\n}", "label": 3}
{"code": "public function setJobs($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Talent\\V4beta1\\Job::class);\n        $this->jobs = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def submit_form_action(step, url):\n    \"\"\"\n    Submit the form having given action URL.\n    \"\"\"\n    form = world.browser.find_element_by_xpath(str('//form[@action=\"%s\"]' %\n                                                   url))\n    form.submit()", "label": 1}
{"code": "public final boolean hasReturnValues()\r\n    {\r\n        if (this.hasReturnValue())\r\n        {\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            // TODO: We may be able to 'pre-calculate' the results\r\n            // of this loop by just checking arguments as they are added\r\n            // The only problem is that the 'isReturnedbyProcedure' property\r\n            // can be modified once the argument is added to this procedure.\r\n            // If that occurs, then 'pre-calculated' results will be inacccurate.\r\n            Iterator iter = this.getArguments().iterator();\r\n            while (iter.hasNext())\r\n            {\r\n                ArgumentDescriptor arg = (ArgumentDescriptor) iter.next();\r\n                if (arg.getIsReturnedByProcedure())\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }", "label": 0}
{"code": "def destroyed_for_counter_culture?\n      if respond_to?(:paranoia_destroyed?)\n        paranoia_destroyed?\n      elsif defined?(Discard::Model) && self.class.include?(Discard::Model)\n        discarded?\n      else\n        false\n      end\n    end", "label": 4}
{"code": "function() {\n    var that = this;\n    this.killed = true;\n    if (this.started) {\n      this.container.kill();\n    } else {\n      this.once('container start', function() {\n        that.container.kill();\n      });\n    }\n  }", "label": 3}
{"code": "func (r *RotateRequest) CheckAndSetDefaults(clock clockwork.Clock) error {\n\tif r.TargetPhase == \"\" {\n\t\t// if phase if not set, imply that the first meaningful phase\n\t\t// is set as a target phase\n\t\tr.TargetPhase = services.RotationPhaseInit\n\t}\n\t// if mode is not set, default to manual (as it's safer)\n\tif r.Mode == \"\" {\n\t\tr.Mode = services.RotationModeManual\n\t}\n\tswitch r.Type {\n\tcase \"\", services.HostCA, services.UserCA:\n\tdefault:\n\t\treturn trace.BadParameter(\"unsupported certificate authority type: %q\", r.Type)\n\t}\n\tif r.GracePeriod == nil {\n\t\tperiod := defaults.RotationGracePeriod\n\t\tr.GracePeriod = &period\n\t}\n\tif r.Schedule == nil {\n\t\tvar err error\n\t\tr.Schedule, err = services.GenerateSchedule(clock, *r.GracePeriod)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t} else {\n\t\tif err := r.Schedule.CheckAndSetDefaults(clock); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function join() {\n  const components = _.isArray(arguments[0]) ? arguments[0] : _.toArray(arguments);\n  return path.join.apply(null, components).replace(/(.+)\\/+$/, '$1');\n}", "label": 3}
{"code": "func (i *IPAMData) Validate() error {\n\tvar isV6 bool\n\tif i.Pool == nil {\n\t\treturn types.BadRequestErrorf(\"invalid pool\")\n\t}\n\tif i.Gateway == nil {\n\t\treturn types.BadRequestErrorf(\"invalid gateway address\")\n\t}\n\tisV6 = i.IsV6()\n\tif isV6 && i.Gateway.IP.To4() != nil || !isV6 && i.Gateway.IP.To4() == nil {\n\t\treturn types.BadRequestErrorf(\"incongruent ip versions for pool and gateway\")\n\t}\n\tfor k, sip := range i.AuxAddresses {\n\t\tif isV6 && sip.IP.To4() != nil || !isV6 && sip.IP.To4() == nil {\n\t\t\treturn types.BadRequestErrorf(\"incongruent ip versions for pool and secondary ip address %s\", k)\n\t\t}\n\t}\n\tif !i.Pool.Contains(i.Gateway.IP) {\n\t\treturn types.BadRequestErrorf(\"invalid gateway address (%s) does not belong to the pool (%s)\", i.Gateway, i.Pool)\n\t}\n\tfor k, sip := range i.AuxAddresses {\n\t\tif !i.Pool.Contains(sip.IP) {\n\t\t\treturn types.BadRequestErrorf(\"invalid secondary address %s (%s) does not belong to the pool (%s)\", k, i.Gateway, i.Pool)\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "public function setType($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Dialogflow\\V2\\Intent_TrainingPhrase_Type::class);\n        $this->type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def updated?\n      current_watched = watched\n      if @last_watched.size != current_watched.size\n        @watched = current_watched\n        true\n      else\n        current_updated_at = updated_at(current_watched)\n        if @last_update_at < current_updated_at\n          @watched    = current_watched\n          @updated_at = current_updated_at\n          true\n        else\n          false\n        end\n      end\n    end", "label": 4}
{"code": "function (options, iterationInfo, modules) {\n        // filename filter\n        if (options.fileNameFilter) {\n            var match = iterationInfo.fileName.match(options.fileNameFilter);\n            if (!match) {\n                return;\n            }\n        }\n\n        // Filter spec.js files\n        var match = iterationInfo.fileName.match(/.spec.js/i);\n        if (match) {\n            return;\n        }\n\n        // relative path filter\n        if (options.relativePathFilter) {\n            var pathMatch = iterationInfo.relativeFullPath.match(options.relativePathFilter);\n            if (!pathMatch)\n                return;\n        }\n\n        //load module\n        loadModule(modules, options, iterationInfo);\n    }", "label": 3}
{"code": "public function collections(array $options = [])\n    {\n        $resultLimit = $this->pluck('resultLimit', $options, false);\n        return new ItemIterator(\n            new PageIterator(\n                function ($collectionId) {\n                    return new CollectionReference(\n                        $this->connection,\n                        $this->valueMapper,\n                        $this->childPath($this->name, $collectionId)\n                    );\n                },\n                [$this->connection, 'listCollectionIds'],\n                $options + ['parent' => $this->name],\n                [\n                    'itemsKey' => 'collectionIds',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "def add_atomic_update(clazz, updates={})\n      documents = updates.map { |id, m| prepare_atomic_update(clazz, id, m) }\n      add_batch_documents(documents)\n    end", "label": 4}
{"code": "function Logger( configuration, channels = [] ) {\n   this.levels = { ...levels, ...configuration.get( 'logging.levels' ) };\n\n   this.queueSize_ = 100;\n   this.channels_ = channels;\n   this.counter_ = 0;\n   this.messageQueue_ = [];\n   this.threshold_ = 0;\n   this.tags_ = {};\n\n   this.levelToName_ = ( levels => {\n      const result = {};\n      forEach( levels, ( level, levelName ) => {\n         this[ levelName.toLowerCase() ] = ( ...args ) => {\n            this.log( level, ...args, BLACKBOX );\n         };\n         result[ level ] = levelName;\n      } );\n      return result;\n   } )( this.levels );\n\n   this.setLogThreshold( configuration.ensure( 'logging.threshold' ) );\n}", "label": 3}
{"code": "function filterOutNullData(fieldValues) {\n  return _.filter(fieldValues || [], function(val) {\n    return val === false || val === 0 || val;\n  });\n}", "label": 3}
{"code": "public function start()\n    {\n        if ($this->restart) {\n            echo 'Restarting consumer.' . PHP_EOL;\n            $this->restart = false;\n        } else {\n            echo 'Starting consumer.' . PHP_EOL;\n        }\n\n        $exchange = 'router';\n        $queue    = 'msgs';\n\n        $this->channel = $this->connection->channel();\n        $this->channel->queue_declare($queue, false, true, false, false);\n        $this->channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);\n        $this->channel->queue_bind($queue, $exchange);\n        $this->channel->basic_consume(\n            $queue,\n            $this->consumerTag,\n            false,\n            false,\n            false,\n            false,\n            [$this,'messageHandler'],\n            null,\n            ['x-cancel-on-ha-failover' => ['t', true]] // fail over to another node\n        );\n\n        echo 'Enter wait.' . PHP_EOL;\n        while ($this->channel->is_consuming()) {\n            $this->channel->wait();\n        }\n        echo 'Exit wait.' . PHP_EOL;\n    }", "label": 2}
{"code": "function() {\n      var propertyName = this.ids.property;\n      var propertyNameContainsIdContainer = containsContainerDefinition(propertyName);\n      var hasIdContainerProperty = !_.isUndefined(this.ids.idContainer);\n\n      var idContainer;\n      if (hasIdContainerProperty) {\n        idContainer = this.__parseIdContainer();\n      }\n\n      if (propertyNameContainsIdContainer) {\n        var containerAndDetail = this.__parseContainerDetailString(propertyName);\n        propertyName = containerAndDetail.detail;\n        idContainer = containerAndDetail.idContainer;\n      }\n\n      if (_.isUndefined(idContainer)) {\n        idContainer = this.view;\n      }\n\n      return {\n        idsPropertyName: propertyName,\n        idContainer: idContainer\n      };\n    }", "label": 3}
{"code": "def encrypted_attributes\n      @encrypted_attributes ||= begin\n        duplicated= {}\n        self.class.encrypted_attributes.map { |key, value| duplicated[key] = value.dup }\n        duplicated\n      end\n    end", "label": 4}
{"code": "def user_is_depositor?(document_id)\n        Hyrax::WorkRelation.new.search_with_conditions(\n          id: document_id,\n          DepositSearchBuilder.depositor_field => current_user.user_key\n        ).any?\n      end", "label": 4}
{"code": "func (l *Limiter) WrapHandle(h http.Handler) {\n\tl.rateLimiter.Wrap(h)\n\tl.ConnLimiter.Wrap(l.rateLimiter)\n}", "label": 5}
{"code": "def update_attributes(attributes)\n      attributes.each { |attribute, value| write_attribute(attribute, value) }\n      save\n    end", "label": 4}
{"code": "def optimize_quoted_uri_escapes!(escaped)\n      escaped.gsub!('%3D', '=')\n      escaped.gsub!('%3A', ':')\n      escaped.gsub!('%2F', '/')\n      escaped.gsub!('%27', \"'\")\n      escaped.tr!('+', ' ')\n    end", "label": 4}
{"code": "def render_custom(tags)\n      meta_tags.meta_tags.each do |name, data|\n        Array(data).each do |val|\n          tags << Tag.new(:meta, configured_name_key(name) => name, content: val)\n        end\n        meta_tags.extract(name)\n      end\n    end", "label": 4}
{"code": "def primary_machine_name\n      # If it is a single machine environment, then return the name\n      return machine_names.first if machine_names.length == 1\n\n      # If it is a multi-machine environment, then return the primary\n      @config.vm.defined_vms.each do |name, subvm|\n        return name if subvm.options[:primary]\n      end\n\n      # If no primary was specified, nil it is\n      nil\n    end", "label": 4}
{"code": "function (value, length, pad) {\n        return _gpfToBaseANY(_gpfB16, value, {\n            length: length,\n            pad: pad\n        });\n    }", "label": 3}
{"code": "public double Function1D(double x) {\n        return Math.exp(x * x / (-2 * sqrSigma)) / (Math.sqrt(2 * Math.PI) * sigma);\n    }", "label": 0}
{"code": "public function setConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Iot\\V1\\DeviceConfig::class);\n        $this->config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function() {\n            var keys = arguments.length > 0 ? Array.prototype.slice.call(arguments, 0) : undefined;\n            return {\n                getInitialState: function() {\n                    var self = this;\n                    modelOrCollectionEventHandler(typeData.type, keys || 'updateOn', this, '{key}', function() {\n                        self.deferUpdate();\n                    });\n                }\n            };\n        }", "label": 3}
{"code": "def index_bamfile(job, bamfile, sample_type, univ_options, samtools_options, sample_info=None,\n                  export=True):\n    \"\"\"\n    Index `bamfile` using samtools\n\n    :param toil.fileStore.FileID bamfile: fsID for the bam file\n    :param str sample_type: Description of the sample to inject into the filename\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict samtools_options: Options specific to samtools\n    :param str sample_info: Information regarding the sample that will beinjected into the filename\n               as `sample_type`_`sample_info`.bam(.bai)\n    :param bool export: Should the bam and bai be exported to the output directory?\n    :return: Dict containing input bam and the generated index (.bam.bai)\n             output_files:\n                 |- '<sample_type>(_<sample_info>).bam': fsID\n                 +- '<sample_type>(_<sample_info>).bam.bai': fsID\n    :rtype: dict\n    \"\"\"\n    work_dir = os.getcwd()\n    in_bamfile = sample_type\n    if sample_info is not None:\n        assert isinstance(sample_info, str)\n        in_bamfile = '_'.join([in_bamfile, sample_info])\n    in_bamfile += '.bam'\n    input_files = {\n        in_bamfile: bamfile}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=True)\n    parameters = ['index',\n                  input_files[in_bamfile]]\n    docker_call(tool='samtools', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], tool_version=samtools_options['version'])\n    out_bai = '/'.join([work_dir, in_bamfile + '.bai'])\n    output_files = {in_bamfile: bamfile,\n                    in_bamfile + '.bai': job.fileStore.writeGlobalFile(out_bai)}\n    if export:\n        export_results(job, bamfile, os.path.splitext(out_bai)[0], univ_options,\n                       subfolder='alignments')\n        export_results(job, output_files[in_bamfile + '.bai'], out_bai, univ_options,\n                       subfolder='alignments')\n    job.fileStore.logToMaster('Ran samtools-index on %s:%s successfully'\n                              % (univ_options['patient'], sample_type))\n    return output_files", "label": 1}
{"code": "function createNewFile(db, fileName, fileReadStream, options, cb) {\n  defaultLogger.debug(\"In createNewFile\");\n  createFileWithVersion(db, fileName, fileReadStream, constants.LOWEST_VERSION, options, cb);\n}", "label": 3}
{"code": "function sendError(res,err) {\n    console.error(err);\n    // also log last executed query, for easier debugging\n    console.error(lastQry.sql);\n    res.statusCode = 500;\n    res.send({\n        result: 'error',\n        err:    err\n    });\n}", "label": 3}
{"code": "function swagger20TypeFor(type) {\n    if (!type) { return null; }\n    if (type === Number) { return 'number'; }\n    if (type === Boolean) { return 'boolean'; }\n    if (type === String || \n\t\ttype === Date ||\n\t\ttype === mongoose.Schema.Types.ObjectId || \n\t\ttype === mongoose.Schema.Types.Oid) { \n\t\treturn 'string'; \n\t}\n    if (type === mongoose.Schema.Types.Array || \n\t\tArray.isArray(type) || \n\t\ttype.name === \"Array\") { \n\t\treturn 'array'; \n\t}\n    if (type === Object  ||\n\t\ttype instanceof Object ||\n\t\ttype === mongoose.Schema.Types.Mixed ||\n\t\ttype === mongoose.Schema.Types.Buffer) { \n\t\treturn null; \n\t}\n    throw new Error('Unrecognized type: ' + type);\n  }", "label": 3}
{"code": "func StartBee(bee BeeConfig) *BeeInterface {\n\tb := NewBeeInstance(bee)\n\n\t(*b).Start()\n\tgo func(mod *BeeInterface) {\n\t\tstartBee(mod, 0)\n\t}(b)\n\n\treturn b\n}", "label": 5}
{"code": "def _get_bucket_endpoint(self):\n        \"\"\"\n        Queries S3 to identify the region hosting the provided bucket.\n        \"\"\"\n        conn = S3Connection()\n        bucket = conn.lookup(self.bucket_name)\n        if not bucket:\n            # TODO: Make the bucket here?\n            raise InputParameterError('The provided bucket %s doesn\\'t exist' % self.bucket_name)\n        endpoint = str(bucket.get_location())\n        return endpoint", "label": 1}
{"code": "def perform(action, options = {})\n      return unless %i[\n        backtrace\n        down\n        finish\n        frame\n        next\n        step\n        up\n      ].include?(action)\n\n      send(\"perform_#{action}\", options)\n    end", "label": 4}
{"code": "private PersistenceBroker obtainBroker()\r\n    {\r\n        PersistenceBroker _broker;\r\n        try\r\n        {\r\n            if (pbKey == null)\r\n            {\r\n                //throw new OJBRuntimeException(\"Not possible to do action, cause no tx runnning and no PBKey is set\");\r\n                log.warn(\"No tx runnning and PBKey is null, try to use the default PB\");\r\n                _broker = PersistenceBrokerFactory.defaultPersistenceBroker();\r\n            }\r\n            else\r\n            {\r\n                _broker = PersistenceBrokerFactory.createPersistenceBroker(pbKey);\r\n            }\r\n        }\r\n        catch (PBFactoryException e)\r\n        {\r\n            log.error(\"Could not obtain PB for PBKey \" + pbKey, e);\r\n            throw new OJBRuntimeException(\"Unexpected micro-kernel exception\", e);\r\n        }\r\n        return _broker;\r\n    }", "label": 0}
{"code": "public function refresh($entity)\n    {\n        if (! is_object($entity)) {\n            throw ORMInvalidArgumentException::invalidObject('EntityManager#refresh()', $entity);\n        }\n\n        $this->errorIfClosed();\n\n        $this->unitOfWork->refresh($entity);\n    }", "label": 2}
{"code": "public static aaagroup_aaauser_binding[] get(nitro_service service, String groupname) throws Exception{\n\t\taaagroup_aaauser_binding obj = new aaagroup_aaauser_binding();\n\t\tobj.set_groupname(groupname);\n\t\taaagroup_aaauser_binding response[] = (aaagroup_aaauser_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def run_umap(self, X=None, metric=None, **kwargs):\n        \"\"\"Wrapper for umap-learn.\n\n        See https://github.com/lmcinnes/umap sklearn for the documentation\n        and source code.\n        \"\"\"\n\n        import umap as umap\n\n        if metric is None:\n            metric = self.distance\n\n        if(X is not None):\n            umap_obj = umap.UMAP(metric=metric, **kwargs)\n            dt = umap_obj.fit_transform(X)\n            return dt\n\n        else:\n            umap_obj = umap.UMAP(metric=metric, **kwargs)\n            umap2d = umap_obj.fit_transform(self.adata.obsm['X_pca'])\n            self.adata.obsm['X_umap'] = umap2d", "label": 1}
{"code": "public function forgetUsed()\n    {\n        if ($this->app['files']->exists($this->getUsedStoragePath())) {\n            $this->app['files']->delete($this->getUsedStoragePath());\n        }\n    }", "label": 2}
{"code": "def update_one(filter, update, options = {})\n      find(filter, options).update_one(update, options)\n    end", "label": 4}
{"code": "def register_curation_concern(*curation_concern_types)\n      Array.wrap(curation_concern_types).flatten.compact.each do |cc_type|\n        @registered_concerns << cc_type unless @registered_concerns.include?(cc_type)\n      end\n    end", "label": 4}
{"code": "func (sl *DiskSessionLogger) flush() error {\n\tvar err, err2 error\n\n\tif sl.RecordSessions && sl.chunksFile != nil {\n\t\terr = sl.chunksFile.Flush()\n\t}\n\tif sl.eventsFile != nil {\n\t\terr2 = sl.eventsFile.Flush()\n\t}\n\treturn trace.NewAggregate(err, err2)\n}", "label": 5}
{"code": "def dumps(obj, indent=None, default=None, sort_keys=False, **kw):\n    \"\"\"Dump string.\"\"\"\n    return YAMLEncoder(indent=indent, default=default, sort_keys=sort_keys, **kw).encode(obj)", "label": 1}
{"code": "def disconnect!(wait=false)\n      unless @connecting || @connected\n        return true\n      end\n      @periodic_executor.stop!\n      @servers.each do |server|\n        if server.connected?\n          server.disconnect!(wait)\n          publish_sdam_event(\n            Monitoring::SERVER_CLOSED,\n            Monitoring::Event::ServerClosed.new(server.address, topology)\n          )\n        end\n      end\n      publish_sdam_event(\n        Monitoring::TOPOLOGY_CLOSED,\n        Monitoring::Event::TopologyClosed.new(topology)\n      )\n      @connecting = @connected = false\n      true\n    end", "label": 4}
{"code": "def to_hash\n      {\n        'status'       => status.to_hash,\n        'headers'      => headers,\n        'body'         => serializable_body,\n        'http_version' => http_version\n      }.tap do |hash|\n        hash['adapter_metadata'] = adapter_metadata unless adapter_metadata.empty?\n      end\n    end", "label": 4}
{"code": "func (c *Manager) UpdateCategory(ctx context.Context, category *Category) error {\n\tspec := struct {\n\t\tCategory Category `json:\"update_spec\"`\n\t}{\n\t\tCategory: Category{\n\t\t\tAssociableTypes: category.AssociableTypes,\n\t\t\tCardinality:     category.Cardinality,\n\t\t\tDescription:     category.Description,\n\t\t\tName:            category.Name,\n\t\t},\n\t}\n\turl := internal.URL(c, internal.CategoryPath).WithID(category.ID)\n\treturn c.Do(ctx, url.Request(http.MethodPatch, spec), nil)\n}", "label": 5}
{"code": "func (c *LicenseV3) String() string {\n\tvar features []string\n\tif !c.Expiry().IsZero() {\n\t\tfeatures = append(features, fmt.Sprintf(\"expires at %v\", c.Expiry()))\n\t}\n\tif c.Spec.ReportsUsage.Value() {\n\t\tfeatures = append(features, \"reports usage\")\n\t}\n\tif c.Spec.SupportsKubernetes.Value() {\n\t\tfeatures = append(features, \"supports kubernetes\")\n\t}\n\tif c.Spec.AWSProductID != \"\" {\n\t\tfeatures = append(features, fmt.Sprintf(\"is limited to AWS product ID %q\", c.Spec.AWSProductID))\n\t}\n\tif c.Spec.AWSAccountID != \"\" {\n\t\tfeatures = append(features, fmt.Sprintf(\"is limited to AWS account ID %q\", c.Spec.AWSAccountID))\n\t}\n\tif len(features) == 0 {\n\t\treturn \"\"\n\t}\n\treturn strings.Join(features, \",\")\n}", "label": 5}
{"code": "public function getResponsiveImagesDirectoryUrl(): string\n    {\n        return url($this->getBaseMediaDirectoryUrl().'/'.$this->pathGenerator->getPathForResponsiveImages($this->media)).'/';\n    }", "label": 2}
{"code": "public function record(ResolveInfo $resolveInfo, $start, $end): void\n    {\n        $this->resolverTraces [] = [\n            'path' => $resolveInfo->path,\n            'parentType' => $resolveInfo->parentType->name,\n            'returnType' => $resolveInfo->returnType->__toString(),\n            'fieldName' => $resolveInfo->fieldName,\n            'startOffset' => $this->diffTimeInNanoseconds($this->requestStartPrecise, $start),\n            'duration' => $this->diffTimeInNanoseconds($start, $end),\n        ];\n    }", "label": 2}
{"code": "def verified(signed_message, purpose: nil, **)\n      if valid_message?(signed_message)\n        begin\n          data = signed_message.split(\"--\")[0]\n          message = Messages::Metadata.verify(decode(data), purpose)\n          @serializer.load(message) if message\n        rescue ArgumentError => argument_error\n          return if argument_error.message.include?(\"invalid base64\")\n          raise\n        end\n      end\n    end", "label": 4}
{"code": "def delete_messages(messages, strict = false)\n      raise ArgumentError, 'Can only delete between 2 and 100 messages!' unless messages.count.between?(2, 100)\n\n      messages.map!(&:resolve_id)\n      bulk_delete(messages, strict)\n    end", "label": 4}
{"code": "function create(modulePath, moduleStack) {\n\n        // first check the cache to see if we already loaded it\n        if (this.cache[modulePath]) {\n            return this.cache[modulePath];\n        }\n\n        // try to get the resource for this module\n        var resource;\n        if (this.resources[modulePath]) {\n            resource = this.resources[modulePath];\n        }\n        else if (this.resourceNames[modulePath]) {\n            resource = this.injector.loadModule(this.resourceNames[modulePath] + 'Resource');\n        }\n        else {\n            return null;\n        }\n\n        // get the service for this model\n        var serviceName = modulePath.substring(0, 1).toLowerCase() + modulePath.substring(1) + 'Service';\n        var service = this.injector.loadModule(serviceName, moduleStack);\n\n        // save the model to cache and return it\n        var Model = this.getModel(service, resource.mixins);\n        this.cache[modulePath] = Model;\n        return Model;\n    }", "label": 3}
{"code": "public function info( $_, $assoc_args ) {\n\t\t$php_bin = Utils\\get_php_binary();\n\n\t\t// php_uname() $mode argument was only added with PHP 7.0+. Fall back to\n\t\t// entire string for older versions.\n\t\t$system_os = PHP_MAJOR_VERSION < 7\n\t\t\t? php_uname()\n\t\t\t: sprintf(\n\t\t\t\t'%s %s %s %s',\n\t\t\t\tphp_uname( 's' ),\n\t\t\t\tphp_uname( 'r' ),\n\t\t\t\tphp_uname( 'v' ),\n\t\t\t\tphp_uname( 'm' )\n\t\t\t);\n\n\t\t$shell = getenv( 'SHELL' );\n\t\tif ( ! $shell && Utils\\is_windows() ) {\n\t\t\t$shell = getenv( 'ComSpec' );\n\t\t}\n\n\t\t$runner = WP_CLI::get_runner();\n\n\t\t$packages_dir = $runner->get_packages_dir_path();\n\t\tif ( ! is_dir( $packages_dir ) ) {\n\t\t\t$packages_dir = null;\n\t\t}\n\t\tif ( \\WP_CLI\\Utils\\get_flag_value( $assoc_args, 'format' ) === 'json' ) {\n\t\t\t$info = array(\n\t\t\t\t'php_binary_path'          => $php_bin,\n\t\t\t\t'global_config_path'       => $runner->global_config_path,\n\t\t\t\t'project_config_path'      => $runner->project_config_path,\n\t\t\t\t'wp_cli_dir_path'          => WP_CLI_ROOT,\n\t\t\t\t'wp_cli_packages_dir_path' => $packages_dir,\n\t\t\t\t'wp_cli_version'           => WP_CLI_VERSION,\n\t\t\t\t'system_os'                => $system_os,\n\t\t\t\t'shell'                    => $shell,\n\t\t\t);\n\n\t\t\tWP_CLI::line( json_encode( $info ) );\n\t\t} else {\n\t\t\tWP_CLI::line( \"OS:\\t\" . $system_os );\n\t\t\tWP_CLI::line( \"Shell:\\t\" . $shell );\n\t\t\tWP_CLI::line( \"PHP binary:\\t\" . $php_bin );\n\t\t\tWP_CLI::line( \"PHP version:\\t\" . PHP_VERSION );\n\t\t\tWP_CLI::line( \"php.ini used:\\t\" . get_cfg_var( 'cfg_file_path' ) );\n\t\t\tWP_CLI::line( \"WP-CLI root dir:\\t\" . WP_CLI_ROOT );\n\t\t\tWP_CLI::line( \"WP-CLI vendor dir:\\t\" . WP_CLI_VENDOR_DIR );\n\t\t\tWP_CLI::line( \"WP_CLI phar path:\\t\" . ( defined( 'WP_CLI_PHAR_PATH' ) ? WP_CLI_PHAR_PATH : '' ) );\n\t\t\tWP_CLI::line( \"WP-CLI packages dir:\\t\" . $packages_dir );\n\t\t\tWP_CLI::line( \"WP-CLI global config:\\t\" . $runner->global_config_path );\n\t\t\tWP_CLI::line( \"WP-CLI project config:\\t\" . $runner->project_config_path );\n\t\t\tWP_CLI::line( \"WP-CLI version:\\t\" . WP_CLI_VERSION );\n\t\t}\n\t}", "label": 2}
{"code": "def extract_enabled_linters(config, options)\n      included_linters =\n        LinterRegistry.extract_linters_from(options.fetch(:included_linters, []))\n\n      included_linters = LinterRegistry.linters if included_linters.empty?\n\n      excluded_linters =\n        LinterRegistry.extract_linters_from(options.fetch(:excluded_linters, []))\n\n      # After filtering out explicitly included/excluded linters, only include\n      # linters which are enabled in the configuration\n      linters = (included_linters - excluded_linters).map do |linter_class|\n        linter_config = config.for_linter(linter_class)\n        linter_class.new(linter_config) if linter_config['enabled']\n      end.compact\n\n      # Highlight condition where all linters were filtered out, as this was\n      # likely a mistake on the user's part\n      if linters.empty?\n        raise HamlLint::Exceptions::NoLintersError, 'No linters specified'\n      end\n\n      linters\n    end", "label": 4}
{"code": "func (m *MockMatcher) Matches(arg0 interface{}) bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Matches\", arg0)\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}", "label": 5}
{"code": "def bulk_export(self, config_ids=None, device_ids=None, package_ids=None, result_ids=None, exclude_captures=False):\n        \"\"\"Bulk export a set of configs, devices, packages and results.\n\n        :param config_ids: (optional) Int list of config IDs.\n        :param device_ids: (optional) Int list of device IDs.\n        :param package_ids: (optional) Int list of package IDs.\n        :param result_ids: (optional) Int list of result IDs.\n        :param exclude_captures: (optional) Exclude capture files if bool `True`.\n        :rtype: tuple `(io.BytesIO, 'filename')`\n        \"\"\"\n        if config_ids is None:\n            config_ids = []\n        if device_ids is None:\n            device_ids = []\n        if package_ids is None:\n            package_ids = []\n        if result_ids is None:\n            result_ids = []\n        json = {\n            'configs': map(int, config_ids),\n            'devices': map(int, device_ids),\n            'packages': map(int, package_ids),\n            'results': map(int, result_ids),\n            'options': {'exclude_captures': exclude_captures}\n        }\n        resp = self.service.post(self.base, json=json, stream=True)\n        b = io.BytesIO()\n        stream.stream_response_to_file(resp, path=b)\n        resp.close()\n        b.seek(0)\n        return (b, self.service.filename(resp))", "label": 1}
{"code": "protected function getRequestParameter($parameter, ServerRequestInterface $request, $default = null)\n    {\n        $requestParameters = (array) $request->getParsedBody();\n\n        return $requestParameters[$parameter] ?? $default;\n    }", "label": 2}
{"code": "def head(self, url, *args, **kwargs):\n        \"\"\"Returns response to http HEAD\n        on provided url\n        \"\"\"\n        res = self._conn.head(url, headers=self._prepare_headers(**kwargs))\n        if res.status_code == 200:\n            return res\n        return None", "label": 1}
{"code": "public function ListUptimeCheckIps(\\Google\\Cloud\\Monitoring\\V3\\ListUptimeCheckIpsRequest $argument,\n      $metadata = [], $options = []) {\n        return $this->_simpleRequest('/google.monitoring.v3.UptimeCheckService/ListUptimeCheckIps',\n        $argument,\n        ['\\Google\\Cloud\\Monitoring\\V3\\ListUptimeCheckIpsResponse', 'decode'],\n        $metadata, $options);\n    }", "label": 2}
{"code": "func AuthUserGroupByID(db XODB, id int) (*AuthUserGroup, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`id, user_id, group_id ` +\n\t\t`FROM django.auth_user_groups ` +\n\t\t`WHERE id = ?`\n\n\t// run query\n\tXOLog(sqlstr, id)\n\taug := AuthUserGroup{\n\t\t_exists: true,\n\t}\n\n\terr = db.QueryRow(sqlstr, id).Scan(&aug.ID, &aug.UserID, &aug.GroupID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &aug, nil\n}", "label": 5}
{"code": "public static base_response update(nitro_service client, csparameter resource) throws Exception {\n\t\tcsparameter updateresource = new csparameter();\n\t\tupdateresource.stateupdate = resource.stateupdate;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def render(*args)\n      return ''.freeze if @root.nil?\n\n      context = case args.first\n      when Liquid::Context\n        c = args.shift\n\n        if @rethrow_errors\n          c.exception_renderer = ->(e) { raise }\n        end\n\n        c\n      when Liquid::Drop\n        drop = args.shift\n        drop.context = Context.new([drop, assigns], instance_assigns, registers, @rethrow_errors, @resource_limits)\n      when Hash\n        Context.new([args.shift, assigns], instance_assigns, registers, @rethrow_errors, @resource_limits)\n      when nil\n        Context.new(assigns, instance_assigns, registers, @rethrow_errors, @resource_limits)\n      else\n        raise ArgumentError, \"Expected Hash or Liquid::Context as parameter\"\n      end\n\n      case args.last\n      when Hash\n        options = args.pop\n\n        registers.merge!(options[:registers]) if options[:registers].is_a?(Hash)\n\n        apply_options_to_context(context, options)\n      when Module, Array\n        context.add_filters(args.pop)\n      end\n\n      # Retrying a render resets resource usage\n      context.resource_limits.reset\n\n      begin\n        # render the nodelist.\n        # for performance reasons we get an array back here. join will make a string out of it.\n        result = with_profiling(context) do\n          @root.render(context)\n        end\n        result.respond_to?(:join) ? result.join : result\n      rescue Liquid::MemoryError => e\n        context.handle_error(e)\n      ensure\n        @errors = context.errors\n      end\n    end", "label": 4}
{"code": "def delete(self, filepath):\n        \"\"\"\n        Stop and delete the specified filewatcher.\n        \"\"\"\n        Filewatcher.remove_directory_to_watch(filepath)\n        self.write({'msg':'Watcher deleted for {}'.format(filepath)})", "label": 1}
{"code": "function (cfg, state, n) {\n        // Node 0.8 and 0.10 differently handle spawning errors ('exit' vs 'error'), but errors that happened after\n        // launching the command are both handled in 'exit' callback\n        return function (code, signal) {\n            // See http://tldp.org/LDP/abs/html/exitcodes.html and http://stackoverflow.com/a/1535733/\n            if (code === 0 || signal == \"SIGTERM\" || state.resetCalled) {\n                return;\n            }\n\n            var isNotRecoverable = (code == 127 || code == 126);\n            if (isNotRecoverable) {\n                ++state.erroredPhantomInstances;\n                var path = cfg.phantomPath;\n                if (code == 127) {\n                    logger.logError(\"Spawn: exited with code 127. PhantomJS executable not found. Make sure to download PhantomJS and add its folder to your system's PATH, or pass the full path directly to Attester via --phantomjs-path.\\nUsed command: '\" + path + \"'\");\n                } else if (code == 126) {\n                    logger.logError(\"Spawn: exited with code 126. Unable to execute PhantomJS. Make sure to have proper read & execute permissions set.\\nUsed command: '\" + path + \"'\");\n                }\n                checkIfAllPhantomsDied(cfg, state);\n                return;\n            }\n\n            // Now, try to recover unless retried too many times\n\n            // prepare error message\n            var errMsg;\n            if (code == 75) {\n                errMsg = \"Spawn: PhantomJS[\" + n + \"] exited with code 75: unable to load attester page within specified timeout, or errors happened while loading.\";\n                if (cfg.phantomInstances > 1) {\n                    errMsg += \" You may try decreasing the number of PhantomJS instances in attester config to avoid that problem.\";\n                }\n            } else {\n                errMsg = \"Spawn: PhantomJS[\" + n + \"] exited with code \" + code + \" and signal \" + signal;\n            }\n\n            // check how many retries happened for this instance\n            var retries = state.retries;\n            retries[n] = (retries[n] || 0) + 1;\n            if (retries[n] < cfg.maxRetries) {\n                // log just a warning and try rebooting\n                logger.logWarn(errMsg);\n                logger.logWarn(\"Trying to reboot instance nr \" + n + \"...\");\n                this.bootPhantom(cfg, state, n);\n            } else {\n                logger.logError(errMsg);\n                ++state.erroredPhantomInstances;\n                checkIfAllPhantomsDied(cfg, state);\n            }\n        };\n    }", "label": 3}
{"code": "public static autoscaleprofile[] get(nitro_service service) throws Exception{\n\t\tautoscaleprofile obj = new autoscaleprofile();\n\t\tautoscaleprofile[] response = (autoscaleprofile[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function resolve() {\n  expect(arguments).to.have.length.within(\n    1,\n    4,\n    'Invalid arguments length when resolving an Attribute (it has to be ' +\n    'passed from 1 to 4 arguments)'\n  );\n\n  var argumentArray = Array.prototype.slice.call(arguments);\n  var TypedAttribute = attributes.types.ObjectAttribute;\n\n  if (arguments.length === 1 && typeof arguments[0] !== 'string') {\n    var attribute = objects.copy(arguments[0]);\n    argumentArray[0] = attribute;\n\n    expect(attribute).to.be.an(\n      'object',\n      'Invalid argument type when resolving an Attribute (it has to be an ' +\n      'object)'\n    );\n\n    if (attribute.type) {\n      expect(attribute.type).to.be.a(\n        'string',\n        'Invalid argument \"type\" when resolving an Attribute' +\n        (attribute.name ? ' called' + attribute.name : '') +\n        ' (it has to be a string)'\n      );\n\n      try {\n        TypedAttribute = attributes.types.get(attribute.type);\n      } catch (e) {\n        if (e instanceof errors.AttributeTypeNotFoundError) {\n          TypedAttribute = attributes.types.AssociationAttribute;\n          attribute.entity = attribute.type;\n        } else {\n          throw e;\n        }\n      }\n\n      delete attribute.type;\n    }\n  } else {\n    if (arguments.length > 1) {\n      expect(arguments[1]).to.be.a(\n        'string',\n        'Invalid argument \"type\" when resolving an Attribute' +\n        (arguments[0] ? ' called' + arguments[0] : '') +\n        ' (it has to be a string)'\n      );\n\n      try {\n        TypedAttribute = attributes.types.get(arguments[1]);\n      } catch (e) {\n        if (e instanceof errors.AttributeTypeNotFoundError) {\n          TypedAttribute = attributes.types.AssociationAttribute;\n          argumentArray.splice(2, 0, arguments[1]);\n        } else {\n          throw e;\n        }\n      }\n\n      argumentArray.splice(1,1);\n    }\n  }\n\n  return new (Function.prototype.bind.apply(\n    TypedAttribute,\n    [null].concat(argumentArray)\n  ))();\n}", "label": 3}
{"code": "def endpoint(request):\n    \"\"\"Endpoint that SNS accesses. Includes logic verifying request\"\"\"\n    # pylint: disable=too-many-return-statements,too-many-branches\n\n    # In order to 'hide' the endpoint, all non-POST requests should return\n    # the site's default HTTP404\n    if request.method != 'POST':\n        raise Http404\n\n    # If necessary, check that the topic is correct\n    if hasattr(settings, 'BOUNCY_TOPIC_ARN'):\n        # Confirm that the proper topic header was sent\n        if 'HTTP_X_AMZ_SNS_TOPIC_ARN' not in request.META:\n            return HttpResponseBadRequest('No TopicArn Header')\n\n        # Check to see if the topic is in the settings\n        # Because you can have bounces and complaints coming from multiple\n        # topics, BOUNCY_TOPIC_ARN is a list\n        if (not request.META['HTTP_X_AMZ_SNS_TOPIC_ARN']\n                in settings.BOUNCY_TOPIC_ARN):\n            return HttpResponseBadRequest('Bad Topic')\n\n    # Load the JSON POST Body\n    if isinstance(request.body, str):\n        # requests return str in python 2.7\n        request_body = request.body\n    else:\n        # and return bytes in python 3.4\n        request_body = request.body.decode()\n    try:\n        data = json.loads(request_body)\n    except ValueError:\n        logger.warning('Notification Not Valid JSON: {}'.format(request_body))\n        return HttpResponseBadRequest('Not Valid JSON')\n\n    # Ensure that the JSON we're provided contains all the keys we expect\n    # Comparison code from http://stackoverflow.com/questions/1285911/\n    if not set(VITAL_NOTIFICATION_FIELDS) <= set(data):\n        logger.warning('Request Missing Necessary Keys')\n        return HttpResponseBadRequest('Request Missing Necessary Keys')\n\n    # Ensure that the type of notification is one we'll accept\n    if not data['Type'] in ALLOWED_TYPES:\n        logger.info('Notification Type Not Known %s', data['Type'])\n        return HttpResponseBadRequest('Unknown Notification Type')\n\n    # Confirm that the signing certificate is hosted on a correct domain\n    # AWS by default uses sns.{region}.amazonaws.com\n    # On the off chance you need this to be a different domain, allow the\n    # regex to be overridden in settings\n    domain = urlparse(data['SigningCertURL']).netloc\n    pattern = getattr(\n        settings, 'BOUNCY_CERT_DOMAIN_REGEX', r\"sns.[a-z0-9\\-]+.amazonaws.com$\"\n    )\n    if not re.search(pattern, domain):\n        logger.warning(\n            'Improper Certificate Location %s', data['SigningCertURL'])\n        return HttpResponseBadRequest('Improper Certificate Location')\n\n    # Verify that the notification is signed by Amazon\n    if (getattr(settings, 'BOUNCY_VERIFY_CERTIFICATE', True)\n            and not verify_notification(data)):\n        logger.error('Verification Failure %s', )\n        return HttpResponseBadRequest('Improper Signature')\n\n    # Send a signal to say a valid notification has been received\n    signals.notification.send(\n        sender='bouncy_endpoint', notification=data, request=request)\n\n    # Handle subscription-based messages.\n    if data['Type'] == 'SubscriptionConfirmation':\n        # Allow the disabling of the auto-subscription feature\n        if not getattr(settings, 'BOUNCY_AUTO_SUBSCRIBE', True):\n            raise Http404\n        return approve_subscription(data)\n    elif data['Type'] == 'UnsubscribeConfirmation':\n        # We won't handle unsubscribe requests here. Return a 200 status code\n        # so Amazon won't redeliver the request. If you want to remove this\n        # endpoint, remove it either via the API or the AWS Console\n        logger.info('UnsubscribeConfirmation Not Handled')\n        return HttpResponse('UnsubscribeConfirmation Not Handled')\n\n    try:\n        message = json.loads(data['Message'])\n    except ValueError:\n        # This message is not JSON. But we need to return a 200 status code\n        # so that Amazon doesn't attempt to deliver the message again\n        logger.info('Non-Valid JSON Message Received')\n        return HttpResponse('Message is not valid JSON')\n\n    return process_message(message, data)", "label": 1}
{"code": "public function write_shortstr($s)\n    {\n        $len = mb_strlen($s, 'ASCII');\n        if ($len > 255) {\n            throw new AMQPInvalidArgumentException('String too long');\n        }\n\n        $this->write_octet($len);\n        $this->out .= $s;\n\n        return $this;\n    }", "label": 2}
{"code": "private function translate(): self\n    {\n        if (empty($this->translations)) {\n            return $this;\n        }\n\n        $lang = $this->get('lang');\n\n        foreach ($this->attributes as $key => $attribute) {\n            if (in_array($key, $this->translations, true)) {\n                $this->set($key, __($attribute, [], $lang));\n            }\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "def _document_xml(self, doc_id):\n        \"\"\" Return xml Element for the document document_id. \"\"\"\n        doc_str = self._get_doc_by_raw_offset(str(doc_id))\n        return compat.ElementTree.XML(doc_str.encode('utf8'))", "label": 1}
{"code": "public function reload(array $options = [])\n    {\n        return $this->info = $this->connection->getOperation($options + [\n            'name' => $this->name\n        ]);\n    }", "label": 2}
{"code": "public static authenticationtacacspolicy_systemglobal_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauthenticationtacacspolicy_systemglobal_binding obj = new authenticationtacacspolicy_systemglobal_binding();\n\t\tobj.set_name(name);\n\t\tauthenticationtacacspolicy_systemglobal_binding response[] = (authenticationtacacspolicy_systemglobal_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function (root, symbol, bass) {\n  var name = root.name + symbol;\n  var octave = bass ? bass.octave : root.octave;\n\n  if (bass) name += '/' + bass.name;\n  return new Chord(name, octave);\n}", "label": 3}
{"code": "function add(className) {\n    if (typeof className === 'function') {\n      className = className.name;\n    }\n\n    extractBits.DIRECT_TYPES.push(className);\n  }", "label": 3}
{"code": "function convertToObject(unknownTypedInput, valueFunc = undefined) {\n    let obj = {};\n    if (typeof unknownTypedInput !== 'undefined') {\n        if (typeof unknownTypedInput === 'string') {\n            unknownTypedInput = [unknownTypedInput];\n        }\n        if (_.isArray(unknownTypedInput)) {\n            for (const element of unknownTypedInput) {\n                let value;\n                if (typeof valueFunc !== 'undefined') {\n                    value = valueFunc(element);\n                }\n                else {\n                    value = undefined;\n                }\n                obj[element] = value;\n            }\n        }\n        else {\n            obj = _.cloneDeep(unknownTypedInput);\n        }\n    }\n    return obj;\n}", "label": 3}
{"code": "public function stop($drop = false)\n    {\n        if (!$this->valid()) {\n            return false;\n        }\n\n        if ($drop) {\n            $this->invalidate();\n            $this->disconnect();\n        } else {\n            if ($this->isFlagSet(self::STATUS_SUBSCRIBED)) {\n                $this->unsubscribe();\n            }\n            if ($this->isFlagSet(self::STATUS_PSUBSCRIBED)) {\n                $this->punsubscribe();\n            }\n        }\n\n        return !$drop;\n    }", "label": 2}
{"code": "func (c *Call) dropPrereqs() (preReqs []*Call) {\n\tpreReqs = c.preReqs\n\tc.preReqs = nil\n\treturn\n}", "label": 5}
{"code": "function queryRxNormGroup(medname, callback) {\n    query(\"http://rxnav.nlm.nih.gov/REST/drugs.json\", {\n        name: medname\n    }, function (err, body) {\n        if (err) return callback(err);\n        drugFormList(JSON.parse(body), callback);\n    });\n}", "label": 3}
{"code": "func (f *DatastoreFile) Close() error {\n\tvar err error\n\n\tif f.body != nil {\n\t\terr = f.body.Close()\n\t\tf.body = nil\n\t}\n\n\tf.buf = nil\n\n\treturn err\n}", "label": 5}
{"code": "def get_patient_vcf(job, patient_dict):\n    \"\"\"\n    Convenience function to get the vcf from the patient dict\n\n    :param dict patient_dict: dict of patient info\n    :return: The vcf\n    :rtype: toil.fileStore.FileID\n    \"\"\"\n    temp = job.fileStore.readGlobalFile(patient_dict['mutation_vcf'],\n                                        os.path.join(os.getcwd(), 'temp.gz'))\n    if is_gzipfile(temp):\n        outfile = job.fileStore.writeGlobalFile(gunzip(temp))\n        job.fileStore.deleteGlobalFile(patient_dict['mutation_vcf'])\n    else:\n        outfile = patient_dict['mutation_vcf']\n    return outfile", "label": 1}
{"code": "func GetFilter(identifier string) *FilterInterface {\n\tfilter, ok := filters[identifier]\n\tif ok {\n\t\treturn filter\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "func (cfg *Config) CheckAndSetDefaults() error {\n\tif cfg.Path == \"\" && !cfg.Memory {\n\t\treturn trace.BadParameter(\"specify directory path to the database using 'path' parameter\")\n\t}\n\tif cfg.BufferSize == 0 {\n\t\tcfg.BufferSize = backend.DefaultBufferSize\n\t}\n\tif cfg.PollStreamPeriod == 0 {\n\t\tcfg.PollStreamPeriod = backend.DefaultPollStreamPeriod\n\t}\n\tif cfg.Clock == nil {\n\t\tcfg.Clock = clockwork.NewRealClock()\n\t}\n\tif cfg.Sync == \"\" {\n\t\tcfg.Sync = syncOFF\n\t}\n\tif cfg.BusyTimeout == 0 {\n\t\tcfg.BusyTimeout = busyTimeout\n\t}\n\tif cfg.MemoryName == \"\" {\n\t\tcfg.MemoryName = defaultDBFile\n\t}\n\treturn nil\n}", "label": 5}
{"code": "public function setQueryParams($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\QueryParameters::class);\n        $this->query_params = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function partial(area) {\n    var allFilter = null;\n\n    for (var _len2 = arguments.length, filters = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        filters[_key2 - 1] = arguments[_key2];\n    }\n\n    if (filters.length == 1 && typeof filters[0] === 'string') {\n        allFilter = filter$1(filters[0]);\n    } else {\n        allFilter = merge$1(filters);\n    }\n\n    return function (bitmap, done) {\n        var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        allFilter(getBitmap(bitmap, area), function (newBitmap) {\n            done(putBitmap(bitmap, newBitmap, area));\n        }, opt);\n    };\n}", "label": 3}
{"code": "def load_pip_addons(_globals):\n    '''Load all known fabsetup addons which are installed as pypi pip-packages.\n\n    Args:\n        _globals(dict): the globals() namespace of the fabric script.\n\n    Return: None\n    '''\n    for package_name in known_pip_addons:\n        _, username = package_username(package_name)\n        try:\n            load_addon(username, package_name.replace('-', '_'), _globals)\n        except ImportError:\n            pass", "label": 1}
{"code": "private String parseRssFeed(String feed) {\n        String[] result = feed.split(\"<br />\");\n        String[] result2 = result[2].split(\"<BR />\");\n\n        return result2[0];\n    }", "label": 0}
{"code": "def GetBEDnarrowPeakgz(URL_or_PATH_TO_file):\n    \"\"\"\n    Reads a gz compressed BED narrow peak file from a web address or local file\n\n    :param URL_or_PATH_TO_file: web address of path to local file\n\n    :returns: a Pandas dataframe\n    \"\"\"\n\n    if os.path.isfile(URL_or_PATH_TO_file):\n        response=open(URL_or_PATH_TO_file, \"r\")\n        compressedFile = StringIO.StringIO(response.read())\n    else:\n        response = urllib2.urlopen(URL_or_PATH_TO_file)\n        compressedFile = StringIO.StringIO(response.read())\n    decompressedFile = gzip.GzipFile(fileobj=compressedFile)\n    out=decompressedFile.read().split(\"\\n\")\n    out=[ s.split(\"\\t\") for s in out]\n    out=pd.DataFrame(out)\n    out.columns=[\"chrom\",\"chromStart\",\"chromEnd\",\"name\",\"score\",\"strand\",\"signalValue\",\"-log10(pValue)\",\"-log10(qvalue)\",\"peak\"]\n    out[\"name\"]=out.index.tolist()\n    out[\"name\"]=\"Peak_\"+out[\"name\"].astype(str)\n    out=out[:-1]\n    return out", "label": 1}
{"code": "public function setLocalizedObjectAnnotations($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\LocalizedObjectAnnotation::class);\n        $this->localized_object_annotations = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "protected function getDocBlockResponses(array $tags)\n    {\n        $responseTags = array_values(\n            array_filter($tags, function ($tag) {\n                return $tag instanceof Tag && strtolower($tag->getName()) === 'response';\n            })\n        );\n\n        if (empty($responseTags)) {\n            return;\n        }\n\n        return array_map(function (Tag $responseTag) {\n            preg_match('/^(\\d{3})?\\s?([\\s\\S]*)$/', $responseTag->getContent(), $result);\n\n            $status = $result[1] ?: 200;\n            $content = $result[2] ?: '{}';\n\n            return new JsonResponse(json_decode($content, true), (int) $status);\n        }, $responseTags);\n    }", "label": 2}
{"code": "def cleanup_environment\n      unless initial_commit? || (@stash_attempted && !@changes_stashed)\n        clear_working_tree # Ensure working tree is clean before restoring it\n        restore_modified_times\n      end\n\n      if @changes_stashed\n        restore_working_tree\n        restore_modified_times\n      end\n\n      Overcommit::GitRepo.restore_merge_state\n      Overcommit::GitRepo.restore_cherry_pick_state\n      restore_modified_times\n    end", "label": 4}
{"code": "public static netbridge[] get(nitro_service service, options option) throws Exception{\n\t\tnetbridge obj = new netbridge();\n\t\tnetbridge[] response = (netbridge[])obj.get_resources(service,option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func NetworkOptionDriverOpts(opts map[string]string) NetworkOption {\n\treturn func(n *network) {\n\t\tif n.generic == nil {\n\t\t\tn.generic = make(map[string]interface{})\n\t\t}\n\t\tif opts == nil {\n\t\t\topts = make(map[string]string)\n\t\t}\n\t\t// Store the options\n\t\tn.generic[netlabel.GenericData] = opts\n\t}\n}", "label": 5}
{"code": "private function formatValueForApi($value)\n    {\n        $type = gettype($value);\n\n        switch ($type) {\n            case 'string':\n                return ['string_value' => $value];\n            case 'double':\n            case 'integer':\n                return ['number_value' => $value];\n            case 'boolean':\n                return ['bool_value' => $value];\n            case 'NULL':\n                return ['null_value' => NullValue::NULL_VALUE];\n            case 'array':\n                if (!empty($value) && $this->isAssoc($value)) {\n                    return ['struct_value' => $this->formatStructForApi($value)];\n                }\n\n                return ['list_value' => $this->formatListForApi($value)];\n        }\n    }", "label": 2}
{"code": "function (str, options, cb) {\n    var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));\n    tmpl.eval(options, function(str){\n      cb(null, str);\n    });\n  }", "label": 3}
{"code": "def _parse_raster_info(self, prop=RASTER_INFO):\n        \"\"\" Collapses multiple dimensions into a single raster_info complex struct \"\"\"\n\n        raster_info = {}.fromkeys(_iso_definitions[prop], u'')\n\n        # Ensure conversion of lists to newlines is in place\n        raster_info['dimensions'] = get_default_for_complex_sub(\n            prop=prop,\n            subprop='dimensions',\n            value=parse_property(self._xml_tree, None, self._data_map, '_ri_num_dims'),\n            xpath=self._data_map['_ri_num_dims']\n        )\n\n        xpath_root = self._get_xroot_for(prop)\n        xpath_map = self._data_structures[prop]\n\n        for dimension in parse_complex_list(self._xml_tree, xpath_root, xpath_map, RASTER_DIMS):\n            dimension_type = dimension['type'].lower()\n\n            if dimension_type == 'vertical':\n                raster_info['vertical_count'] = dimension['size']\n\n            elif dimension_type == 'column':\n                raster_info['column_count'] = dimension['size']\n                raster_info['x_resolution'] = u' '.join(dimension[k] for k in ['value', 'units']).strip()\n\n            elif dimension_type == 'row':\n                raster_info['row_count'] = dimension['size']\n                raster_info['y_resolution'] = u' '.join(dimension[k] for k in ['value', 'units']).strip()\n\n        return raster_info if any(raster_info[k] for k in raster_info) else {}", "label": 1}
{"code": "public static function fromJson(array $data)\n    {\n        if (!$data) {\n            return null;\n        }\n\n        $data += [\n            'isError' => false,\n            'refersTo' => null,\n            'description' => null\n        ];\n        return new static($data['isError'], $data['refersTo'], FormatMessage::fromJson($data['description']));\n    }", "label": 2}
{"code": "def edit(self, resource):\n        \"\"\"Edit a tag.\n\n        :param resource: :class:`tags.Tag <tags.Tag>` object\n        :return: :class:`tags.Tag <tags.Tag>` object\n        :rtype: tags.Tag\n        \"\"\"\n        schema = TagSchema(only=('name', 'configs', 'devices', 'packages', 'results'))\n        json = self.service.encode(schema, resource)\n\n        schema = TagSchema()\n        resp = self.service.edit(self.base, resource.name, json)\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "function merge(dst, src, ignoreMap)\n{\n  if (isObject( dst ) && isObject( src ))\n  {\n    for (var prop in src)\n    {\n      if (!ignoreMap || !ignoreMap[ prop ])\n      {\n        var adding = src[ prop ];\n\n        if (prop in dst)\n        {\n          var existing = dst[ prop ];\n\n          if (isArray( existing ))\n          {\n            if (isArray( adding ))\n            {\n              existing.push.apply( existing, adding );\n            }\n            else\n            {\n              existing.push( adding );\n            }\n          }\n          else if (isObject( existing ))\n          {\n            merge( existing, adding, ignoreMap );\n          }\n          else\n          {\n            dst[ prop ] = copy( adding, true );\n          }\n        }\n        else\n        {\n          dst[ prop ] = copy( adding, true );\n        }\n      }\n    }\n  }\n\n  return dst;\n}", "label": 3}
{"code": "function _GpfClassDefMember (name, defaultValue, type) {\n    /*jshint validthis:true*/ // constructor\n    this._name = name;\n    this._setDefaultValue(defaultValue);\n    this._setType(type || \"undefined\");\n}", "label": 3}
{"code": "func (c *ChainInfo) Link(action Action, ip1, ip2 net.IP, port int, proto string, bridgeName string) error {\n\t// forward\n\targs := []string{\n\t\t\"-i\", bridgeName, \"-o\", bridgeName,\n\t\t\"-p\", proto,\n\t\t\"-s\", ip1.String(),\n\t\t\"-d\", ip2.String(),\n\t\t\"--dport\", strconv.Itoa(port),\n\t\t\"-j\", \"ACCEPT\",\n\t}\n\tif err := ProgramRule(Filter, c.Name, action, args); err != nil {\n\t\treturn err\n\t}\n\t// reverse\n\targs[7], args[9] = args[9], args[7]\n\targs[10] = \"--sport\"\n\treturn ProgramRule(Filter, c.Name, action, args)\n}", "label": 5}
{"code": "public function setMedical($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Vision\\V1\\Likelihood::class);\n        $this->medical = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "protected function getToken(Request $request)\n    {\n        try {\n            $this->validateAuthorizationHeader($request);\n\n            $token = $this->parseAuthorizationHeader($request);\n        } catch (Exception $exception) {\n            if (! $token = $request->query('token', false)) {\n                throw $exception;\n            }\n        }\n\n        return $token;\n    }", "label": 2}
{"code": "public static sslservice[] get(nitro_service service, sslservice_args args) throws Exception{\n\t\tsslservice obj = new sslservice();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tsslservice[] response = (sslservice[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private function formatArguments($arguments)\n    {\n        return collect($arguments)->map(function ($argument) {\n            return $argument instanceof Model ? FormatModel::given($argument) : $argument;\n        })->toArray();\n    }", "label": 2}
{"code": "function updateFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\tconst parent = node.parent;\n\n\t// Edge case: a single inline-level child inside node without text:\n\t// allow it to be inlined\n\tif (profile.get('inlineBreak') === 0 && isInline(node, profile)\n\t\t&& !isRoot(parent) && parent.value == null && parent.children.length === 1) {\n\t\toutNode.beforeOpen = ': ';\n\t}\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}", "label": 3}
{"code": "func (l *httpFileSystem) MkDir(path string, mode int) error {\n\treturn trace.BadParameter(\"directories are not supported in http file transfer\")\n}", "label": 5}
{"code": "def schemes\n      @schemes ||= if workspace?\n                     workspace.schemes.reject do |k, v|\n                       v.include?(\"Pods/Pods.xcodeproj\")\n                     end.keys\n                   else\n                     Xcodeproj::Project.schemes(path)\n                   end\n    end", "label": 4}
{"code": "private void appendJoinSQL92(Join join, StringBuffer where, StringBuffer buf)\r\n    {\r\n        if (join.isOuter)\r\n        {\r\n            buf.append(\" LEFT OUTER JOIN \");\r\n        }\r\n        else\r\n        {\r\n            buf.append(\" INNER JOIN \");\r\n        }\r\n        if (join.right.hasJoins())\r\n        {\r\n            buf.append(\"(\");\r\n            appendTableWithJoins(join.right, where, buf);\r\n            buf.append(\")\");\r\n        }\r\n        else\r\n        {\r\n            appendTableWithJoins(join.right, where, buf);\r\n        }\r\n        buf.append(\" ON \");\r\n        join.appendJoinEqualities(buf);\r\n    }", "label": 0}
{"code": "def _loopreport(self):\n        '''\n        Loop over the report progress\n        '''\n        while 1:\n            eventlet.sleep(0.2)\n            ac2popenlist = {}\n            for action in self.session._actions:\n                for popen in action._popenlist:\n                    if popen.poll() is None:\n                        lst = ac2popenlist.setdefault(action.activity, [])\n                        lst.append(popen)\n                if not action._popenlist and action in self._actionmayfinish:\n                    super(RetoxReporter, self).logaction_finish(action)\n                    self._actionmayfinish.remove(action)\n\n            self.screen.draw_next_frame(repeat=False)", "label": 1}
{"code": "public String toIPTC(SubjectReferenceSystem srs) {\r\n\t\tStringBuffer b = new StringBuffer();\r\n\t\tb.append(\"IPTC:\");\r\n\t\tb.append(getNumber());\r\n\t\tb.append(\":\");\r\n\t\tif (getNumber().endsWith(\"000000\")) {\r\n\t\t\tb.append(toIPTCHelper(srs.getName(this)));\r\n\t\t\tb.append(\"::\");\r\n\t\t} else if (getNumber().endsWith(\"000\")) {\r\n\t\t\tb.append(toIPTCHelper(srs.getName(srs.get(getNumber().substring(0, 2) + \"000000\"))));\r\n\t\t\tb.append(\":\");\r\n\t\t\tb.append(toIPTCHelper(srs.getName(this)));\r\n\t\t\tb.append(\":\");\r\n\t\t} else {\r\n\t\t\tb.append(toIPTCHelper(srs.getName(srs.get(getNumber().substring(0, 2) + \"000000\"))));\r\n\t\t\tb.append(\":\");\r\n\t\t\tb.append(toIPTCHelper(srs.getName(srs.get(getNumber().substring(0, 5) + \"000\"))));\r\n\t\t\tb.append(\":\");\r\n\t\t\tb.append(toIPTCHelper(srs.getName(this)));\r\n\t\t}\r\n\t\treturn b.toString();\r\n\t}", "label": 0}
{"code": "public static base_response disable(nitro_service client, String id) throws Exception {\n\t\tInterface disableresource = new Interface();\n\t\tdisableresource.id = id;\n\t\treturn disableresource.perform_operation(client,\"disable\");\n\t}", "label": 0}
{"code": "private function encodeAssociativeArrayValue(array $value)\n    {\n        $out = [];\n        foreach ($value as $key => $item) {\n            $out[$key] = $this->encodeValue($item);\n        }\n\n        return ['mapValue' => ['fields' => $out]];\n    }", "label": 2}
{"code": "function normalizeDistance(distance = 0) {\n    if (typeof distance !== 'object') distance = { top: distance, left: distance, right: distance, bottom: distance };\n\n    return distance;\n}", "label": 3}
{"code": "private String addAndEncodeValue(String originalValue, String newValue,\n      boolean encode) {\n    return addAndEncode(originalValue, null, newValue, encode);\n  }", "label": 0}
{"code": "public function setPosition(WebDriverPoint $position)\n    {\n        $params = [\n            'x' => $position->getX(),\n            'y' => $position->getY(),\n            ':windowHandle' => 'current',\n        ];\n        $this->executor->execute(DriverCommand::SET_WINDOW_POSITION, $params);\n\n        return $this;\n    }", "label": 2}
{"code": "public function setFulfillmentMessages($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dialogflow\\V2\\Intent\\Message::class);\n        $this->fulfillment_messages = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function getTypingNamesFromJson(jsonPath, filesToWatch) {\n                if (host.fileExists(jsonPath)) {\n                    filesToWatch.push(jsonPath);\n                }\n                var result = ts.readConfigFile(jsonPath, function (path) { return host.readFile(path); });\n                if (result.config) {\n                    var jsonConfig = result.config;\n                    if (jsonConfig.dependencies) {\n                        mergeTypings(ts.getOwnKeys(jsonConfig.dependencies));\n                    }\n                    if (jsonConfig.devDependencies) {\n                        mergeTypings(ts.getOwnKeys(jsonConfig.devDependencies));\n                    }\n                    if (jsonConfig.optionalDependencies) {\n                        mergeTypings(ts.getOwnKeys(jsonConfig.optionalDependencies));\n                    }\n                    if (jsonConfig.peerDependencies) {\n                        mergeTypings(ts.getOwnKeys(jsonConfig.peerDependencies));\n                    }\n                }\n            }", "label": 3}
{"code": "func ObjectEach(data []byte, callback func(key []byte, value []byte, dataType ValueType, offset int) error, keys ...string) (err error) {\n\tvar stackbuf [unescapeStackBufSize]byte // stack-allocated array for allocation-free unescaping of small strings\n\toffset := 0\n\n\t// Descend to the desired key, if requested\n\tif len(keys) > 0 {\n\t\tif off := searchKeys(data, keys...); off == -1 {\n\t\t\treturn KeyPathNotFoundError\n\t\t} else {\n\t\t\toffset = off\n\t\t}\n\t}\n\n\t// Validate and skip past opening brace\n\tif off := nextToken(data[offset:]); off == -1 {\n\t\treturn MalformedObjectError\n\t} else if offset += off; data[offset] != '{' {\n\t\treturn MalformedObjectError\n\t} else {\n\t\toffset++\n\t}\n\n\t// Skip to the first token inside the object, or stop if we find the ending brace\n\tif off := nextToken(data[offset:]); off == -1 {\n\t\treturn MalformedJsonError\n\t} else if offset += off; data[offset] == '}' {\n\t\treturn nil\n\t}\n\n\t// Loop pre-condition: data[offset] points to what should be either the next entry's key, or the closing brace (if it's anything else, the JSON is malformed)\n\tfor offset < len(data) {\n\t\t// Step 1: find the next key\n\t\tvar key []byte\n\n\t\t// Check what the the next token is: start of string, end of object, or something else (error)\n\t\tswitch data[offset] {\n\t\tcase '\"':\n\t\t\toffset++ // accept as string and skip opening quote\n\t\tcase '}':\n\t\t\treturn nil // we found the end of the object; stop and return success\n\t\tdefault:\n\t\t\treturn MalformedObjectError\n\t\t}\n\n\t\t// Find the end of the key string\n\t\tvar keyEscaped bool\n\t\tif off, esc := stringEnd(data[offset:]); off == -1 {\n\t\t\treturn MalformedJsonError\n\t\t} else {\n\t\t\tkey, keyEscaped = data[offset:offset+off-1], esc\n\t\t\toffset += off\n\t\t}\n\n\t\t// Unescape the string if needed\n\t\tif keyEscaped {\n\t\t\tif keyUnescaped, err := Unescape(key, stackbuf[:]); err != nil {\n\t\t\t\treturn MalformedStringEscapeError\n\t\t\t} else {\n\t\t\t\tkey = keyUnescaped\n\t\t\t}\n\t\t}\n\n\t\t// Step 2: skip the colon\n\t\tif off := nextToken(data[offset:]); off == -1 {\n\t\t\treturn MalformedJsonError\n\t\t} else if offset += off; data[offset] != ':' {\n\t\t\treturn MalformedJsonError\n\t\t} else {\n\t\t\toffset++\n\t\t}\n\n\t\t// Step 3: find the associated value, then invoke the callback\n\t\tif value, valueType, off, err := Get(data[offset:]); err != nil {\n\t\t\treturn err\n\t\t} else if err := callback(key, value, valueType, offset+off); err != nil { // Invoke the callback here!\n\t\t\treturn err\n\t\t} else {\n\t\t\toffset += off\n\t\t}\n\n\t\t// Step 4: skip over the next comma to the following token, or stop if we hit the ending brace\n\t\tif off := nextToken(data[offset:]); off == -1 {\n\t\t\treturn MalformedArrayError\n\t\t} else {\n\t\t\toffset += off\n\t\t\tswitch data[offset] {\n\t\t\tcase '}':\n\t\t\t\treturn nil // Stop if we hit the close brace\n\t\t\tcase ',':\n\t\t\t\toffset++ // Ignore the comma\n\t\t\tdefault:\n\t\t\t\treturn MalformedObjectError\n\t\t\t}\n\t\t}\n\n\t\t// Skip to the next token after the comma\n\t\tif off := nextToken(data[offset:]); off == -1 {\n\t\t\treturn MalformedArrayError\n\t\t} else {\n\t\t\toffset += off\n\t\t}\n\t}\n\n\treturn MalformedObjectError // we shouldn't get here; it's expected that we will return via finding the ending brace\n}", "label": 5}
{"code": "func ToTTL(c clockwork.Clock, tm time.Time) time.Duration {\n\tnow := c.Now().UTC()\n\tif tm.IsZero() || tm.Before(now) {\n\t\treturn 0\n\t}\n\treturn tm.Sub(now)\n}", "label": 5}
{"code": "def http_proxy(addr = nil, port = nil, user = nil, pass = nil)\n      default_options[:http_proxyaddr] = addr\n      default_options[:http_proxyport] = port\n      default_options[:http_proxyuser] = user\n      default_options[:http_proxypass] = pass\n    end", "label": 4}
{"code": "def mkIntDate(s):\n    \"\"\"\n\tConvert the webserver formatted dates\n\tto an integer format by stripping the\n\tleading char and casting\n\t\"\"\"\n    n = s.__len__()\n    d = int(s[-(n - 1):n])\n\n    return d", "label": 1}
{"code": "def _prepare_record(record, index, doc_type):\n        \"\"\"Prepare record data for indexing.\n\n        :param record: The record to prepare.\n        :param index: The Elasticsearch index.\n        :param doc_type: The Elasticsearch document type.\n        :returns: The record metadata.\n        \"\"\"\n        if current_app.config['INDEXER_REPLACE_REFS']:\n            data = copy.deepcopy(record.replace_refs())\n        else:\n            data = record.dumps()\n\n        data['_created'] = pytz.utc.localize(record.created).isoformat() \\\n            if record.created else None\n        data['_updated'] = pytz.utc.localize(record.updated).isoformat() \\\n            if record.updated else None\n\n        # Allow modification of data prior to sending to Elasticsearch.\n        before_record_index.send(\n            current_app._get_current_object(),\n            json=data,\n            record=record,\n            index=index,\n            doc_type=doc_type,\n        )\n\n        return data", "label": 1}
{"code": "public static RgbaColor from(String color) {\n        if (color.startsWith(\"#\")) {\n            return fromHex(color);\n        }\n        else if (color.startsWith(\"rgba\")) {\n            return fromRgba(color);\n        }\n        else if (color.startsWith(\"rgb\")) {\n            return fromRgb(color);\n        }\n        else if (color.startsWith(\"hsla\")) {\n            return fromHsla(color);\n        }\n        else if (color.startsWith(\"hsl\")) {\n            return fromHsl(color);\n        }\n        else {\n            return getDefaultColor();\n        }\n    }", "label": 0}
{"code": "public static aaacertparams get(nitro_service service) throws Exception{\n\t\taaacertparams obj = new aaacertparams();\n\t\taaacertparams[] response = (aaacertparams[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def write_bus_data(self, file):\n        \"\"\" Writes bus data to an Excel spreadsheet.\n        \"\"\"\n        bus_sheet = self.book.add_sheet(\"Buses\")\n\n        for i, bus in enumerate(self.case.buses):\n            for j, attr in enumerate(BUS_ATTRS):\n                bus_sheet.write(i, j, getattr(bus, attr))", "label": 1}
{"code": "def fill_prefixes(key, value, prefix, prefixes)\n      prefixes = {} if prefixes.nil?\n      if prefix.size == 1\n        pr = prefix.to_i\n        prefixes[pr] ||= {}\n        prefixes[pr][key] = value\n      else\n        pr = prefix[0].to_i\n        prefixes[pr] = fill_prefixes(key, value, prefix[1..-1], prefixes[pr])\n      end\n      prefixes\n    end", "label": 4}
{"code": "private function validateConfig()\n    {\n        $mustBePositiveKeys = ['maxCyclesToWaitForSession', 'maxSessions', 'minSessions', 'sleepIntervalSeconds'];\n\n        foreach ($mustBePositiveKeys as $key) {\n            if ($this->config[$key] < 0) {\n                throw new \\InvalidArgumentException(\"$key may not be negative\");\n            }\n        }\n\n        if ($this->config['maxSessions'] < $this->config['minSessions']) {\n            throw new \\InvalidArgumentException('minSessions cannot exceed maxSessions');\n        }\n\n        if (isset($this->config['lock']) && !$this->config['lock'] instanceof LockInterface) {\n            throw new \\InvalidArgumentException(\n                'The lock must implement Google\\Cloud\\Core\\Lock\\LockInterface'\n            );\n        }\n    }", "label": 2}
{"code": "public static function getErrorLevelString($level)\n    {\n        switch ($level) {\n            case E_PARSE:\n                return 'CRITICAL';\n            case E_ERROR:\n            case E_CORE_ERROR:\n            case E_COMPILE_ERROR:\n            case E_USER_ERROR:\n            case E_RECOVERABLE_ERROR:\n                return 'ERROR';\n            case E_WARNING:\n            case E_CORE_WARNING:\n            case E_COMPILE_WARNING:\n            case E_USER_WARNING:\n                return 'WARNING';\n            case E_NOTICE:\n            case E_USER_NOTICE:\n                return 'NOTICE';\n            case E_STRICT:\n                return 'DEBUG';\n            default:\n                return 'NOTICE';\n        }\n    }", "label": 2}
{"code": "function(kind, viewId, moduleId) {\n            if (viewId) {\n                kindViewMaps[kind] = viewId;\n            }\n\n            if (moduleId) {\n                kindModuleMaps[kind] = moduleId;\n            }\n        }", "label": 3}
{"code": "def possibly_include_hidden?\n      return @possibly_include_hidden if defined?(@possibly_include_hidden)\n\n      @possibly_include_hidden = patterns_to_include.any? do |s|\n        s.is_a?(Regexp) || s.start_with?('.') || s.include?('/.')\n      end\n    end", "label": 4}
{"code": "func (tc *TeleportClient) AskOTP() (token string, err error) {\n\tfmt.Printf(\"Enter your OTP token:\\n\")\n\ttoken, err = lineFromConsole()\n\tif err != nil {\n\t\tfmt.Fprintln(tc.Stderr, err)\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn token, nil\n}", "label": 5}
{"code": "def disconnect(self, receiver):\n        \"\"\"\n        Disconnect a receiver from a signal.\n        Signal and receiver must exist, otherwise an exception is thrown.\n\n        :param receiver: Name of the receiver\n        \"\"\"\n        if receiver not in self.receivers.keys():\n            raise Exception(\"No receiver %s was registered\" % receiver)\n        self.receivers[receiver].disconnect()\n        del(self.receivers[receiver])\n        self.__log.debug(\"Receiver %s disconnected\" % receiver)", "label": 1}
{"code": "public function destroy($id)\n    {\n        try {\n            $key = $this->datastore->key(\n                $this->kind,\n                $id,\n                ['namespaceId' => $this->namespaceId]\n            );\n            $this->transaction->delete($key);\n            $this->transaction->commit();\n        } catch (Exception $e) {\n            trigger_error(\n                sprintf('Datastore delete failed: %s', $e->getMessage()),\n                E_USER_WARNING\n            );\n            return false;\n        }\n        return true;\n    }", "label": 2}
{"code": "def remove_role(role, reason = nil)\n      role_ids = role_id_array(role)\n\n      if role_ids.count == 1\n        API::Server.remove_member_role(@bot.token, @server.id, @user.id, role_ids[0], reason)\n      else\n        old_role_ids = @roles.map(&:id)\n        new_role_ids = old_role_ids.reject { |i| role_ids.include?(i) }\n        API::Server.update_member(@bot.token, @server.id, @user.id, roles: new_role_ids, reason: reason)\n      end\n    end", "label": 4}
{"code": "function compile(pos) {\n  var values = []\n\n  if (!pos) {\n    return null\n  }\n\n  values = [[pos.line || 1, pos.column || 1].join(':')]\n\n  if ('offset' in pos) {\n    values.push(String(pos.offset || 0))\n  }\n\n  return values\n}", "label": 3}
{"code": "function generateCodebook() {\n\n    var codebook = {};\n    reverse_codebook.forEach(function (value, i) {\n        codebook[value] = i;\n    });\n\n    return codebook;\n}", "label": 3}
{"code": "def organismsKEGG():\n    \"\"\"\n    Lists all organisms present in the KEGG database.\n\n    :returns: a dataframe containing one organism per row.\n\n    \"\"\"\n    organisms=urlopen(\"http://rest.kegg.jp/list/organism\").read()\n    organisms=organisms.split(\"\\n\")\n    #for o in organisms:\n    #    print o\n    #    sys.stdout.flush()\n    organisms=[ s.split(\"\\t\") for s in organisms ]\n    organisms=pd.DataFrame(organisms)\n    return organisms", "label": 1}
{"code": "public function getServiceAccount(array $options = [])\n    {\n        $resp = $this->connection->getServiceAccount($options + ['projectId' => $this->projectId]);\n        return $resp['email'];\n    }", "label": 2}
{"code": "func (cli *NetworkCli) CmdServiceDetach(chain string, args ...string) error {\n\tcmd := cli.Subcmd(chain, \"detach\", \"CONTAINER SERVICE\", \"Removes a container from service backend\", false)\n\tcmd.Require(flag.Min, 2)\n\terr := cmd.ParseFlags(args, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsn, nn := parseServiceName(cmd.Arg(1))\n\tcontainerID, err := lookupContainerID(cli, cmd.Arg(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsandboxID, err := lookupSandboxID(cli, containerID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserviceID, err := lookupServiceID(cli, nn, sn)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, _, err = readBody(cli.call(\"DELETE\", \"/services/\"+serviceID+\"/backend/\"+sandboxID, nil, nil))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "label": 5}
{"code": "public function handle(FieldValue $fieldValue): array\n    {\n        $fieldDefinitionNode = $fieldValue->getField();\n\n        // Directives have the first priority for defining a resolver for a field\n        if ($resolverDirective = $this->directiveFactory->createFieldResolver($fieldDefinitionNode)) {\n            $this->fieldValue = $resolverDirective->resolveField($fieldValue);\n        } else {\n            $this->fieldValue = $fieldValue->setResolver(\n                $fieldValue->getParentName() === 'Subscription'\n                    ? $this->providesSubscriptionResolver->provideSubscriptionResolver($fieldValue)\n                    : $this->providesResolver->provideResolver($fieldValue)\n            );\n        }\n\n        $resolverWithMiddleware = $this->pipeline\n            ->send($this->fieldValue)\n            ->through(\n                $this->directiveFactory->createFieldMiddleware($fieldDefinitionNode)\n            )\n            ->via('handleField')\n            ->then(\n                function (FieldValue $fieldValue): FieldValue {\n                    return $fieldValue;\n                }\n            )\n            ->getResolver();\n\n        $argumentValues = $this->getArgumentValues();\n\n        $this->fieldValue->setResolver(\n            function () use ($argumentValues, $resolverWithMiddleware) {\n                $this->setResolverArguments(...func_get_args());\n\n                $this->validationErrorBuffer = (new ErrorBuffer)->setErrorType('validation');\n                $this->builder = new Builder;\n\n                $this->queryFilter = QueryFilter::getInstance($this->fieldValue);\n\n                $argumentValues->each(\n                    function (ArgumentValue $argumentValue): void {\n                        $this->handleArgDirectivesRecursively(\n                            $argumentValue->getType(),\n                            $argumentValue->getAstNode(),\n                            [$argumentValue->getName()]\n                        );\n                    }\n                );\n\n                $this->runArgDirectives();\n\n                // Apply the argument spreadings after we are finished with all\n                // the other argument handling\n                foreach ($this->spreadPaths as $argumentPath) {\n                    $inputValues = $this->argValue($argumentPath);\n                    $this->unsetArgValue($argumentPath);\n\n                    array_pop($argumentPath);\n\n                    foreach ($inputValues as $key => $value) {\n                        $this->setArgValue(\n                            array_merge($argumentPath, [$key]),\n                            $value\n                        );\n                    }\n                }\n\n                $this->builder->setQueryFilter(\n                    $this->queryFilter\n                );\n\n                // The final resolver can access the builder through the ResolveInfo\n                $this->resolveInfo->builder = $this->builder;\n\n                return $resolverWithMiddleware($this->root, $this->args, $this->context, $this->resolveInfo);\n            }\n        );\n\n        // To see what is allowed here, look at the validation rules in\n        // GraphQL\\Type\\Definition\\FieldDefinition::getDefinition()\n        return [\n            'name' => $fieldDefinitionNode->name->value,\n            'type' => $this->fieldValue->getReturnType(),\n            'args' => $this->getInputValueDefinitions($argumentValues),\n            'resolve' => $this->fieldValue->getResolver(),\n            'description' => data_get($fieldDefinitionNode->description, 'value'),\n            'complexity' => $this->fieldValue->getComplexity(),\n            'deprecationReason' => $this->fieldValue->getDeprecationReason(),\n        ];\n    }", "label": 2}
{"code": "public function setSubscriptions($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\PubSub\\V1\\Subscription::class);\n        $this->subscriptions = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function(not, primitive){\n        // NOT(5) U 5\n        if( set.isEqual( not.value, primitive) ) {\n            return set.UNIVERSAL;\n        }\n        // NOT(4) U 6\n        else {\n            throw new Error(\"Not,Identity Union is not filled out\");\n        }\n    }", "label": 3}
{"code": "func (s *ID) Time() time.Time {\n\ttm, ok := s.UUID().Time()\n\tif !ok {\n\t\treturn time.Time{}\n\t}\n\tsec, nsec := tm.UnixTime()\n\treturn time.Unix(sec, nsec).UTC()\n}", "label": 5}
{"code": "def discover_roku():\n    \"\"\" Search LAN for available Roku devices. Returns a Roku object. \"\"\"\n\n    print(\"Searching for Roku devices within LAN ...\")\n    rokus = Roku.discover()\n    if not rokus:\n        print(\"Unable to discover Roku devices. \" +\n              \"Try again, or manually specify the IP address with \" +\n              \"\\'roku <ipaddr>\\' (e.g. roku 192.168.1.130)\")\n        return None\n\n    print(\"Found the following Roku devices:\")\n    for i, r in enumerate(rokus):\n        # dinfo = ' '.join(re.split(', |: ', str(r.device_info))[1:3])\n        dinfo = ''\n        print(\"[\" + str(i+1) + \"]   \" + str(r.host) + \":\" +\n              str(r.port) + ' (' + dinfo + ')')\n    print(\"\")\n\n    if len(rokus) == 1:\n        print(\"Selecting Roku 1 by default\")\n        return rokus[0]\n    else:\n        print(\"Multiple Rokus found. Select the index of the Roku to control:\")\n\n        while True:\n            try:\n                query = \"Select (1 to \" + str(len(rokus)) + \") > \"\n                sel = int(input(query)) - 1\n                if sel >= len(rokus):\n                    raise ValueError\n                else:\n                    break\n            except ValueError:\n                print(\"Invalid selection\")\n\n        return rokus[sel]", "label": 1}
{"code": "def attribute_name(column_name=nil)\n      if column_name\n        @state_machine.config.column = column_name.to_sym\n      else\n        @state_machine.config.column ||= :aasm_state\n      end\n      @state_machine.config.column\n    end", "label": 4}
{"code": "public function getNumericProjectId()\n    {\n        if (!isset($this->numericProjectId)) {\n            $this->numericProjectId = $this->get('project/numeric-project-id');\n        }\n\n        return $this->numericProjectId;\n    }", "label": 2}
{"code": "function expandField(input, grunt){\n  var get = pointer(input);\n\n  return function(memo, fin, fout){\n    if(_.isString(fin)){\n      var match = fin.match(re.PATH_POINT);\n      // matched  ...with a `$.`       ...but not with a `\\`\n      if(match && match[3] === '$.' && !match[1]){\n        // field name, starts with an unescaped `$`, treat as JSON Path\n        memo[fout] = jsonPath(input, match[2]);\n      }else if(match && match[3] === '/' && !match[1]){\n        // field name, treat as a JSON pointer\n        memo[fout] = get(match[2]);\n      }else{\n        memo[fout] = input[match[2]];\n      }\n    }else if(_.isFunction(fin)){\n      // call a function\n      memo[fout] = fin(input);\n    }else if(_.isArray(fin)){\n      // pick out the values\n      memo[fout] = _.map(fin, function(value){\n        return expandField(input)({}, value, \"dummy\")[\"dummy\"];\n      });\n    }else if(_.isObject(fin)){\n      // build up an object of something else\n      memo[fout] = _.reduce(fin, expandField(input, grunt), {});\n    }else if(_.isNull(fin)){\n      // copy the value\n      memo[fout] = input[fout];\n    }else{\n      grunt.fail.warn('Could not map `' + JSON.stringify(fin) + '` to `' + \n        JSON.stringify(fout) + '`');\n    }\n    return memo;\n  };\n}", "label": 3}
{"code": "function (manifest, file, callback) {\n            generate(file.src, options, function (err, sriData) {\n                // Make relative if a cwd is specified\n                if (file.orig && file.orig.cwd) {\n                    file.id = file.id.replace(file.orig.cwd, \"\");\n                    sriData.path = sriData.path.replace(file.orig.cwd, \"\");\n                }\n                // Attach a property to the WIP manifest object\n                manifest[file.id] = sriData;\n                callback(err, manifest);\n            });\n        }", "label": 3}
{"code": "function (server, uid, token) {\n\t\n\ttry {\n\t\t// convert uid to number if not already\n\t\tif (typeof uid === 'string')\n\t\t\tuid = parseInt(uid);\n\t}\n\tcatch (e) {\n\t\tLOG.error('uid cannot be parsed as integer...', 'login.send_remote_login');\n\t\treturn false;\n\t}\n\t\n\tSR.User.loginLocal(server, uid, token, function (result) {\n\t\t// NOTE: if local server is not registered, will return 'undefined' as result\n\t\tif (result) {\n\t\t\t// NOTE: result has U and P fields\n\t\t\tLOG.warn('local login result for [' + uid + ']: ' + (result.code === 0));\n\t\t}\n\t\telse\n\t\t\tLOG.warn('local login result for [' + uid + ']: remote server not online');\n\t});\n\t\n\treturn true;\n}", "label": 3}
{"code": "def contains?(x, y)\n      self_area = triangle_area(@x1, @y1, @x2, @y2, @x3, @y3)\n      questioned_area =\n        triangle_area(@x1, @y1, @x2, @y2, x, y) +\n        triangle_area(@x2, @y2, @x3, @y3, x, y) +\n        triangle_area(@x3, @y3, @x1, @y1, x, y)\n\n      questioned_area <= self_area\n    end", "label": 4}
{"code": "public static base_responses update(nitro_service client, clusternodegroup resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tclusternodegroup updateresources[] = new clusternodegroup[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new clusternodegroup();\n\t\t\t\tupdateresources[i].name = resources[i].name;\n\t\t\t\tupdateresources[i].strict = resources[i].strict;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function(collection, blacklist){\n        var obj,\n            result = [],\n            prop,\n            i,\n            j,\n            collLen,\n            listLen;\n\n        blacklist = blacklist || [\"__columns\"];\n\n        if(!collection || !collection.length){\n            return result;\n        }\n\n        collLen = collection.length;\n\n        for(i=0; i<collLen; i++){\n            obj = collection[i];\n\n            //delete null properties\n            for(prop in obj){\n                if(obj[prop] === null){\n                    delete obj[prop];\n                }\n            }\n\n            listLen = blacklist.length;\n            for(j=0; j<listLen; j++){\n                delete obj[blacklist[j]];\n            }\n            //These are javascript objects and not json, so we have to do this magic to strip it of get methods.\n            result.push(JSON.parse(JSON.stringify(obj)));\n        }\n\n        return result;\n    }", "label": 3}
{"code": "public Map getPathClasses()\r\n\t{\r\n\t\tif (m_pathClasses.isEmpty())\r\n\t\t{\r\n\t\t\tif (m_parentCriteria == null)\r\n\t\t\t{\r\n\t\t\t\tif (m_query == null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn m_pathClasses;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn m_query.getPathClasses();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn m_parentCriteria.getPathClasses();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn m_pathClasses;\r\n\t\t}\r\n\t}", "label": 0}
{"code": "func (p *printer) marshalTextInterface(val encoding.TextMarshaler, start StartElement) error {\n\tif err := p.writeStart(&start); err != nil {\n\t\treturn err\n\t}\n\ttext, err := val.MarshalText()\n\tif err != nil {\n\t\treturn err\n\t}\n\tEscapeText(p, text)\n\treturn p.writeEnd(start.Name)\n}", "label": 5}
{"code": "def _async_callable(func):\n    \"\"\"Ensure the callable is an async def.\"\"\"\n    if isinstance(func, types.CoroutineType):\n\n        return func\n\n    @functools.wraps(func)\n    async def _async_def_wrapper(*args, **kwargs):\n        \"\"\"Wrap a a sync callable in an async def.\"\"\"\n        return func(*args, **kwargs)\n\n    return _async_def_wrapper", "label": 1}
{"code": "func (f *Fpdf) SetLeftMargin(margin float64) {\n\tf.lMargin = margin\n\tif f.page > 0 && f.x < margin {\n\t\tf.x = margin\n\t}\n}", "label": 5}
{"code": "func (p *ProvisionTokenV2) SetRoles(r teleport.Roles) {\n\tp.Spec.Roles = r\n}", "label": 5}
{"code": "public function setTextClassificationDatasetMetadata($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\AutoMl\\V1beta1\\TextClassificationDatasetMetadata::class);\n        $this->writeOneof(25, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "function parseEnumMember() {\n            var node = createNode(255 /* EnumMember */, scanner.getStartPos());\n            node.name = parsePropertyName();\n            node.initializer = allowInAnd(parseNonParameterInitializer);\n            return finishNode(node);\n        }", "label": 3}
{"code": "def enable_auth(path, type, description = nil)\n      payload = { type: type }\n      payload[:description] = description if !description.nil?\n\n      client.post(\"/v1/sys/auth/#{encode_path(path)}\", JSON.fast_generate(payload))\n      return true\n    end", "label": 4}
{"code": "public static dospolicy[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{\n\t\tdospolicy obj = new dospolicy();\n\t\toptions option = new options();\n\t\toption.set_filter(filter);\n\t\tdospolicy[] response = (dospolicy[]) obj.getfiltered(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function (options, overrides) {\n    let resolved = null;\n\n    if (typeof options === 'string') { //we've been give a path to a project dir or babelrc\n      let babelrcPath;\n      const stats = fs.statSync(options);\n      if (stats.isDirectory()) {\n        babelrcPath = path.join(options, '.babelrc');\n      } else if (stats.isFile()) {\n        babelrcPath = options;\n      }\n\n      if (babelrcPath) {\n        try {\n          const babelOptions = JSON.parse(fs.readFileSync(babelrcPath));\n          resolved = resolveOptions(babelOptions);\n        } catch (e) {\n          console.log(e);\n        }\n      }\n\n    } else if (typeof options === 'object') {\n      resolved = resolveOptions(options);\n    }\n\n    if (resolved) {\n      Object.keys(overrides).forEach(function (key) {\n        resolved[key] = overrides[key];\n      });\n      return resolved;\n    }\n\n    return null;\n  }", "label": 3}
{"code": "def authority\n      self.host && @authority ||= begin\n        authority = String.new\n        if self.userinfo != nil\n          authority << \"#{self.userinfo}@\"\n        end\n        authority << self.host\n        if self.port != nil\n          authority << \":#{self.port}\"\n        end\n        authority\n      end\n    end", "label": 4}
{"code": "func (l VirtualDeviceList) ChildDisk(parent *types.VirtualDisk) *types.VirtualDisk {\n\tdisk := *parent\n\tbacking := disk.Backing.(*types.VirtualDiskFlatVer2BackingInfo)\n\tp := new(DatastorePath)\n\tp.FromString(backing.FileName)\n\tp.Path = \"\"\n\n\t// Use specified disk as parent backing to a new disk.\n\tdisk.Backing = &types.VirtualDiskFlatVer2BackingInfo{\n\t\tVirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{\n\t\t\tFileName:  p.String(),\n\t\t\tDatastore: backing.Datastore,\n\t\t},\n\t\tParent:          backing,\n\t\tDiskMode:        backing.DiskMode,\n\t\tThinProvisioned: backing.ThinProvisioned,\n\t}\n\n\treturn &disk\n}", "label": 5}
{"code": "def table_driven(self, in_data):\n        \"\"\"\n        The Standard table_driven CRC algorithm.\n        \"\"\"\n        # If the input data is a string, convert to bytes.\n        if isinstance(in_data, str):\n            in_data = [ord(c) for c in in_data]\n\n        tbl = self.gen_table()\n\n        register = self.DirectInit << self.CrcShift\n        if not self.ReflectIn:\n            for octet in in_data:\n                tblidx = ((register >> (self.Width - self.TableIdxWidth + self.CrcShift)) ^ octet) & 0xff\n                register = ((register << (self.TableIdxWidth - self.CrcShift)) ^ tbl[tblidx]) & (self.Mask << self.CrcShift)\n            register = register >> self.CrcShift\n        else:\n            register = self.reflect(register, self.Width + self.CrcShift) << self.CrcShift\n            for octet in in_data:\n                tblidx = ((register >> self.CrcShift) ^ octet) & 0xff\n                register = ((register >> self.TableIdxWidth) ^ tbl[tblidx]) & (self.Mask << self.CrcShift)\n            register = self.reflect(register, self.Width + self.CrcShift) & self.Mask\n\n        if self.ReflectOut:\n            register = self.reflect(register, self.Width)\n        return register ^ self.XorOut", "label": 1}
{"code": "def get_final_path(path):\n\tr\"\"\"\n\tFor a given path, determine the ultimate location of that path.\n\tUseful for resolving symlink targets.\n\tThis functions wraps the GetFinalPathNameByHandle from the Windows\n\tSDK.\n\n\tNote, this function fails if a handle cannot be obtained (such as\n\tfor C:\\Pagefile.sys on a stock windows system). Consider using\n\ttrace_symlink_target instead.\n\t\"\"\"\n\tdesired_access = api.NULL\n\tshare_mode = (\n\t\tapi.FILE_SHARE_READ | api.FILE_SHARE_WRITE | api.FILE_SHARE_DELETE\n\t)\n\tsecurity_attributes = api.LPSECURITY_ATTRIBUTES()  # NULL pointer\n\thFile = api.CreateFile(\n\t\tpath,\n\t\tdesired_access,\n\t\tshare_mode,\n\t\tsecurity_attributes,\n\t\tapi.OPEN_EXISTING,\n\t\tapi.FILE_FLAG_BACKUP_SEMANTICS,\n\t\tapi.NULL,\n\t)\n\n\tif hFile == api.INVALID_HANDLE_VALUE:\n\t\traise WindowsError()\n\n\tbuf_size = api.GetFinalPathNameByHandle(\n\t\thFile, LPWSTR(), 0, api.VOLUME_NAME_DOS)\n\thandle_nonzero_success(buf_size)\n\tbuf = create_unicode_buffer(buf_size)\n\tresult_length = api.GetFinalPathNameByHandle(\n\t\thFile, buf, len(buf), api.VOLUME_NAME_DOS)\n\n\tassert result_length < len(buf)\n\thandle_nonzero_success(result_length)\n\thandle_nonzero_success(api.CloseHandle(hFile))\n\n\treturn buf[:result_length]", "label": 1}
{"code": "public function getLockMode()\n    {\n        $lockMode = $this->getHint(self::HINT_LOCK_MODE);\n\n        if ($lockMode === false) {\n            return null;\n        }\n\n        return $lockMode;\n    }", "label": 2}
{"code": "public function processRequest(Request $request)\n    {\n        $contentType = $request->header('content-type') ?: '';\n\n        if (mb_stripos($contentType, 'multipart/form-data') !== false) {\n            $this->validateParsedBody($request);\n            $request = $this->parseUploadedFiles($request);\n        }\n\n        return $request;\n    }", "label": 2}
{"code": "public static function setFallbackLocale($locale)\n    {\n        $translator = static::getTranslator();\n\n        if (method_exists($translator, 'setFallbackLocales')) {\n            $translator->setFallbackLocales([$locale]);\n\n            if ($translator instanceof Translator) {\n                $preferredLocale = $translator->getLocale();\n                $translator->setMessages($preferredLocale, array_replace_recursive(\n                    $translator->getMessages()[$locale] ?? [],\n                    Translator::get($locale)->getMessages()[$locale] ?? [],\n                    $translator->getMessages($preferredLocale)\n                ));\n            }\n        }\n    }", "label": 2}
{"code": "def rack_env(request)\n      uri = URI.parse(request.path)\n\n      # Minimum required variables according to Rack Spec\n      env = {\n        \"REQUEST_METHOD\" => \"GET\",\n        \"SCRIPT_NAME\" => \"\",\n        \"PATH_INFO\" => uri.path,\n        \"QUERY_STRING\" => uri.query,\n        \"SERVER_NAME\" => uri.host,\n        \"SERVER_PORT\" => uri.port.to_s,\n        \"HTTP_HOST\" => uri.host,\n        \"REMOTE_ADDR\" => request.headers.delete(\"REMOTE_ADDR\"),\n        \"rack.url_scheme\" => uri.scheme,\n        \"rack.input\" => \"\"\n      }\n\n      env.merge!(build_headers(request.headers))\n    end", "label": 4}
{"code": "def create(self, id, fd, filename='attachment-name'): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Add an attachment to a device.\n\n        :param id: Device ID as an int.\n        :param fd: File-like object to upload.\n        :param filename: (optional) Name to use for new attachment as a string.\n        :return: :class:`attachments.Attachment <attachments.Attachment>` object\n        :rtype: attachments.Attachment\n        \"\"\"\n        schema = AttachmentSchema(exclude=('id', 'created', 'updated', 'size', 'path', 'device_id'))\n        resp = self.service.post(self._base(id),\n                                 files={'file': (filename, fd)})\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "func (g *generator) GenerateMockMethod(mockType string, m *model.Method, pkgOverride string) error {\n\targNames := g.getArgNames(m)\n\targTypes := g.getArgTypes(m, pkgOverride)\n\targString := makeArgString(argNames, argTypes)\n\n\trets := make([]string, len(m.Out))\n\tfor i, p := range m.Out {\n\t\trets[i] = p.Type.String(g.packageMap, pkgOverride)\n\t}\n\tretString := strings.Join(rets, \", \")\n\tif len(rets) > 1 {\n\t\tretString = \"(\" + retString + \")\"\n\t}\n\tif retString != \"\" {\n\t\tretString = \" \" + retString\n\t}\n\n\tia := newIdentifierAllocator(argNames)\n\tidRecv := ia.allocateIdentifier(\"m\")\n\n\tg.p(\"// %v mocks base method\", m.Name)\n\tg.p(\"func (%v *%v) %v(%v)%v {\", idRecv, mockType, m.Name, argString, retString)\n\tg.in()\n\tg.p(\"%s.ctrl.T.Helper()\", idRecv)\n\n\tvar callArgs string\n\tif m.Variadic == nil {\n\t\tif len(argNames) > 0 {\n\t\t\tcallArgs = \", \" + strings.Join(argNames, \", \")\n\t\t}\n\t} else {\n\t\t// Non-trivial. The generated code must build a []interface{},\n\t\t// but the variadic argument may be any type.\n\t\tidVarArgs := ia.allocateIdentifier(\"varargs\")\n\t\tidVArg := ia.allocateIdentifier(\"a\")\n\t\tg.p(\"%s := []interface{}{%s}\", idVarArgs, strings.Join(argNames[:len(argNames)-1], \", \"))\n\t\tg.p(\"for _, %s := range %s {\", idVArg, argNames[len(argNames)-1])\n\t\tg.in()\n\t\tg.p(\"%s = append(%s, %s)\", idVarArgs, idVarArgs, idVArg)\n\t\tg.out()\n\t\tg.p(\"}\")\n\t\tcallArgs = \", \" + idVarArgs + \"...\"\n\t}\n\tif len(m.Out) == 0 {\n\t\tg.p(`%v.ctrl.Call(%v, %q%v)`, idRecv, idRecv, m.Name, callArgs)\n\t} else {\n\t\tidRet := ia.allocateIdentifier(\"ret\")\n\t\tg.p(`%v := %v.ctrl.Call(%v, %q%v)`, idRet, idRecv, idRecv, m.Name, callArgs)\n\n\t\t// Go does not allow \"naked\" type assertions on nil values, so we use the two-value form here.\n\t\t// The value of that is either (x.(T), true) or (Z, false), where Z is the zero value for T.\n\t\t// Happily, this coincides with the semantics we want here.\n\t\tretNames := make([]string, len(rets))\n\t\tfor i, t := range rets {\n\t\t\tretNames[i] = ia.allocateIdentifier(fmt.Sprintf(\"ret%d\", i))\n\t\t\tg.p(\"%s, _ := %s[%d].(%s)\", retNames[i], idRet, i, t)\n\t\t}\n\t\tg.p(\"return \" + strings.Join(retNames, \", \"))\n\t}\n\n\tg.out()\n\tg.p(\"}\")\n\treturn nil\n}", "label": 5}
{"code": "def performAction(self, action):\n        \"\"\" Execute one action.\n        \"\"\"\n#        print \"ACTION:\", action\n        self.t += 1\n        Task.performAction(self, action)\n#        self.addReward()\n        self.samples += 1", "label": 1}
{"code": "def math_func(f):\n    \"\"\"\n    Statics the methods. wut.\n    \"\"\"\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        if len(args) > 0:\n            return_type = type(args[0])\n        if kwargs.has_key('return_type'):\n            return_type = kwargs['return_type']\n            kwargs.pop('return_type')\n            return return_type(f(*args, **kwargs))\n        args = list((setify(x) for x in args))\n        return return_type(f(*args, **kwargs))\n    return wrapper", "label": 1}
{"code": "public static systemcountergroup get(nitro_service service) throws Exception{\n\t\tsystemcountergroup obj = new systemcountergroup();\n\t\tsystemcountergroup[] response = (systemcountergroup[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "def empty_values(obj)\n      values = case obj\n               when Hash         then obj\n               when StripeObject then obj.instance_variable_get(:@values)\n               else\n                 raise ArgumentError, \"#empty_values got unexpected object type: #{obj.class.name}\"\n               end\n\n      values.each_with_object({}) do |(k, _), update|\n        update[k] = \"\"\n      end\n    end", "label": 4}
{"code": "function setChSetFromADSRegisterQuery (str, channelSettings) {\n  let key = k.OBCIRegisterQueryNameCHnSET[channelSettings.channelNumber];\n  if (key === undefined) key = k.OBCIRegisterQueryNameCHnSET[channelSettings.channelNumber - k.OBCINumberOfChannelsCyton];\n  channelSettings.powerDown = getBooleanFromRegisterQuery(str, key, 16);\n  channelSettings.gain = k.gainForCommand(getNumFromThreeCSVADSRegisterQuery(str, key, 19));\n  channelSettings.inputType = k.inputTypeForCommand(getNumFromThreeCSVADSRegisterQuery(str, key, 31));\n  channelSettings.srb2 = getBooleanFromRegisterQuery(str, key, 28);\n}", "label": 3}
{"code": "def read_js\n      @@js ||= begin\n        root = Pathname(File.dirname(__FILE__))\n        path = root.join(\"../../vendor/autoprefixer.js\")\n        path.read\n      end\n    end", "label": 4}
{"code": "def arraymax(X,Y):\n    \"\"\"\n    Fast \"vectorized\" max function for element-wise comparison of two numpy arrays.\n\n    For two numpy arrays `X` and `Y` of equal length,\n    return numpy array `Z` such that::\n\n            Z[i] = max(X[i],Y[i])\n\n    **Parameters**\n\n            **X** :  numpy array\n\n                    Numpy array; `len(X) = len(Y)`.\n\n            **Y** :  numpy array\n\n                    Numpy array; `len(Y) = len(X)`.\n\n    **Returns**\n\n            **Z** :  numpy array\n\n                    Numpy array such that `Z[i] = max(X[i],Y[i])`.\n\n    **See Also**\n\n            :func:`tabular.fast.arraymin`\n\n    \"\"\"\n    Z = np.zeros((len(X),), int)\n    A = X <= Y\n    B = Y < X\n    Z[A] = Y[A]\n    Z[B] = X[B]\n    return Z", "label": 1}
{"code": "func (l *Handler) Upload(ctx context.Context, sessionID session.ID, reader io.Reader) (string, error) {\n\tpath := l.path(sessionID)\n\tf, err := os.Create(path)\n\tif err != nil {\n\t\treturn \"\", trace.ConvertSystemError(err)\n\t}\n\tdefer f.Close()\n\t_, err = io.Copy(f, reader)\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn fmt.Sprintf(\"%v://%v\", teleport.SchemeFile, path), nil\n}", "label": 5}
{"code": "def init():\r\n    \"\"\"Initialize configuration and web application.\"\"\"\r\n    global app\r\n    if app: return app\r\n    conf.init(), db.init(conf.DbPath, conf.DbStatements)\r\n\r\n    bottle.TEMPLATE_PATH.insert(0, conf.TemplatePath)\r\n    app = bottle.default_app()\r\n    bottle.BaseTemplate.defaults.update(get_url=app.get_url)\r\n    return app", "label": 1}
{"code": "def lock\n      acquire\n\n      @refresh_thread = Thread.new do\n        renew_interval = [1.0, @expiration/2].max\n\n        begin\n          done_refreshing = false\n          until @unlock || done_refreshing\n            @refresh_mutex.synchronize do\n              @refresh_signal.wait(@refresh_mutex, renew_interval)\n              break if @unlock\n\n              @logger.debug(\"Renewing lock: #@name\")\n              lock_expiration = Time.now.to_f + @expiration + 1\n\n              if Models::Lock.where(name: @name, uid: @uid).update(expired_at: Time.at(lock_expiration)) == 0\n                done_refreshing = true\n              end\n            end\n          end\n        ensure\n          if !@unlock\n            Models::Event.create(\n              user: Config.current_job.username,\n              action: 'lost',\n              object_type: 'lock',\n              object_name: @name,\n              task: @task_id,\n              deployment: @deployment_name,\n              error: 'Lock renewal thread exiting',\n              timestamp: Time.now,\n            )\n\n            Models::Task[@task_id].update(state: 'cancelling')\n\n            @logger.debug('Lock renewal thread exiting')\n          end\n        end\n      end\n\n      if block_given?\n        begin\n          yield\n        ensure\n          release\n        end\n      end\n    end", "label": 4}
{"code": "def to_liquid(attrs = nil)\n      further_data = Hash[(attrs || self.class::ATTRIBUTES_FOR_LIQUID).map do |attribute|\n        [attribute, send(attribute)]\n      end]\n\n      defaults = site.frontmatter_defaults.all(relative_path, type)\n      Utils.deep_merge_hashes defaults, Utils.deep_merge_hashes(data, further_data)\n    end", "label": 4}
{"code": "def double_quote(value)\n      return if value.nil?\n\n      case value.to_s\n        # Ignore keys that contain double quotes or a Arel.star (*)[all columns]\n        # or if a table has already been explicitly declared (ex: users.id)\n      when \"*\", /((^\".+\"$)|(^[[:alpha:]]+\\.[[:alnum:]]+))/\n        value\n      else\n        PG::Connection.quote_ident(value.to_s)\n      end\n    end", "label": 4}
{"code": "func isLongitude(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tvar v string\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\tv = field.String()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tv = strconv.FormatInt(field.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tv = strconv.FormatUint(field.Uint(), 10)\n\tcase reflect.Float32:\n\t\tv = strconv.FormatFloat(field.Float(), 'f', -1, 32)\n\tcase reflect.Float64:\n\t\tv = strconv.FormatFloat(field.Float(), 'f', -1, 64)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\n\treturn longitudeRegex.MatchString(v)\n}", "label": 5}
{"code": "func (t *typeInfo) LoadFromObjectContent(o types.ObjectContent) (reflect.Value, error) {\n\tv := reflect.New(t.typ)\n\tassignValue(v, t.self, reflect.ValueOf(o.Obj))\n\n\tfor _, p := range o.PropSet {\n\t\trv, ok := t.props[p.Name]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tassignValue(v, rv, reflect.ValueOf(p.Val))\n\t}\n\n\treturn v, nil\n}", "label": 5}
{"code": "public static base_responses delete(nitro_service client, String certkey[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (certkey != null && certkey.length > 0) {\n\t\t\tsslcertkey deleteresources[] = new sslcertkey[certkey.length];\n\t\t\tfor (int i=0;i<certkey.length;i++){\n\t\t\t\tdeleteresources[i] = new sslcertkey();\n\t\t\t\tdeleteresources[i].certkey = certkey[i];\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function max(compare, iterable, dflt = undefined) {\n\n  let iterator = (0, _iter.iter)(iterable);\n\n  let first = iterator.next();\n\n  if (first.done) return dflt;\n\n  let largest = first.value;\n\n  for (let candidate of iterator) {\n\n    if (compare(candidate, largest) > 0) {\n\n      largest = candidate;\n    }\n  }\n\n  return largest;\n}", "label": 3}
{"code": "func (ta *TextArea) HideCursor(on bool) {\n\tta.Init()\n\tta.model.hide = on\n}", "label": 5}
{"code": "def add_namespace_uri(self, ns_uri, prefix=None, schema_location=None):\n        \"\"\"Adds a new namespace to this set, optionally with a prefix and\n        schema location URI.\n\n        If the namespace already exists, the given prefix and schema location\n        are merged with the existing entry:\n            * If non-None, ``prefix`` is added to the set.  The preferred\n                prefix is not modified.\n            * If a schema location is not already associated with the\n                namespace, it is set to ``schema_location`` (if given).\n\n        If the namespace doesn't already exist in this set (so a new one is\n        being created) and a prefix is given, that prefix becomes preferred.\n        If not given, a preference as a default namespace is used.\n\n        Args:\n            ns_uri (str): The URI of the new namespace\n            prefix (str): The desired prefix for the new namespace (optional)\n            schema_location (str): The desired schema location for the new\n                namespace (optional).\n\n        Raises:\n            DuplicatePrefixError: If a prefix is given which already maps to a\n                different namespace\n            ConflictingSchemaLocationError: If a schema location is given and\n                the namespace already exists in this set with a different\n                schema location.\n        \"\"\"\n        assert ns_uri\n\n        if ns_uri in self.__ns_uri_map:\n            # We have a _NamespaceInfo object for this URI already.  So this\n            # is a merge operation.\n            #\n            # We modify a copy of the real _NamespaceInfo so that we are\n            # exception-safe: if something goes wrong, we don't end up with a\n            # half-changed NamespaceSet.\n            ni = self.__lookup_uri(ns_uri)\n            new_ni = copy.deepcopy(ni)\n\n            # Reconcile prefixes\n            if prefix:\n                self.__check_prefix_conflict(ni, prefix)\n                new_ni.prefixes.add(prefix)\n\n            self.__merge_schema_locations(new_ni, schema_location)\n\n            # At this point, we have a legit new_ni object.  Now we update\n            # the set, ensuring our invariants.  This should replace\n            # all instances of the old ni in this set.\n            for p in new_ni.prefixes:\n                self.__prefix_map[p] = new_ni\n            self.__ns_uri_map[new_ni.uri] = new_ni\n\n        else:\n            # A brand new namespace.  The incoming prefix should not exist at\n            # all in the prefix map.\n            if prefix:\n                self.__check_prefix_conflict(ns_uri, prefix)\n\n            ni = _NamespaceInfo(ns_uri, prefix, schema_location)\n            self.__add_namespaceinfo(ni)", "label": 1}
{"code": "function done(err, content) {\n            if (err) return cb(err);\n\n            var code = JSON.parse(self.square.package.source)\n              , current = bundle.version || self.version(bundle.meta.content)\n              , source;\n\n            code.bundle[key].version = version;\n            bundle.version = version;\n            bundle.content = content;\n\n            // now that we have updated the shizzle, we can write a new file\n            // also update the old source with the new version\n            source = JSON.stringify(code, null, 2);\n            self.square.package.source = source;\n\n            try {\n              async.parallel([\n                  async.apply(fs.writeFile, self.square.package.location, source)\n                , async.apply(fs.writeFile, bundle.meta.location, content)\n              ], function (err, results) {\n                self.square.logger.notice(\n                    'sucessfully updated %s from version %s to %s'\n                  , key\n                  , current.grey\n                  , version.green\n                );\n\n                cb(err);\n              });\n            } catch (e) { err = e; }\n          }", "label": 3}
{"code": "protected function errorResponse(\\Exception $exception)\n    {\n        $error = $this->config->get('datatables.error');\n        $debug = $this->config->get('app.debug');\n\n        if ($error === 'throw' || (! $error && ! $debug)) {\n            throw new Exception($exception->getMessage(), $code = 0, $exception);\n        }\n\n        $this->getLogger()->error($exception);\n\n        return new JsonResponse([\n            'draw'            => (int) $this->request->input('draw'),\n            'recordsTotal'    => $this->totalRecords,\n            'recordsFiltered' => 0,\n            'data'            => [],\n            'error'           => $error ? __($error) : \"Exception Message:\\n\\n\".$exception->getMessage(),\n        ]);\n    }", "label": 2}
{"code": "function processApiCall(resource, operation, requestParams) {\n    var service = injector.loadModule(utensils.getCamelCase(resource.name + '.service'));\n    var adapterName = resource.adapters.api;\n\n    // remove the keys that start with onBehalfOf\n    _.each(requestParams, function (val, key) {\n        if (key.indexOf('onBehalfOf') === 0) { delete requestParams[key]; }\n    });\n\n    // hack fix for when _id not filled in\n    if (requestParams._id === '{_id}') {\n        delete requestParams._id;\n    }\n\n    // loop through request values and parse json\n    for (var key in requestParams) {\n        if (requestParams.hasOwnProperty(key)) {\n            requestParams[key] = utensils.parseIfJson(requestParams[key]);\n        }\n    }\n\n    var filters = getFilters(resource.name, adapterName, operation);\n    return utensils.chainPromises(filters.before, requestParams)\n        .then(function (filteredRequest) {\n            requestParams = filteredRequest;\n            return service[operation](requestParams);\n        })\n        .then(function (data) {\n            return utensils.chainPromises(filters.after, {\n                caller:     requestParams.caller,\n                lang:       requestParams.lang,\n                resource:   resource,\n                inputData:  requestParams.data,\n                data:       data\n            });\n        });\n}", "label": 3}
{"code": "def attribute_changed?(attr)\n      attr = database_field_name(attr)\n      return false unless changed_attributes.key?(attr)\n      changed_attributes[attr] != attributes[attr]\n    end", "label": 4}
{"code": "public static int hoursDiff(Date earlierDate, Date laterDate) {\n        if (earlierDate == null || laterDate == null) {\n            return 0;\n        }\n\n        return (int) ((laterDate.getTime() / HOUR_MILLIS) - (earlierDate.getTime() / HOUR_MILLIS));\n    }", "label": 0}
{"code": "def _count_by_date(self, fname, all_dates):\n        \"\"\"\n        reads a logfile and returns a dictionary by date\n        showing the count of log entries\n        \"\"\"\n        if not os.path.isfile(fname):\n            return {}\n        d_log_sum = {}\n        with open(fname, \"r\") as raw_log:\n            for line in raw_log:\n                cols = line.split(',')\n                dte = cols[0].strip('\"')[0:10].replace('-', '')\n                all_dates.append(dte)\n                if dte in d_log_sum:\n                    d_log_sum[dte] += 1\n                else:\n                    d_log_sum[dte] = 1\n        return d_log_sum", "label": 1}
{"code": "def cascadable_children(kind, children = Set.new)\n      embedded_relations.each_pair do |name, association|\n        next unless association.cascading_callbacks?\n        without_autobuild do\n          delayed_pulls = delayed_atomic_pulls[name]\n          delayed_unsets = delayed_atomic_unsets[name]\n          children.merge(delayed_pulls) if delayed_pulls\n          children.merge(delayed_unsets) if delayed_unsets\n          relation = send(name)\n          Array.wrap(relation).each do |child|\n            next if children.include?(child)\n            children.add(child) if cascadable_child?(kind, child, association)\n            child.send(:cascadable_children, kind, children)\n          end\n        end\n      end\n      children.to_a\n    end", "label": 4}
{"code": "public function hasFilter($filter)\n    {\n        $key = is_callable($filter) ? 0 : 1;\n\n        foreach ($this->filters as $tuple) {\n            if ($tuple[$key] === $filter) {\n                return true;\n            }\n        }\n\n        return false;\n    }", "label": 2}
{"code": "def verify_recaptcha(options = {})\n      options = {model: options} unless options.is_a? Hash\n      return true if Recaptcha::Verify.skip?(options[:env])\n\n      model = options[:model]\n      attribute = options[:attribute] || :base\n      recaptcha_response = options[:response] || params['g-recaptcha-response'].to_s\n\n      begin\n        verified = if recaptcha_response.empty? || recaptcha_response.length > G_RESPONSE_LIMIT\n          false\n        else\n          recaptcha_verify_via_api_call(request, recaptcha_response, options)\n        end\n\n        if verified\n          flash.delete(:recaptcha_error) if recaptcha_flash_supported? && !model\n          true\n        else\n          recaptcha_error(\n            model,\n            attribute,\n            options[:message],\n            \"recaptcha.errors.verification_failed\",\n            \"reCAPTCHA verification failed, please try again.\"\n          )\n          false\n        end\n      rescue Timeout::Error\n        if Recaptcha.configuration.handle_timeouts_gracefully\n          recaptcha_error(\n            model,\n            attribute,\n            options[:message],\n            \"recaptcha.errors.recaptcha_unreachable\",\n            \"Oops, we failed to validate your reCAPTCHA response. Please try again.\"\n          )\n          false\n        else\n          raise RecaptchaError, \"Recaptcha unreachable.\"\n        end\n      rescue StandardError => e\n        raise RecaptchaError, e.message, e.backtrace\n      end\n    end", "label": 4}
{"code": "public function setJobTriggers($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\JobTrigger::class);\n        $this->job_triggers = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def default_params(h = {})\n      raise ArgumentError, 'Default params must be an object which responds to #to_hash' unless h.respond_to?(:to_hash)\n      default_options[:default_params] ||= {}\n      default_options[:default_params].merge!(h)\n    end", "label": 4}
{"code": "public function rename($nameSingular, $namePlural)\n    {\n        $this->name_singular = $nameSingular;\n        $this->name_plural = $namePlural;\n\n        $this->raise(new Renamed($this));\n\n        return $this;\n    }", "label": 2}
{"code": "public function setVoice($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\TextToSpeech\\V1\\VoiceSelectionParams::class);\n        $this->voice = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function _linkIdentity() {\n    var identityOptions = {\n            id: this.params.raw.user_id,\n            accessToken: this.params.access_token,\n            accessSecret: this.params.access_secret,\n            screen_name: this.params.raw.screen_name\n        };\n\n    return BB.resolve(grasshopper.request(this.token).users.linkIdentity(this.user._id.toString(), 'twitter', identityOptions));\n}", "label": 3}
{"code": "def get(options)\n      return options if options.is_a?(Unacknowledged) || options.is_a?(Acknowledged)\n      if options\n        validate!(options)\n        if unacknowledged?(options)\n          Unacknowledged.new(options)\n        else\n          Acknowledged.new(options)\n        end\n      end\n    end", "label": 4}
{"code": "def find_field_by_label(browser, field, label):\n    \"\"\"Locate the control input that has a label pointing to it\n\n    This will first locate the label element that has a label of the given\n    name. It then pulls the id out of the 'for' attribute, and uses it to\n    locate the element by its id.\n\n    \"\"\"\n\n    return XPathSelector(browser,\n                         field_xpath(field, 'id', escape=False) %\n                         u'//label[contains(., \"{0}\")]/@for'.format(label))", "label": 1}
{"code": "def write_file(self, filename, *, overwrite=False):\n        \"\"\"Write new ChemKED YAML file based on object.\n\n        Arguments:\n            filename (`str`): Filename for target YAML file\n            overwrite (`bool`, optional): Whether to overwrite file with given name if present.\n                Must be supplied as a keyword-argument.\n\n        Raises:\n            `NameError`: If ``filename`` is already present, and ``overwrite`` is not ``True``.\n\n        Example:\n            >>> dataset = ChemKED(yaml_file)\n            >>> dataset.write_file(new_yaml_file)\n        \"\"\"\n        # Ensure file isn't already present\n        if exists(filename) and not overwrite:\n            raise OSError(filename + ' already present. Specify \"overwrite=True\" '\n                          'to overwrite, or rename.'\n                          )\n\n        with open(filename, 'w') as yaml_file:\n            yaml.dump(self._properties, yaml_file)", "label": 1}
{"code": "def update_status(status, activity, url, since = 0, afk = false, activity_type = 0)\n      gateway_check\n\n      @activity = activity\n      @status = status\n      @streamurl = url\n      type = url ? 1 : activity_type\n\n      activity_obj = activity || url ? { 'name' => activity, 'url' => url, 'type' => type } : nil\n      @gateway.send_status_update(status, since, activity_obj, afk)\n\n      # Update the status in the cache\n      profile.update_presence('status' => status.to_s, 'game' => activity_obj)\n    end", "label": 4}
{"code": "def save_matpower(self, fd):\n        \"\"\" Serialize the case as a MATPOWER data file.\n        \"\"\"\n        from pylon.io import MATPOWERWriter\n        MATPOWERWriter(self).write(fd)", "label": 1}
{"code": "function(model, value, attr) {\n      var indices, validators,\n        validations = model.validation ? _.result(model, 'validation') || {} : {};\n      // If the validations hash contains an entry for the attr\n      if (_.contains(_.keys(validations), attr)) {\n        return validateAttrWithOpenArray(model, attr, value, _.extend({}, model.attributes));\n      } else {\n        indices = extractIndices(attr);\n        attr = stripIndices(attr);\n        validators = getValidators(model, attr);\n        return invokeValidator(validators, model, value, attr, _.extend({}, model.attributes), indices);\n      }\n    }", "label": 3}
{"code": "public Iterator<IntTaggedWord> ruleIteratorByWord(String word, int loc) {\r\n    return ruleIteratorByWord(wordIndex.indexOf(word, true), loc, null);\r\n  }", "label": 0}
{"code": "func (c *Client) Thumbprint(host string) string {\n\thost = hostAddr(host)\n\tc.hostsMu.Lock()\n\tdefer c.hostsMu.Unlock()\n\treturn c.hosts[host]\n}", "label": 5}
{"code": "public String getShortMessage(Locale locale) {\n\t\tString message;\n\t\tmessage = translate(Integer.toString(exceptionCode), locale);\n\t\tif (message != null && msgParameters != null && msgParameters.length > 0) {\n\t\t\tfor (int i = 0; i < msgParameters.length; i++) {\n\t\t\t\tboolean isIncluded = false;\n\t\t\t\tString needTranslationParam = \"$${\" + i + \"}\";\n\t\t\t\tif (message.contains(needTranslationParam)) {\n\t\t\t\t\tString translation = translate(msgParameters[i], locale);\n\t\t\t\t\tif (null == translation && null != msgParameters[i]) {\n\t\t\t\t\t\ttranslation = msgParameters[i].toString();\n\t\t\t\t\t}\n\t\t\t\t\tif (null == translation) {\n\t\t\t\t\t\ttranslation = \"[null]\";\n\t\t\t\t\t}\n\t\t\t\t\tmessage = message.replace(needTranslationParam, translation);\n\t\t\t\t\tisIncluded = true;\n\t\t\t\t}\n\t\t\t\tString verbatimParam = \"${\" + i + \"}\";\n\t\t\t\tString rs = null == msgParameters[i] ? \"[null]\" : msgParameters[i].toString();\n\t\t\t\tif (message.contains(verbatimParam)) {\n\t\t\t\t\tmessage = message.replace(verbatimParam, rs);\n\t\t\t\t\tisIncluded = true;\n\t\t\t\t}\n\t\t\t\tif (!isIncluded) {\n\t\t\t\t\tmessage = message + \" (\" + rs + \")\"; // NOSONAR replace/contains makes StringBuilder use difficult\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}", "label": 0}
{"code": "def register_cache_buster(self, app, config=None):\n        \"\"\"\n        Register `app` in cache buster so that `url_for` adds a unique prefix\n        to URLs generated for the `'static'` endpoint. Also make the app able\n        to serve cache-busted static files.\n\n        This allows setting long cache expiration values on static resources\n        because whenever the resource changes, so does its URL.\n        \"\"\"\n        if not (config is None or isinstance(config, dict)):\n            raise ValueError(\"`config` must be an instance of dict or None\")\n\n        bust_map = {}  # map from an unbusted filename to a busted one\n        unbust_map = {}  # map from a busted filename to an unbusted one\n        # http://flask.pocoo.org/docs/0.12/api/#flask.Flask.static_folder\n\n        app.logger.debug('Starting computing hashes for static assets')\n        # compute (un)bust tables.\n        for dirpath, dirnames, filenames in os.walk(app.static_folder):\n            for filename in filenames:\n                # compute version component\n                rooted_filename = os.path.join(dirpath, filename)\n                if not self.__is_file_to_be_busted(rooted_filename):\n                    continue\n                app.logger.debug(f'Computing hashes for {rooted_filename}')\n                with open(rooted_filename, 'rb') as f:\n                    version = hashlib.md5(\n                        f.read()\n                    ).hexdigest()[:self.hash_size]\n\n                # add version\n                unbusted = os.path.relpath(rooted_filename, app.static_folder)\n                # busted = os.path.join(version, unbusted)\n                busted = f\"{unbusted}?q={version}\"\n\n                # save computation to map\n                bust_map[unbusted] = busted\n                unbust_map[busted] = unbusted\n        app.logger.debug('Finished Starting computing hashes for static assets')\n\n        def bust_filename(file):\n            return bust_map.get(file, file)\n\n        def unbust_filename(file):\n            return unbust_map.get(file, file)\n\n        @app.url_defaults\n        def reverse_to_cache_busted_url(endpoint, values):\n            \"\"\"\n            Make `url_for` produce busted filenames when using the 'static'\n            endpoint.\n            \"\"\"\n            if endpoint == 'static':\n                values['filename'] = bust_filename(values['filename'])\n\n        def debusting_static_view(*args, **kwargs):\n            \"\"\"\n            Serve a request for a static file having a busted name.\n            \"\"\"\n            kwargs['filename'] = unbust_filename(kwargs.get('filename'))\n            return original_static_view(*args, **kwargs)\n\n        # Replace the default static file view with our debusting view.\n        original_static_view = app.view_functions['static']\n        app.view_functions['static'] = debusting_static_view", "label": 1}
{"code": "def export(self, id, exclude_captures=False): # pylint: disable=invalid-name,redefined-builtin\n        \"\"\"Export a result.\n\n        :param id: Result ID as an int.\n        :param exclude_captures: If bool `True`, don't export capture files\n        :rtype: tuple `(io.BytesIO, 'filename')`\n        \"\"\"\n        return self.service.export(self.base, id, params={'exclude_captures': exclude_captures})", "label": 1}
{"code": "public List<List<IN>> classifyFile(String filename) {\r\n    ObjectBank<List<IN>> documents =\r\n      makeObjectBankFromFile(filename, plainTextReaderAndWriter);\r\n    List<List<IN>> result = new ArrayList<List<IN>>();\r\n\r\n    for (List<IN> document : documents) {\r\n      // System.err.println(document);\r\n      classify(document);\r\n\r\n      List<IN> sentence = new ArrayList<IN>();\r\n      for (IN wi : document) {\r\n        sentence.add(wi);\r\n        // System.err.println(wi);\r\n      }\r\n      result.add(sentence);\r\n    }\r\n    return result;\r\n  }", "label": 0}
{"code": "protected Collection loadData() throws PersistenceBrokerException\r\n    {\r\n        PersistenceBroker broker = getBroker();\r\n        try\r\n        {\r\n            Collection result;\r\n\r\n            if (_data != null) // could be set by listener\r\n            {\r\n                result = _data;\r\n            }\r\n            else if (_size != 0)\r\n            {\r\n                // TODO: returned ManageableCollection should extend Collection to avoid\r\n                // this cast\r\n                result = (Collection) broker.getCollectionByQuery(getCollectionClass(), getQuery());\r\n            }\r\n            else\r\n            {\r\n                result = (Collection)getCollectionClass().newInstance();\r\n            }\r\n            return result;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            throw new PersistenceBrokerException(ex);\r\n        }\r\n        finally\r\n        {\r\n            releaseBroker(broker);\r\n        }\r\n    }", "label": 0}
{"code": "def modifydocs(a, b, desc=''):\n    \"\"\"\n    Convenience function for writing documentation.\n\n    For a class method `a` that is essentially a wrapper for an outside \n    function `b`, rope in the docstring from `b` and append to that of `a`.  \n    Also modify the docstring of `a` to get the indentation right.\n    \n    Will probably deprecate this soon.\n\n    **Parameters**\n\n\t\t**a** :  class method\n\n\t\t\tClass method wrapping `b`.\n\n\t\t**b** :  function\n\n\t\t\tFunction wrapped by `a`.\n\n\t\t**desc** :  string, optional\n\n\t\t\tDescription of `b`, e.g. restructured text providing a link to the \n\t\t\tdocumentation for `b`.  Default is an empty string.\n\n    **Returns**\n\n\t\t**newdoc** :  string\n\n\t\t\tNew docstring for `a`.\n\n    \"\"\"\n    newdoc = a.func_doc.replace('\\t\\t', '\\t')\n    newdoc += \"Documentation from \" + desc + \":\\n\" + b.func_doc\n    return newdoc", "label": 1}
{"code": "function _require(requireMe, provides, injects, currentDirectory, next) {\n\n    var requireResult =  _requireFile (requireMe, currentDirectory) ||\n                         _requireFile (requireMe, defaultDirectory) ||\n                         _requireFile (requireMe, __dirname) ||\n                         _requireFile (requireMe, process.cwd()) ||\n                         _requireFile (requireMe, (void 0));\n\n    if(!exists(requireResult)) {\n      var directories = 'directories:(';\n      directories += exists(currentDirectory) ? currentDirectory + ', ' : '';\n      directories += exists(defaultDirectory) ? defaultDirectory + ', ' : '';\n      directories += __dirname + ')';\n      throw new Error('dihelper incapable of finding specified file for require filename:' +\n          requireMe + ', ' + directories);\n    }\n\n    if (typeof provides === 'undefined' && !exists(requireResult.$provide)) {\n    //TODO(@davequick): also look for annotations once ES6, for now can't because you would\n    // receive a different di instance if you did require('di/dist/cjs/annotations') so class\n    // equalities would not work.  Once all is ES6, then instanceof for the classes should work\n    // and add it here.  For now you have to have a string or object on yourmodule.$provide or\n    // it will be overwritten.\n\n      provides = requireMe;\n    }\n\n    return next(requireResult, provides, injects);\n  }", "label": 3}
{"code": "function loadCollection(collection, data) {\n        return Q(collection.fetch()).then(function () {\n            // delete all before running tests\n            return Q.all(collection.models.slice().map(function (model) {\n                return model.destroy();\n            })).then(function () {\n                chai_1.assert.equal(collection.models.length, 0, 'collection must be empty initially after destroy');\n                return collection;\n            });\n        }).then(function (collection2) {\n            // load sample data into fresh database\n            chai_1.assert.equal(collection2, collection, 'same collection object');\n            return Q.all(data.map(function (attrs) {\n                return new TestModel(attrs, {\n                    collection: collection2\n                }).save();\n            })).then(function () {\n                chai_1.assert.equal(collection2.models.length, data.length, 'collection was updated by async events');\n                return collection2;\n            });\n        });\n    }", "label": 3}
{"code": "func SqParseType(args *internal.ArgType, dt string, nullable bool) (int, string, string) {\n\tprecision := 0\n\tnilVal := \"nil\"\n\tunsigned := false\n\n\tdt = strings.ToLower(dt)\n\n\t// extract precision\n\tdt, precision, _ = args.ParsePrecision(dt)\n\n\tif uRE.MatchString(dt) {\n\t\tunsigned = true\n\t\tuRE.ReplaceAllString(dt, \"\")\n\t}\n\n\tvar typ string\n\tswitch dt {\n\tcase \"bool\", \"boolean\":\n\t\tnilVal = \"false\"\n\t\ttyp = \"bool\"\n\t\tif nullable {\n\t\t\tnilVal = \"sql.NullBool{}\"\n\t\t\ttyp = \"sql.NullBool\"\n\t\t}\n\n\tcase \"int\", \"integer\", \"tinyint\", \"smallint\", \"mediumint\", \"bigint\":\n\t\tnilVal = \"0\"\n\t\ttyp = args.Int32Type\n\t\tif nullable {\n\t\t\tnilVal = \"sql.NullInt64{}\"\n\t\t\ttyp = \"sql.NullInt64\"\n\t\t}\n\n\tcase \"numeric\", \"real\", \"double\", \"float\", \"decimal\":\n\t\tnilVal = \"0.0\"\n\t\ttyp = \"float64\"\n\t\tif nullable {\n\t\t\tnilVal = \"sql.NullFloat64{}\"\n\t\t\ttyp = \"sql.NullFloat64\"\n\t\t}\n\n\tcase \"blob\":\n\t\ttyp = \"[]byte\"\n\n\tcase \"timestamp\", \"datetime\", \"date\", \"timestamp with time zone\", \"time with time zone\", \"time without time zone\", \"timestamp without time zone\":\n\t\tnilVal = \"xoutil.SqTime{}\"\n\t\ttyp = \"xoutil.SqTime\"\n\n\tdefault:\n\t\t// case \"varchar\", \"character\", \"varying character\", \"nchar\", \"native character\", \"nvarchar\", \"text\", \"clob\", \"datetime\", \"date\", \"time\":\n\t\tnilVal = `\"\"`\n\t\ttyp = \"string\"\n\t\tif nullable {\n\t\t\tnilVal = \"sql.NullString{}\"\n\t\t\ttyp = \"sql.NullString\"\n\t\t}\n\t}\n\n\t// if unsigned ...\n\tif internal.IntRE.MatchString(typ) && unsigned {\n\t\ttyp = \"u\" + typ\n\t}\n\n\treturn precision, nilVal, typ\n}", "label": 5}
{"code": "function init(app) {\n    app.post('/api/v1/push/registration', \n    /**\n    * register the device on the push Service\n    *\n    * @param req containing body JSON to pass as input.\n    * @param res result of call is provided as JSON body data.\n    * @param next function to invoke error handling.\n    */\n    function serviceCall(req, res, next) {\n        Q(pushService.registerPushDevice(req.body)).then(res.json.bind(res), next).done();\n    });\n    app.post('/api/v1/push', \n    /**\n    * posts push notification(s).\n    *\n    * @param req containing body JSON to pass as input.\n    * @param res result of call is provided as JSON body data.\n    * @param next function to invoke error handling.\n    */\n    function serviceCall(req, res, next) {\n        Q(pushService.postPushNotification(req.body)).then(res.json.bind(res), next).done();\n    });\n    app.get('/api/v1/push/:uuid', \n    /**\n    * gets push notification status.\n    *\n    * @param req containing body JSON to pass as input.\n    * @param res result of call is provided as JSON body data.\n    * @param next function to invoke error handling.\n    */\n    function serviceCall(req, res, next) {\n        Q(pushService.fetchPushNotification(req.params.uuid)).then(res.json.bind(res), next).done();\n    });\n}", "label": 3}
{"code": "def contains?(point)\n      point = Geokit::LatLng.normalize(point)\n      res = point.lat > @sw.lat && point.lat < @ne.lat\n      if crosses_meridian?\n        res &= point.lng < @ne.lng || point.lng > @sw.lng\n      else\n        res &= point.lng < @ne.lng && point.lng > @sw.lng\n      end\n      res\n    end", "label": 4}
{"code": "func (t *terminal) Kill() error {\n\tif t.cmd.Process != nil {\n\t\tif err := t.cmd.Process.Kill(); err != nil {\n\t\t\tif err.Error() != \"os: process already finished\" {\n\t\t\t\treturn trace.Wrap(err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "func PgAttrdefByOid(db XODB, oid pgtypes.Oid) (*PgAttrdef, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, adrelid, adnum, adbin, adsrc ` +\n\t\t`FROM pg_catalog.pg_attrdef ` +\n\t\t`WHERE oid = $1`\n\n\t// run query\n\tXOLog(sqlstr, oid)\n\tpa := PgAttrdef{}\n\n\terr = db.QueryRow(sqlstr, oid).Scan(&pa.Tableoid, &pa.Cmax, &pa.Xmax, &pa.Cmin, &pa.Xmin, &pa.Oid, &pa.Ctid, &pa.Adrelid, &pa.Adnum, &pa.Adbin, &pa.Adsrc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pa, nil\n}", "label": 5}
{"code": "func (p *Pod) WaitFinished(ctx context.Context) error {\n\tf := func() bool {\n\t\tswitch err := p.TrySharedLock(); err {\n\t\tcase nil:\n\t\t\t// the pod is now locked successfully, hence one of the running phases passed.\n\t\t\t// continue with unlocking the pod immediately below.\n\t\tcase lock.ErrLocked:\n\t\t\t// pod is still locked, hence we are still in a running phase.\n\t\t\t// i.e. in pepare, run, exitedGarbage, garbage state.\n\t\t\treturn false\n\t\tdefault:\n\t\t\t// some error occurred, bail out.\n\t\t\treturn true\n\t\t}\n\n\t\t// unlock immediately\n\t\tif err := p.Unlock(); err != nil {\n\t\t\treturn true\n\t\t}\n\n\t\tif err := p.refreshState(); err != nil {\n\t\t\treturn true\n\t\t}\n\n\t\t// if we're in the gap between preparing and running in a split prepare/run-prepared usage, take a nap\n\t\tif p.isPrepared {\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\n\t\treturn p.IsFinished()\n\t}\n\n\treturn retry(ctx, f, 100*time.Millisecond)\n}", "label": 5}
{"code": "def split number\n      # Split the number into country, cc, and national part.\n      country, cc, national_number = partial_split number\n      \n      # Split the national number into ndc and local part.\n      _, ndc, *local = country.split national_number\n      \n      [cc, ndc, *local]\n    end", "label": 4}
{"code": "public function instanceConfigurations(array $options = [])\n    {\n        $resultLimit = $this->pluck('resultLimit', $options, false) ?: 0;\n\n        return new ItemIterator(\n            new PageIterator(\n                function (array $config) {\n                    return $this->instanceConfiguration($config['name'], $config);\n                },\n                [$this->connection, 'listInstanceConfigs'],\n                ['projectId' => InstanceAdminClient::projectName($this->projectId)] + $options,\n                [\n                    'itemsKey' => 'instanceConfigs',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "function _endBatch() {\n        --_batch;\n        _cometd._debug('Ending batch, depth', _batch);\n        if (_batch < 0) {\n            throw 'Calls to startBatch() and endBatch() are not paired';\n        }\n\n        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n            _flushBatch();\n        }\n    }", "label": 3}
{"code": "public function setValue($value, $type = null)\n    {\n        $this->value = $value;\n        $this->type  = $type ?: ParameterTypeInferer::inferType($value);\n    }", "label": 2}
{"code": "func (m *MockIndex) NillableRet() error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"NillableRet\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}", "label": 5}
{"code": "def get_all_tool_inputs(job, tools, outer_key='', mutation_caller_list=None):\n    \"\"\"\n    Iterate through all the tool options and download required files from their remote locations.\n\n    :param dict tools: A dict of dicts of all tools, and their options\n    :param str outer_key: If this is being called recursively, what was the outer dict called?\n    :param list mutation_caller_list: A list of mutation caller keys to append the indexes to.\n    :return: The fully resolved tool dictionary\n    :rtype: dict\n    \"\"\"\n    for tool in tools:\n        for option in tools[tool]:\n            if isinstance(tools[tool][option], dict):\n                tools[tool][option] = get_all_tool_inputs(\n                    job, {option: tools[tool][option]},\n                    outer_key=':'.join([outer_key, tool]).lstrip(':'))[option]\n            else:\n                # If a file is of the type file, vcf, tar or fasta, it needs to be downloaded from\n                # S3 if reqd, then written to job store.\n                if option.split('_')[-1] in ['file', 'vcf', 'index', 'fasta', 'fai', 'idx', 'dict',\n                                             'tbi', 'beds', 'gtf', 'config']:\n                    tools[tool][option] = job.addChildJobFn(\n                        get_pipeline_inputs, ':'.join([outer_key, tool, option]).lstrip(':'),\n                        tools[tool][option]).rv()\n                elif option == 'version':\n                    tools[tool][option] = str(tools[tool][option])\n    if mutation_caller_list is not None:\n        # Guaranteed to occur only in the outermost loop\n        indexes = tools.pop('indexes')\n        indexes['chromosomes'] = parse_chromosome_string(job, indexes['chromosomes'])\n        for mutation_caller in mutation_caller_list:\n            if mutation_caller == 'indexes':\n                continue\n            tools[mutation_caller].update(indexes)\n    return tools", "label": 1}
{"code": "function isIndependentMember(symbol) {\n            if (symbol.declarations && symbol.declarations.length === 1) {\n                var declaration = symbol.declarations[0];\n                if (declaration) {\n                    switch (declaration.kind) {\n                        case 145 /* PropertyDeclaration */:\n                        case 144 /* PropertySignature */:\n                            return isIndependentVariableLikeDeclaration(declaration);\n                        case 147 /* MethodDeclaration */:\n                        case 146 /* MethodSignature */:\n                        case 148 /* Constructor */:\n                            return isIndependentFunctionLikeDeclaration(declaration);\n                    }\n                }\n            }\n            return false;\n        }", "label": 3}
{"code": "def []=(url, value)\n      case\n        when store.respond_to?(:[]=)\n          store[key_for(url)] = value\n        when store.respond_to?(:set)\n          store.set key_for(url), value\n        when store.respond_to?(:write)\n          store.write key_for(url), value\n      end\n    end", "label": 4}
{"code": "def _check_codons(self):\n        \"\"\"\n        If codon table is missing stop codons, then add them.\n        \"\"\"\n        for stop_codon in self.stop_codons:\n            if stop_codon in self.codon_table:\n                if self.codon_table[stop_codon] != \"*\":\n                    raise ValueError(\n                        (\"Codon '%s' not found in stop_codons, but codon table \"\n                         \"indicates that it should be\") % (stop_codon,))\n            else:\n                self.codon_table[stop_codon] = \"*\"\n\n        for start_codon in self.start_codons:\n            if start_codon not in self.codon_table:\n                raise ValueError(\n                    \"Start codon '%s' missing from codon table\" % (\n                        start_codon,))\n\n        for codon, amino_acid in self.codon_table.items():\n            if amino_acid == \"*\" and codon not in self.stop_codons:\n                raise ValueError(\n                    \"Non-stop codon '%s' can't translate to '*'\" % (\n                        codon,))\n\n        if len(self.codon_table) != 64:\n            raise ValueError(\n                \"Expected 64 codons but found %d in codon table\" % (\n                    len(self.codon_table,)))", "label": 1}
{"code": "def plan_hash(plan_name, plan)\n      elements = plan.params_type.elements || []\n      parameters = elements.each_with_object({}) do |param, acc|\n        type = if param.value_type.is_a?(Puppet::Pops::Types::PTypeAliasType)\n                 param.value_type.name\n               else\n                 param.value_type.to_s\n               end\n        acc[param.name] = { 'type' => type }\n        acc[param.name]['default_value'] = nil if param.key_type.is_a?(Puppet::Pops::Types::POptionalType)\n      end\n      {\n        'name' => plan_name,\n        'parameters' => parameters\n      }\n    end", "label": 4}
{"code": "func (c *connection) upload(msg func(pp.Message) bool) bool {\n\t// Breaking or completing this loop means we don't want to upload to the\n\t// peer anymore, and we choke them.\nanother:\n\tfor c.uploadAllowed() {\n\t\t// We want to upload to the peer.\n\t\tif !c.Unchoke(msg) {\n\t\t\treturn false\n\t\t}\n\t\tfor r := range c.PeerRequests {\n\t\t\tres := c.t.cl.config.UploadRateLimiter.ReserveN(time.Now(), int(r.Length))\n\t\t\tif !res.OK() {\n\t\t\t\tpanic(fmt.Sprintf(\"upload rate limiter burst size < %d\", r.Length))\n\t\t\t}\n\t\t\tdelay := res.Delay()\n\t\t\tif delay > 0 {\n\t\t\t\tres.Cancel()\n\t\t\t\tc.setRetryUploadTimer(delay)\n\t\t\t\t// Hard to say what to return here.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tmore, err := c.sendChunk(r, msg)\n\t\t\tif err != nil {\n\t\t\t\ti := pieceIndex(r.Index)\n\t\t\t\tif c.t.pieceComplete(i) {\n\t\t\t\t\tc.t.updatePieceCompletion(i)\n\t\t\t\t\tif !c.t.pieceComplete(i) {\n\t\t\t\t\t\t// We had the piece, but not anymore.\n\t\t\t\t\t\tbreak another\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlog.Str(\"error sending chunk to peer\").AddValues(c, r, err).Log(c.t.logger)\n\t\t\t\t// If we failed to send a chunk, choke the peer to ensure they\n\t\t\t\t// flush all their requests. We've probably dropped a piece,\n\t\t\t\t// but there's no way to communicate this to the peer. If they\n\t\t\t\t// ask for it again, we'll kick them to allow us to send them\n\t\t\t\t// an updated bitfield.\n\t\t\t\tbreak another\n\t\t\t}\n\t\t\tdelete(c.PeerRequests, r)\n\t\t\tif !more {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tgoto another\n\t\t}\n\t\treturn true\n\t}\n\treturn c.Choke(msg)\n}", "label": 5}
{"code": "func getApplist(manifest *schema.PodManifest) []*v1alpha.App {\n\tvar apps []*v1alpha.App\n\tfor _, app := range manifest.Apps {\n\t\timg := &v1alpha.Image{\n\t\t\tBaseFormat: &v1alpha.ImageFormat{\n\t\t\t\t// Only support appc image now. If it's a docker image, then it\n\t\t\t\t// will be transformed to appc before storing in the disk store.\n\t\t\t\tType:    v1alpha.ImageType_IMAGE_TYPE_APPC,\n\t\t\t\tVersion: schema.AppContainerVersion.String(),\n\t\t\t},\n\t\t\tId: app.Image.ID.String(),\n\t\t\t// Only image format and image ID are returned in 'ListPods()'.\n\t\t}\n\n\t\tapps = append(apps, &v1alpha.App{\n\t\t\tName:        app.Name.String(),\n\t\t\tImage:       img,\n\t\t\tAnnotations: convertAnnotationsToKeyValue(app.Annotations),\n\t\t\tState:       v1alpha.AppState_APP_STATE_UNDEFINED,\n\t\t\tExitCode:    -1,\n\t\t})\n\t}\n\treturn apps\n}", "label": 5}
{"code": "def json_pretty_print(item = nil)\n      FFI_Yajl::Encoder.new(pretty: true, validate_utf8: false).encode(item || @data)\n    end", "label": 4}
{"code": "def builddepends\n    # Handle the requires\n    self.class.relationship_params.collect do |klass|\n      if param = @parameters[klass.name]\n        param.to_edges\n      end\n    end.flatten.reject { |r| r.nil? }\n  end", "label": 4}
{"code": "public function setExcludedFields($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\FieldId::class);\n        $this->excluded_fields = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function writeJSON(dbName, schema) {\n\n    var baseUrl = 'http://www.filltext.com/?',\n        promises = [],\n        collection;\n\n    for (collection in schema) {\n\n        var meta = schema[collection].meta,\n            fields = meta.fields,\n            url;\n\n        url = Object.keys(fields).map(function(key) {\n            if (fields[key][0] === '[' && fields[key].slice(-1) === ']') {\n                return key + '=' + fields[key];\n            }\n            return key + '={' + fields[key] + '}';\n        }).join('&') + '&rows=' + meta.rows;\n\n        console.log('Url for', collection, url);\n\n        (function(c) {\n            promises.push(fetch(baseUrl + url).then(function(response) {\n                return response.json();\n            })\n            .then(function(rows) {\n                schema[c] = rows;\n            }));\n        })(collection);\n    }\n\n    return Promise.all(promises).then(function() {\n        fs.writeFile(dbName, JSON.stringify(schema, null, 4), function(err) {\n            if (err) {\n                Promise.reject('Failed to save JSON file: ' + err);\n            }\n        });\n    });\n}", "label": 3}
{"code": "function checkDecorators(node) {\n            if (!node.decorators) {\n                return;\n            }\n            // skip this check for nodes that cannot have decorators. These should have already had an error reported by\n            // checkGrammarDecorators.\n            if (!ts.nodeCanBeDecorated(node)) {\n                return;\n            }\n            if (!compilerOptions.experimentalDecorators) {\n                error(node, ts.Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_to_remove_this_warning);\n            }\n            if (compilerOptions.emitDecoratorMetadata) {\n                // we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.\n                switch (node.kind) {\n                    case 221 /* ClassDeclaration */:\n                        var constructor = ts.getFirstConstructorWithBody(node);\n                        if (constructor) {\n                            checkParameterTypeAnnotationsAsExpressions(constructor);\n                        }\n                        break;\n                    case 147 /* MethodDeclaration */:\n                    case 149 /* GetAccessor */:\n                    case 150 /* SetAccessor */:\n                        checkParameterTypeAnnotationsAsExpressions(node);\n                        checkReturnTypeAnnotationAsExpression(node);\n                        break;\n                    case 145 /* PropertyDeclaration */:\n                    case 142 /* Parameter */:\n                        checkTypeAnnotationAsExpression(node);\n                        break;\n                }\n            }\n            ts.forEach(node.decorators, checkDecorator);\n        }", "label": 3}
{"code": "def coverage_path\n      @coverage_path ||= begin\n        coverage_path = File.expand_path(coverage_dir, root)\n        FileUtils.mkdir_p coverage_path\n        coverage_path\n      end\n    end", "label": 4}
{"code": "async def dump_varint_t(writer, type_or, pv):\n    \"\"\"\n    Binary dump of the integer of given type\n\n    :param writer:\n    :param type_or:\n    :param pv:\n    :return:\n    \"\"\"\n    width = int_mark_to_size(type_or)\n    n = (pv << 2) | type_or\n\n    buffer = _UINT_BUFFER\n    for _ in range(width):\n        buffer[0] = n & 0xff\n        await writer.awrite(buffer)\n        n >>= 8\n\n    return width", "label": 1}
{"code": "def save_records(self, records):\n        '''\n        Save a collection of records\n        '''\n        for record in records:\n            if not isinstance(record, Record):\n                record = Record(*record)\n            self.save_record(*record)", "label": 1}
{"code": "public function setTcpCheck($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Monitoring\\V3\\UptimeCheckConfig_TcpCheck::class);\n        $this->writeOneof(6, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "func (m *Mock) fail(format string, args ...interface{}) {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tif m.test == nil {\n\t\tpanic(fmt.Sprintf(format, args...))\n\t}\n\tm.test.Errorf(format, args...)\n\tm.test.FailNow()\n}", "label": 5}
{"code": "func (n *Networking) kvmTeardown() {\n\n\tif err := n.teardownForwarding(); err != nil {\n\t\tstderr.PrintE(\"error removing forwarded ports (kvm)\", err)\n\t}\n\tn.teardownKvmNets()\n}", "label": 5}
{"code": "def sam_list_paired(sam):\n\t\"\"\"\n\tget a list of mapped reads\n\trequire that both pairs are mapped in the sam file in order to remove the reads\n\t\"\"\"\n\tlist = []\n\tpair = ['1', '2']\n\tprev = ''\n\tfor file in sam:\n\t\tfor line in file:\n\t\t\tif line.startswith('@') is False:\n\t\t\t\tline = line.strip().split()\n\t\t\t\tid, map = line[0], int(line[1])\n\t\t\t\tif map != 4 and map != 8:\n\t\t\t\t\tread = id.rsplit('/')[0]\n\t\t\t\t\tif read == prev:\n\t\t\t\t\t\tlist.append(read)\n\t\t\t\t\tprev = read\n\treturn set(list)", "label": 1}
{"code": "public void forAllIndexColumns(String template, Properties attributes) throws XDocletException\r\n    {\r\n        for (Iterator it = _curIndexDef.getColumns(); it.hasNext(); )\r\n        {\r\n            _curColumnDef = _curTableDef.getColumn((String)it.next());\r\n            generate(template);\r\n        }\r\n        _curColumnDef = null;\r\n    }", "label": 0}
{"code": "function appendOuterTypeParameters(typeParameters, node) {\n            while (true) {\n                node = node.parent;\n                if (!node) {\n                    return typeParameters;\n                }\n                if (node.kind === 221 /* ClassDeclaration */ || node.kind === 192 /* ClassExpression */ ||\n                    node.kind === 220 /* FunctionDeclaration */ || node.kind === 179 /* FunctionExpression */ ||\n                    node.kind === 147 /* MethodDeclaration */ || node.kind === 180 /* ArrowFunction */) {\n                    var declarations = node.typeParameters;\n                    if (declarations) {\n                        return appendTypeParameters(appendOuterTypeParameters(typeParameters, node), declarations);\n                    }\n                }\n            }\n        }", "label": 3}
{"code": "function(next) {\n            if (options.noDb || core.noDb) return next();\n            db.init(options, next);\n        }", "label": 3}
{"code": "protected synchronized int loadSize() throws PersistenceBrokerException\r\n    {\r\n        PersistenceBroker broker = getBroker();\r\n        try\r\n        {\r\n            return broker.getCount(getQuery());\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            throw new PersistenceBrokerException(ex);\r\n        }\r\n        finally\r\n        {\r\n            releaseBroker(broker);\r\n        }\r\n    }", "label": 0}
{"code": "public static base_responses add(nitro_service client, clusternodegroup resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tclusternodegroup addresources[] = new clusternodegroup[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new clusternodegroup();\n\t\t\t\taddresources[i].name = resources[i].name;\n\t\t\t\taddresources[i].strict = resources[i].strict;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def render_list(self, cnt, unique=False, progress_callback=None, **kwargs):\n        '''Return a list of generated strings.\n\n        Args:\n            cnt (int): length of list\n            unique (bool): whether to make entries unique\n\n        Returns:\n            list.\n\n        We keep track of total attempts because a template may\n        specify something impossible to attain, like [1-9]{} with cnt==1000\n\n        '''\n        \n        rendered_list = []\n        i = 0\n        total_attempts = 0\n        while True:\n            if i >= cnt:\n                break\n            if total_attempts > cnt * self.unique_attempts_factor:\n                raise StringGenerator.UniquenessError(u\"couldn't satisfy uniqueness\")\n            s = self.render(**kwargs)\n            if unique:\n                if not s in rendered_list:\n                    rendered_list.append(s)\n                    i += 1\n            else:\n                rendered_list.append(s)\n                i += 1\n            total_attempts += 1\n\n            # Optionally trigger the progress indicator to inform others about our progress\n            if progress_callback and callable(progress_callback):\n                progress_callback(i, cnt)\n\n        return rendered_list", "label": 1}
{"code": "public function get($url)\n    {\n        $params = ['url' => (string) $url];\n        $this->execute(DriverCommand::GET, $params);\n\n        return $this;\n    }", "label": 2}
{"code": "function makeExportDirectory(params, callback) {\n  var newDirPath = params.workingDir + \"/\" + params.entry.fileName;\n  mkdirp(newDirPath, function(err) {\n    if (err) {\n      logger.debug(\"Error making directory \" + newDirPath, err);\n      return callback(err);\n    }\n    params.zipfile.readEntry();\n    return callback(err);\n  });\n}", "label": 3}
{"code": "def merge_resultsets(result1, result2)\n      (result1.keys | result2.keys).each_with_object({}) do |filename, merged|\n        file1 = result1[filename]\n        file2 = result2[filename]\n        merged[filename] = merge_file_coverage(file1, file2)\n      end\n    end", "label": 4}
{"code": "function rand(options) {\n  options = _.opts(options, {size: 32, ascii: false, alphanumeric: false, numeric: false});\n  const size = options.size;\n  let data = '';\n  while (data.length < size) {\n    // ASCII is in range of 0 to 127\n    let randBytes = crypto.pseudoRandomBytes(Math.max(size, 32)).toString();\n    /* eslint-disable no-control-regex */\n    if (options.ascii) randBytes = randBytes.replace(/[^\\s\\x00-\\x7F]/g, '');\n    /* eslint-enable no-control-regex */\n    if (options.alphanumeric) randBytes = randBytes.replace(/[^a-zA-Z0-9]/g, '');\n    if (options.numeric) randBytes = randBytes.replace(/[^0-9]/g, '');\n    data += randBytes;\n  }\n  data = data.slice(0, size);\n  return data;\n}", "label": 3}
{"code": "def setup_derived_entry_elements(id_generator)\n      @hqmf_id = attr_val('./*/cda:id/@root') || attr_val('./*/cda:typeId/@extension')\n      @title = attr_val('./*/cda:code/cda:displayName/@value').try(:titleize)\n      @type = attr_val('./*/cda:code/@code')\n      @comments = @entry.xpath('./*/cda:text/cda:xml/cda:qdmUserComments/cda:item/text()', HQMF2::Document::NAMESPACES)\n                  .map(&:content)\n      handle_preconditions(id_generator)\n      obs_test = attr_val('./cda:measureObservationDefinition/@classCode')\n      # If there are no measure observations, or there is a title, then there are no aggregations to extract\n      return unless !@title && obs_test.to_s == 'OBS'\n      @title = attr_val('../cda:code/cda:displayName/@value')\n      @aggregator = attr_val('./cda:measureObservationDefinition/cda:methodCode/cda:item/@code')\n    end", "label": 4}
{"code": "func (t *Torrent) DownloadPieces(begin, end pieceIndex) {\n\tt.cl.lock()\n\tdefer t.cl.unlock()\n\tt.downloadPiecesLocked(begin, end)\n}", "label": 5}
{"code": "func (l *LoadBalancer) dropConnections(backend NetAddr) {\n\ttracker := l.connections[backend]\n\tfor _, conn := range tracker {\n\t\tconn.Close()\n\t}\n\tdelete(l.connections, backend)\n}", "label": 5}
{"code": "def start_aikif():\n    \"\"\"\n    starts the web interface and possibly other processes\n    \"\"\"\n    if sys.platform[0:3] == 'win':\n        os.system(\"start go_web_aikif.bat\") \n    else:\n        os.system(\"../aikif/web_app/web_aikif.py\")\n        import webbrowser\n        import time\n        time.sleep(1)\n        webbrowser.open('http://127.0.0.1:5000')", "label": 1}
{"code": "def clear_installed_templates\n      install_path = Pathname.new(TEMPLATES_FOLDER)\n      FileUtils.rm_rf(Dir.glob(install_path))\n    end", "label": 4}
{"code": "public function setAdult($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Vision\\V1\\Likelihood::class);\n        $this->adult = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function pushLoadingState(xhrEvent, stateName, modelOrCollection, context, force) {\n        var currentLoads = getState(stateName, context),\n            currentlyLoading = currentLoads && currentLoads.length;\n        if (!currentLoads) {\n            currentLoads = [];\n        }\n        if (_.isArray(currentLoads)) {\n            if (_.indexOf(currentLoads, xhrEvent) >= 0) {\n                if (!force) {\n                    return;\n                }\n                \n            } else {\n                currentLoads.push(xhrEvent);\n            }\n            \n            if (!currentlyLoading) {\n                var toSet = {};\n                toSet[stateName] = currentLoads;\n                setState(toSet, context);\n            }\n\n            xhrEvent.on('complete', function() {\n                popLoadingState(xhrEvent, stateName, modelOrCollection, context);\n            });\n        }\n    }", "label": 3}
{"code": "def run_radia(job, rna_bam, tumor_bam, normal_bam, univ_options, radia_options):\n    \"\"\"\n    Spawn a RADIA job for each chromosome on the input bam trios.\n\n    :param dict rna_bam: Dict of bam and bai for tumor DNA-Seq.  It can be one of two formats\n           rna_bam:   # Just the genomic bam and bai\n                |- 'rna_genome_sorted.bam': fsID\n                +- 'rna_genome_sorted.bam.bai': fsID\n           OR\n           rna_bam:   # The output from run_star\n               |- 'rna_transcriptome.bam': fsID\n               |- 'rna_genome':     # Only this part will be used\n                       |- 'rna_genome_sorted.bam': fsID\n                       +- 'rna_genome_sorted.bam.bai': fsID\n    :param dict tumor_bam: Dict of bam and bai for tumor DNA-Seq\n    :param dict normal_bam: Dict of bam and bai for normal DNA-Seq\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict radia_options: Options specific to RADIA\n    :return: Dict of results from running RADIA on every chromosome\n             perchrom_radia:\n                 |- 'chr1': fsID\n                 |- 'chr2' fsID\n                 |\n                 |-...\n                 |\n                 +- 'chrM': fsID\n    :rtype: dict\n    \"\"\"\n    if 'rna_genome' in rna_bam.keys():\n        rna_bam = rna_bam['rna_genome']\n    elif set(rna_bam.keys()) == {'rna_genome_sorted.bam', 'rna_genome_sorted.bam.bai'}:\n        pass\n    else:\n        raise RuntimeError('An improperly formatted dict was passed to rna_bam.')\n        \n    bams = {'tumor_rna': rna_bam['rna_genome_sorted.bam'],\n            'tumor_rnai': rna_bam['rna_genome_sorted.bam.bai'],\n            'tumor_dna': tumor_bam['tumor_dna_fix_pg_sorted.bam'],\n            'tumor_dnai': tumor_bam['tumor_dna_fix_pg_sorted.bam.bai'],\n            'normal_dna': normal_bam['normal_dna_fix_pg_sorted.bam'],\n            'normal_dnai': normal_bam['normal_dna_fix_pg_sorted.bam.bai']}\n    # Get a list of chromosomes to process\n    if radia_options['chromosomes']:\n        chromosomes = radia_options['chromosomes']\n    else:\n        chromosomes = sample_chromosomes(job, radia_options['genome_fai'])\n    perchrom_radia = defaultdict()\n    for chrom in chromosomes:\n        radia = job.addChildJobFn(run_radia_perchrom, bams, univ_options, radia_options, chrom,\n                                  memory='6G',\n                                  disk=PromisedRequirement(\n                                      radia_disk, tumor_bam['tumor_dna_fix_pg_sorted.bam'],\n                                      normal_bam['normal_dna_fix_pg_sorted.bam'],\n                                      rna_bam['rna_genome_sorted.bam'],\n                                      radia_options['genome_fasta']))\n        filter_radia = radia.addChildJobFn(run_filter_radia, bams, radia.rv(), univ_options,\n                                           radia_options, chrom, memory='6G',\n                                           disk=PromisedRequirement(\n                                               radia_disk, tumor_bam['tumor_dna_fix_pg_sorted.bam'],\n                                               normal_bam['normal_dna_fix_pg_sorted.bam'],\n                                               rna_bam['rna_genome_sorted.bam'],\n                                               radia_options['genome_fasta']))\n        perchrom_radia[chrom] = filter_radia.rv()\n    job.fileStore.logToMaster('Ran spawn_radia on %s successfully' % univ_options['patient'])\n    return perchrom_radia", "label": 1}
{"code": "function insertObject(entityObject) {\n  var mongoAdapter = this;\n\n  expect(arguments).to.have.length(\n    1,\n    'Invalid arguments length when inserting an object in a MongoAdapter ' +\n    '(it has to be passed 1 argument)'\n  );\n\n  return new Promise(function (resolve, reject) {\n    expect(entityObject).to.be.an.instanceOf(\n      Entity,\n      'Invalid argument \"entityObject\" when inserting an object in a ' +\n      'MongoAdapter (it has to be an Entity instance)'\n    );\n\n    var EntityClass = entityObject.Entity;\n\n    mongoAdapter\n      .getDatabase()\n      .then(function (database) {\n        return database\n          .collection(getEntityCollectionName(EntityClass))\n          .insertOne(\n            objectToDocument(entityObject)\n          );\n      })\n      .then(function (result) {\n        expect(result.insertedCount).to.equal(\n          1,\n          'Invalid result.insertedCount return of collection.insertOne ' +\n          'in MongoDB driver when inserting an Object (it should be 1)'\n        );\n\n        resolve();\n      })\n      .catch(reject);\n  });\n}", "label": 3}
{"code": "def check_extension(conn, extension: str) -> bool:\n    \"\"\"Check to see if an extension is installed.\"\"\"\n\n    query = 'SELECT installed_version FROM pg_available_extensions WHERE name=%s;'\n\n    with conn.cursor() as cursor:\n        cursor.execute(query, (extension,))\n        result = cursor.fetchone()\n\n    if result is None:\n        raise psycopg2.ProgrammingError(\n            'Extension is not available for installation.', extension\n        )\n    else:\n        extension_version = result[0]\n\n        return bool(extension_version)", "label": 1}
{"code": "def predict_netmhcii_binding(job, peptfile, allele, univ_options, netmhciipan_options):\n    \"\"\"\n    Predict binding for each peptide in `peptfile` to `allele` using netMHCIIpan.\n\n    :param toil.fileStore.FileID peptfile: The input peptide fasta\n    :param str allele: Allele to predict binding against\n    :param dict univ_options: Dict of universal options used by almost all tools\n    :param dict netmhciipan_options: Options specific to netmhciipan binding prediction\n    :return: tuple of fsID for file containing the predictions and the predictor used (netMHCIIpan)\n    :rtype: tuple(toil.fileStore.FileID, str)\n    \"\"\"\n    work_dir = os.getcwd()\n    input_files = {\n        'peptfile.faa': peptfile}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=True)\n    peptides = read_peptide_file(os.path.join(os.getcwd(), 'peptfile.faa'))\n    if not peptides:\n        return job.fileStore.writeGlobalFile(job.fileStore.getLocalTempFile()), None\n    # netMHCIIpan accepts differently formatted alleles so we need to modify the input alleles\n    if allele.startswith('HLA-DQA') or allele.startswith('HLA-DPA'):\n        allele = re.sub(r'[*:]', '', allele)\n        allele = re.sub(r'/', '-', allele)\n    elif allele.startswith('HLA-DRB'):\n        allele = re.sub(r':', '', allele)\n        allele = re.sub(r'\\*', '_', allele)\n        allele = allele.lstrip('HLA-')\n    else:\n        raise RuntimeError('Unknown allele seen')\n    parameters = ['-a', allele,\n                  '-xls', '1',\n                  '-xlsfile', 'predictions.tsv',\n                  '-f', input_files['peptfile.faa']]\n    # netMHC writes a lot of useless stuff to sys.stdout so we open /dev/null and dump output there.\n    with open(os.devnull, 'w') as output_catcher:\n        docker_call(tool='netmhciipan', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'], outfile=output_catcher,\n                    tool_version=netmhciipan_options['version'])\n    output_file = job.fileStore.writeGlobalFile('/'.join([work_dir, 'predictions.tsv']))\n    job.fileStore.logToMaster('Ran netmhciipan on %s successfully' % allele)\n    return output_file, 'netMHCIIpan'", "label": 1}
{"code": "public function metrics(array $options = [])\n    {\n        $resultLimit = $this->pluck('resultLimit', $options, false);\n\n        return new ItemIterator(\n            new PageIterator(\n                function (array $metric) {\n                    return new Metric($this->connection, $metric['name'], $this->projectId, $metric);\n                },\n                [$this->connection, 'listMetrics'],\n                $options + ['parent' => $this->formattedProjectName],\n                [\n                    'itemsKey' => 'metrics',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "def rate_limited?(key, thing, increment: 1)\n      # Check whether the bucket actually exists\n      return false unless @buckets && @buckets[key]\n\n      @buckets[key].rate_limited?(thing, increment: increment)\n    end", "label": 4}
{"code": "def run_checkpointing\n      # task check pointer is scoped to separate class to avoid\n      # the secondary thread and main thread modifying the same @task\n      # variable (and accidentally clobbering it in the process)\n      task_checkpointer = TaskCheckPointer.new(@task.id)\n      Thread.new do\n        with_thread_name(\"task:#{@task.id}-checkpoint\") do\n          while true\n            sleep(Config.task_checkpoint_interval)\n            task_checkpointer.checkpoint\n          end\n        end\n      end\n    end", "label": 4}
{"code": "def select_scheme(preferred_to_include: nil)\n      if options[:scheme].to_s.length > 0\n        # Verify the scheme is available\n        unless schemes.include?(options[:scheme].to_s)\n          UI.error(\"Couldn't find specified scheme '#{options[:scheme]}'. Please make sure that the scheme is shared, see https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW3\")\n          options[:scheme] = nil\n        end\n      end\n\n      return if options[:scheme].to_s.length > 0\n\n      if schemes.count == 1\n        options[:scheme] = schemes.last\n      elsif schemes.count > 1\n        preferred = nil\n        if preferred_to_include\n          preferred = schemes.find_all { |a| a.downcase.include?(preferred_to_include.downcase) }\n        end\n\n        if preferred_to_include && preferred.count == 1\n          options[:scheme] = preferred.last\n        elsif automated_scheme_selection? && schemes.include?(project_name)\n          UI.important(\"Using scheme matching project name (#{project_name}).\")\n          options[:scheme] = project_name\n        elsif Helper.ci?\n          UI.error(\"Multiple schemes found but you haven't specified one.\")\n          UI.error(\"Since this is a CI, please pass one using the `scheme` option\")\n          show_scheme_shared_information\n          UI.user_error!(\"Multiple schemes found\")\n        else\n          puts(\"Select Scheme: \")\n          options[:scheme] = choose(*schemes)\n        end\n      else\n        show_scheme_shared_information\n\n        UI.user_error!(\"No Schemes found\")\n      end\n    end", "label": 4}
{"code": "public static function start($app)\n    {\n        if (! config('telescope.enabled')) {\n            return;\n        }\n\n        static::registerWatchers($app);\n\n        static::registerMailableTagExtractor();\n\n        if (static::runningApprovedArtisanCommand($app) ||\n            static::handlingApprovedRequest($app)\n        ) {\n            static::startRecording();\n        }\n    }", "label": 2}
{"code": "public function setRotatedBoundingBox($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\VideoIntelligence\\V1\\NormalizedBoundingPoly::class);\n        $this->rotated_bounding_box = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function isSerializedHelper(obj){\n\tif (typeReflections.isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tif(hasUpdateSymbol(obj)) {\n\t\treturn false;\n\t}\n\treturn typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj);\n}", "label": 3}
{"code": "private function applyHeaders(RequestInterface $request)\n    {\n        $headers = [\n            'User-Agent' => 'gcloud-php/' . $this->componentVersion,\n            'x-goog-api-client' => 'gl-php/' . PHP_VERSION . ' gccl/' . $this->componentVersion,\n        ];\n\n        if ($this->shouldSignRequest) {\n            $headers['Authorization'] = 'Bearer ' . $this->getToken();\n        }\n\n        return Psr7\\modify_request($request, ['set_headers' => $headers]);\n    }", "label": 2}
{"code": "public static nsrollbackcmd[] get(nitro_service service, nsrollbackcmd_args args) throws Exception{\n\t\tnsrollbackcmd obj = new nsrollbackcmd();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tnsrollbackcmd[] response = (nsrollbackcmd[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def button(name, identifier={:index => 0}, &block)\n      standard_methods(name, identifier, 'button_for', &block)\n      define_method(name) do\n        return platform.click_button_for identifier.clone unless block_given?\n        self.send(\"#{name}_element\").click\n      end\n    end", "label": 4}
{"code": "public function read($s3BucketName, $logFileKey)\n    {\n        // Create a command for getting the log file object\n        $command = $this->s3Client->getCommand('GetObject', [\n            'Bucket' => (string) $s3BucketName,\n            'Key' => (string) $logFileKey,\n            'ResponseContentEncoding' => 'x-gzip'\n        ]);\n\n        // Make sure gzip encoding header is sent and accepted in order to\n        // inflate the response data.\n        $command['@http']['headers']['Accept-Encoding'] = 'gzip';\n\n        // Get the JSON response data and extract the log records\n        $result = $this->s3Client->execute($command);\n        $logData = json_decode($result['Body'], true);\n\n        return isset($logData['Records']) ? $logData['Records'] : [];\n    }", "label": 2}
{"code": "func (s SearchIndex) FindByDatastorePath(ctx context.Context, dc *Datacenter, path string) (Reference, error) {\n\treq := types.FindByDatastorePath{\n\t\tThis:       s.Reference(),\n\t\tDatacenter: dc.Reference(),\n\t\tPath:       path,\n\t}\n\n\tres, err := methods.FindByDatastorePath(ctx, s.c, &req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.Returnval == nil {\n\t\treturn nil, nil\n\t}\n\treturn NewReference(s.c, *res.Returnval), nil\n}", "label": 5}
{"code": "protected function addConversionsFromRelatedModel(Media $media)\n    {\n        $modelName = Arr::get(Relation::morphMap(), $media->model_type, $media->model_type);\n\n        /** @var \\Spatie\\MediaLibrary\\HasMedia\\HasMedia $model */\n        $model = new $modelName();\n\n        /*\n         * In some cases the user might want to get the actual model\n         * instance so conversion parameters can depend on model\n         * properties. This will causes extra queries.\n         */\n        if ($model->registerMediaConversionsUsingModelInstance) {\n            $model = $media->model;\n\n            $model->mediaConversion = [];\n        }\n\n        $model->registerAllMediaConversions($media);\n\n        $this->items = $model->mediaConversions;\n    }", "label": 2}
{"code": "private void configureCaching(HttpServletResponse response, int seconds) {\n\t\t// HTTP 1.0 header\n\t\tresponse.setDateHeader(HTTP_EXPIRES_HEADER, System.currentTimeMillis() + seconds * 1000L);\n\t\tif (seconds > 0) {\n\t\t\t// HTTP 1.1 header\n\t\t\tresponse.setHeader(HTTP_CACHE_CONTROL_HEADER, \"max-age=\" + seconds);\n\t\t} else {\n\t\t\t// HTTP 1.1 header\n\t\t\tresponse.setHeader(HTTP_CACHE_CONTROL_HEADER, \"no-cache\");\n\n\t\t}\n\t}", "label": 0}
{"code": "func (l VirtualDeviceList) SelectByType(deviceType types.BaseVirtualDevice) VirtualDeviceList {\n\tdtype := reflect.TypeOf(deviceType)\n\tif dtype == nil {\n\t\treturn nil\n\t}\n\tdname := dtype.Elem().Name()\n\n\treturn l.Select(func(device types.BaseVirtualDevice) bool {\n\t\tt := reflect.TypeOf(device)\n\n\t\tif t == dtype {\n\t\t\treturn true\n\t\t}\n\n\t\t_, ok := t.Elem().FieldByName(dname)\n\n\t\treturn ok\n\t})\n}", "label": 5}
{"code": "func CheckVersions(clientVersion string, minClientVersion string) error {\n\tclientSemver, err := semver.NewVersion(clientVersion)\n\tif err != nil {\n\t\treturn trace.Wrap(err,\n\t\t\t\"unsupported version format, need semver format: %q, e.g 1.0.0\", clientVersion)\n\t}\n\n\tminClientSemver, err := semver.NewVersion(minClientVersion)\n\tif err != nil {\n\t\treturn trace.Wrap(err,\n\t\t\t\"unsupported version format, need semver format: %q, e.g 1.0.0\", minClientVersion)\n\t}\n\n\tif clientSemver.Compare(*minClientSemver) < 0 {\n\t\terrorMessage := fmt.Sprintf(\"minimum client version supported by the server \"+\n\t\t\t\"is %v. Please upgrade the client, downgrade the server, or use the \"+\n\t\t\t\"--skip-version-check flag to by-pass this check.\", minClientVersion)\n\t\treturn trace.BadParameter(errorMessage)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "async def dump_string(writer, val):\n    \"\"\"\n    Binary string dump\n\n    :param writer:\n    :param val:\n    :return:\n    \"\"\"\n    await dump_varint(writer, len(val))\n    await writer.awrite(val)", "label": 1}
{"code": "def insert_field(field)\n      lo, hi = 0, size\n      while lo < hi\n        mid = (lo + hi).div(2)\n        if field < self[mid]\n          hi = mid\n        else\n          lo = mid + 1\n        end\n      end\n\n      insert lo, field\n    end", "label": 4}
{"code": "def token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\n\n    :param remote: The remote application.\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n        identify which token to retrieve. (Default: ``''``)\n    :returns: The token.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)", "label": 1}
{"code": "public int compareTo(WordTag wordTag) {    \r\n    int first = (word != null ? word().compareTo(wordTag.word()) : 0);\r\n    if(first != 0)\r\n      return first;\r\n    else {\r\n      if (tag() == null) {\r\n        if (wordTag.tag() == null)\r\n          return 0;\r\n        else\r\n          return -1;\r\n      }\r\n      return tag().compareTo(wordTag.tag());\r\n    }\r\n  }", "label": 0}
{"code": "public OTMConnection acquireConnection(PBKey pbKey)\r\n    {\r\n        TransactionFactory txFactory = getTransactionFactory();\r\n        return txFactory.acquireConnection(pbKey);\r\n    }", "label": 0}
{"code": "public function parseFractalIncludes(Request $request)\n    {\n        $includes = $request->input($this->includeKey);\n\n        if (! is_array($includes)) {\n            $includes = array_map('trim', array_filter(explode($this->includeSeparator, $includes)));\n        }\n\n        $this->fractal->parseIncludes($includes);\n    }", "label": 2}
{"code": "func (m *Martini) Logger(logger *log.Logger) {\n\tm.logger = logger\n\tm.Map(m.logger)\n}", "label": 5}
{"code": "function validate() {\n  const target = this._obj;\n\n  isValidation(target);\n  this.assert(_.has(target, 'error') && null === target.error,\n      '#{this} should validate but does not because '+getErrorMessages(target),\n      '#{this} should not validate but it does'\n  );\n}", "label": 3}
{"code": "public void loadClassifier(InputStream in, Properties props) throws IOException, ClassCastException,\r\n      ClassNotFoundException {\r\n    loadClassifier(new ObjectInputStream(in), props);\r\n  }", "label": 0}
{"code": "def permission?(action, channel = nil)\n      # If the member is the server owner, it irrevocably has all permissions.\n      return true if owner?\n\n      # First, check whether the user has Manage Roles defined.\n      # (Coincidentally, Manage Permissions is the same permission as Manage Roles, and a\n      # Manage Permissions deny overwrite will override Manage Roles, so we can just check for\n      # Manage Roles once and call it a day.)\n      return true if defined_permission?(:administrator, channel)\n\n      # Otherwise, defer to defined_permission\n      defined_permission?(action, channel)\n    end", "label": 4}
{"code": "def view(self):\n        \"\"\"A list of view specs\"\"\"\n        spec = []\n        for k, v in six.iteritems(self._p4dict):\n            if k.startswith('view'):\n                match = RE_FILESPEC.search(v)\n                if match:\n                    spec.append(FileSpec(v[:match.end() - 1], v[match.end():]))\n\n        return spec", "label": 1}
{"code": "def set_features=(features_json)\n      # return unless features_json.class == Hash\n      features_json.keys.each do |feature_key|\n        # TODO - create feature_key if its missing\n        if features_json[feature_key] == \"true\" || features_json[feature_key] == true\n          features.find_or_create_by( feature_key: feature_key)\n        else\n          features.where( feature_key: feature_key).delete_all\n        end\n      end\n    end", "label": 4}
{"code": "public static vpnglobal_appcontroller_binding[] get(nitro_service service) throws Exception{\n\t\tvpnglobal_appcontroller_binding obj = new vpnglobal_appcontroller_binding();\n\t\tvpnglobal_appcontroller_binding response[] = (vpnglobal_appcontroller_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def append_s(value):\n    \"\"\"\n    Adds the possessive s after a string.\n\n    value = 'Hans' becomes Hans'\n    and value = 'Susi' becomes Susi's\n\n    \"\"\"\n    if value.endswith('s'):\n        return u\"{0}'\".format(value)\n    else:\n        return u\"{0}'s\".format(value)", "label": 1}
{"code": "def factorial(n):\n    \"\"\" Returns the factorial of n.\n    \"\"\"\n    f = 1\n    while (n > 0):\n        f = f * n\n        n = n - 1\n    return f", "label": 1}
{"code": "def recursive_sort(data_structure):\n    \"\"\"Sort a recursive data_structure.\n\n    :param   data_structure: The structure to convert.\n\n    data_structure must be already sortable or you must use freeze() or dump().\n    The function will work with many kinds of input. Dictionaries will be\n    converted to lists of tuples.\n\n    >>> _py2_to_py3(vformat(recursive_sort(dump(\n    ...     [3, 1, {'c' : 'c', 'a' : 'b', 'b' : 'a'}]\n    ... ))))\n    ([\"<class 'dict'>\",\n      (('a',\n        'b'),\n       ('b',\n        'a'),\n       ('c',\n        'c'))],\n     1,\n     3)\n    >>> recursive_sort([3, 1, {'c' : 'c', 'a' : 'b', 'b' : 'a'}])\n    ((('a', 'b'), ('b', 'a'), ('c', 'c')), 1, 3)\n    >>> recursive_sort(_TestClass())\n    (('a', 'huhu'),)\n    \"\"\"\n    # We don't sory primitve types\n    if not isinstance(data_structure, _primitive_types):\n        is_meta = isinstance(data_structure, Meta)\n        was_dict = isinstance(data_structure, WasDict)\n        if not (is_meta or was_dict):\n            was_dict = isinstance(data_structure, dict)\n            if not was_dict:\n                # Dictize if possible (support objects)\n                try:\n                    data_structure = data_structure.__dict__\n                    was_dict = True\n                except:\n                    pass\n            # Itemize if possible\n            try:\n                data_structure = data_structure.items()\n            except:\n                pass\n        tlen = -1\n        # If item has a length we sort it\n        try:\n            tlen = len(data_structure)\n        except:  # pragma: no cover\n            pass\n        if tlen != -1:\n            # Well there are classes out in the wild that answer to len\n            # but have no indexer.\n            try:\n                if was_dict:\n                    return tuple(sorted(\n                        [\n                            (\n                                recursive_sort(x[0]),\n                                recursive_sort(x[1]),\n                            )\n                            for x in data_structure\n                        ],\n                        key=TraversalBasedReprCompare\n                    ))\n                elif is_meta:\n                    return data_structure[0:-1] + [\n                        recursive_sort(\n                            data_structure[-1]\n                        )\n                    ]\n                else:\n                    return tuple(sorted(\n                        [recursive_sort(\n                            x,\n                        ) for x in data_structure],\n                        key=TraversalBasedReprCompare,\n                    ))\n            except:  # pragma: no cover\n                pass\n    return data_structure", "label": 1}
{"code": "public static base_responses update(nitro_service client, autoscaleaction resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tautoscaleaction updateresources[] = new autoscaleaction[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new autoscaleaction();\n\t\t\t\tupdateresources[i].name = resources[i].name;\n\t\t\t\tupdateresources[i].profilename = resources[i].profilename;\n\t\t\t\tupdateresources[i].parameters = resources[i].parameters;\n\t\t\t\tupdateresources[i].vmdestroygraceperiod = resources[i].vmdestroygraceperiod;\n\t\t\t\tupdateresources[i].quiettime = resources[i].quiettime;\n\t\t\t\tupdateresources[i].vserver = resources[i].vserver;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "func (v VirtualMachine) UUID(ctx context.Context) string {\n\tvar o mo.VirtualMachine\n\n\terr := v.Properties(ctx, v.Reference(), []string{\"config.uuid\"}, &o)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\treturn o.Config.Uuid\n}", "label": 5}
{"code": "def unsubscribe(channel, &callback)\n      if callback\n        @channels[channel].callbacks.delete(callback)\n        remove_channel(channel) if @channels[channel].callbacks.empty?\n      else\n        remove_channel(channel)\n      end\n\n      stop if @channels.empty?\n      @status\n    end", "label": 4}
{"code": "def parse_xml_to_obj(self, xml_file, check_version=True, check_root=True,\n                         encoding=None):\n        \"\"\"Creates a STIX binding object from the supplied xml file.\n\n        Args:\n            xml_file: A filename/path or a file-like object representing a STIX\n                instance document\n            check_version: Inspect the version before parsing.\n            check_root: Inspect the root element before parsing.\n            encoding: The character encoding of the input `xml_file`.\n\n        Raises:\n            .UnknownVersionError: If `check_version` is ``True`` and `xml_file`\n                does not contain STIX version information.\n            .UnsupportedVersionError: If `check_version` is ``False`` and\n                `xml_file` contains an unsupported STIX version.\n            .UnsupportedRootElement: If `check_root` is ``True`` and `xml_file`\n                contains an invalid root element.\n\n        \"\"\"\n        root = get_etree_root(xml_file, encoding=encoding)\n\n        if check_root:\n            self._check_root_tag(root)\n\n        if check_version:\n            self._check_version(root)\n\n        entity_class = self.get_entity_class(root.tag)\n        entity_obj = entity_class._binding_class.factory()\n        entity_obj.build(root)\n\n        return entity_obj", "label": 1}
{"code": "private static int med3(int a, int b, int c, IntComparator comp) {\r\n\tint ab = comp.compare(a,b);\r\n\tint ac = comp.compare(a,c);\r\n\tint bc = comp.compare(b,c);\r\n\treturn (ab<0 ?\r\n\t\t(bc<0 ? b : ac<0 ? c : a) :\r\n\t\t(bc>0 ? b : ac>0 ? c : a));\r\n}", "label": 0}
{"code": "def current_command_version\n      output = command('version', [], false)\n      version = output[/\\d+\\.\\d+(\\.\\d+)+/]\n      version.split('.').collect {|i| i.to_i}\n    end", "label": 4}
{"code": "def update_where(self, col, value, where_col_list, where_value_list):\n        \"\"\" \n        updates the array to set cell = value where col_list == val_list\n        \"\"\"\n        if type(col) is str:\n            col_ndx = self.get_col_by_name(col)\n        else:\n            col_ndx = col\n        #print('col_ndx = ', col_ndx    )\n        #print(\"updating \" + col + \" to \" , value, \" where \" , where_col_list , \" = \" , where_value_list)\n        new_arr = self.select_where(where_col_list, where_value_list)\n        #print('new_arr', new_arr)\n        for r in new_arr:\n            self.arr[r[0]][col_ndx] = value", "label": 1}
{"code": "function showLoading() {\n  var popup = getPopup();\n\n  if (!popup) {\n    Swal('');\n  }\n\n  popup = getPopup();\n  var actions = getActions();\n  var confirmButton = getConfirmButton();\n  var cancelButton = getCancelButton();\n  show(actions);\n  show(confirmButton);\n  addClass([popup, actions], swalClasses.loading);\n  confirmButton.disabled = true;\n  cancelButton.disabled = true;\n  popup.setAttribute('data-loading', true);\n  popup.setAttribute('aria-busy', true);\n  popup.focus();\n}", "label": 3}
{"code": "func (l VirtualDeviceList) Connect(device types.BaseVirtualDevice) error {\n\treturn l.connectivity(device, true)\n}", "label": 5}
{"code": "def datastore scope: nil, timeout: nil, client_config: nil\n      Google::Cloud.datastore @project, @keyfile,\n                              scope: scope, timeout: (timeout || @timeout),\n                              client_config: client_config\n    end", "label": 4}
{"code": "def create\n      return render_create_error_missing_email unless resource_params[:email]\n\n      @email = get_case_insensitive_field_from_resource_params(:email)\n      @resource = find_resource(:email, @email)\n\n      if @resource\n        yield @resource if block_given?\n\n        @resource.send_unlock_instructions(\n          email: @email,\n          provider: 'email',\n          client_config: params[:config_name]\n        )\n\n        if @resource.errors.empty?\n          return render_create_success\n        else\n          render_create_error @resource.errors\n        end\n      else\n        render_not_found_error\n      end\n    end", "label": 4}
{"code": "def _collect_parameters(parameter_names, args, kwargs, defaults):\n        \"\"\"Creates a dictionary mapping parameters names to their values in the method call.\n\n        :param parameter_names: The method's parameter names\n        :type parameter_names: list[string]\n        :param args: *args passed into the method\n        :type args: list[object]\n        :param kwargs: **kwargs passed into the method\n        :type kwargs: dict[string, object]\n        :param defaults: The method's default values\n        :type defaults: list[object]\n        :return: Dictionary mapping parameter names to values\n        :rtype: dict[string, object]\n        \"\"\"\n        parameters = {}\n        if defaults is not None:\n            zipped_defaults = zip(reversed(parameter_names), reversed(defaults))\n            for name, default in zipped_defaults:\n                parameters[name] = default\n        for name, value in zip(parameter_names, args):\n            parameters[name] = value\n        for name, value in kwargs.items():\n            parameters[name] = value\n        return parameters", "label": 1}
{"code": "func parseSecureCopy(path string) (string, string, bool, error) {\n\tparts := strings.Fields(path)\n\tif len(parts) == 0 {\n\t\treturn \"\", \"\", false, trace.BadParameter(\"no executable found\")\n\t}\n\n\t// Look for the -t flag, it indicates that an upload occurred. The other\n\t// flags do no matter for now.\n\taction := events.SCPActionDownload\n\tif utils.SliceContainsStr(parts, \"-t\") {\n\t\taction = events.SCPActionUpload\n\t}\n\n\t// Exract the name of the Teleport executable on disk.\n\tteleportPath, err := os.Executable()\n\tif err != nil {\n\t\treturn \"\", \"\", false, trace.Wrap(err)\n\t}\n\t_, teleportBinary := filepath.Split(teleportPath)\n\n\t// Extract the name of the executable that was run. The command was secure\n\t// copy if the executable was \"scp\" or \"teleport\".\n\t_, executable := filepath.Split(parts[0])\n\tswitch executable {\n\tcase teleport.SCP, teleportBinary:\n\t\treturn parts[len(parts)-1], action, true, nil\n\tdefault:\n\t\treturn \"\", \"\", false, nil\n\t}\n}", "label": 5}
{"code": "function getConfig(req, res, next) {\n  var params = {\n    appId: req.params.projectid || req.params.id\n  };\n\n  forms.getAppConfig(req.connectionOptions, params, formsResultHandlers(constants.resultTypes.formProjects, req, next));\n}", "label": 3}
{"code": "def check_instance(function):\n        \"\"\" Wrapper that tests the type of _session.\n\n        Purpose: This decorator function is used by all functions within\n              | the Jaide class that interact with a device to ensure the\n              | proper session type is in use. If it is not, it will\n              | attempt to migrate _session to that type before moving\n              | to the originally requested function.\n              | > **NOTE:** This function is a decorator, and should not be\n              | >  used directly. All other methods in this class that touch\n              | >  the Junos device are wrapped by this function to ensure the\n              | >  proper connection type is used.\n\n        @param function: the function that is being wrapped around\n        @type function: function\n\n        @returns: the originally requested function\n        @rtype: function\n        \"\"\"\n        def wrapper(self, *args, **kwargs):\n            func_trans = {\n                \"commit\": manager.Manager,\n                \"compare_config\": manager.Manager,\n                \"commit_check\": manager.Manager,\n                \"device_info\": manager.Manager,\n                \"diff_config\": manager.Manager,\n                \"health_check\": manager.Manager,\n                \"interface_errors\": manager.Manager,\n                \"op_cmd\": paramiko.client.SSHClient,\n                \"shell_cmd\": paramiko.client.SSHClient,\n                \"scp_pull\": paramiko.client.SSHClient,\n                \"scp_push\": paramiko.client.SSHClient\n            }\n            # when doing an operational command, logging in as root\n            # brings you to shell, so we need to enter the device as a shell\n            # connection, and move to cli to perform the command\n            # this is a one-off because the isinstance() check will be bypassed\n            if self.username == \"root\" and function.__name__ == \"op_cmd\":\n                if not self._session:\n                    self.conn_type = \"paramiko\"\n                    self.connect()\n                if not self._shell:\n                    self.conn_type = \"root\"\n                    self.connect()\n                self.shell_to_cli()  # check if we're in the cli\n            # Have to call shell command separately, since we are using _shell\n            # for comparison, not _session.\n            elif function.__name__ == 'shell_cmd':\n                if not self._shell:\n                    self.conn_type = \"shell\"\n                    self.connect()\n                self.cli_to_shell()  # check if we're in shell.\n            if isinstance(self._session, func_trans[function.__name__]):\n                # If they're doing SCP, we have to check for both _session and\n                # _scp\n                if function.__name__ in ['scp_pull', 'scp_push']:\n                    if not isinstance(self._scp, SCPClient):\n                        self.conn_type = \"scp\"\n                        self.connect()\n            else:\n                self.disconnect()\n                if function.__name__ == \"op_cmd\":\n                    self.conn_type = \"paramiko\"\n                elif function.__name__ in [\"scp_pull\", \"scp_push\"]:\n                    self.conn_type = \"scp\"\n                else:\n                    self.conn_type = \"ncclient\"\n                self.connect()\n            return function(self, *args, **kwargs)\n        return wrapper", "label": 1}
{"code": "public Boolean verifySubscriberRequestedSubscription(SubscriptionRequest sr) throws SubscriptionOriginVerificationException {\n\n        LOG.info(\"(Hub) -> Subscriber, sending notification to verify the origin of the subscription {}.\", sr.getCallback());\n\n        SubscriptionConfirmationRequest sc = new SubscriptionConfirmationRequest(sr.getMode(),\n                sr.getTopic(), \"challenge\", \"0\");\n\n        URI uri;\n        try {\n            uri = new URIBuilder(sr.getCallback()).setParameters(sc.toRequestParameters()).build();\n        } catch (URISyntaxException e) {\n            throw new SubscriptionOriginVerificationException(\"URISyntaxException while sending a confirmation of subscription\", e);\n        }\n\n        HttpGet httpGet = new HttpGet(uri);\n\n        CloseableHttpClient httpclient = HttpClients.createDefault();\n\n        CloseableHttpResponse response;\n        try {\n            response = httpclient.execute(httpGet);\n        } catch (IOException e) {\n            throw new SubscriptionOriginVerificationException(\"IOException while sending a confirmation of subscription\", e);\n        }\n\n        LOG.info(\"Subscriber replied with the http code {}.\", response.getStatusLine().getStatusCode());\n\n        Integer returnedCode = response.getStatusLine().getStatusCode();\n\n        // if code is a success code return true, else false\n        return (199 < returnedCode) && (returnedCode < 300);\n    }", "label": 0}
{"code": "public function where($fieldPath, $operator, $value)\n    {\n        if ($value instanceof FieldValueInterface) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Value cannot be a `%s` value.',\n                FieldValue::class\n            ));\n        }\n\n        if (!($fieldPath instanceof FieldPath)) {\n            $fieldPath = FieldPath::fromString($fieldPath);\n        }\n\n        $escapedPathString = $fieldPath->pathString();\n\n        $operator = array_key_exists($operator, $this->shortOperators)\n            ? $this->shortOperators[$operator]\n            : $operator;\n\n        if (!in_array($operator, $this->allowedOperators)) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Operator %s is not a valid operator',\n                $operator\n            ));\n        }\n\n        if ((is_float($value) && is_nan($value)) || is_null($value)) {\n            if ($operator !== self::OP_EQUAL) {\n                throw new \\InvalidArgumentException('Null and NaN are allowed only with operator EQUALS.');\n            }\n\n            $unaryOperator = is_nan($value)\n                ? self::OP_NAN\n                : self::OP_NULL;\n\n            $filter = [\n                'unaryFilter' => [\n                    'field' => [\n                        'fieldPath' => $escapedPathString\n                    ],\n                    'op' => $unaryOperator\n                ]\n            ];\n        } else {\n            $filter = [\n                'fieldFilter' => [\n                    'field' => [\n                        'fieldPath' => $escapedPathString,\n                    ],\n                    'op' => $operator,\n                    'value' => $this->valueMapper->encodeValue($value)\n                ]\n            ];\n        }\n\n        $query = [\n            'where' => [\n                'compositeFilter' => [\n                    'op' => Operator::PBAND,\n                    'filters' => [\n                        $filter\n                    ]\n                ]\n            ]\n        ];\n\n        return $this->newQuery($query);\n    }", "label": 2}
{"code": "public static void Backward(double[] data) {\n\n        double[] result = new double[data.length];\n        double sum;\n        double scale = Math.sqrt(2.0 / data.length);\n        for (int t = 0; t < data.length; t++) {\n            sum = 0;\n            for (int j = 0; j < data.length; j++) {\n                double cos = Math.cos(((2 * t + 1) * j * Math.PI) / (2 * data.length));\n                sum += alpha(j) * data[j] * cos;\n            }\n            result[t] = scale * sum;\n        }\n        for (int i = 0; i < data.length; i++) {\n            data[i] = result[i];\n        }\n    }", "label": 0}
{"code": "def get(self, str_representation):\n        \"\"\"Retrieves a scale representation from it's string representation\n\n        :param  str_representation: scale string representation to be retrieved\n        :type   str_representation: string\n\n        :raises: ScaleFormatError\n        :returns: scale representation\n        :rtype: ScaleRepresentation\n        \"\"\"\n        for scale in self.SCALES:\n            if str_representation in scale:\n                return scale\n        raise ScaleFormatError(\"Unsupported scale format: {0}\".format(str_representation))", "label": 1}
{"code": "def handle_exception(exception)\n      case exception\n      when HamlLint::Exceptions::ConfigurationError\n        log.error exception.message\n        Sysexits::EX_CONFIG\n      when HamlLint::Exceptions::InvalidCLIOption\n        log.error exception.message\n        log.log \"Run `#{APP_NAME}` --help for usage documentation\"\n        Sysexits::EX_USAGE\n      when HamlLint::Exceptions::InvalidFilePath\n        log.error exception.message\n        Sysexits::EX_NOINPUT\n      when HamlLint::Exceptions::NoLintersError\n        log.error exception.message\n        Sysexits::EX_NOINPUT\n      else\n        print_unexpected_exception(exception)\n        Sysexits::EX_SOFTWARE\n      end\n    end", "label": 4}
{"code": "public function setAliasContext($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\DevTools\\Source\\V1\\AliasContext::class);\n        $this->writeOneof(5, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "func (a *HistoricalApi) freeContainerAggregations(request *restful.Request, response *restful.Response) {\n\tkey := core.HistoricalKey{\n\t\tObjectType:    core.MetricSetTypeSystemContainer,\n\t\tNodeName:      request.PathParameter(\"node-name\"),\n\t\tContainerName: request.PathParameter(\"container-name\"),\n\t}\n\ta.processAggregationRequest(key, request, response)\n}", "label": 5}
{"code": "def install_extensions(extensions, **connection_parameters):\n    \"\"\"Install Postgres extension if available.\n\n    Notes\n    -----\n    - superuser is generally required for installing extensions.\n    - Currently does not support specific schema.\n    \"\"\"\n\n    from postpy.connections import connect\n\n    conn = connect(**connection_parameters)\n    conn.autocommit = True\n\n    for extension in extensions:\n        install_extension(conn, extension)", "label": 1}
{"code": "def _getproject(self, config, section, **kwargs):\n        \"\"\"\n        Creates a VSG project from a configparser instance.\n\n        :param object config: The instance of the configparser class\n        :param str section: The section name to read.\n        :param kwargs:  List of additional keyworded arguments to be passed into the VSGProject.\n        :return: A valid VSGProject instance if succesful; None otherwise.\n        \"\"\"\n        if section not in config:\n            raise ValueError('Section [{}] not found in [{}]'.format(section, ', '.join(config.sections())))\n\n        type = config.get(section, 'type', fallback=None)\n        if not type:\n            raise ValueError('Section [{}] mandatory option \"{}\" not found'.format(section, \"type\"))\n\n        project_class = entrypoint('vsgen.projects', type)\n        return project_class.from_section(config, section, **kwargs)", "label": 1}
{"code": "function (member, memberValue, visibility) {\n        if (undefined === visibility) {\n            visibility = _GPF_VISIBILITY_PUBLIC;\n        } else {\n            visibility = _gpfVisibilityKeywords.indexOf(visibility);\n            if (-1 === visibility) {\n                gpf.Error.classInvalidVisibility();\n            }\n        }\n        this._addMember(member, memberValue, visibility);\n    }", "label": 3}
{"code": "public function getValidator()\n    {\n        $validatorGenerator = new ValidatorGenerator([\n            'name' => $this->name,\n        ]);\n\n        $validator = $validatorGenerator->getRootNamespace() . '\\\\' . $validatorGenerator->getName();\n\n        return 'use ' . str_replace([\n            \"\\\\\",\n            '/'\n        ], '\\\\', $validator) . 'Validator;';\n    }", "label": 2}
{"code": "def get_default(self, create=True):\n        \"\"\"\n        Get the default bridge network that containers are connected to if no\n        other network options are specified.\n\n        :param create:\n            Whether or not to create the network if it doesn't already exist.\n        \"\"\"\n        if self._default_network is None and create:\n            log.debug(\"Creating default network...\")\n            self._default_network = self.create('default', driver='bridge')\n\n        return self._default_network", "label": 1}
{"code": "func (t *TestTLSServer) CloneClient(clt *Client) *Client {\n\taddr := []utils.NetAddr{{Addr: t.Addr().String(), AddrNetwork: t.Addr().Network()}}\n\tnewClient, err := NewTLSClient(ClientConfig{Addrs: addr, TLS: clt.TLSConfig()})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn newClient\n}", "label": 5}
{"code": "def with_index(new_index) # :yields: new_index\n      old_index = @index\n      set_index(new_index, false)\n      return_value = yield @index\n      set_index(old_index)\n      return_value\n    end", "label": 4}
{"code": "func (f *Fpdf) outf(fmtStr string, args ...interface{}) {\n\tf.out(sprintf(fmtStr, args...))\n}", "label": 5}
{"code": "public static base_response rename(nitro_service client, cmppolicylabel resource, String new_labelname) throws Exception {\n\t\tcmppolicylabel renameresource = new cmppolicylabel();\n\t\trenameresource.labelname = resource.labelname;\n\t\treturn renameresource.rename_resource(client,new_labelname);\n\t}", "label": 0}
{"code": "public static function compileContent($content, array $data, $param)\n    {\n        if (is_string($content)) {\n            return static::compileBlade($content, static::getMixedValue($data, $param));\n        } elseif (is_callable($content)) {\n            return $content($param);\n        }\n\n        return $content;\n    }", "label": 2}
{"code": "public void setOjbQuery(org.apache.ojb.broker.query.Query ojbQuery)\r\n    {\r\n        this.ojbQuery = ojbQuery;\r\n    }", "label": 0}
{"code": "func (args Arguments) Int(index int) int {\n\tvar s int\n\tvar ok bool\n\tif s, ok = args.Get(index).(int); !ok {\n\t\tpanic(fmt.Sprintf(\"assert: arguments: Int(%d) failed because object wasn't correct type: %v\", index, args.Get(index)))\n\t}\n\treturn s\n}", "label": 5}
{"code": "public function setMutations($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Spanner\\V1\\Mutation::class);\n        $this->mutations = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "private GeometryCoordinateSequenceTransformer getTransformer() {\n\t\tif (unitToPixel == null) {\n\t\t\tunitToPixel = new GeometryCoordinateSequenceTransformer();\n\t\t\tunitToPixel.setMathTransform(ProjectiveTransform.create(new AffineTransform(scale, 0, 0, -scale, -scale\n\t\t\t\t\t* panOrigin.x, scale * panOrigin.y)));\n\t\t}\n\t\treturn unitToPixel;\n\t}", "label": 0}
{"code": "func (s *gRPCBrokerClientImpl) Send(i *plugin.ConnInfo) error {\n\tch := make(chan error)\n\tdefer close(ch)\n\n\tselect {\n\tcase <-s.quit:\n\t\treturn errors.New(\"broker closed\")\n\tcase s.send <- &sendErr{\n\t\ti:  i,\n\t\tch: ch,\n\t}:\n\t}\n\n\treturn <-ch\n}", "label": 5}
{"code": "def generate(options, command: nil)\n      # First, enable `always_trace`, to show the stack trace\n      always_trace!\n\n      used_switches = []\n      options.each do |option|\n        next if option.description.to_s.empty? # \"private\" options\n        next unless option.display_in_shell\n\n        short_switch = option.short_option\n        key = option.key\n        validate_short_switch(used_switches, short_switch, key)\n\n        type = option.data_type\n\n        # We added type: Hash to code generation, but Ruby's OptionParser doesn't like that\n        # so we need to switch that to something that is supported, luckily, we have an `is_string`\n        # property and if that is false, we'll default to nil\n        if type == Hash\n          type = option.is_string ? String : nil\n        end\n\n        # Boolean is a fastlane thing, it's either TrueClass, or FalseClass, but we won't know\n        # that until runtime, so nil is the best we get\n        if type == Fastlane::Boolean\n          type = nil\n        end\n\n        # This is an important bit of trickery to solve the boolean option situation.\n        #\n        # Typically, boolean command line flags do not accept trailing values. If the flag\n        # is present, the value is true, if it is missing, the value is false. fastlane\n        # supports this style of flag. For example, you can specify a flag like `--clean`,\n        # and the :clean option will be true.\n        #\n        # However, fastlane also supports another boolean flag style that accepts trailing\n        # values much like options for Strings and other value types. That looks like\n        # `--include_bitcode false` The problem is that this does not work out of the box\n        # for Commander and OptionsParser. So, we need to get tricky.\n        #\n        # The value_appendix below acts as a placeholder in the switch definition that\n        # states that we expect to have a trailing value for our options. When an option\n        # declares a data type, we use the name of that data type in all caps like:\n        # \"--devices ARRAY\". When the data type is nil, this implies that we're going\n        # to be doing some special handling on that value. One special thing we do\n        # automatically in Configuration is to coerce special Strings into boolean values.\n        #\n        # If the data type is nil, the trick we do is to specify a value placeholder, but\n        # we wrap it in [] brackets to mark it as optional. That means that the trailing\n        # value may or may not be present for this flag. If the flag is present, but the\n        # value is not, we get a value of `true`. Perfect for the boolean flag base-case!\n        # If the value is there, we'll actually get it back as a String, which we can\n        # later coerce into a boolean.\n        #\n        # In this way we support handling boolean flags with or without trailing values.\n        value_appendix = (type || '[VALUE]').to_s.upcase\n        long_switch = \"--#{option.key} #{value_appendix}\"\n\n        description = option.description\n        description += \" (#{option.env_name})\" unless option.env_name.to_s.empty?\n\n        # We compact this array here to remove the short_switch variable if it is nil.\n        # Passing a nil value to global_option has been shown to create problems with\n        # option parsing!\n        #\n        # See: https://github.com/fastlane/fastlane_core/pull/89\n        #\n        # If we don't have a data type for this option, we tell it to act like a String.\n        # This allows us to get a reasonable value for boolean options that can be\n        # automatically coerced or otherwise handled by the ConfigItem for others.\n        args = [short_switch, long_switch, (type || String), description].compact\n\n        if command\n          command.option(*args)\n        else\n          # This is the call to Commander to set up the option we've been building.\n          global_option(*args)\n        end\n      end\n    end", "label": 4}
{"code": "public void setPixelPerUnit(double pixelPerUnit) {\n\t\tif (pixelPerUnit < MINIMUM_PIXEL_PER_UNIT) {\n\t\t\tpixelPerUnit = MINIMUM_PIXEL_PER_UNIT;\n\t\t}\n\t\tif (pixelPerUnit > MAXIMUM_PIXEL_PER_UNIT) {\n\t\t\tpixelPerUnit = MAXIMUM_PIXEL_PER_UNIT;\n\t\t}\n\t\tthis.pixelPerUnit = pixelPerUnit;\n\t\tsetPixelPerUnitBased(true);\n\t\tpostConstruct();\n\t}", "label": 0}
{"code": "def attribute_missing(match, *args, &block)\n      __send__(match.target, match.attr_name, *args, &block)\n    end", "label": 4}
{"code": "def exec_rabbitmqctl_list(self, resources, args=[],\n                              rabbitmq_opts=['-q', '--no-table-headers']):\n        \"\"\"\n        Execute a ``rabbitmqctl`` command to list the given resources.\n\n        :param resources: the resources to list, e.g. ``'vhosts'``\n        :param args: a list of args for the command\n        :param rabbitmqctl_opts:\n            a list of extra options to pass to ``rabbitmqctl``\n        :returns: a tuple of the command exit code and output\n        \"\"\"\n        command = 'list_{}'.format(resources)\n        return self.exec_rabbitmqctl(command, args, rabbitmq_opts)", "label": 1}
{"code": "function default_value() {\n  start_pos = input.pointer();\n  value = parse_balanced(/\\[/, /\\]/, /[^\\[\\]]*/);\n  if (look(/\\]/)) {\n    return value;\n  }\n  else {\n    input.setPointer(start_pos);\n    return match(/[^\\]]*/);\n  }\n}", "label": 3}
{"code": "def save(_options = {})\n      self.class.create_table\n\n      if new_record?\n        conditions = { unless_exists: [self.class.hash_key] }\n        conditions[:unless_exists] << range_key if range_key\n\n        run_callbacks(:create) { persist(conditions) }\n      else\n        persist\n      end\n    end", "label": 4}
{"code": "function init() {\n\t\t// Make sure all connectors have data set\n\t\t$(svgcontent).find('*').each(function() { \n\t\t\tvar conn = this.getAttributeNS(se_ns, \"connector\");\n\t\t\tif(conn) {\n\t\t\t\tthis.setAttribute('class', conn_sel.substr(1));\n\t\t\t\tvar conn_data = conn.split(' ');\n\t\t\t\tvar sbb = svgCanvas.getStrokedBBox([getElem(conn_data[0])]);\n\t\t\t\tvar ebb = svgCanvas.getStrokedBBox([getElem(conn_data[1])]);\n\t\t\t\t$(this).data('c_start',conn_data[0])\n\t\t\t\t\t.data('c_end',conn_data[1])\n\t\t\t\t\t.data('start_bb', sbb)\n\t\t\t\t\t.data('end_bb', ebb);\n\t\t\t\tsvgCanvas.getEditorNS(true);\n\t\t\t}\n\t\t});\n//\t\tupdateConnectors();\n\t}", "label": 3}
{"code": "protected function escapeRow(array $row)\n    {\n        $arrayDot = array_filter(array_dot($row));\n        foreach ($arrayDot as $key => $value) {\n            if (! in_array($key, $this->rawColumns)) {\n                $arrayDot[$key] = e($value);\n            }\n        }\n\n        foreach ($arrayDot as $key => $value) {\n            array_set($row, $key, $value);\n        }\n\n        return $row;\n    }", "label": 2}
{"code": "func (tc *TeleportClient) AddTrustedCA(ca services.CertAuthority) error {\n\terr := tc.LocalAgent().AddHostSignersToCache(auth.AuthoritiesToTrustedCerts([]services.CertAuthority{ca}))\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\t// only host CA has TLS certificates, user CA will overwrite trusted certs\n\t// to empty file if called\n\tif ca.GetType() == services.HostCA {\n\t\terr = tc.LocalAgent().SaveCerts(auth.AuthoritiesToTrustedCerts([]services.CertAuthority{ca}))\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "function StatelessListener(ptcl, readableFactory, opts) {\n  MessageListener.call(this, ptcl, opts);\n  var self = this;\n  var readable;\n\n  process.nextTick(function () {\n    // Delay listening to allow handlers to be attached even if the factory is\n    // purely synchronous.\n    readable = readableFactory.call(this, function (err, writable) {\n      if (err) {\n        self.emit('error', err);\n        // Since stateless listeners are only used once, it is safe to destroy.\n        onFinish();\n        return;\n      }\n      self._writable = writable.on('finish', onFinish);\n      self.emit('_writable');\n    }).on('data', onRequest)\n      .on('end', onEnd);\n  });\n\n  function onRequest(obj) {\n    var id = obj.id;\n    var buf = Buffer.concat(obj.payload);\n    var err = null;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      var adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = wrapError('invalid handshake request', cause);\n    }\n\n    if (err) {\n      done(encodeError(err));\n    } else {\n      self._receive(parts.tail, adapter, done);\n    }\n\n    function done(resBuf) {\n      if (!self._writable) {\n        self.once('_writable', function () { done(resBuf); });\n        return;\n      }\n      var hres = self._createHandshakeResponse(err, hreq);\n      self.emit('handshake', hreq, hres);\n      var payload = [\n        HANDSHAKE_RESPONSE_TYPE.toBuffer(hres),\n        resBuf\n      ];\n      self._writable.write({id: id, payload: payload});\n      if (self._endWritable) {\n        self._writable.end();\n      }\n    }\n  }\n\n  function onEnd() { self.destroy(); }\n\n  function onFinish() {\n    if (readable) {\n      readable\n        .removeListener('data', onRequest)\n        .removeListener('end', onEnd);\n    }\n    self.destroy(true);\n  }\n}", "label": 3}
{"code": "public static nssimpleacl[] get(nitro_service service) throws Exception{\n\t\tnssimpleacl obj = new nssimpleacl();\n\t\tnssimpleacl[] response = (nssimpleacl[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function setMatchingType($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Dlp\\V2\\MatchingType::class);\n        $this->matching_type = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public function find_command_to_run( $args ) {\n\t\t$command = \\WP_CLI::get_root_command();\n\n\t\tWP_CLI::do_hook( 'find_command_to_run_pre' );\n\n\t\t$cmd_path = array();\n\n\t\twhile ( ! empty( $args ) && $command->can_have_subcommands() ) {\n\t\t\t$cmd_path[] = $args[0];\n\t\t\t$full_name  = implode( ' ', $cmd_path );\n\n\t\t\t$subcommand = $command->find_subcommand( $args );\n\n\t\t\tif ( ! $subcommand ) {\n\t\t\t\tif ( count( $cmd_path ) > 1 ) {\n\t\t\t\t\t$child       = array_pop( $cmd_path );\n\t\t\t\t\t$parent_name = implode( ' ', $cmd_path );\n\t\t\t\t\t$suggestion  = $this->get_subcommand_suggestion( $child, $command );\n\t\t\t\t\treturn sprintf(\n\t\t\t\t\t\t\"'%s' is not a registered subcommand of '%s'. See 'wp help %s' for available subcommands.%s\",\n\t\t\t\t\t\t$child,\n\t\t\t\t\t\t$parent_name,\n\t\t\t\t\t\t$parent_name,\n\t\t\t\t\t\t! empty( $suggestion ) ? PHP_EOL . \"Did you mean '{$suggestion}'?\" : ''\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t$suggestion = $this->get_subcommand_suggestion( $full_name, $command );\n\n\t\t\t\treturn sprintf(\n\t\t\t\t\t\"'%s' is not a registered wp command. See 'wp help' for available commands.%s\",\n\t\t\t\t\t$full_name,\n\t\t\t\t\t! empty( $suggestion ) ? PHP_EOL . \"Did you mean '{$suggestion}'?\" : ''\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( $this->is_command_disabled( $subcommand ) ) {\n\t\t\t\treturn sprintf(\n\t\t\t\t\t\"The '%s' command has been disabled from the config file.\",\n\t\t\t\t\t$full_name\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$command = $subcommand;\n\t\t}\n\n\t\treturn array( $command, $args, $cmd_path );\n\t}", "label": 2}
{"code": "public function setField($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\FieldId::class);\n        $this->field = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def bigquery scope: nil, retries: nil, timeout: nil\n      Google::Cloud.bigquery @project, @keyfile, scope:   scope,\n                                                 retries: (retries || @retries),\n                                                 timeout: (timeout || @timeout)\n    end", "label": 4}
{"code": "def biomaRtTOkegg(df):\n    \"\"\"\n    Transforms a pandas dataframe with the columns 'ensembl_gene_id','kegg_enzyme'\n    to dataframe ready for use in ...\n\n    :param df: a pandas dataframe with the following columns: 'ensembl_gene_id','kegg_enzyme'\n\n    :returns: a pandas dataframe with the following columns: 'ensembl_gene_id','kegg_enzyme'\n    \"\"\"\n    df=df.dropna()\n    ECcols=df.columns.tolist()\n    df.reset_index(inplace=True,drop=True)\n    # field = ECsb[['kegg_enzyme']]\n    field = pd.DataFrame(df['kegg_enzyme'].str.split('+',1).tolist())[1]\n    field = pd.DataFrame(field)\n    df=pd.concat([df[['ensembl_gene_id']],field],axis=1)\n    df.columns=ECcols\n    df.drop_duplicates(inplace=True)\n    df.reset_index(inplace=True,drop=True)\n    plus=df['kegg_enzyme'].tolist()\n    plus=[ s for s in plus if \"+\" in s ]\n    noPlus=df[~df['kegg_enzyme'].isin(plus)]\n    plus=df[df['kegg_enzyme'].isin(plus)]\n    noPlus.reset_index(inplace=True, drop=True)\n    plus.reset_index(inplace=True, drop=True)\n    for p in range(0,len(plus)):\n        enz=plus.ix[p]['kegg_enzyme']\n        enz=enz.split(\"+\")\n        enz=pd.DataFrame(enz)\n        enz.colums=['kegg_enzyme']\n        enz['ensembl_gene_id']=plus.ix[p]['kegg_enzyme']\n        noPlus=pd.concat([noPlus,enz])\n    noPlus=noPlus.drop_duplicates()\n    noPlus=noPlus[['ensembl_gene_id','kegg_enzyme']]\n    noPlus['fake']='ec:'\n    noPlus['kegg_enzyme']=noPlus['fake']+noPlus['kegg_enzyme']\n    noPlus=noPlus[['ensembl_gene_id','kegg_enzyme']]\n\n    return noPlus", "label": 1}
{"code": "def update_callback\n      @update_proc.call\n\n      # Accept and eval commands if in console mode\n      if @console\n        if STDIN.ready?\n          cmd = STDIN.gets\n          begin\n            res = eval(cmd, TOPLEVEL_BINDING)\n            STDOUT.puts \"=> #{res.inspect}\"\n            STDOUT.flush\n          rescue SyntaxError => se\n            STDOUT.puts se\n            STDOUT.flush\n          rescue Exception => e\n            STDOUT.puts e\n            STDOUT.flush\n          end\n        end\n      end\n\n    end", "label": 4}
{"code": "func (s *remoteSite) Close() error {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\ts.cancel()\n\tfor i := range s.connections {\n\t\ts.connections[i].Close()\n\t}\n\ts.connections = []*remoteConn{}\n\treturn nil\n}", "label": 5}
{"code": "def extract_key_value(line)\n      match = line.match(KEY_VALUE_PATTERN)\n      if match\n        key = match[1]\n        value = match[2]\n        [key.strip, value.strip]\n      else\n        []\n      end\n    end", "label": 4}
{"code": "public void setAttributes(Object feature, Map<String, Attribute> attributes) throws LayerException {\n\t\tfor (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tif (!name.equals(getGeometryAttributeName())) {\n\t\t\t\tasFeature(feature).setAttribute(name, entry.getValue());\n\t\t\t}\n\t\t}\n\t}", "label": 0}
{"code": "func RangeEnd(key []byte) []byte {\n\tend := make([]byte, len(key))\n\tcopy(end, key)\n\tfor i := len(end) - 1; i >= 0; i-- {\n\t\tif end[i] < 0xff {\n\t\t\tend[i] = end[i] + 1\n\t\t\tend = end[:i+1]\n\t\t\treturn end\n\t\t}\n\t}\n\t// next key does not exist (e.g., 0xffff);\n\treturn noEnd\n}", "label": 5}
{"code": "func satisfiesAnyImageFilters(image *v1alpha.Image, filters []*v1alpha.ImageFilter) bool {\n\t// No filters, return true directly.\n\tif len(filters) == 0 {\n\t\treturn true\n\t}\n\tfor _, filter := range filters {\n\t\tif satisfiesImageFilter(*image, *filter) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "label": 5}
{"code": "def print_MannWhitneyU(div_calc):\n    \"\"\"\n    Compute the Mann-Whitney U test for unequal group sample sizes.\n    \"\"\"\n    try:\n        x = div_calc.values()[0].values()\n        y = div_calc.values()[1].values()\n    except:\n        return \"Error setting up input arrays for Mann-Whitney U Test. Skipping \"\\\n               \"significance testing.\"\n    T, p = stats.mannwhitneyu(x, y)\n    print \"\\nMann-Whitney U test statistic:\", T\n    print \"Two-tailed p-value: {}\".format(2 * p)", "label": 1}
{"code": "def render_template(view, template, layout_name, locals)\n        render_with_layout(view, template, layout_name, locals) do |layout|\n          instrument(:template, identifier: template.identifier, layout: layout.try(:virtual_path)) do\n            template.render(view, locals) { |*name| view._layout_for(*name) }\n          end\n        end\n      end", "label": 4}
{"code": "private function getComponentComposer($libraryRootPath, $componentId, $defaultComposerPath = null)\n    {\n        if (!$defaultComposerPath) {\n            $defaultComposerPath = isset($this->defaultComponentComposer)\n                ? $this->defaultComponentComposer\n                : null;\n        }\n\n        $componentsDir = isset($this->components)\n            ? $this->components\n            : $libraryRootPath;\n\n        $components = $this->getComponents($libraryRootPath, $componentsDir, $defaultComposerPath);\n\n        $components = array_values(array_filter($components, function ($component) use ($componentId) {\n            return ($component['id'] === $componentId);\n        }));\n\n        if (count($components) === 0) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Given component id %s is not a valid component.',\n                $componentId\n            ));\n        }\n\n        return $components[0];\n    }", "label": 2}
{"code": "def style=(style)\n      each_with_index do | cell, index |\n        cell.style = style.is_a?(Array) ? style[index] : style\n      end\n    end", "label": 4}
{"code": "def format number, options = {}\n      country, _, national_number = partial_split number\n      country.format national_number, options\n    end", "label": 4}
{"code": "def select_list(name, identifier={:index => 0}, &block)\n      standard_methods(name, identifier, 'select_list_for', &block)\n      define_method(name) do\n        return platform.select_list_value_for identifier.clone unless block_given?\n        self.send(\"#{name}_element\").value\n      end\n      define_method(\"#{name}=\") do |value|\n        return platform.select_list_value_set(identifier.clone, value) unless block_given?\n        self.send(\"#{name}_element\").select(value)\n      end\n      define_method(\"#{name}_options\") do\n        element = self.send(\"#{name}_element\")\n        (element && element.options) ? element.options.collect(&:text) : []\n      end\n    end", "label": 4}
{"code": "func Exists(path string) (bool, error) {\n\tpath, err := filepath.Abs(filepath.Join(path, keysBoltFile))\n\tif err != nil {\n\t\treturn false, trace.Wrap(err)\n\t}\n\tf, err := os.Open(path)\n\terr = trace.ConvertSystemError(err)\n\tif err != nil {\n\t\tif trace.IsNotFound(err) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, trace.Wrap(err)\n\t}\n\tdefer f.Close()\n\treturn true, nil\n}", "label": 5}
{"code": "def mark(*args)\n      arguments(args)\n      params = arguments.params\n\n      if ( (user_name = params.delete('user')) &&\n           (repo_name = params.delete('repo')) )\n\n        put_request(\"/repos/#{user_name}/#{repo_name}/notifications\", params)\n      elsif (thread_id = params.delete(\"id\"))\n        patch_request(\"/notifications/threads/#{thread_id}\", params)\n      else\n        put_request('/notifications', params)\n      end\n    end", "label": 4}
{"code": "def list_items(location_id, opts = {})\n      data, _status_code, _headers = list_items_with_http_info(location_id, opts)\n      return data\n    end", "label": 4}
{"code": "function size(file) {\n  if (!exists(file) || !isFile(file)) {\n    return -1;\n  } else {\n    try {\n      return _fileStats(file).size;\n    } catch (e) {\n      return -1;\n    }\n  }\n}", "label": 3}
{"code": "def check_valid_ad_range(date):\n    \"\"\"\n    Checks if the english date is in valid range for conversion\n    \"\"\"\n    if date < values.START_EN_DATE or date > values.END_EN_DATE:\n        raise ValueError(\"Date out of range\")\n    return True", "label": 1}
{"code": "function() {\n      var modelConfigs = [];\n      _.each(this.getMappings(), function(config, alias) {\n        if (config.computed) {\n          var computedModelConfigs = this.__getComputedModelConfigs(alias);\n          if (computedModelConfigs) {\n            modelConfigs = modelConfigs.concat(computedModelConfigs);\n          }\n        } else {\n          var modelConfig = this.__createModelConfig(alias, config.mapping);\n          if (modelConfig) {\n            modelConfigs.push(modelConfig);\n          }\n        }\n      }, this);\n      return modelConfigs;\n    }", "label": 3}
{"code": "public function isDayOfWeek($dayOfWeek)\n    {\n        if (is_string($dayOfWeek) && defined($constant = static::class.'::'.strtoupper($dayOfWeek))) {\n            $dayOfWeek = constant($constant);\n        }\n\n        return $this->dayOfWeek === $dayOfWeek;\n    }", "label": 2}
{"code": "protected function isNotEagerLoaded($relation)\n    {\n        return ! $relation\n            || ! array_key_exists($relation, $this->query->getEagerLoads())\n            || $relation === $this->query->getModel()->getTable();\n    }", "label": 2}
{"code": "public static <T extends Number> int[] asArray(final T... array) {\n        int[] b = new int[array.length];\n        for (int i = 0; i < b.length; i++) {\n            b[i] = array[i].intValue();\n        }\n        return b;\n    }", "label": 0}
{"code": "def identify_manifests(file_list)\n      ignored_dirs_with_slash = ignored_dirs.map { |d| if d.end_with?(\"/\") then d else d + \"/\" end }\n      allowed_file_list = file_list.reject do |f|\n        ignored_dirs.include?(f) || f.start_with?(*ignored_dirs_with_slash)\n      end\n      allowed_file_list = allowed_file_list.reject{|f| ignored_files.include?(f)}\n      package_managers.map do |pm|\n        allowed_file_list.select do |file_path|\n          # this is a call to match? without file contents, which will skip\n          # ambiguous filenames that are only possibly a manifest\n          pm.match?(file_path)\n        end\n      end.flatten.uniq.compact\n    end", "label": 4}
{"code": "function(opts) {\n        opts = opts || {};\n\n        if (this.expectedRequests.length === 0) {\n            // calling flushAllExpected when there are no expectations is a\n            // silly thing to do, and probably means that your test isn't\n            // doing what you think it is doing (or it is racy). Hence we\n            // reject this, rather than resolving immediately.\n            return Promise.reject(new Error(\n                `flushAllExpected called with an empty expectation list`,\n            ));\n        }\n\n        const waitTime = opts.timeout === undefined ? 1000 : opts.timeout;\n        const endTime = waitTime + Date.now();\n        let flushed = 0;\n\n        const iterate = () => {\n            const timeRemaining = endTime - Date.now();\n            if (timeRemaining <= 0) {\n                throw new Error(\n                    `Timed out after flushing ${flushed} requests; `+\n                    `${this.expectedRequests.length} remaining`,\n                );\n            }\n\n            return this.flush(\n                undefined, undefined, timeRemaining,\n            ).then((f) => {\n                flushed += f;\n\n                if (this.expectedRequests.length === 0) {\n                    // we're done\n                    return null;\n                }\n\n                return iterate();\n            });\n        };\n\n        const prom = new Promise((resolve, reject) => {\n            iterate().then(() => {\n                resolve(flushed);\n            }, (e) => {\n                reject(e);\n            });\n        });\n        this._flushPromises.push(prom);\n        return prom;\n    }", "label": 3}
{"code": "function makePool(options, database) {\n    return Pool({\n        name: options.name + ':' + database,\n\n        create: function(callback) {\n\n            var callbackCalled = false;\n\n            var client = redis.createClient(options.port, options.host, {\n                no_ready_check: options.noReadyCheck\n            });\n\n            client.on('error', function (err) {\n                log(options, {db: database, action: 'error', err: err.message});\n                if (!callbackCalled) {\n                    callbackCalled = true;\n                    callback(err, client);\n                }\n                client.end(FLUSH_CONNECTION);\n            });\n\n            client.on('ready', function () {\n                client.select(database, function(err/*, res*/) {\n                    if (!callbackCalled) {\n                        callbackCalled = true;\n                        callback(err, client);\n                    }\n                });\n            });\n        },\n\n        destroy: function(client) {\n            client.quit();\n            client.end(FLUSH_CONNECTION);\n        },\n\n        validate: function(client) {\n            return client && client.connected;\n        },\n\n        max: options.max,\n        idleTimeoutMillis: options.idleTimeoutMillis,\n        reapIntervalMillis: options.reapIntervalMillis,\n        returnToHead: options.returnToHead,\n        log: options.log\n    });\n}", "label": 3}
{"code": "def stop(self, activity, action):\n        '''\n        Mark a task as completed\n\n        :param activity: The virtualenv activity name\n        :type  activity: ``str``\n\n        :param action: The virtualenv action\n        :type  action: :class:`tox.session.Action`\n        '''\n        try:\n            self._remove_running_action(activity, action)\n        except ValueError:\n            retox_log.debug(\"Could not find action %s in env %s\" % (activity, self.name))\n        self._mark_action_completed(activity, action)\n        self.refresh()", "label": 1}
{"code": "public static vpnglobal_authenticationcertpolicy_binding[] get(nitro_service service) throws Exception{\n\t\tvpnglobal_authenticationcertpolicy_binding obj = new vpnglobal_authenticationcertpolicy_binding();\n\t\tvpnglobal_authenticationcertpolicy_binding response[] = (vpnglobal_authenticationcertpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private double CosineInterpolate(double x1, double x2, double a) {\n        double f = (1 - Math.cos(a * Math.PI)) * 0.5;\n\n        return x1 * (1 - f) + x2 * f;\n    }", "label": 0}
{"code": "function(opts) {\n  this.load_balancer = opts.load_balancer;\n  this.task_manager  = opts.task_manager;\n  this.file_manager  = opts.file_manager;\n  this.net_manager   = opts.net_manager;\n  this.port          = opts.port || 10000;\n  this.tls           = opts.tls;\n}", "label": 3}
{"code": "public function setJobLevel($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Talent\\V4beta1\\JobLevel::class);\n        $this->job_level = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public synchronized boolean hasNext()\r\n    {\r\n        try\r\n        {\r\n            if (!isHasCalledCheck())\r\n            {\r\n                setHasCalledCheck(true);\r\n                setHasNext(getRsAndStmt().m_rs.next());\r\n                if (!getHasNext())\r\n                {\r\n                    autoReleaseDbResources();\r\n                }\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            setHasNext(false);\r\n            autoReleaseDbResources();\r\n            if(ex instanceof ResourceClosedException)\r\n            {\r\n                throw (ResourceClosedException)ex;\r\n            }\r\n            if(ex instanceof SQLException)\r\n            {\r\n                throw new PersistenceBrokerSQLException(\"Calling ResultSet.next() failed\", (SQLException) ex);\r\n            }\r\n            else\r\n            {\r\n               throw new PersistenceBrokerException(\"Can't get next row from ResultSet\", ex);\r\n            }\r\n        }\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"hasNext() -> \" + getHasNext());\r\n\r\n        return getHasNext();\r\n    }", "label": 0}
{"code": "public static cacheglobal_cachepolicy_binding[] get(nitro_service service) throws Exception{\n\t\tcacheglobal_cachepolicy_binding obj = new cacheglobal_cachepolicy_binding();\n\t\tcacheglobal_cachepolicy_binding response[] = (cacheglobal_cachepolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public void setPropertyDestinationType(Class<?> clazz, String propertyName,\r\n\t\t\tTypeReference<?> destinationType) {\r\n\t\tpropertiesDestinationTypes.put(new ClassProperty(clazz, propertyName), destinationType);\r\n\t}", "label": 0}
{"code": "def fix_bam_header(job, bamfile, sample_type, univ_options):\n    \"\"\"\n    This module modified the header in BAMFILE\n\n    ARGUMENTS\n    1. bamfile: <JSid for a bam file>\n    2. sample_type: string of 'tumor_dna' or 'normal_dna'\n    3. univ_options: Dict of universal arguments used by almost all tools\n         univ_options\n                +- 'dockerhub': <dockerhub to use>\n    RETURN VALUES\n    1. output_files: REFER output_files in run_bwa()\n    \"\"\"\n    job.fileStore.logToMaster('Running reheader on %s:%s' % (univ_options['patient'], sample_type))\n    work_dir = job.fileStore.getLocalTempDir()\n    input_files = {\n        'aligned.bam': bamfile}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=True)\n    parameters = ['view',\n                  '-H',\n                  input_files['aligned.bam']]\n    with open('/'.join([work_dir, 'aligned_bam.header']), 'w') as headerfile:\n        docker_call(tool='samtools', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'], outfile=headerfile)\n    with open(headerfile.name, 'r') as headerfile, \\\n            open('/'.join([work_dir, 'output_bam.header']), 'w') as outheaderfile:\n        for line in headerfile:\n            if line.startswith('@PG'):\n                line = '\\t'.join([x for x in line.strip().split('\\t') if not x.startswith('CL')])\n            print(line.strip(), file=outheaderfile)\n    parameters = ['reheader',\n                  docker_path(outheaderfile.name),\n                  input_files['aligned.bam']]\n    with open('/'.join([work_dir, 'aligned_fixPG.bam']), 'w') as fixpg_bamfile:\n        docker_call(tool='samtools', tool_parameters=parameters, work_dir=work_dir,\n                    dockerhub=univ_options['dockerhub'], outfile=fixpg_bamfile)\n    output_file = job.fileStore.writeGlobalFile(fixpg_bamfile.name)\n    job.fileStore.deleteGlobalFile(bamfile)\n    add_rg = job.wrapJobFn(add_readgroups, output_file, sample_type, univ_options, disk='60G')\n    job.addChild(add_rg)\n    return add_rg.rv()", "label": 1}
{"code": "public static function stalenessOf(WebDriverElement $element)\n    {\n        return new static(\n            function () use ($element) {\n                try {\n                    $element->isEnabled();\n\n                    return false;\n                } catch (StaleElementReferenceException $e) {\n                    return true;\n                }\n            }\n        );\n    }", "label": 2}
{"code": "function readDirAbs(dir, cb) {\n  fs.readdir(dir, function(err, entries) {\n    if (err || !entries) {\n      return cb(err, null);\n    }\n    var items = [];\n    entries.forEach(function(entry) {\n      items.push(path.join(dir, entry));\n    });\n    return cb(null, items);\n  });\n}", "label": 3}
{"code": "function list(req, res, next) {\n  logger.debug(\"Middleware Submissions List \", {connectionOptions: req.connectionOptions});\n  forms.getSubmissions(req.connectionOptions, {}, _getSubmissionsResultHandler(req, next));\n}", "label": 3}
{"code": "func (flag *ClientFlag) configure(sc *soap.Client) (soap.RoundTripper, error) {\n\tif flag.cert != \"\" {\n\t\tcert, err := tls.LoadX509KeyPair(flag.cert, flag.key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsc.SetCertificate(cert)\n\t}\n\n\t// Set namespace and version\n\tsc.Namespace = \"urn:\" + flag.vimNamespace\n\tsc.Version = flag.vimVersion\n\n\tsc.UserAgent = fmt.Sprintf(\"govc/%s\", Version)\n\n\tif err := flag.SetRootCAs(sc); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := sc.LoadThumbprints(flag.tlsKnownHosts); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif t, ok := sc.Transport.(*http.Transport); ok {\n\t\tvar err error\n\n\t\tvalue := os.Getenv(\"GOVC_TLS_HANDSHAKE_TIMEOUT\")\n\t\tif value != \"\" {\n\t\t\tt.TLSHandshakeTimeout, err = time.ParseDuration(value)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// Retry twice when a temporary I/O error occurs.\n\t// This means a maximum of 3 attempts.\n\treturn vim25.Retry(sc, vim25.TemporaryNetworkError(3)), nil\n}", "label": 5}
{"code": "public static void touch(final File folder , final String fileName) throws IOException {\n        if(!folder.exists()){\n            folder.mkdirs();\n        }\n\n        final File touchedFile = new File(folder, fileName);\n\n        // The JVM will only 'touch' the file if you instantiate a\n        // FileOutputStream instance for the file in question.\n        // You don't actually write any data to the file through\n        // the FileOutputStream.  Just instantiate it and close it.\n\n        try (\n            FileOutputStream doneFOS = new FileOutputStream(touchedFile);\n        ) {\n            // Touching the file\n        }\n        catch (FileNotFoundException e) {\n            throw new FileNotFoundException(\"Failed to the find file.\" + e);\n        }\n    }", "label": 0}
{"code": "def visit_children(parent)\n      parent.children.each do |child|\n        child.node_parent = parent\n        visit(child)\n      end\n    end", "label": 4}
{"code": "public function loadLanguagePackFrom($directory)\n    {\n        $name = $title = basename($directory);\n\n        if (file_exists($manifest = $directory.'/composer.json')) {\n            $json = json_decode(file_get_contents($manifest), true);\n\n            if (empty($json)) {\n                throw new RuntimeException(\"Error parsing composer.json in $name: \".json_last_error_msg());\n            }\n\n            $locale = array_get($json, 'extra.flarum-locale.code');\n            $title = array_get($json, 'extra.flarum-locale.title', $title);\n        }\n\n        if (! isset($locale)) {\n            throw new RuntimeException(\"Language pack $name must define \\\"extra.flarum-locale.code\\\" in composer.json.\");\n        }\n\n        $this->locales->addLocale($locale, $title);\n\n        if (! is_dir($localeDir = $directory.'/locale')) {\n            throw new RuntimeException(\"Language pack $name must have a \\\"locale\\\" subdirectory.\");\n        }\n\n        if (file_exists($file = $localeDir.'/config.js')) {\n            $this->locales->addJsFile($locale, $file);\n        }\n\n        if (file_exists($file = $localeDir.'/config.css')) {\n            $this->locales->addCssFile($locale, $file);\n        }\n\n        foreach (new DirectoryIterator($localeDir) as $file) {\n            if ($file->isFile() && in_array($file->getExtension(), ['yml', 'yaml'])) {\n                $this->locales->addTranslations($locale, $file->getPathname());\n            }\n        }\n    }", "label": 2}
{"code": "function( input, chunk, context ){\n    // return given input if there is no dust reference to resolve\n    var output = input;\n    // dust compiles a string to function, if there are references\n    if( typeof input === \"function\"){\n      if( ( typeof input.isReference !== \"undefined\" ) && ( input.isReference === true ) ){ // just a plain function, not a dust `body` function\n        output = input();\n      } else {\n        output = '';\n        chunk.tap(function(data){\n          output += data;\n          return '';\n        }).render(input, context).untap();\n        if( output === '' ){\n          output = false;\n        }\n      }\n    }\n    return output;\n  }", "label": 3}
{"code": "public static function resolve(callable $provider, $version, $service, $region)\n    {\n        $result = $provider($version, $service, $region);\n        if ($result instanceof SignatureInterface) {\n            return $result;\n        }\n\n        throw new UnresolvedSignatureException(\n            \"Unable to resolve a signature for $version/$service/$region.\\n\"\n            . \"Valid signature versions include v4 and anonymous.\"\n        );\n    }", "label": 2}
{"code": "function isJsxIntrinsicIdentifier(tagName) {\n            // TODO (yuisu): comment\n            if (tagName.kind === 172 /* PropertyAccessExpression */ || tagName.kind === 97 /* ThisKeyword */) {\n                return false;\n            }\n            else {\n                return ts.isIntrinsicJsxName(tagName.text);\n            }\n        }", "label": 3}
{"code": "func (r *Registry) applyHandlers(f func(o RegisterObject)) {\n\tr.m.Lock()\n\thandlers := make([]RegisterObject, 0, len(r.handlers))\n\tfor _, handler := range r.handlers {\n\t\thandlers = append(handlers, handler)\n\t}\n\tr.m.Unlock()\n\n\tfor i := range handlers {\n\t\tf(handlers[i])\n\t}\n}", "label": 5}
{"code": "function _gpfArrayFromString(array, string) {\n        var length = string.length, index = 0;\n        for (; index < length; ++index) {\n            array.push(string.charAt(index));\n        }\n    }", "label": 3}
{"code": "def _lookup(self, skip_cache, fun, *args, **kwargs):\n        \"\"\" \n        Checks for cached responses, before requesting from \n        web-service\n        \"\"\"\n        if args not in self.cache or skip_cache:\n            self.cache[args] = fun(*args, **kwargs)\n        return self.cache[args]", "label": 1}
{"code": "func (f *Fetcher) fetchImageDeps(hash string) error {\n\timgsl := list.New()\n\tseen := map[string]dist.Distribution{}\n\tf.addImageDeps(hash, imgsl, seen)\n\tfor el := imgsl.Front(); el != nil; el = el.Next() {\n\t\ta := &asc{}\n\t\td := el.Value.(*dist.Appc)\n\t\tstr := d.String()\n\t\tdb := &distBundle{\n\t\t\tdist:  d,\n\t\t\timage: str,\n\t\t}\n\t\thash, err := f.fetchSingleImage(db, a)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.addImageDeps(hash, imgsl, seen)\n\t}\n\treturn nil\n}", "label": 5}
{"code": "function LinkMeta(properties) {\n                this.refs = [];\n                this.tags = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }", "label": 3}
{"code": "def object_list(generation)\n\n      rvalue_size = GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]\n      helper = Helpers.new\n\n      result = StatHash.new.compare_by_identity\n\n      ObjectSpace.each_object do |obj|\n        next unless ObjectSpace.allocation_generation(obj) == generation\n\n        file = ObjectSpace.allocation_sourcefile(obj) || \"(no name)\"\n        next if @ignore_files && @ignore_files =~ file\n        next if @allow_files && !(@allow_files =~ file)\n\n        klass = obj.class rescue nil\n        unless Class === klass\n          # attempt to determine the true Class when .class returns something other than a Class\n          klass = Kernel.instance_method(:class).bind(obj).call\n        end\n        next if @trace && !trace.include?(klass)\n\n        begin\n          line       = ObjectSpace.allocation_sourceline(obj)\n          location   = helper.lookup_location(file, line)\n          class_name = helper.lookup_class_name(klass)\n          gem        = helper.guess_gem(file)\n\n          # we do memsize first to avoid freezing as a side effect and shifting\n          # storage to the new frozen string, this happens on @hash[s] in lookup_string\n          memsize = ObjectSpace.memsize_of(obj)\n          string     = klass == String ? helper.lookup_string(obj) : nil\n\n          # compensate for API bug\n          memsize = rvalue_size if memsize > 100_000_000_000\n          result[obj.__id__] = MemoryProfiler::Stat.new(class_name, gem, file, location, memsize, string)\n        rescue\n          # give up if any any error occurs inspecting the object\n        end\n      end\n\n      result\n    end", "label": 4}
{"code": "func (p *ProfileStatus) IsExpired(clock clockwork.Clock) bool {\n\treturn p.ValidUntil.Sub(clock.Now()) <= 0\n}", "label": 5}
{"code": "def exception(cls, name, message, *args):\n        \"\"\"\n        Convenience function to log a message at the ERROR level with additonal exception information.\n\n        :param name:    The name of the logger instance in the VSG namespace (VSG.<name>)\n        :param message: A message format string.\n        :param args:    The arguments that are are merged into msg using the string formatting operator.\n        :..note:        This method should only be called from an exception handler.\n        \"\"\"\n        cls.getLogger(name).exception(message, *args)", "label": 1}
{"code": "def render_alternate(tags)\n      alternate = meta_tags.extract(:alternate)\n      return unless alternate\n\n      if alternate.kind_of?(Hash)\n        alternate.each do |hreflang, href|\n          tags << Tag.new(:link, rel: 'alternate', href: href, hreflang: hreflang) if href.present?\n        end\n      elsif alternate.kind_of?(Array)\n        alternate.each do |link_params|\n          tags << Tag.new(:link, { rel: 'alternate' }.with_indifferent_access.merge(link_params))\n        end\n      end\n    end", "label": 4}
{"code": "public function create(array $options = [])\n    {\n        // If a subscription is created via PubSubClient::subscription(),\n        // it may or may not have a topic name. This is fine for most API\n        // interactions, but a topic name is required to create a subscription.\n        if (!$this->topicName) {\n            throw new InvalidArgumentException('A topic name is required to\n                create a subscription.');\n        }\n\n        $this->info = $this->connection->createSubscription($options + [\n            'name' => $this->name,\n            'topic' => $this->topicName\n        ]);\n\n        return $this->info;\n    }", "label": 2}
{"code": "def process_files(report)\n      files.each do |file|\n        process_file(file, report)\n        break if report.failed? && fail_fast?\n      end\n    end", "label": 4}
{"code": "function(key, options) {\n      options = opts(this, options);\n      var response = {success: {}}, query;\n\n      if (options.filename) {\n        query = {\n          force_download: true,\n          apikey: options.apikey,\n          session_token: options.session_token,\n          filename: options.filename\n        }\n      }\n\n      var apicall = new APICall({\n        action: 'binary/' + key,\n        type: 'GET',\n        later: true,\n        encoding: 'binary',\n        options: options,\n        query: query\n      });\n\n      // Download file directly to computer if given a filename.\n      if (options.filename) {\n        if (isNode) {\n          apicall.setProcessor(function(data) {\n            response.success[key] = fs.writeFileSync(options.filename, data, 'binary');\n            return response;\n          }).done();\n        } else {\n          function detach() {\n            if (iframe.parentNode) document.body.removeChild(iframe);\n          }\n          var iframe = document.createElement('iframe');\n          iframe.style.display = 'none';\n          document.body.appendChild(iframe);\n          setTimeout(function() { iframe.src = apicall.url; }, 25);\n          iframe.onload = function() {\n            clearTimeout(detach.timer);\n            detach.timer = setTimeout(detach, 5000);\n          };\n          detach.timer = setTimeout(detach, 60000);\n          response.success[key] = iframe;\n        }\n\n        apicall.done(response);\n      } else if (options.mode === 'buffer' && (ArrayBuffer || Buffer)) {\n        apicall.setProcessor(function(data) {\n          var buffer;\n          if (Buffer) {\n            buffer = new Buffer(data, 'binary');\n          } else {\n            buffer = new ArrayBuffer(data.length);\n            var charView = new Uint8Array(buffer);\n            for (var i = 0; i < data.length; ++i) {\n              charView[i] = data[i] & 0xFF;\n            }\n          }\n\n          response.success[key] = buffer;\n          return response;\n        }).done();\n      } else {\n        // Raw data return. Do not attempt to process the result.\n        apicall.setProcessor(function(data) {\n          response.success[key] = data;\n          return response;\n        }).done();\n      }\n\n      return apicall;\n    }", "label": 3}
{"code": "function listDirContents(prefix, options) {\n  prefix = path.resolve(prefix);\n  options = _.sanitize(options, {stripPrefix: false, includeTopDir: false, compact: true, getAllAttrs: false,\n    include: ['*'], exclude: [], onlyFiles: false, rootDir: null, prefix: null, followSymLinks: false,\n    listSymLinks: true});\n  const results = [];\n  // TODO: prefix is an alias to rootDir. Remove it\n  const root = options.rootDir || options.prefix || prefix;\n  walkDir(prefix, (file, data) => {\n    if (!matches(file, options.include, options.exclude)) return;\n    if (data.type === 'directory' && options.onlyFiles) return;\n    if (data.type === 'link' && !options.listSymLinks) return;\n    if (data.topDir && !options.includeTopDir) return;\n    const filename = options.stripPrefix ? data.file : file;\n    if (options.compact) {\n      results.push(filename);\n    } else {\n      let fileInfo = {file: filename, type: data.type};\n      if (options.getAllAttrs) {\n        fileInfo = _getFileMetadata(file, fileInfo);\n        fileInfo.srcPath = file;\n      }\n      results.push(fileInfo);\n    }\n  }, {prefix: root});\n  return results;\n}", "label": 3}
{"code": "def backfill_derived_code_lists\n      data_criteria_by_id = {}\n      @data_criteria.each {|criteria| data_criteria_by_id[criteria.id] = criteria}\n      @data_criteria.each do |criteria|\n        if (criteria.derived_from)\n          derived_from = data_criteria_by_id[criteria.derived_from]\n          criteria.definition = derived_from.definition\n          criteria.status = derived_from.status\n          criteria.code_list_id = derived_from.code_list_id\n        end\n      end\n    end", "label": 4}
{"code": "def compress(self):\n        \"\"\"Main function of compression.\"\"\"\n        for ast_token in self.ast_tokens:\n            if type(ast_token) in self.dispatcher:  # pylint: disable=unidiomatic-typecheck\n                self.dispatcher[type(ast_token)](ast_token)\n            else:\n                self.dispatcher['default'](ast_token)", "label": 1}
{"code": "public void rollback() throws GeomajasException {\n\t\ttry {\n\t\t\tsetConfigLocations(previousConfigLocations);\n\t\t\trefresh();\n\t\t} catch (Exception e) {\n\t\t\tthrow new GeomajasException(e, ExceptionCode.REFRESH_CONFIGURATION_FAILED);\n\t\t}\n\t}", "label": 0}
{"code": "function () {\n            var allItems = [];\n            each(this.chart.series, function (series) {\n                var seriesOptions = series.options;\n\n                // Handle showInLegend. If the series is linked to another series, defaults to false.\n                if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {\n                    return;\n                }\n\n                // use points or series for the legend item depending on legendType\n                allItems = allItems.concat(\n                  series.legendItems ||\n                  (seriesOptions.legendType === 'point' ?\n                    series.data :\n                    series)\n                );\n            });\n            return allItems;\n        }", "label": 3}
{"code": "def similarity(other)\n      overlap = (wordset & other.wordset).size\n      total = wordset.size + other.wordset.size\n      100.0 * (overlap * 2.0 / total)\n    end", "label": 4}
{"code": "def get_case24_ieee_rts():\n    \"\"\" Returns the 24 bus IEEE Reliability Test System.\n    \"\"\"\n    path = os.path.dirname(pylon.__file__)\n    path = os.path.join(path, \"test\", \"data\")\n    path = os.path.join(path, \"case24_ieee_rts\", \"case24_ieee_rts.pkl\")\n\n    case = pylon.Case.load(path)\n\n    # FIXME: Correct generator naming order.\n    for g in case.generators:\n        g.name\n\n    return case", "label": 1}
{"code": "public static bridgegroup_nsip6_binding[] get(nitro_service service, Long id) throws Exception{\n\t\tbridgegroup_nsip6_binding obj = new bridgegroup_nsip6_binding();\n\t\tobj.set_id(id);\n\t\tbridgegroup_nsip6_binding response[] = (bridgegroup_nsip6_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function processMultiBytePacketStop (o) {\n  processMultiBytePacket(o);\n  const str = o.multiPacketBuffer.toString();\n  o.multiPacketBuffer = null;\n  return {\n    'message': str\n  };\n}", "label": 3}
{"code": "def finish_task(state, result)\n      @task.refresh\n      @task.state = state\n      @task.result = truncate(result.to_s)\n      @task.timestamp = Time.now\n      @task.save\n    end", "label": 4}
{"code": "func (s *PresenceService) GetTunnelConnections(clusterName string, opts ...services.MarshalOption) ([]services.TunnelConnection, error) {\n\tif clusterName == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing cluster name\")\n\t}\n\tstartKey := backend.Key(tunnelConnectionsPrefix, clusterName)\n\tresult, err := s.GetRange(context.TODO(), startKey, backend.RangeEnd(startKey), backend.NoLimit)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tconns := make([]services.TunnelConnection, len(result.Items))\n\tfor i, item := range result.Items {\n\t\tconn, err := services.UnmarshalTunnelConnection(item.Value,\n\t\t\tservices.AddOptions(opts, services.WithResourceID(item.ID), services.WithExpires(item.Expires))...)\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tconns[i] = conn\n\t}\n\n\treturn conns, nil\n}", "label": 5}
{"code": "private void handleApplicationCommandRequest(SerialMessage incomingMessage) {\n\t\tlogger.trace(\"Handle Message Application Command Request\");\n\t\tint nodeId = incomingMessage.getMessagePayloadByte(1);\n\t\tlogger.debug(\"Application Command Request from Node \" + nodeId);\n\t\tZWaveNode node = getNode(nodeId);\n\t\t\n\t\tif (node == null) {\n\t\t\tlogger.warn(\"Node {} not initialized yet, ignoring message.\", nodeId);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tnode.resetResendCount();\n\t\t\n\t\tint commandClassCode = incomingMessage.getMessagePayloadByte(3);\n\t\tZWaveCommandClass.CommandClass commandClass = ZWaveCommandClass.CommandClass.getCommandClass(commandClassCode);\n\n\t\tif (commandClass == null) {\n\t\t\tlogger.error(String.format(\"Unsupported command class 0x%02x\", commandClassCode));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlogger.debug(String.format(\"Incoming command class %s (0x%02x)\", commandClass.getLabel(), commandClass.getKey()));\n\t\tZWaveCommandClass zwaveCommandClass =  node.getCommandClass(commandClass);\n\t\t\n\t\t// We got an unsupported command class, return.\n\t\tif (zwaveCommandClass == null) {\n\t\t\tlogger.error(String.format(\"Unsupported command class %s (0x%02x)\", commandClass.getLabel(), commandClassCode));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlogger.trace(\"Found Command Class {}, passing to handleApplicationCommandRequest\", zwaveCommandClass.getCommandClass().getLabel());\n\t\tzwaveCommandClass.handleApplicationCommandRequest(incomingMessage, 4, 1);\n\n\t\tif (incomingMessage.getMessageClass() == this.lastSentMessage.getExpectedReply() && nodeId == this.lastSentMessage.getMessageNode() && !incomingMessage.isTransActionCanceled()) {\n\t\t\t\tnotifyEventListeners(new ZWaveEvent(ZWaveEventType.TRANSACTION_COMPLETED_EVENT, this.lastSentMessage.getMessageNode(), 1, this.lastSentMessage));\n\t\t\t\ttransactionCompleted.release();\n\t\t\t\tlogger.trace(\"Released. Transaction completed permit count -> {}\", transactionCompleted.availablePermits());\n\t\t}\n\t}", "label": 0}
{"code": "function sendChat(roomId, content) {\n        return retryAction(() => forum._emit('modules.chats.send', {\n            roomId: roomId,\n            message: content\n        }), 5);\n    }", "label": 3}
{"code": "public static void Forward(double[][] data) {\n        int rows = data.length;\n        int cols = data[0].length;\n\n        double[] row = new double[cols];\n        double[] col = new double[rows];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < row.length; j++)\n                row[j] = data[i][j];\n\n            Forward(row);\n\n            for (int j = 0; j < row.length; j++)\n                data[i][j] = row[j];\n        }\n\n        for (int j = 0; j < cols; j++) {\n            for (int i = 0; i < col.length; i++)\n                col[i] = data[i][j];\n\n            Forward(col);\n\n            for (int i = 0; i < col.length; i++)\n                data[i][j] = col[i];\n        }\n    }", "label": 0}
{"code": "func (roles Roles) StringSlice() []string {\n\ts := make([]string, 0)\n\tfor _, r := range roles {\n\t\ts = append(s, r.String())\n\t}\n\treturn s\n}", "label": 5}
{"code": "public function setPartialMatchingImages($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\WebDetection\\WebImage::class);\n        $this->partial_matching_images = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.offsetHeight;\n  }", "label": 3}
{"code": "function(obj) {\n  var ret = {};\n  var key;\n  invariant(\n    obj instanceof Object && !Array.isArray(obj),\n    'keyMirror(...): Argument must be an object.'\n  );\n  for (key in obj) {\n    if (!obj.hasOwnProperty(key)) {\n      continue;\n    }\n    ret[key] = key;\n  }\n  return ret;\n}", "label": 3}
{"code": "public static base_response delete(nitro_service client, Long clid) throws Exception {\n\t\tclusterinstance deleteresource = new clusterinstance();\n\t\tdeleteresource.clid = clid;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "func (t *Torrent) announceRequest() tracker.AnnounceRequest {\n\t// Note that IPAddress is not set. It's set for UDP inside the tracker\n\t// code, since it's dependent on the network in use.\n\treturn tracker.AnnounceRequest{\n\t\tEvent:    tracker.None,\n\t\tNumWant:  -1,\n\t\tPort:     uint16(t.cl.incomingPeerPort()),\n\t\tPeerId:   t.cl.peerID,\n\t\tInfoHash: t.infoHash,\n\t\tKey:      t.cl.announceKey(),\n\n\t\t// The following are vaguely described in BEP 3.\n\n\t\tLeft:     t.bytesLeftAnnounce(),\n\t\tUploaded: t.stats.BytesWrittenData.Int64(),\n\t\t// There's no mention of wasted or unwanted download in the BEP.\n\t\tDownloaded: t.stats.BytesReadUsefulData.Int64(),\n\t}\n}", "label": 5}
{"code": "protected function getArgumentValues(): Collection\n    {\n        return (new Collection($this->fieldValue->getField()->arguments))\n            ->map(function (InputValueDefinitionNode $inputValueDefinition): ArgumentValue {\n                return new ArgumentValue($inputValueDefinition, $this->fieldValue);\n            });\n    }", "label": 2}
{"code": "public function deleteMedia($mediaId)\n    {\n        if ($mediaId instanceof Media) {\n            $mediaId = $mediaId->id;\n        }\n\n        $media = $this->media->find($mediaId);\n\n        if (! $media) {\n            throw MediaCannotBeDeleted::doesNotBelongToModel($mediaId, $this);\n        }\n\n        $media->delete();\n    }", "label": 2}
{"code": "func Dial(socket string) (net.Conn, error) {\n\tconn, err := net.Dial(\"unix\", socket)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn conn, nil\n}", "label": 5}
{"code": "def main(argv=None):\n    \"\"\"General function for converting between ReSpecTh and ChemKED files based on extension.\n    \"\"\"\n    parser = ArgumentParser(\n        description='Convert between ReSpecTh XML file and ChemKED YAML file '\n                    'automatically based on file extension.'\n        )\n    parser.add_argument('-i', '--input',\n                        type=str,\n                        required=True,\n                        help='Input filename (e.g., \"file1.yaml\" or \"file2.xml\")'\n                        )\n    parser.add_argument('-o', '--output',\n                        type=str,\n                        required=False,\n                        default='',\n                        help='Output filename (e.g., \"file1.xml\" or \"file2.yaml\")'\n                        )\n    parser.add_argument('-fa', '--file-author',\n                        dest='file_author',\n                        type=str,\n                        required=False,\n                        default='',\n                        help='File author name to override original'\n                        )\n    parser.add_argument('-fo', '--file-author-orcid',\n                        dest='file_author_orcid',\n                        type=str,\n                        required=False,\n                        default='',\n                        help='File author ORCID'\n                        )\n\n    args = parser.parse_args(argv)\n\n    if os.path.splitext(args.input)[1] == '.xml' and os.path.splitext(args.output)[1] == '.yaml':\n        respth2ck(['-i', args.input, '-o', args.output, '-fa', args.file_author,\n                   '-fo', args.file_author_orcid])\n\n    elif os.path.splitext(args.input)[1] == '.yaml' and os.path.splitext(args.output)[1] == '.xml':\n        c = chemked.ChemKED(yaml_file=args.input)\n        c.convert_to_ReSpecTh(args.output)\n\n    elif os.path.splitext(args.input)[1] == '.xml' and os.path.splitext(args.output)[1] == '.xml':\n        raise KeywordError('Cannot convert .xml to .xml')\n\n    elif os.path.splitext(args.input)[1] == '.yaml' and os.path.splitext(args.output)[1] == '.yaml':\n        raise KeywordError('Cannot convert .yaml to .yaml')\n\n    else:\n        raise KeywordError('Input/output args need to be .xml/.yaml')", "label": 1}
{"code": "func DjangoSessionBySessionKey(db XODB, sessionKey string) (*DjangoSession, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`session_key, session_data, expire_date ` +\n\t\t`FROM django.django_session ` +\n\t\t`WHERE session_key = ?`\n\n\t// run query\n\tXOLog(sqlstr, sessionKey)\n\tds := DjangoSession{\n\t\t_exists: true,\n\t}\n\n\terr = db.QueryRow(sqlstr, sessionKey).Scan(&ds.SessionKey, &ds.SessionData, &ds.ExpireDate)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ds, nil\n}", "label": 5}
{"code": "def add_comment(options={})\n      raise ArgumentError, \"Comment require an author\" unless options[:author]\n      raise ArgumentError, \"Comment requires text\" unless options[:text]\n      raise ArgumentError, \"Comment requires ref\" unless options[:ref]\n      self << Comment.new(self, options)\n      yield last if block_given?\n      last\n    end", "label": 4}
{"code": "def extract_pair(line)\n      key, value = line.split(\"=\", 2)\n      [key.tr(\"-\", \"_\").to_sym, value.gsub(/[\\n\\r]+/, \"\")]\n    end", "label": 4}
{"code": "function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n    if (!text) return;\n    var special = builder.cm.options.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(text.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt.setAttribute(\"role\", \"presentation\");\n          builder.col += tabWidth;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }", "label": 3}
{"code": "public static function isSimplyContainedBy(\n        Type\\Union $input_type,\n        Type\\Union $container_type\n    ) {\n        if ($input_type->getId() === $container_type->getId()) {\n            return true;\n        }\n\n        if ($input_type->isNullable() && !$container_type->isNullable()) {\n            return false;\n        }\n\n        $input_type_not_null = clone $input_type;\n        $input_type_not_null->removeType('null');\n\n        $container_type_not_null = clone $container_type;\n        $container_type_not_null->removeType('null');\n\n        return (bool) array_intersect_key(\n            $input_type_not_null->getTypes(),\n            $container_type_not_null->getTypes()\n        );\n    }", "label": 2}
{"code": "def reacted_with(reaction, limit: 100)\n      reaction = reaction.to_reaction if reaction.respond_to?(:to_reaction)\n      paginator = Paginator.new(limit, :down) do |last_page|\n        after_id = last_page.last.id if last_page\n        last_page = JSON.parse(API::Channel.get_reactions(@bot.token, @channel.id, @id, reaction, nil, after_id, limit))\n        last_page.map { |d| User.new(d, @bot) }\n      end\n      paginator.to_a\n    end", "label": 4}
{"code": "public function sendSetRecoveryToken($token)\n    {\n        $child = new ProtocolNode('pin',\n            [\n                'xmlns' => 'w:ch:p',\n            ], null, $token);\n\n        $node = new ProtocolNode('iq',\n            [\n                'id'   => $this->createIqId(),\n                'type' => 'set',\n                'to'   => Constants::WHATSAPP_SERVER,\n            ], [$child], null);\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "def search_aikif(txt, formatHTML=True):\n    \"\"\"\n    search for text - currently this looks in all folders in the\n    root of AIKIF but that also contains binaries so will need to \n    use the agent_filelist.py to specify the list of folders.\n    \n    NOTE - this needs to use indexes rather than full search each time\n    \"\"\"\n    results = []\n    num_found = 0\n    import aikif.lib.cls_filelist as mod_fl\n    my_files = mod_fl.FileList([aikif_folder ], ['*.*'], ['*.pyc'])\n    files = my_files.get_list()\n    for f in files:\n        try:\n            num_found = 0\n            with open(f, 'r') as cur:\n                line_num = 0\n                for line in cur:\n                    line_num += 1\n                    if txt in line:\n                        num_found += 1\n                        if formatHTML is True:\n                            results.append(format_result(line, line_num, txt))\n                        else:\n                            results.append([f, line, line_num, txt])\n            if num_found > 0:\n                if formatHTML is True:\n                    results.append('<h3>' + f + ' = ' + str(num_found) + ' results</h3>')\n                else:    \n                    print(f + ' = ' + str(num_found) + '')\n        except Exception:\n            results.append('problem with file ' + f)\n    if len(results) == 0:\n        results.append(\"No results\")\n    return results", "label": 1}
{"code": "private void appendClazzColumnForSelect(StringBuffer buf)\r\n    {\r\n        ClassDescriptor cld = getSearchClassDescriptor();\r\n        ClassDescriptor[] clds = getMultiJoinedClassDescriptors(cld);\r\n\r\n        if (clds.length == 0)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        buf.append(\",CASE\");\r\n\r\n        for (int i = clds.length; i > 0; i--)\r\n        {\r\n            buf.append(\" WHEN \");\r\n\r\n            ClassDescriptor subCld = clds[i - 1];\r\n            FieldDescriptor[] fieldDescriptors = subCld.getPkFields();\r\n\r\n            TableAlias alias = getTableAliasForClassDescriptor(subCld);\r\n            for (int j = 0; j < fieldDescriptors.length; j++)\r\n            {\r\n                FieldDescriptor field = fieldDescriptors[j];\r\n                if (j > 0)\r\n                {\r\n                    buf.append(\" AND \");\r\n                }\r\n                appendColumn(alias, field, buf);\r\n                buf.append(\" IS NOT NULL\");\r\n            }\r\n            buf.append(\" THEN '\").append(subCld.getClassNameOfObject()).append(\"'\");\r\n        }\r\n        buf.append(\" ELSE '\").append(cld.getClassNameOfObject()).append(\"'\");\r\n        buf.append(\" END AS \" + SqlHelper.OJB_CLASS_COLUMN);\r\n    }", "label": 0}
{"code": "func (c *Manager) ListLibraryItems(ctx context.Context, id string) ([]string, error) {\n\turl := internal.URL(c, internal.LibraryItemPath).WithParameter(\"library_id\", id)\n\tvar res []string\n\treturn res, c.Do(ctx, url.Request(http.MethodGet), &res)\n}", "label": 5}
{"code": "public static String getMemberName() throws XDocletException\r\n    {\r\n        if (getCurrentField() != null) {\r\n            return getCurrentField().getName();\r\n        }\r\n        else if (getCurrentMethod() != null) {\r\n            return MethodTagsHandler.getPropertyNameFor(getCurrentMethod());\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }", "label": 0}
{"code": "public static dnspolicy64[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception{\n\t\tdnspolicy64 obj = new dnspolicy64();\n\t\toptions option = new options();\n\t\toption.set_filter(filter);\n\t\tdnspolicy64[] response = (dnspolicy64[]) obj.getfiltered(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def read_csv_to_html_list(csvFile):\n    \"\"\"\n    reads a CSV file and converts it to a HTML List\n    \"\"\"\n    txt = ''\n    with open(csvFile) as csv_file:\n        for row in csv.reader(csv_file, delimiter=','):\n            txt += '<div id=\"table_row\">'\n            for col in row:\n                txt += \" \"\n                try:\n                    txt += col\n                except Exception:\n                    txt += 'Error'\n                txt += \" \"\n            txt += \"</div>\\n\"\n    return txt", "label": 1}
{"code": "def threaded(system, func, *args, **kwargs):\n    \"\"\" uses thread_init as a decorator-style \"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            if system.raven_client:\n                system.raven_client.captureException()\n            logger.exception('Exception occurred in thread: %s', e)\n            return False\n\n    return lambda: wrapper(*args, **kwargs)", "label": 1}
{"code": "public void processClass(String template, Properties attributes) throws XDocletException\r\n    {\r\n        if (!_model.hasClass(getCurrentClass().getQualifiedName()))\r\n        {\r\n            // we only want to output the log message once\r\n            LogHelper.debug(true, OjbTagsHandler.class, \"processClass\", \"Type \"+getCurrentClass().getQualifiedName());\r\n        }\r\n\r\n        ClassDescriptorDef classDef = ensureClassDef(getCurrentClass());\r\n        String attrName;\r\n\r\n        for (Enumeration attrNames = attributes.propertyNames(); attrNames.hasMoreElements(); )\r\n        {\r\n            attrName = (String)attrNames.nextElement();\r\n            classDef.setProperty(attrName, attributes.getProperty(attrName));\r\n        }\r\n        _curClassDef = classDef;\r\n        generate(template);\r\n        _curClassDef = null;\r\n    }", "label": 0}
{"code": "def action_runner\n      @action_runner ||= Action::Runner.new do\n        {\n          action_runner:  action_runner,\n          box_collection: boxes,\n          hook:           method(:hook),\n          host:           host,\n          machine_index:  machine_index,\n          gems_path:      gems_path,\n          home_path:      home_path,\n          root_path:      root_path,\n          tmp_path:       tmp_path,\n          ui:             @ui,\n          env:            self\n        }\n      end\n    end", "label": 4}
{"code": "public static <T> String listToString(List<T> list, final boolean justValue,\r\n                                        final String separator) {\r\n    StringBuilder s = new StringBuilder();\r\n    for (Iterator<T> wordIterator = list.iterator(); wordIterator.hasNext();) {\r\n      T o = wordIterator.next();\r\n      s.append(wordToString(o, justValue, separator));\r\n      if (wordIterator.hasNext()) {\r\n        s.append(' ');\r\n      }\r\n    }\r\n    return s.toString();\r\n  }", "label": 0}
{"code": "def consumer?(provider_intent, deployment_plan)\n      return true if provider_intent.shared\n\n      link_consumers = deployment_plan.model.link_consumers\n      link_consumers = link_consumers.select do |consumer|\n        consumer.serial_id == @serial_id\n      end\n\n      link_consumers.any? do |consumer|\n        consumer.intents.any? do |consumer_intent|\n          can_be_consumed?(consumer, provider_intent, consumer_intent, @serial_id)\n        end\n      end\n    end", "label": 4}
{"code": "def all_build_trains(app_id: nil, platform: 'ios')\n      platform = 'ios' if platform.nil?\n      r = request(:get, \"ra/apps/#{app_id}/buildHistory?platform=#{platform}\")\n      handle_itc_response(r.body)\n    end", "label": 4}
{"code": "public void checkConstraints(String checkLevel) throws ConstraintException\r\n    {\r\n        // check constraints now after all classes have been processed\r\n        for (Iterator it = getClasses(); it.hasNext();)\r\n        {\r\n            ((ClassDescriptorDef)it.next()).checkConstraints(checkLevel);\r\n        }\r\n        // additional model constraints that either deal with bigger parts of the model or\r\n        // can only be checked after the individual classes have been checked (e.g. specific\r\n        // attributes have been ensured)\r\n        new ModelConstraints().check(this, checkLevel);\r\n    }", "label": 0}
{"code": "def write_generator_cost_data(self, file):\n        \"\"\" Writes generator cost data to file.\n        \"\"\"\n        file.write(\"\\n%%%% generator cost data\\n\")\n        file.write(\"%%\\t1\\tstartup\\tshutdown\\tn\\tx1\\ty1\\t...\\txn\\tyn\\n\")\n        file.write(\"%%\\t2\\tstartup\\tshutdown\\tn\\tc(n-1)\\t...\\tc0\\n\")\n        file.write(\"%sgencost = [\\n\" % self._prefix)\n\n        for generator in self.case.generators:\n            n = len(generator.p_cost)\n            template = '\\t%d\\t%g\\t%g\\t%d'\n            for _ in range(n):\n                template = '%s\\t%%g' % template\n            template = '%s;\\n' % template\n\n            if generator.pcost_model == PW_LINEAR:\n                t = 2\n#                cp = [p for p, q in generator.p_cost]\n#                cq = [q for p, q in generator.p_cost]\n#                c = zip(cp, cq)\n                c = [v for pc in generator.p_cost for v in pc]\n            elif generator.pcost_model == POLYNOMIAL:\n                t = 1\n                c = list(generator.p_cost)\n            else:\n                raise\n\n            vals = [t, generator.c_startup, generator.c_shutdown, n] + c\n\n            file.write(template % tuple(vals))\n        file.write(\"];\\n\")", "label": 1}
{"code": "function writeExtensionFile(options) {\n  return new Promise((resolve, reject) => {\n    try {\n      const {\n        file,\n        input,\n        defaultContent,\n        logNotFound,\n        logEnd,\n      } = options;\n      const filePath = path.resolve(getExtensionsPath(), file);\n\n      if (!input) {\n        logger.warn(logNotFound);\n        fs.writeFileSync(filePath, defaultContent, { flag: 'w+' });\n        return resolve();\n      }\n\n      fs.writeFileSync(filePath, input, { flag: 'w+' });\n      logger.log(logEnd);\n\n      return resolve();\n    } catch (e) {\n      return reject(e);\n    }\n  });\n}", "label": 3}
{"code": "function(val) {\n      var seed;\n      if (_.isArray(val)) {\n        seed = [];\n      } else if (_.isObject(val)) {\n        seed = {};\n      } else {\n        return val;\n      }\n      return $.extend(true, seed, val);\n    }", "label": 3}
{"code": "public function setReciprocity($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Language\\V1\\PartOfSpeech_Reciprocity::class);\n        $this->reciprocity = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func GetIPCopy(from net.IP) net.IP {\n\tif from == nil {\n\t\treturn nil\n\t}\n\tto := make(net.IP, len(from))\n\tcopy(to, from)\n\treturn to\n}", "label": 5}
{"code": "function tryAddingExtensions(candidate, extensions, failedLookupLocation, onlyRecordFailures, state) {\n        if (!onlyRecordFailures) {\n            // check if containing folder exists - if it doesn't then just record failures for all supported extensions without disk probing\n            var directory = ts.getDirectoryPath(candidate);\n            if (directory) {\n                onlyRecordFailures = !directoryProbablyExists(directory, state.host);\n            }\n        }\n        return ts.forEach(extensions, function (ext) {\n            return !(state.skipTsx && ts.isJsxOrTsxExtension(ext)) && tryFile(candidate + ext, failedLookupLocation, onlyRecordFailures, state);\n        });\n    }", "label": 3}
{"code": "public function filter_http_response( $response, $args, $url ) {\n\t\t// check if whitelisted\n\t\tif ( ! isset( $this->whitelist[ $url ] ) ) {\n\t\t\treturn $response;\n\t\t}\n\t\t// check if downloading\n\t\tif ( 'GET' !== $args['method'] || empty( $args['filename'] ) ) {\n\t\t\treturn $response;\n\t\t}\n\t\t// check if download was successful\n\t\tif ( is_wp_error( $response ) || 200 !== wp_remote_retrieve_response_code( $response ) ) {\n\t\t\treturn $response;\n\t\t}\n\t\t// cache downloaded file\n\t\t$this->cache->import( $this->whitelist[ $url ]['key'], $response['filename'] );\n\t\treturn $response;\n\t}", "label": 2}
{"code": "def bam2fastq(job, bamfile, univ_options):\n    \"\"\"\n    split an input bam to paired fastqs.\n\n    ARGUMENTS\n    1. bamfile: Path to a bam file\n    2. univ_options: Dict of universal arguments used by almost all tools\n         univ_options\n                |- 'dockerhub': <dockerhub to use>\n                +- 'java_Xmx': value for max heap passed to java\n    \"\"\"\n    work_dir = os.path.split(bamfile)[0]\n    base_name = os.path.split(os.path.splitext(bamfile)[0])[1]\n    parameters = ['SamToFastq',\n                  ''.join(['I=', docker_path(bamfile)]),\n                  ''.join(['F=/data/', base_name, '_1.fastq']),\n                  ''.join(['F2=/data/', base_name, '_2.fastq']),\n                  ''.join(['FU=/data/', base_name, '_UP.fastq'])]\n    docker_call(tool='picard', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'], java_opts=univ_options['java_Xmx'])\n    first_fastq = ''.join([work_dir, '/', base_name, '_1.fastq'])\n    assert os.path.exists(first_fastq)\n    return first_fastq", "label": 1}
{"code": "def underscored2camel_case(v):\n    \"\"\"converts ott_id to ottId.\"\"\"\n    vlist = v.split('_')\n    c = []\n    for n, el in enumerate(vlist):\n        if el:\n            if n == 0:\n                c.append(el)\n            else:\n                c.extend([el[0].upper(), el[1:]])\n    return ''.join(c)", "label": 1}
{"code": "function(fileRef){\n    var filename;\n    var file;\n\n    if (fileRef instanceof File)\n    {\n      file = fileRef;\n      filename = file.filename;\n    }\n    else\n    {\n      filename = abspath(this.baseURI, fileRef);\n      file = this.map[filename];\n\n      if (!file)\n      {\n        this.flow.warn({\n          file: filename,\n          message: 'File `' + fileRef + '` not found in map'\n        });\n        return;\n      }\n    }\n\n    // remove links\n    for (var i = file.linkTo.length, linkTo; linkTo = file.linkTo[i]; i--)\n      file.unlink(linkTo);\n\n    for (var i = file.linkBack.length, linkBack; linkBack = file.linkBack[i]; i--)\n      linkBack.unlink(file);\n\n    // remove from queue\n    var index = this.queue.indexOf(file);\n\n    if (index != -1)\n      this.queue.splice(index, 1);\n\n    // remove from map\n    if (filename)\n      delete this.map[filename];\n  }", "label": 3}
{"code": "public Set<DbLicense> resolveLicenses(List<String> licStrings) {\n        Set<DbLicense> result = new HashSet<>();\n\n        licStrings\n                .stream()\n                .map(this::getMatchingLicenses)\n                .forEach(result::addAll);\n\n        return result;\n    }", "label": 0}
{"code": "func GetIPNetCopy(from *net.IPNet) *net.IPNet {\n\tif from == nil {\n\t\treturn nil\n\t}\n\tbm := make(net.IPMask, len(from.Mask))\n\tcopy(bm, from.Mask)\n\treturn &net.IPNet{IP: GetIPCopy(from.IP), Mask: bm}\n}", "label": 5}
{"code": "def to_obj(self, ns_info=None):\n        \"\"\"Convert to a GenerateDS binding object.\n\n        Subclasses can override this function.\n\n        Returns:\n            An instance of this Entity's ``_binding_class`` with properties\n            set from this Entity.\n        \"\"\"\n        if ns_info:\n            ns_info.collect(self)\n\n        # null behavior for classes that inherit from Entity but do not\n        # have _binding_class\n        if not hasattr(self, \"_binding_class\"):\n            return None\n\n        entity_obj = self._binding_class()\n\n        for field, val in six.iteritems(self._fields):\n            # EntityLists with no list items should be dropped\n            if isinstance(val, EntityList) and len(val) == 0:\n                val = None\n            elif field.multiple:\n                if val:\n                    val = [_objectify(field, x, ns_info) for x in val]\n                else:\n                    val = []\n            else:\n                val = _objectify(field, val, ns_info)\n\n            setattr(entity_obj, field.name, val)\n\n        self._finalize_obj(entity_obj)\n        return entity_obj", "label": 1}
{"code": "def listunion(ListOfLists):\n    \"\"\"\n    Take the union of a list of lists.\n\n    Take a Python list of Python lists::\n\n            [[l11,l12, ...], [l21,l22, ...], ... , [ln1, ln2, ...]]\n\n    and return the aggregated list::\n\n            [l11,l12, ..., l21, l22 , ...]\n\n    For a list of two lists, e.g. `[a, b]`, this is like::\n\n            a.extend(b)\n\n    **Parameters**\n\n            **ListOfLists** :  Python list\n\n                    Python list of Python lists.\n\n    **Returns**\n\n            **u** :  Python list\n\n                    Python list created by taking the union of the\n                    lists in `ListOfLists`.\n\n    \"\"\"\n    u = []\n    for s in ListOfLists:\n        if s != None:\n            u.extend(s)\n    return u", "label": 1}
{"code": "private function updateComponentVersionFile($version, array $component)\n    {\n        $path = $this->rootPath() .'/'. $component['path'] .'/VERSION';\n        $result = file_put_contents($path, $version);\n\n        if (!$result) {\n            throw new \\RuntimeException('File write failed');\n        }\n\n        return true;\n    }", "label": 2}
{"code": "public function sendGetPrivacySettings()\n    {\n        $msgId = $this->nodeId['privacy_settings'] = $this->createIqId();\n        $privacyNode = new ProtocolNode('privacy', null, null, null);\n        $node = new ProtocolNode('iq',\n            [\n                'to'    => Constants::WHATSAPP_SERVER,\n                'id'    => $msgId,\n                'xmlns' => 'privacy',\n                'type'  => 'get',\n            ], [$privacyNode], null);\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "def interpret(line)\n      # is it a comment?\n      return nil if line.strip.start_with?(\"#\")\n\n      keyword, command = line.split(\"=\", 2).collect(&:strip)\n\n      # validate the keyword\n      if keyword.match(/\\s/i)\n        raise Errors::AliasInvalidError, alias: line, message: \"Alias keywords must not contain any whitespace.\"\n      end\n\n      [keyword, command]\n    end", "label": 4}
{"code": "public function get_global_config_path() {\n\n\t\tif ( getenv( 'WP_CLI_CONFIG_PATH' ) ) {\n\t\t\t$config_path                    = getenv( 'WP_CLI_CONFIG_PATH' );\n\t\t\t$this->global_config_path_debug = 'Using global config from WP_CLI_CONFIG_PATH env var: ' . $config_path;\n\t\t} else {\n\t\t\t$config_path                    = Utils\\get_home_dir() . '/.wp-cli/config.yml';\n\t\t\t$this->global_config_path_debug = 'Using default global config: ' . $config_path;\n\t\t}\n\n\t\tif ( is_readable( $config_path ) ) {\n\t\t\treturn $config_path;\n\t\t}\n\n\t\t$this->global_config_path_debug = 'No readable global config found';\n\n\t\treturn false;\n\t}", "label": 2}
{"code": "function processPartitionKeys(keys){\n    var result = \"(\",\n        j,\n        len,\n        keyGroup;\n\n    if(typeof keys === 'string'){\n        return result += keys + \")\";\n    }\n\n    len = keys.length;\n    for(j = 0; j< keys.length; j++){\n        keyGroup = keys[j];\n        if(keyGroup instanceof Array){\n            result += \"(\";\n            result += keyGroup.join(\", \");\n            result += \")\";\n        }else{\n            result += keyGroup;\n        }\n        result += (j < len-1) ? \", \" : \"\";\n    }\n    result += \")\";\n\n    return result;\n}", "label": 3}
{"code": "public function setTags($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->tags = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function getModulePath($module)\n    {\n        try {\n            return $this->findOrFail($module)->getPath() . '/';\n        } catch (ModuleNotFoundException $e) {\n            return $this->getPath() . '/' . Str::studly($module) . '/';\n        }\n    }", "label": 2}
{"code": "def add_chart(chart_type, options={})\n      TwoCellAnchor.new(self, options)\n      @anchors.last.add_chart(chart_type, options)\n    end", "label": 4}
{"code": "function getSuperCallInConstructor(constructor) {\n            var links = getNodeLinks(constructor);\n            // Only trying to find super-call if we haven't yet tried to find one.  Once we try, we will record the result\n            if (links.hasSuperCall === undefined) {\n                links.superCall = findFirstSuperCall(constructor.body);\n                links.hasSuperCall = links.superCall ? true : false;\n            }\n            return links.superCall;\n        }", "label": 3}
{"code": "func (bee *Bee) Logf(format string, args ...interface{}) {\n\ts := fmt.Sprintf(format, args...)\n\tlog.Printf(\"[%s]: %s\", bee.Name(), s)\n\tLog(bee.Name(), s, 0)\n}", "label": 5}
{"code": "public static base_response update(nitro_service client, snmptrap resource) throws Exception {\n\t\tsnmptrap updateresource = new snmptrap();\n\t\tupdateresource.trapclass = resource.trapclass;\n\t\tupdateresource.trapdestination = resource.trapdestination;\n\t\tupdateresource.destport = resource.destport;\n\t\tupdateresource.version = resource.version;\n\t\tupdateresource.communityname = resource.communityname;\n\t\tupdateresource.srcip = resource.srcip;\n\t\tupdateresource.severity = resource.severity;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "public static appflowglobal_binding get(nitro_service service) throws Exception{\n\t\tappflowglobal_binding obj = new appflowglobal_binding();\n\t\tappflowglobal_binding response = (appflowglobal_binding) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static nssimpleacl_stats get(nitro_service service) throws Exception{\n\t\tnssimpleacl_stats obj = new nssimpleacl_stats();\n\t\tnssimpleacl_stats[] response = (nssimpleacl_stats[])obj.stat_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "public function synchronize(callable $func, array $options = [])\n    {\n        $result = null;\n        $exception = null;\n\n        if ($this->acquire($options)) {\n            try {\n                $result = $func();\n            } catch (\\Exception $ex) {\n                $exception = $ex;\n            }\n            $this->release();\n        }\n\n        if ($exception) {\n            throw $exception;\n        }\n\n        return $result;\n    }", "label": 2}
{"code": "def ele_index(class_name, index)\n      results = tags(class_name)\n      if index == 'last()'\n        index = results.length\n        index -= 1 if index >= 0\n      else\n        raise 'Index must be >= 1' unless index >= 1\n\n        index -= 1 if index >= 1\n      end\n\n      # uiautomator has issues with index/instance so calculate the index\n      # client side.\n      results[index]\n    end", "label": 4}
{"code": "func (s *Server) HandleNewChan(wconn net.Conn, sconn *ssh.ServerConn, nch ssh.NewChannel) {\n\tidentityContext, err := s.authHandlers.CreateIdentityContext(sconn)\n\tif err != nil {\n\t\tnch.Reject(ssh.Prohibited, fmt.Sprintf(\"Unable to create identity from connection: %v\", err))\n\t\treturn\n\t}\n\n\tchannelType := nch.ChannelType()\n\tif s.proxyMode {\n\t\t// Channels of type \"session\" handle requests that are involved in running\n\t\t// commands on a server. In the case of proxy mode subsystem and agent\n\t\t// forwarding requests occur over the \"session\" channel.\n\t\tif channelType == \"session\" {\n\t\t\tch, requests, err := nch.Accept()\n\t\t\tif err != nil {\n\t\t\t\tlog.Warnf(\"Unable to accept channel: %v.\", err)\n\t\t\t\tnch.Reject(ssh.ConnectionFailed, fmt.Sprintf(\"unable to accept channel: %v\", err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgo s.handleSessionRequests(wconn, sconn, identityContext, ch, requests)\n\t\t} else {\n\t\t\tnch.Reject(ssh.UnknownChannelType, fmt.Sprintf(\"unknown channel type: %v\", channelType))\n\t\t}\n\t\treturn\n\t}\n\n\tswitch channelType {\n\t// Channels of type \"session\" handle requests that are involved in running\n\t// commands on a server, subsystem requests, and agent forwarding.\n\tcase \"session\":\n\t\tch, requests, err := nch.Accept()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Unable to accept channel: %v.\", err)\n\t\t\tnch.Reject(ssh.ConnectionFailed, fmt.Sprintf(\"unable to accept channel: %v\", err))\n\t\t\treturn\n\t\t}\n\t\tgo s.handleSessionRequests(wconn, sconn, identityContext, ch, requests)\n\t// Channels of type \"direct-tcpip\" handles request for port forwarding.\n\tcase \"direct-tcpip\":\n\t\treq, err := sshutils.ParseDirectTCPIPReq(nch.ExtraData())\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Failed to parse request data: %v, err: %v.\", string(nch.ExtraData()), err)\n\t\t\tnch.Reject(ssh.UnknownChannelType, \"failed to parse direct-tcpip request\")\n\t\t\treturn\n\t\t}\n\t\tch, _, err := nch.Accept()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Unable to accept channel: %v.\", err)\n\t\t\tnch.Reject(ssh.ConnectionFailed, fmt.Sprintf(\"unable to accept channel: %v\", err))\n\t\t\treturn\n\t\t}\n\t\tgo s.handleDirectTCPIPRequest(wconn, sconn, identityContext, ch, req)\n\tdefault:\n\t\tnch.Reject(ssh.UnknownChannelType, fmt.Sprintf(\"unknown channel type: %v\", channelType))\n\t}\n}", "label": 5}
{"code": "def normalize_friendly_id(value)\n      value = value.to_s.parameterize\n      value = value[0...friendly_id_config.slug_limit] if friendly_id_config.slug_limit\n      value\n    end", "label": 4}
{"code": "function (k, v) {\n        checkJobs.push(function (checkDone) {\n          api.elasticsearch.search(self.alias, [k], [v], 0, 2, null, 1, function (error, results) {\n            if (error) { return checkDone(error) }\n            if (results.length === 0) { return checkDone() }\n            if (results.length === 1 && results[0].guid === self.data.guid) { return checkDone() }\n            return checkDone(new Error('uniqueFields:' + k + ' uniqueness violated via #' + results[0].guid))\n          })\n        })\n      }", "label": 3}
{"code": "func (c *Client) GetSignupU2FRegisterRequest(token string) (u2fRegisterRequest *u2f.RegisterRequest, e error) {\n\tout, err := c.Get(c.Endpoint(\"u2f\", \"signuptokens\", token), url.Values{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar u2fRegReq u2f.RegisterRequest\n\tif err := json.Unmarshal(out.Bytes(), &u2fRegReq); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &u2fRegReq, nil\n}", "label": 5}
{"code": "func (s *Server) Start() error {\n\tif len(s.getCommandLabels()) > 0 {\n\t\ts.updateLabels()\n\t}\n\tgo s.heartbeat.Run()\n\n\t// If the server requested connections to it arrive over a reverse tunnel,\n\t// don't call Start() which listens on a socket, return right away.\n\tif s.useTunnel {\n\t\treturn nil\n\t}\n\treturn s.srv.Start()\n}", "label": 5}
{"code": "function (mime) {\n\n        var info = {\n                type: UNKNOWN,\n                format: RAW,\n                guessed: true\n            },\n            match,\n            base;\n\n        // extract the mime base\n        base = (base = mime.split(SEP)) && base[0] || E;\n\n        // bail out on the mime types that are sure-shot ones with no ambiguity\n        match = base.match(AUDIO_VIDEO_IMAGE_TEXT);\n        if (match && match[1]) {\n            info.type = info.format = match[1];\n\n            // we do special kane matching to extract the format in case the match was text\n            // this ensures that we get same formats like we will do in kane match later down the line\n            if (info.type === TEXT) {\n                match = mime.match(JSON_XML_SCRIPT_SIBLINGS);\n                info.format = match && match[1] || PLAIN;\n            }\n            return info;\n        }\n\n        // we do a kane match on entire mime (not just base) to find texts\n        match = mime.match(JSON_XML_SCRIPT_SIBLINGS);\n        if (match && match[1]) {\n            info.type = TEXT;\n            info.format = match[1];\n            return info;\n        }\n\n        // now we match the subtype having names from the sure shot bases\n        match = mime.match(AUDIO_VIDEO_IMAGE_TEXT_SUBTYPE);\n        if (match && match[1]) {\n            info.type = info.format = match[1];\n            return info;\n        }\n\n        // now that most text and sure-shot types and sub-types are out of our way, we detect standard bases\n        // and rest are unknown\n        match = base.match(APPLICATION_MESSAGE_MULTIPART);\n        if (match && match[1]) {\n            info.type = match[1];\n            info.format = RAW;\n            return info;\n        }\n\n        // at this point nothing has matched nothing. it is worth keeping a note of it\n        info.orphan = true;\n        return info;\n    }", "label": 3}
{"code": "func GetNetworkDescriptions(n *networking.Networking) []NetDescriber {\n\tvar nds []NetDescriber\n\tfor _, an := range n.GetActiveNetworks() {\n\t\tnds = append(nds, an)\n\t}\n\treturn nds\n}", "label": 5}
{"code": "public static dnscnamerec[] get(nitro_service service) throws Exception{\n\t\tdnscnamerec obj = new dnscnamerec();\n\t\tdnscnamerec[] response = (dnscnamerec[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "function clone(req, res, next) {\n  var cloneFormParams = {\n    _id: req.params.id,\n    name: req.body.name,\n    userEmail: req.body.updatedBy\n  };\n\n  logger.debug(\"Middleware: clone form: \", {params: cloneFormParams});\n\n  forms.cloneForm(_.extend(req.connectionOptions, cloneFormParams), formsResultHandlers(constants.resultTypes.forms, req, next));\n}", "label": 3}
{"code": "func (f *Finder) ObjectReference(ctx context.Context, ref types.ManagedObjectReference) (object.Reference, error) {\n\te, err := f.Element(ctx, ref)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr := object.NewReference(f.client, ref)\n\n\ttype common interface {\n\t\tSetInventoryPath(string)\n\t}\n\n\tr.(common).SetInventoryPath(e.Path)\n\n\tif f.dc != nil {\n\t\tif ds, ok := r.(*object.Datastore); ok {\n\t\t\tds.DatacenterPath = f.dc.InventoryPath\n\t\t}\n\t}\n\n\treturn r, nil\n}", "label": 5}
{"code": "def get(*args)\n      arguments(args, required: [:user, :repo, :sha])\n      user   = arguments.user\n      repo   = arguments.repo\n      sha    = arguments.sha\n      params = arguments.params\n\n      response = if params['recursive']\n        params['recursive'] = 1\n        get_request(\"/repos/#{user}/#{repo}/git/trees/#{sha}\", params)\n      else\n        get_request(\"/repos/#{user}/#{repo}/git/trees/#{sha.to_s}\", params)\n      end\n      return response unless block_given?\n      response.tree.each { |el| yield el }\n    end", "label": 4}
{"code": "public static base_response add(nitro_service client, snmptrap resource) throws Exception {\n\t\tsnmptrap addresource = new snmptrap();\n\t\taddresource.trapclass = resource.trapclass;\n\t\taddresource.trapdestination = resource.trapdestination;\n\t\taddresource.version = resource.version;\n\t\taddresource.destport = resource.destport;\n\t\taddresource.communityname = resource.communityname;\n\t\taddresource.srcip = resource.srcip;\n\t\taddresource.severity = resource.severity;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public function setCryptoKey($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\CryptoKey::class);\n        $this->writeOneof(4, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "def redirect_to(uri)\n      raise StateError, \"no Location header in redirect\" unless uri\n\n      verb = @request.verb\n      code = @response.status.code\n\n      if UNSAFE_VERBS.include?(verb) && STRICT_SENSITIVE_CODES.include?(code)\n        raise StateError, \"can't follow #{@response.status} redirect\" if @strict\n        verb = :get\n      end\n\n      verb = :get if !SEE_OTHER_ALLOWED_VERBS.include?(verb) && 303 == code\n\n      @request.redirect(uri, verb)\n    end", "label": 4}
{"code": "def remove(*args)\n      arguments(args, required: [:user, :repo, :number])\n      params = arguments.params\n      params['data'] = { 'assignees' => arguments.remaining } unless arguments.remaining.empty?\n\n      delete_request(\"/repos/#{arguments.user}/#{arguments.repo}/issues/#{arguments.number}/assignees\", params)\n    end", "label": 4}
{"code": "public function setDatabases($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Spanner\\Admin\\Database\\V1\\Database::class);\n        $this->databases = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function set_return_listener($callback)\n    {\n        if (!is_callable($callback)) {\n            throw new \\InvalidArgumentException(sprintf(\n                'Given callback \"%s\" should be callable. %s type was given.',\n                $callback,\n                gettype($callback)\n            ));\n        }\n\n        $this->basic_return_callback = $callback;\n    }", "label": 2}
{"code": "function (conn) {\n        \n\t\tLOG.error('AppManager disconnected', 'SR.AppConnector');\n\t\t\n\t\tif (SR.Settings.APPSERVER_AUTOSHUT === true) {\n\t\t\n\t\t\t// shutdown this frontier\n\t\t\tl_dispose();\n\t\t\tSR.Settings.FRONTIER.dispose();\n\t\t}\n\t\telse {\n\t\t\tLOG.warn('auto-shutdown is false, attempt to re-connect AppManager in ' + l_timeoutReconnect + ' ms...');\n\n\t\t\t// keep app server alive and try to re-connect if lobby shuts down\n\t\t\tsetTimeout(l_connect, l_timeoutReconnect);\n\t\t}\n    }", "label": 3}
{"code": "function(context, pkg, source) {\n\t\tsource = source || \"{}\";\n\t\tvar packageJSON = JSON.parse(source);\n\t\tutils.extend(pkg, packageJSON);\n\t\tcontext.packages.push(pkg);\n\t\treturn pkg;\n\t}", "label": 3}
{"code": "def server\n      require 'middleman-core'\n      require 'middleman-core/preview_server'\n\n      unless ENV['MM_ROOT']\n        puts '== Could not find a Middleman project config.rb'\n        exit\n      end\n\n      params = {\n        debug: options['verbose'],\n        instrumenting: options['instrument'],\n        reload_paths: options['reload_paths'],\n        daemon: options['daemon']\n      }\n\n      puts '== The Middleman is loading'\n      ::Middleman::PreviewServer.start(params, options)\n    end", "label": 4}
{"code": "public function save(JobConfig $config)\n    {\n        $shmid = shm_attach($this->sysvKey, $this->shmSize, $this->perm);\n        if ($shmid === false) {\n            throw new \\RuntimeException(\n                'Failed to attach to the shared memory'\n            );\n        }\n\n        // If the variable write fails, clear the memory and re-raise the exception\n        try {\n            $result = shm_put_var($shmid, self::VAR_KEY, $config);\n        } catch (\\Exception $e) {\n            $this->clear();\n            throw new \\RuntimeException($e->getMessage());\n        } finally {\n            shm_detach($shmid);\n        }\n        return $result;\n    }", "label": 2}
{"code": "def _p_iteration(self, P, Bp_solver, Vm, Va, pvpq):\n        \"\"\" Performs a P iteration, updates Va.\n        \"\"\"\n        dVa = -Bp_solver.solve(P)\n\n        # Update voltage.\n        Va[pvpq] = Va[pvpq] + dVa\n        V = Vm * exp(1j * Va)\n\n        return V, Vm, Va", "label": 1}
{"code": "@Override\n    public void onKeyDown(KeyDownEvent event) {\n\tchar c = MiscUtils.getCharCode(event.getNativeEvent());\n\tonKeyCodeEvent(event, box.getValue()+c);\n    }", "label": 0}
{"code": "function requireModule(filePath, refreshFlag) {\n    if (refreshFlag) {\n        delete injector.require.cache[filePath];\n    }\n    return injector.require(filePath);\n}", "label": 3}
{"code": "func (d *Decoder) Skip() error {\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch tok.(type) {\n\t\tcase StartElement:\n\t\t\tif err := d.Skip(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase EndElement:\n\t\t\treturn nil\n\t\t}\n\t}\n}", "label": 5}
{"code": "def to_html(self, index=False, escape=False, header=True,\n            collapse_table=True, class_outer=\"table_outer\", **kargs):\n        \"\"\"Return HTML version of the table\n\n        This is a wrapper of the to_html method of the pandas dataframe.\n\n        :param bool index: do not include the index\n        :param bool escape: do not escape special characters\n        :param bool header: include header\n        :param bool collapse_table: long tables are shorten with a scroll bar\n        :param kargs: any parameter accepted by\n            :meth:`pandas.DataFrame.to_html`\n\n        \"\"\"\n        _buffer = {}\n        for k, v in self.pd_options.items():\n            # save the current option\n            _buffer[k] = pd.get_option(k)\n            # set with user value\n            pd.set_option(k, v)\n\n        # class sortable is to use the sorttable javascript\n        # note that the class has one t and the javascript library has 2\n        # as in the original version of sorttable.js\n        table = self.df.to_html(escape=escape, header=header, index=index,\n                classes='sortable', **kargs)\n\n        # get back to default options\n        for k, v in _buffer.items():\n            pd.set_option(k, v)\n\n        # We wrap the table in a dedicated class/div nammed table_scroller\n        # that users must define.\n        return '<div class=\"%s\">' % class_outer + table+\"</div>\"", "label": 1}
{"code": "func standardFlags(cmd string) (*flag.FlagSet, *string) {\n\tf := flag.NewFlagSet(appName()+\" \"+cmd, flag.ExitOnError)\n\ttarget := f.String(\"target\", \"\", \"Make target (example: $(FOO_BINARY))\")\n\treturn f, target\n}", "label": 5}
{"code": "def format_rst(self):\n        \"\"\"\n        return table in RST format\n        \"\"\"\n        res = ''\n        num_cols = len(self.header)\n        col_width = 25\n        for _ in range(num_cols):\n            res += ''.join(['=' for _ in range(col_width - 1)]) + ' ' \n        res += '\\n'\n        for c in self.header:\n            res += c.ljust(col_width) \n        res += '\\n'\n        for _ in range(num_cols):\n            res += ''.join(['=' for _ in range(col_width - 1)]) + ' ' \n        res += '\\n'\n        for row in self.arr:\n            for c in row:\n                res += self.force_to_string(c).ljust(col_width)\n            res += '\\n' \n        for _ in range(num_cols):\n            res += ''.join(['=' for _ in range(col_width - 1)]) + ' ' \n        res += '\\n'\n        return res", "label": 1}
{"code": "def predict_proba(self, X):\n        \"\"\"\n        Calculate posterior probabilities of test data.\n\n        Parameters\n        ----------\n        X : array\n            Test data, of dimension N times d (rows are examples, columns\n            are data dimensions)\n\n        Returns:\n        -------\n        y_prob : array\n            An array of dimension N times n_inlier_classes+1, containing\n            the probabilities of each row of X being one of the inlier\n            classes, or the outlier class (last column).\n        \"\"\"\n        Phi = metrics.pairwise.rbf_kernel(X, self.kernel_pos, self.gamma)\n        N = X.shape[0]\n        predictions = np.zeros((N, self.n_classes+1))\n        for i in range(N):\n            post = np.zeros(self.n_classes)\n            for c in range(self.n_classes):\n                post[c] = max(0,\n                              np.dot(self.theta[self.classes[c]].T, Phi[i, :]))\n                post[c] = min(post[c], 1.)\n            predictions[i, :-1] = post\n            predictions[i, -1] = max(0, 1-sum(post))\n\n        return predictions", "label": 1}
{"code": "function getResolvedSymbol(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedSymbol) {\n                links.resolvedSymbol = !ts.nodeIsMissing(node) && resolveName(node, node.text, 107455 /* Value */ | 1048576 /* ExportValue */, ts.Diagnostics.Cannot_find_name_0, node) || unknownSymbol;\n            }\n            return links.resolvedSymbol;\n        }", "label": 3}
{"code": "def provisioning_profiles_via_xcode_api(mac: false)\n      req = request(:post) do |r|\n        r.url(\"https://developerservices2.apple.com/services/#{PROTOCOL_VERSION}/#{platform_slug(mac)}/listProvisioningProfiles.action\")\n        r.params = {\n          teamId: team_id,\n          includeInactiveProfiles: true,\n          onlyCountLists: true\n        }\n      end\n\n      result = parse_response(req, 'provisioningProfiles')\n\n      csrf_cache[Spaceship::Portal::ProvisioningProfile] = self.csrf_tokens\n\n      result\n    end", "label": 4}
{"code": "public function setMessages($locale, $messages)\n    {\n        $this->loadMessagesFromFile($locale);\n        $this->addResource('array', $messages, $locale);\n        $this->messages[$locale] = array_merge(\n            isset($this->messages[$locale]) ? $this->messages[$locale] : [],\n            $messages\n        );\n\n        return $this;\n    }", "label": 2}
{"code": "public static aaauser_vpntrafficpolicy_binding[] get(nitro_service service, String username) throws Exception{\n\t\taaauser_vpntrafficpolicy_binding obj = new aaauser_vpntrafficpolicy_binding();\n\t\tobj.set_username(username);\n\t\taaauser_vpntrafficpolicy_binding response[] = (aaauser_vpntrafficpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "@Override\n\tpublic Trajectory subList(int fromIndex, int toIndex) {\n\t\tTrajectory t = new Trajectory(dimension);\n\t\t\n\t\tfor(int i = fromIndex; i < toIndex; i++){\n\t\t\tt.add(this.get(i));\n\t\t}\n\t\treturn t;\n\t}", "label": 0}
{"code": "function isAutostartEnabled(key, callback) {\n  if (arguments.length < 1) {\n    throw new Error('Not enough arguments passed to isAutostartEnabled()');\n  } else if (typeof key !== 'string') {\n    throw new TypeError('Passed \"key\" to disableAutostart() is not a string.');\n  }\n\n  if (typeof callback !== 'function') {\n    return new Promise((resolve, reject) => {\n      autostart.isAutostartEnabled(key, (error, isEnabled) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(isEnabled);\n        }\n      });\n    });\n  }\n\n  autostart.isAutostartEnabled(key, (error, isEnabled) => {\n    callback(error, isEnabled);\n  });\n}", "label": 3}
{"code": "private function platformSupportsRowNumber()\n    {\n        return $this->platform instanceof PostgreSqlPlatform\n            || $this->platform instanceof SQLServerPlatform\n            || $this->platform instanceof OraclePlatform\n            || $this->platform instanceof SQLAnywherePlatform\n            || $this->platform instanceof DB2Platform\n            || (method_exists($this->platform, 'supportsRowNumberFunction')\n                && $this->platform->supportsRowNumberFunction());\n    }", "label": 2}
{"code": "def diagnose filename\n      # @todo Only open files get diagnosed. Determine whether anything or\n      #   everything in the workspace should get diagnosed, or if there should\n      #   be an option to do so.\n      #\n      return [] unless open?(filename)\n      catalog\n      result = []\n      source = read(filename)\n      workspace.config.reporters.each do |name|\n        reporter = Diagnostics.reporter(name)\n        raise DiagnosticsError, \"Diagnostics reporter #{name} does not exist\" if reporter.nil?\n        result.concat reporter.new.diagnose(source, api_map)\n      end\n      result\n    end", "label": 4}
{"code": "def write_generator_data(self, file):\n        \"\"\" Write generator data to file.\n        \"\"\"\n        generator_sheet = self.book.add_sheet(\"Generators\")\n\n        for j, generator in enumerate(self.case.generators):\n            i = generator.bus._i\n            for k, attr in enumerate(GENERATOR_ATTRS):\n                generator_sheet.write(j, 0, i)", "label": 1}
{"code": "public static base_responses update(nitro_service client, vpnurl resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tvpnurl updateresources[] = new vpnurl[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new vpnurl();\n\t\t\t\tupdateresources[i].urlname = resources[i].urlname;\n\t\t\t\tupdateresources[i].linkname = resources[i].linkname;\n\t\t\t\tupdateresources[i].actualurl = resources[i].actualurl;\n\t\t\t\tupdateresources[i].clientlessaccess = resources[i].clientlessaccess;\n\t\t\t\tupdateresources[i].comment = resources[i].comment;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "func ParseBool(value string) (bool, error) {\n\tswitch strings.ToLower(value) {\n\tcase \"yes\", \"yeah\", \"y\", \"true\", \"1\", \"on\":\n\t\treturn true, nil\n\tcase \"no\", \"nope\", \"n\", \"false\", \"0\", \"off\":\n\t\treturn false, nil\n\tdefault:\n\t\treturn false, trace.BadParameter(\"unsupported value: %q\", value)\n\t}\n}", "label": 5}
{"code": "function (definition) {\n                var\n                    result = new gpf.Parameter(),\n                    typeDefaultValue;\n                if (definition === gpf.Parameter.VERBOSE\n                    || definition.prefix === gpf.Parameter.VERBOSE) {\n                    definition = {\n                        name: \"verbose\",\n                        description: \"Enable verbose mode\",\n                        type: \"boolean\",\n                        defaultValue: false,\n                        prefix: gpf.Parameter.VERBOSE\n                    };\n                } else if (definition === gpf.Parameter.HELP\n                           || definition.prefix === gpf.Parameter.HELP) {\n                    definition = {\n                        name: \"help\",\n                        description: \"Display help\",\n                        type: \"boolean\",\n                        defaultValue: false,\n                        prefix: gpf.Parameter.HELP\n                    };\n                }\n                gpf.json.load(result, definition);\n                // name is required\n                if (!result._name) {\n                    gpf.Error.paramsNameRequired();\n                }\n                if (!result._multiple) {\n                    /**\n                     * When multiple is used, the default value will be an array\n                     * if not specified.\n                     * Otherwise, we get the default value based on the type\n                     */\n                    typeDefaultValue = this.DEFAULTS[result._type];\n                    if (undefined === typeDefaultValue) {\n                        gpf.Error.paramsTypeUnknown();\n                    }\n                    if (result.hasOwnProperty(\"_defaultValue\")) {\n                        result._defaultValue =\n                            gpf.value(result._defaultValue, typeDefaultValue,\n                                result._type);\n                    }\n                }\n                return result;\n            }", "label": 3}
{"code": "protected function nestedListing($key, $type, $value)\n    {\n        if (is_int($key)) {\n            return $this->listing($type, $value);\n        } else {\n            return '<li>' . $key . $this->listing($type, $value) . '</li>';\n        }\n    }", "label": 2}
{"code": "function walkPages(pages, drizzleData, writePromises = []) {\n  if (isPage(pages)) {\n    return writePage(\n      pages.id,\n      pages,\n      drizzleData.options.dest.pages,\n      drizzleData.options.keys.pages.plural\n    );\n  }\n  for (var pageKey in pages) {\n    writePromises = writePromises.concat(\n      walkPages(pages[pageKey], drizzleData, writePromises)\n    );\n  }\n  return writePromises;\n}", "label": 3}
{"code": "public function setNodePool($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Container\\V1\\NodePool::class);\n        $this->node_pool = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function loadPluginsForType(type, options, version, compress) {\n  // Start with default if available\n  let plugins = type in allPlugins && allPlugins[type].default ? allPlugins[type].default.slice() : [];\n\n  // Add plugins based on version presets\n  plugins = version.reduce((plugins, preset) => {\n    let presetPlugins;\n\n    if ('string' == typeof preset) {\n      preset = preset.toLowerCase();\n      // Ignore generic\n      if (RE_GENERIC_VERSION.test(preset)) return plugins;\n      // Skip if babel version and type is postcss\n      if (type == 'postcss' && preset in allPlugins.babel) return plugins;\n\n      presetPlugins = allPlugins[type][preset];\n      // Try and parse with browserslist if no match\n      if (!presetPlugins) preset = { browsers: [preset] };\n    }\n\n    // Handle object ({ chrome: 5 }, { browsers: ['last 3'] })\n    if (!presetPlugins && 'string' != typeof preset) {\n      const key = Object.keys(preset)[0];\n      const value = preset[key];\n\n      if (key == 'browsers' && Array.isArray(value)) {\n        if (type == 'postcss') {\n          // Add Autoprefixer and pass-through\n          presetPlugins = [['autoprefixer', preset]];\n        } else if (type == 'babel') {\n          try {\n            // Add Babel plugins based on Autoprefixer-style config\n            presetPlugins = resolvePluginsForBrowsers(\n              browserslist(value).map(browser => {\n                const [name, version] = browser.split(' ');\n\n                return { [name]: version };\n              })\n            );\n          } catch (err) {\n            /* invalid browserslist value */\n          }\n        }\n      } else {\n        // See if concated key+value exists already\n        presetPlugins =\n          allPlugins[type][(key + value).toLowerCase()] || (type == 'babel' && resolvePluginsForBrowsers(preset));\n      }\n    }\n\n    if (!presetPlugins) warn(`unable to resolve plugins for ${strong(preset)} version`, 1);\n\n    return unique(plugins.concat(presetPlugins || []));\n  }, plugins);\n\n  // Add compression plugins\n  if (compress && type in allPlugins && allPlugins[type].compress) {\n    plugins.push(...allPlugins[type].compress);\n  }\n\n  // Add plugins defined in build (add before current plugins, but preserve order)\n  for (let i = options.plugins.length - 1; i >= 0; i--) {\n    const plugin = options.plugins[i];\n    const pluginName = Array.isArray(plugin) ? plugin[0] : plugin;\n    let exists = false;\n\n    plugins.some((existingPlugin, idx) => {\n      const existingPluginName = Array.isArray(existingPlugin) ? existingPlugin[0] : existingPlugin;\n\n      // Overwrite if exists\n      if (pluginName == existingPluginName) {\n        plugins[idx] = plugin;\n        exists = true;\n      }\n\n      return exists;\n    });\n\n    if (!exists) plugins.unshift(plugin);\n  }\n  options.plugins = plugins;\n  // Store hash of plugin names\n  options.fingerprint = md5(JSON.stringify(options));\n  // Install missing dependencies\n  dependencies.install(extractDependencyIds(options));\n  resolveDependencyPaths(options);\n}", "label": 3}
{"code": "def _acronym_lic(self, license_statement):\n        \"\"\"Convert license acronym.\"\"\"\n        pat = re.compile(r'\\(([\\w+\\W?\\s?]+)\\)')\n        if pat.search(license_statement):\n            lic = pat.search(license_statement).group(1)\n            if lic.startswith('CNRI'):\n                acronym_licence = lic[:4]\n            else:\n                acronym_licence = lic.replace(' ', '')\n        else:\n            acronym_licence = ''.join(\n                [w[0]\n                 for w in license_statement.split(self.prefix_lic)[1].split()])\n        return acronym_licence", "label": 1}
{"code": "private boolean isCacheable(PipelineContext context) throws GeomajasException {\n\t\tVectorLayer layer = context.get(PipelineCode.LAYER_KEY, VectorLayer.class);\n\t\treturn !(layer instanceof VectorLayerLazyFeatureConversionSupport &&\n\t\t\t\t((VectorLayerLazyFeatureConversionSupport) layer).useLazyFeatureConversion());\n\t}", "label": 0}
{"code": "def needs_fixity_check?(latest_fixity_check)\n        return true unless latest_fixity_check\n        unless latest_fixity_check.updated_at\n          logger.warn \"***FIXITY*** problem with fixity check log! Latest Fixity check is not nil, but updated_at is not set #{latest_fixity_check}\"\n          return true\n        end\n        days_since_last_fixity_check(latest_fixity_check) >= max_days_between_fixity_checks\n      end", "label": 4}
{"code": "func (c *Client) Retrieve(ctx context.Context, objs []types.ManagedObjectReference, p []string, dst interface{}) error {\n\treturn c.PropertyCollector().Retrieve(ctx, objs, p, dst)\n}", "label": 5}
{"code": "function isWhitelisted(url) {\n\t\treturn options.adiPathFilter.some(function (route) {\n\t\t\treturn url.substr(0, route.length) === route;\n\t\t});\n\t}", "label": 3}
{"code": "public static clusterinstance get(nitro_service service, Long clid) throws Exception{\n\t\tclusterinstance obj = new clusterinstance();\n\t\tobj.set_clid(clid);\n\t\tclusterinstance response = (clusterinstance) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def arcsin_sqrt(biom_tbl):\n    \"\"\"\n    Applies the arcsine square root transform to the\n    given BIOM-format table\n    \"\"\"\n    arcsint = lambda data, id_, md: np.arcsin(np.sqrt(data))\n\n    tbl_relabd = relative_abd(biom_tbl)\n    tbl_asin = tbl_relabd.transform(arcsint, inplace=False)\n\n    return tbl_asin", "label": 1}
{"code": "def validate_member_type(self, value):\n        \"\"\"Validate each member of the list, if member_type exists\"\"\"\n        if self.member_type:\n            for item in value:\n                self.member_type.validate(item)", "label": 1}
{"code": "def filter_form_for(filter, url = url_for)\n      content_tag :div, class: \"filters\" do\n        form_for filter, namespace: filter_form_namespace, builder: FilterFormBuilder, url: url, as: :filter, method: :get, remote: true, html: { id: nil } do |form|\n          yield form\n        end\n      end\n    end", "label": 4}
{"code": "def create_random_population(num=100):\n    \"\"\"\n    create a list of people with randomly generated names and stats\n    \"\"\"\n    people = []\n    for _ in range(num):\n        nme = 'blah'\n        tax_min = random.randint(1,40)/100\n        tax_max = tax_min + random.randint(1,40)/100\n        tradition = random.randint(1,100)/100\n        equity = random.randint(1,100)/100\n        pers = mod_hap_env.Person(nme, {'tax_min':tax_min, 'tax_max':tax_max, 'tradition':tradition, 'equity':equity})\n        people.append(pers)\n        print(pers)\n\n    return people", "label": 1}
{"code": "public static spilloverpolicy get(nitro_service service, String name) throws Exception{\n\t\tspilloverpolicy obj = new spilloverpolicy();\n\t\tobj.set_name(name);\n\t\tspilloverpolicy response = (spilloverpolicy) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def collect_mimes_from_class_level #:nodoc:\n      action = action_name.to_sym\n\n      self.class.mimes_for_respond_to.keys.select do |mime|\n        config = self.class.mimes_for_respond_to[mime]\n\n        if config[:except]\n          !config[:except].include?(action)\n        elsif config[:only]\n          config[:only].include?(action)\n        else\n          true\n        end\n      end\n    end", "label": 4}
{"code": "def run_log      \n        log = @base.lib.full_log_commits(:count => @count, :object => @object, \n                                    :path_limiter => @path, :since => @since, \n                                    :author => @author, :grep => @grep, :skip => @skip,\n                                    :until => @until, :between => @between)\n        @commits = log.map { |c| Git::Object::Commit.new(@base, c['sha'], c) }\n      end", "label": 4}
{"code": "function parseObject(obj, { name, path, subPaths, type, recursive = true, ...args }) {\n    let property = get(obj, path);\n    if (property === null || !validatePropertyType(property, type, recursive)) {\n        return [];\n    }\n    if (type === 'uuidList' && isUuidList(property)) {\n        return [{ [name]: property.split(',') }];\n    }\n    if (recursive && typeof property === 'object') {\n        const propertyName = isNil(name) ? '' : name;\n        const nextPaths = subPaths || Object.keys(property);\n        return flatten(nextPaths\n            .map(subPath => parseObject(obj, {\n                name: `${propertyName}${subPath}`,\n                path: `${path}.${subPath}`,\n                recursive: false,\n                type,\n                ...args,\n            })));\n    }\n    if (args.filterPattern) {\n        property = typeof property === 'string' ? get(property.match(args.filterPattern), '[1]') : null;\n    }\n    if (args.hideUUID) {\n        property = typeof property === 'string' ? property.replace(\n            RegExp('[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}', 'g'),\n            '{uuid}',\n        ) : null;\n    }\n    return property === null ? [] : [{ [name]: property }];\n}", "label": 3}
{"code": "func (s *ID) Set(v string) error {\n\tid, err := ParseID(v)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t*s = *id\n\treturn nil\n}", "label": 5}
{"code": "private ClassDescriptor discoverDescriptor(Class clazz)\r\n    {\r\n        ClassDescriptor result = (ClassDescriptor) descriptorTable.get(clazz.getName());\r\n\r\n        if (result == null)\r\n        {\r\n            Class superClass = clazz.getSuperclass();\r\n            // only recurse if the superClass is not java.lang.Object\r\n            if (superClass != null)\r\n            {\r\n                result = discoverDescriptor(superClass);\r\n            }\r\n            if (result == null)\r\n            {\r\n                // we're also checking the interfaces as there could be normal\r\n                // mappings for them in the repository (using factory-class,\r\n                // factory-method, and the property field accessor)\r\n                Class[] interfaces = clazz.getInterfaces();\r\n\r\n                if ((interfaces != null) && (interfaces.length > 0))\r\n                {\r\n                    for (int idx = 0; (idx < interfaces.length) && (result == null); idx++)\r\n                    {\r\n                        result = discoverDescriptor(interfaces[idx]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (result != null)\r\n            {\r\n                /**\r\n                 * Kuali Foundation modification -- 6/19/2009\r\n                 */\r\n            \tsynchronized (descriptorTable) {\r\n                /**\r\n                 * End of Kuali Foundation modification\r\n                 */\r\n            \t\tdescriptorTable.put(clazz.getName(), result);\r\n                /**\r\n                 * Kuali Foundation modification -- 6/19/2009\r\n                 */\r\n            \t}\r\n                /**\r\n                 * End of Kuali Foundation modification\r\n                 */\r\n            }\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "func newSink(c influxdb_common.InfluxdbConfig) core.EventSink {\n\tclient, err := influxdb_common.NewClient(c)\n\tif err != nil {\n\t\tglog.Errorf(\"issues while creating an InfluxDB sink: %v, will retry on use\", err)\n\t}\n\treturn &influxdbSink{\n\t\tclient: client, // can be nil\n\t\tc:      c,\n\t}\n}", "label": 5}
{"code": "function sendAjaxRequest(url, data, execOptions) {\n            var xhr = new XMLHttpRequest();\n            var d = vow.defer();\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === XMLHttpRequest.DONE) {\n                    if (xhr.status === 200) {\n                        d.resolve(JSON.parse(xhr.responseText));\n                    } else {\n                        d.reject(xhr);\n                    }\n                }\n            };\n            xhr.ontimeout = function () {\n                d.reject(new ApiError(ApiError.TIMEOUT, 'Timeout was reached while waiting for ' + url));\n                xhr.abort();\n            };\n\n            // shim for browsers which don't support timeout/ontimeout\n            if (typeof xhr.timeout !== 'number' && execOptions.timeout) {\n                var timeoutId = setTimeout(xhr.ontimeout.bind(xhr), execOptions.timeout);\n                var oldHandler = xhr.onreadystatechange;\n                xhr.onreadystatechange = function () {\n                    if (xhr.readyState === XMLHttpRequest.DONE) {\n                        clearTimeout(timeoutId);\n                    }\n                    oldHandler();\n                };\n            }\n\n            xhr.open('POST', url, true);\n            xhr.timeout = execOptions.timeout;\n            xhr.setRequestHeader('Accept', 'application/json, text/javascript, */*; q=0.01');\n            xhr.setRequestHeader('Content-type', 'application/json');\n            xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n            xhr.send(data);\n\n            return d.promise();\n        }", "label": 3}
{"code": "public ClientLayerInfo securityClone(ClientLayerInfo original) {\n\t\t// the data is explicitly copied as this assures the security is considered when copying.\n\t\tif (null == original) {\n\t\t\treturn null;\n\t\t}\n\t\tClientLayerInfo client = null;\n\t\tString layerId = original.getServerLayerId();\n\t\tif (securityContext.isLayerVisible(layerId)) {\n\t\t\tclient = (ClientLayerInfo) SerializationUtils.clone(original);\n\t\t\tclient.setWidgetInfo(securityClone(original.getWidgetInfo()));\n\t\t\tclient.getLayerInfo().setExtraInfo(securityCloneLayerExtraInfo(original.getLayerInfo().getExtraInfo()));\n\t\t\tif (client instanceof ClientVectorLayerInfo) {\n\t\t\t\tClientVectorLayerInfo vectorLayer = (ClientVectorLayerInfo) client;\n\t\t\t\t// set statuses\n\t\t\t\tvectorLayer.setCreatable(securityContext.isLayerCreateAuthorized(layerId));\n\t\t\t\tvectorLayer.setUpdatable(securityContext.isLayerUpdateAuthorized(layerId));\n\t\t\t\tvectorLayer.setDeletable(securityContext.isLayerDeleteAuthorized(layerId));\n\t\t\t\t// filter feature info\n\t\t\t\tFeatureInfo featureInfo = vectorLayer.getFeatureInfo();\n\t\t\t\tList<AttributeInfo> originalAttr = featureInfo.getAttributes();\n\t\t\t\tList<AttributeInfo> filteredAttr = new ArrayList<AttributeInfo>();\n\t\t\t\tfeatureInfo.setAttributes(filteredAttr);\n\t\t\t\tfor (AttributeInfo ai : originalAttr) {\n\t\t\t\t\tif (securityContext.isAttributeReadable(layerId, null, ai.getName())) {\n\t\t\t\t\t\tfilteredAttr.add(ai);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn client;\n\t}", "label": 0}
{"code": "private function registerRoutes()\n    {\n        $path = config('wink.path');\n        $middlewareGroup = config('wink.middleware_group');\n\n        Route::namespace('Wink\\Http\\Controllers')\n            ->middleware($middlewareGroup)\n            ->as('wink.')\n            ->prefix($path)\n            ->group(function () {\n                Route::get('/login', 'LoginController@showLoginForm')->name('auth.login');\n                Route::post('/login', 'LoginController@login')->name('auth.attempt');\n\n                Route::get('/password/forgot', 'ForgotPasswordController@showResetRequestForm')->name('password.forgot');\n                Route::post('/password/forgot', 'ForgotPasswordController@sendResetLinkEmail')->name('password.email');\n                Route::get('/password/reset/{token}', 'ForgotPasswordController@showNewPassword')->name('password.reset');\n            });\n\n        Route::namespace('Wink\\Http\\Controllers')\n            ->middleware([$middlewareGroup, Authenticate::class])\n            ->as('wink.')\n            ->prefix($path)\n            ->group(function () {\n                $this->loadRoutesFrom(__DIR__.'/Http/routes.php');\n            });\n    }", "label": 2}
{"code": "public void setConnection(JdbcConnectionDescriptor jcd) throws PlatformException\r\n    {\r\n        _jcd = jcd;\r\n\r\n        String targetDatabase = (String)_dbmsToTorqueDb.get(_jcd.getDbms().toLowerCase());\r\n\r\n        if (targetDatabase == null)\r\n        {\r\n            throw new PlatformException(\"Database \"+_jcd.getDbms()+\" is not supported by torque\");\r\n        }\r\n        if (!targetDatabase.equals(_targetDatabase))\r\n        {\r\n            _targetDatabase = targetDatabase;\r\n            _creationScript = null;\r\n            _initScripts.clear();\r\n        }\r\n    }", "label": 0}
{"code": "function applyPatches (versions) {\n    versions = sortVersions(versions, 'ASC')\n\n    let state = []\n    // iterate patches to the final one => get previous commit state\n    versions.forEach((v) => {\n      v.changes.forEach((c) => {\n        if (c.operation === 'insert') {\n          return state.push({\n            entityId: c.entityId,\n            entitySet: c.entitySet,\n            entity: parse(c.serializedDoc),\n            path: c.path\n          })\n        }\n\n        if (c.operation === 'remove') {\n          state = state.filter((e) => e.entityId !== c.entityId)\n          return\n        }\n\n        const entityState = state.find((e) => e.entityId === c.entityId)\n        applyPatch(entityState.entity, parse(c.serializedPatch), c.entitySet, documentModel)\n      })\n    })\n    return state\n  }", "label": 3}
{"code": "def serialized_element_attributes(str='', additional_attributes=[], &block)\n      attrs = self.class.xml_element_attributes + additional_attributes\n      values = instance_values\n      attrs.each do |attribute_name|\n        value = values[attribute_name.to_s]\n        next if value.nil?\n        value = yield value if block_given?\n        element_name = Axlsx.camel(attribute_name, false)\n        str << \"<#{element_name}>#{value}</#{element_name}>\"\n      end\n      str\n    end", "label": 4}
{"code": "public function loadMedia(string $collectionName)\n    {\n        $collection = $this->exists\n            ? $this->media\n            : collect($this->unAttachedMediaLibraryItems)->pluck('media');\n\n        return $collection\n            ->filter(function (Media $mediaItem) use ($collectionName) {\n                if ($collectionName == '') {\n                    return true;\n                }\n\n                return $mediaItem->collection_name === $collectionName;\n            })\n            ->sortBy('order_column')\n            ->values();\n    }", "label": 2}
{"code": "func (r *Registry) OptionManager() *OptionManager {\n\treturn r.Get(r.content().Setting.Reference()).(*OptionManager)\n}", "label": 5}
{"code": "private void sortFields()\r\n    {\r\n        HashMap            fields          = new HashMap();\r\n        ArrayList          fieldsWithId    = new ArrayList();\r\n        ArrayList          fieldsWithoutId = new ArrayList();\r\n        FieldDescriptorDef fieldDef;\r\n\r\n        for (Iterator it = getFields(); it.hasNext(); )\r\n        {\r\n            fieldDef = (FieldDescriptorDef)it.next();\r\n            fields.put(fieldDef.getName(), fieldDef);\r\n            if (fieldDef.hasProperty(PropertyHelper.OJB_PROPERTY_ID))\r\n            {\r\n                fieldsWithId.add(fieldDef.getName());\r\n            }\r\n            else\r\n            {\r\n                fieldsWithoutId.add(fieldDef.getName());\r\n            }\r\n        }\r\n\r\n        Collections.sort(fieldsWithId, new FieldWithIdComparator(fields));\r\n\r\n        ArrayList result = new ArrayList();\r\n\r\n        for (Iterator it = fieldsWithId.iterator(); it.hasNext();)\r\n        {\r\n            result.add(getField((String)it.next()));\r\n        }\r\n        for (Iterator it = fieldsWithoutId.iterator(); it.hasNext();)\r\n        {\r\n            result.add(getField((String)it.next()));\r\n        }\r\n\r\n        _fields = result;\r\n    }", "label": 0}
{"code": "public static function batch(\n        AwsClientInterface $client,\n        $commands,\n        array $config = []\n    ) {\n        $results = [];\n        self::cmpCallback($config, 'fulfilled', $results);\n        self::cmpCallback($config, 'rejected', $results);\n\n        return (new self($client, $commands, $config))\n            ->promise()\n            ->then(static function () use (&$results) {\n                ksort($results);\n                return $results;\n            })\n            ->wait();\n    }", "label": 2}
{"code": "def before_node_visit(node)\n      return unless (commands = Array(extract_commands(node))).any?\n\n      commands.each do |command|\n        linters = command[:linters]\n        next unless linters.include?('all') || linters.include?(@linter.name)\n\n        process_command(command, node)\n\n        # Is the control comment the only thing on this line?\n        next if node.is_a?(Sass::Tree::RuleNode) ||\n                  %r{^\\s*(//|/\\*)}.match(@linter.engine.lines[command[:line] - 1])\n\n        # Otherwise, pop since we only want comment to apply to the single line\n        pop_control_comment_stack(node)\n      end\n    end", "label": 4}
{"code": "private function decorateWithHashes(Stream $stream, array &$data)\n    {\n        // Make sure that a tree hash is calculated.\n        $stream = new HashingStream($stream, new TreeHash(),\n            function ($result) use (&$data) {\n                $data['checksum'] = bin2hex($result);\n            }\n        );\n\n        // Make sure that a linear SHA256 hash is calculated.\n        $stream = new HashingStream($stream, new PhpHash('sha256'),\n            function ($result) use (&$data) {\n                $data['ContentSHA256'] = bin2hex($result);\n            }\n        );\n\n        return $stream;\n    }", "label": 2}
{"code": "public DataSetInfo create(int dataSet) throws InvalidDataSetException {\r\n\t\tDataSetInfo info = dataSets.get(createKey(dataSet));\r\n\t\tif (info == null) {\r\n\t\t\tint recordNumber = (dataSet >> 8) & 0xFF;\r\n\t\t\tint dataSetNumber = dataSet & 0xFF;\r\n\t\t\tthrow new UnsupportedDataSetException(recordNumber + \":\" + dataSetNumber);\r\n\t\t\t// info = super.create(dataSet);\r\n\t\t}\r\n\t\treturn info;\r\n\t}", "label": 0}
{"code": "public static systemsession[] get(nitro_service service, Long sid[]) throws Exception{\n\t\tif (sid !=null && sid.length>0) {\n\t\t\tsystemsession response[] = new systemsession[sid.length];\n\t\t\tsystemsession obj[] = new systemsession[sid.length];\n\t\t\tfor (int i=0;i<sid.length;i++) {\n\t\t\t\tobj[i] = new systemsession();\n\t\t\t\tobj[i].set_sid(sid[i]);\n\t\t\t\tresponse[i] = (systemsession) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "private Method getPropertySourceMethod(Object sourceObject,\r\n\t\t\tObject destinationObject, String destinationProperty) {\r\n\t\tBeanToBeanMapping beanToBeanMapping = beanToBeanMappings.get(ClassPair\r\n\t\t\t\t.get(sourceObject.getClass(), destinationObject\r\n\t\t\t\t\t\t.getClass()));\r\n\t\tString sourceProperty = null;\r\n\t\tif (beanToBeanMapping != null) {\r\n\t\t\tsourceProperty = beanToBeanMapping\r\n\t\t\t\t\t.getSourceProperty(destinationProperty);\r\n\t\t}\r\n\t\tif (sourceProperty == null) {\r\n\t\t\tsourceProperty = destinationProperty;\r\n\t\t}\r\n\r\n\t\treturn BeanUtils.getGetterPropertyMethod(sourceObject.getClass(),\r\n\t\t\t\tsourceProperty);\r\n\t}", "label": 0}
{"code": "private function isSessionValid(array $session)\n    {\n        $halfHourBeforeExpiration = $session['expiration'] - (SessionPoolInterface::SESSION_EXPIRATION_SECONDS / 2);\n\n        if ($this->time() < $halfHourBeforeExpiration) {\n            return true;\n        } elseif ($halfHourBeforeExpiration < $this->time() && $this->time() < $session['expiration']) {\n            return $this->database\n                ->session($session['name'])\n                ->exists();\n        }\n\n        return false;\n    }", "label": 2}
{"code": "function getScanStartPosition(enclosingNode, originalRange, sourceFile) {\n            var start = enclosingNode.getStart(sourceFile);\n            if (start === originalRange.pos && enclosingNode.end === originalRange.end) {\n                return start;\n            }\n            var precedingToken = ts.findPrecedingToken(originalRange.pos, sourceFile);\n            if (!precedingToken) {\n                // no preceding token found - start from the beginning of enclosing node\n                return enclosingNode.pos;\n            }\n            // preceding token ends after the start of original range (i.e when originalRange.pos falls in the middle of literal)\n            // start from the beginning of enclosingNode to handle the entire 'originalRange'\n            if (precedingToken.end >= originalRange.pos) {\n                return enclosingNode.pos;\n            }\n            return precedingToken.end;\n        }", "label": 3}
{"code": "func (s *Service) backoff() {\n\tif s.delay < maxDelay {\n\t\tif s.delay > 0 {\n\t\t\td := s.delay * 2\n\t\t\tif d > s.delay && d < maxDelay {\n\t\t\t\ts.delay = d\n\t\t\t} else {\n\t\t\t\ts.delay = maxDelay\n\t\t\t}\n\t\t} else {\n\t\t\ts.delay = 1\n\t\t}\n\t}\n}", "label": 5}
{"code": "def notify(event)\n      fail NoEventError, 'Please pass an event object, not a class' if event.is_a?(Class)\n\n      @handlers[event.class.to_s].each { |handler| handler.call(event) }\n    end", "label": 4}
{"code": "public static dnssrvrec[] get(nitro_service service, dnssrvrec_args args) throws Exception{\n\t\tdnssrvrec obj = new dnssrvrec();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\tdnssrvrec[] response = (dnssrvrec[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static RgbaColor fromHex(String hex) {\n        if (hex.length() == 0 || hex.charAt(0) != '#') return getDefaultColor();\n\n        // #rgb\n        if (hex.length() == 4) {\n\n            return new RgbaColor(parseHex(hex, 1, 2),\n                                 parseHex(hex, 2, 3),\n                                 parseHex(hex, 3, 4));\n\n        }\n        // #rrggbb\n        else if (hex.length() == 7) {\n\n            return new RgbaColor(parseHex(hex, 1, 3),\n                                 parseHex(hex, 3, 5),\n                                 parseHex(hex, 5, 7));\n\n        }\n        else {\n            return getDefaultColor();\n        }\n    }", "label": 0}
{"code": "function extendClass(parent, members) {\n        var object = function () { return UNDEFINED; };\n        object.prototype = new parent();\n        extend(object.prototype, members);\n        return object;\n    }", "label": 3}
{"code": "public function objectProperty($value)\n    {\n        switch (true) {\n            case $value instanceof Int64:\n                return [\n                    'integerValue' => $value->get()\n                ];\n\n                break;\n            case $value instanceof Blob:\n                return [\n                    'blobValue' => ($this->encode)\n                        ? base64_encode((string) $value)\n                        : (string) $value\n                ];\n\n                break;\n\n            case $value instanceof \\DateTimeInterface:\n                return [\n                    'timestampValue' => $value->format(self::DATE_FORMAT)\n                ];\n\n                break;\n\n            case $value instanceof EntityInterface:\n                return [\n                    'entityValue' => $this->objectToRequest($value)\n                ];\n\n                break;\n\n            case $value instanceof GeoPoint:\n                return [\n                    'geoPointValue' => $value->point()\n                ];\n\n                break;\n\n            case $value instanceof Key:\n                return [\n                    'keyValue' => $value->keyObject()\n                ];\n\n                break;\n\n            case $value instanceof \\stdClass:\n                return $this->convertArrayToEntityValue((array) $value);\n\n            default:\n                throw new \\InvalidArgumentException(\n                    sprintf('Value of type `%s` could not be serialized', get_class($value))\n                );\n\n                break;\n        }\n    }", "label": 2}
{"code": "function(filedata, callback) {\n        var lines;\n        lines = filedata.toString().split(/(?:\\r\\n|\\r|\\n)/gm);\n        if (module.exports.verify(lines)) {\n            return callback(undefined, lines);\n        }\n        return callback('INVALID_SRT_FORMAT');\n    }", "label": 3}
{"code": "def link(ref)\n      if ref.kind_of?(Range)\n        \"@see - \" + \"https://github.com/dbgrandi/danger-prose/blob/v2.0.0/lib/danger_plugin.rb#L#{ref.min}#-L#{ref.max}\".blue\n      elsif ref.kind_of?(Integer)\n        \"@see - \" + \"https://github.com/dbgrandi/danger-prose/blob/v2.0.0/lib/danger_plugin.rb#L#{ref}\".blue\n      else\n        \"@see - \" + \"https://github.com/dbgrandi/danger-prose/blob/v2.0.0/lib/danger_plugin.rb\".blue\n      end\n    end", "label": 4}
{"code": "def _try_trigger_before_first_request_funcs(self):  # pylint: disable=C0103\n        \"\"\"Runs each function from ``self.before_first_request_funcs`` once and only once.\"\"\"\n        if self._after_first_request_handled:\n            return\n        else:\n            with self._before_first_request_lock:\n                if self._after_first_request_handled:\n                    return\n                for func in self._before_first_request_funcs:\n                    func()\n                self._after_first_request_handled = True", "label": 1}
{"code": "public function setPublishTimeRange($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Talent\\V4beta1\\TimestampRange::class);\n        $this->publish_time_range = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def define_log_processors():\n    \"\"\"\n    log processors that structlog executes before final rendering\n    \"\"\"\n    # these processors should accept logger, method_name and event_dict\n    # and return a new dictionary which will be passed as event_dict to the next one.\n    return [\n        structlog.processors.TimeStamper(fmt=\"iso\"),\n        _structlog_default_keys_processor,\n        structlog.stdlib.PositionalArgumentsFormatter(),\n        structlog.processors.StackInfoRenderer(),\n        structlog.processors.format_exc_info,\n    ]", "label": 1}
{"code": "public function sortByColumn($arr_items)\n    {\n        $sort_by = $this->helper->input('sort_type');\n        if (in_array($sort_by, ['name', 'time'])) {\n            $key_to_sort = $sort_by;\n        } else {\n            $key_to_sort = 'name';\n        }\n\n        uasort($arr_items, function ($a, $b) use ($key_to_sort) {\n            return strcmp($a->{$key_to_sort}, $b->{$key_to_sort});\n        });\n\n        return $arr_items;\n    }", "label": 2}
{"code": "func (d *Decoder) readName() (ok bool) {\n\tvar b byte\n\tif b, ok = d.mustgetc(); !ok {\n\t\treturn\n\t}\n\tif b < utf8.RuneSelf && !isNameByte(b) {\n\t\td.ungetc(b)\n\t\treturn false\n\t}\n\td.buf.WriteByte(b)\n\n\tfor {\n\t\tif b, ok = d.mustgetc(); !ok {\n\t\t\treturn\n\t\t}\n\t\tif b < utf8.RuneSelf && !isNameByte(b) {\n\t\t\td.ungetc(b)\n\t\t\tbreak\n\t\t}\n\t\td.buf.WriteByte(b)\n\t}\n\treturn true\n}", "label": 5}
{"code": "func CipherSuiteMapping(cipherSuites []string) ([]uint16, error) {\n\tout := make([]uint16, 0, len(cipherSuites))\n\n\tfor _, cs := range cipherSuites {\n\t\tc, ok := cipherSuiteMapping[cs]\n\t\tif !ok {\n\t\t\treturn nil, trace.BadParameter(\"cipher suite not supported: %v\", cs)\n\t\t}\n\n\t\tout = append(out, c)\n\t}\n\n\treturn out, nil\n}", "label": 5}
{"code": "func sliceUncompress(data []byte) (outData []byte, err error) {\n\tinBuf := bytes.NewReader(data)\n\tr, err := zlib.NewReader(inBuf)\n\tdefer r.Close()\n\tif err == nil {\n\t\tvar outBuf bytes.Buffer\n\t\t_, err = outBuf.ReadFrom(r)\n\t\tif err == nil {\n\t\t\toutData = outBuf.Bytes()\n\t\t}\n\t}\n\treturn\n}", "label": 5}
{"code": "func (p Params) GetString(key string) string {\n\tv, ok := p[key]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\ts, _ := v.(string)\n\treturn s\n}", "label": 5}
{"code": "function (args, onDone, extra) {\n\t\t// if args are not provided then we shift the parameters\n\t\tif (typeof args === 'function') {\n\t\t\textra = onDone;\n\t\t\tonDone = args;\n\t\t\targs = {};\n\t\t}\n\n\t\t// TODO: perform argument type check (currently there's none, so internal API calls won't do type checks)\n\t\t// TODO: move checker to here\n\n\t\tvar onError = function(err) {\n\t\t\tLOG.error('onError '+ err, l_name);\n\t\t\tUTIL.safeCall(onDone, err);\n\t\t}\n\n\t\tfunction onExec() {\n\t\t\t// make actual call to user-defined function\n\t\t\t// NOTE: we also return values for direct function calls\n\t\t\treturn UTIL.safeCall(l_list[name], args, function (err, result, unsupported_return) {\n\t\t\t\tif (err) {\n\t\t\t\t\tLOG.error('[' + name + '] error:', l_name);\n\t\t\t\t\tLOG.error(err, l_name);\n\t\t\t\t}\n\n\t\t\t\tif (unsupported_return) {\n\t\t\t\t\tvar errmsg = 'onDone() in SR.API does not support more than one return variable, please return everything inside a result object';\n\t\t\t\t\tLOG.error(errmsg, l_name);\n\t\t\t\t\tLOG.stack();\n\t\t\t\t\treturn UTIL.safeCall(onDone, errmsg);\n\t\t\t\t}\n\n\t\t\t\t// perform post-event actions, if any\n\t\t\t\tif (l_afterActions.hasOwnProperty(name) === false) {\n\t\t\t\t\treturn UTIL.safeCall(onDone, err, result);\n\t\t\t\t}\n\n\t\t\t\tvar posts = l_afterActions[name];\n\t\t\t\tvar promise = undefined;\n\t\t\t\tfor (var i=0; i < posts.length; i++) {\n\t\t\t\t\tif (!promise) {\n\t\t\t\t\t\tpromise = post_action(args, { err: err, result: result }, posts[i], extra);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpromise = promise.then(post_action(args, { err: err, result: result }, posts[i], extra));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// last action\n\t\t\t\tpromise.then(new SR.promise(function (resolve, reject) {\n\t\t\t\t\t//LOG.warn('everything is done... call original onDone...', l_name);\n\t\t\t\t\tUTIL.safeCall(onDone, err, result);\n\t\t\t\t\tresolve();\n\t\t\t\t}));\n\n\t\t\t}, extra);\n\t\t}\n\n\t\t// perform pre-event actions, if any\n\t\tif (l_beforeActions.hasOwnProperty(name) === false) {\n\t\t\treturn onExec();\n\t\t}\n\n\t\tconst pres = l_beforeActions[name].map((callback) => pre_action(args, callback, extra));\n\t\tpres.reduce((p, callback) => p.then(() => callback), Promise.resolve())\n\t\t\t.then(onExec)\n\t\t\t.catch((err) => {\n\t\t\t\tLOG.error(err);\n\t\t\t\tonDone(err);\n\t\t\t});\n\t}", "label": 3}
{"code": "func (l VirtualDeviceList) CreateDisk(c types.BaseVirtualController, ds types.ManagedObjectReference, name string) *types.VirtualDisk {\n\t// If name is not specified, one will be chosen for you.\n\t// But if when given, make sure it ends in .vmdk, otherwise it will be treated as a directory.\n\tif len(name) > 0 && filepath.Ext(name) != \".vmdk\" {\n\t\tname += \".vmdk\"\n\t}\n\n\tdevice := &types.VirtualDisk{\n\t\tVirtualDevice: types.VirtualDevice{\n\t\t\tBacking: &types.VirtualDiskFlatVer2BackingInfo{\n\t\t\t\tDiskMode:        string(types.VirtualDiskModePersistent),\n\t\t\t\tThinProvisioned: types.NewBool(true),\n\t\t\t\tVirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{\n\t\t\t\t\tFileName:  name,\n\t\t\t\t\tDatastore: &ds,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tl.AssignController(device, c)\n\treturn device\n}", "label": 5}
{"code": "protected function createSentinelConnection($parameters)\n    {\n        if ($parameters instanceof NodeConnectionInterface) {\n            return $parameters;\n        }\n\n        if (is_string($parameters)) {\n            $parameters = Parameters::parse($parameters);\n        }\n\n        if (is_array($parameters)) {\n            // We explicitly set \"database\" and \"password\" to null,\n            // so that no AUTH and SELECT command is send to the sentinels.\n            $parameters['database'] = null;\n            $parameters['password'] = null;\n\n            if (!isset($parameters['timeout'])) {\n                $parameters['timeout'] = $this->sentinelTimeout;\n            }\n        }\n\n        $connection = $this->connectionFactory->create($parameters);\n\n        return $connection;\n    }", "label": 2}
{"code": "func ParseFloat(b []byte) (float64, error) {\n\tif v, err := parseFloat(&b); err != nil {\n\t\treturn 0, MalformedValueError\n\t} else {\n\t\treturn v, nil\n\t}\n}", "label": 5}
{"code": "func receiverType(val interface{}) string {\n\tt := reflect.TypeOf(val)\n\tif t.Name() != \"\" {\n\t\treturn t.String()\n\t}\n\treturn \"(\" + t.String() + \")\"\n}", "label": 5}
{"code": "func (g *GRPCServer) UpsertNode(ctx context.Context, server *services.ServerV2) (*services.KeepAlive, error) {\n\tauth, err := g.authenticate(ctx)\n\tif err != nil {\n\t\treturn nil, trail.ToGRPC(err)\n\t}\n\tkeepAlive, err := auth.UpsertNode(server)\n\tif err != nil {\n\t\treturn nil, trail.ToGRPC(err)\n\t}\n\treturn keepAlive, nil\n}", "label": 5}
{"code": "def trim(n)\n      result = self\n      while n > 0 && !result.empty?\n        result = result.tail\n        n -= 1\n      end\n      result\n    end", "label": 4}
{"code": "function addPatch(patches, patch) {\n\tvar lastPatch = patches[patches.length -1];\n\tif(lastPatch) {\n\t\t// same number of deletes and counts as the index is back\n\t\tif(lastPatch.deleteCount === lastPatch.insert.length && (patch.index - lastPatch.index === lastPatch.deleteCount) ) {\n\t\t\tlastPatch.insert.push.apply(lastPatch.insert, patch.insert);\n\t\t\tlastPatch.deleteCount += patch.deleteCount;\n\t\t\treturn;\n\t\t}\n\t}\n\tpatches.push(patch);\n}", "label": 3}
{"code": "public function sendGetServerProperties()\n    {\n        $id = $this->createIqId();\n        $child = new ProtocolNode('props', null, null, null);\n        $node = new ProtocolNode('iq',\n            [\n                'id'    => $id,\n                'type'  => 'get',\n                'xmlns' => 'w',\n                'to'    => Constants::WHATSAPP_SERVER,\n            ], [$child], null);\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "public function push($target, $ref, $targetBranch = 'master', $force = true)\n    {\n        $cmd = [\n            'git push -q',\n            sprintf('https://%s@github.com/%s', $this->token, $target),\n            sprintf('%s:%s', $ref, $targetBranch)\n        ];\n\n        if ($force) {\n            $cmd[] = '--force';\n        }\n\n        return $this->shell->execute(implode(' ' , $cmd));\n    }", "label": 2}
{"code": "public function exists()\n    {\n        try {\n            $this->connection->getDataset($this->identity + ['fields' => 'datasetReference']);\n        } catch (NotFoundException $ex) {\n            return false;\n        }\n\n        return true;\n    }", "label": 2}
{"code": "function SchemaMoment(key, options) {\n\t\tSchemaType.call(this, key, options);\n\n\t\tthis.get(function(val, self){\n\t\t\tif(!val){\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn new Moment(val);\n\t\t\t}\n\t\t});\n\t}", "label": 3}
{"code": "private Envelope getMaxScreenEnvelope(InternalTile tile, Coordinate panOrigin) {\n\t\tint nrOfTilesX = Math.max(1, MAXIMUM_TILE_COORDINATE / tile.getScreenWidth());\n\t\tint nrOfTilesY = Math.max(1, MAXIMUM_TILE_COORDINATE / tile.getScreenHeight());\n\n\t\tdouble x1 = panOrigin.x - nrOfTilesX * tile.getTileWidth();\n\t\t// double x2 = x1 + (nrOfTilesX * tileWidth * 2);\n\t\tdouble x2 = panOrigin.x + nrOfTilesX * tile.getTileWidth();\n\t\tdouble y1 = panOrigin.y - nrOfTilesY * tile.getTileHeight();\n\t\t// double y2 = y1 + (nrOfTilesY * tileHeight * 2);\n\t\tdouble y2 = panOrigin.y + nrOfTilesY * tile.getTileHeight();\n\t\treturn new Envelope(x1, x2, y1, y2);\n\t}", "label": 0}
{"code": "func (c *Client) GetUsers() ([]services.User, error) {\n\tout, err := c.Get(c.Endpoint(\"users\"), url.Values{})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvar items []json.RawMessage\n\tif err := json.Unmarshal(out.Bytes(), &items); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tusers := make([]services.User, len(items))\n\tfor i, userBytes := range items {\n\t\tuser, err := services.GetUserMarshaler().UnmarshalUser(userBytes, services.SkipValidation())\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tusers[i] = user\n\t}\n\treturn users, nil\n}", "label": 5}
{"code": "def and_return(response=nil, &block)\n      new_response = (response.nil? ? block : response)\n      responses.push(*new_response)\n    end", "label": 4}
{"code": "public function setRecognitionResult($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\StreamingRecognitionResult::class);\n        $this->recognition_result = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_responses delete(nitro_service client, dnstxtrec resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tdnstxtrec deleteresources[] = new dnstxtrec[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tdeleteresources[i] = new dnstxtrec();\n\t\t\t\tdeleteresources[i].domain = resources[i].domain;\n\t\t\t\tdeleteresources[i].String = resources[i].String;\n\t\t\t\tdeleteresources[i].recordid = resources[i].recordid;\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function(Type){\n        return Type && canReflect.isConstructorLike(Type) &&\n            !set.hasComparisons(Type) &&\n            !Type[canSymbol.for(\"can.SetType\")] &&\n            Type.prototype.valueOf && Type.prototype.valueOf !== Object.prototype.valueOf;\n    }", "label": 3}
{"code": "def warn(message, ids: [], &block)\n      msg = ids.empty? ? '' : \"[#{ids.map!(&:to_s).map(&:inspect).join(', ')}] \"\n      msg += message\n      @logger.warn(msg, &block) unless (@ignored & ids).any?\n    end", "label": 4}
{"code": "protected <T extends Listener> Collection<T> copyList(Class<T> listenerClass,\n            Stream<Object> listeners, int sizeHint) {\n        if (sizeHint == 0) {\n            return Collections.emptyList();\n        }\n        return listeners\n                .map(listenerClass::cast)\n                .collect(Collectors.toCollection(() -> new ArrayList<>(sizeHint)));\n    }", "label": 0}
{"code": "def subdir_findall(dir, subdir):\n    \"\"\"\n    Find all files in a subdirectory and return paths relative to dir\n\n    This is similar to (and uses) setuptools.findall\n    However, the paths returned are in the form needed for package_data\n    \"\"\"\n    strip_n = len(dir.split('/'))\n    path = '/'.join((dir, subdir))\n    return ['/'.join(s.split('/')[strip_n:]) for s in setuptools.findall(path)]", "label": 1}
{"code": "private function parseUploadedFiles(Request $request)\n    {\n        $bodyParams = $request->all();\n        if (!isset($bodyParams['map'])) {\n            throw new RequestError('The request must define a `map`');\n        }\n\n        $map = json_decode($bodyParams['map'], true);\n        $result = json_decode($bodyParams['operations'], true);\n        if (isset($result['operationName'])) {\n            $result['operation'] = $result['operationName'];\n            unset($result['operationName']);\n        }\n\n        foreach ($map as $fileKey => $locations) {\n            foreach ($locations as $location) {\n                $items = &$result;\n                foreach (explode('.', $location) as $key) {\n                    if (!isset($items[$key]) || !is_array($items[$key])) {\n                        $items[$key] = [];\n                    }\n                    $items = &$items[$key];\n                }\n\n                $items = $request->allFiles()[$fileKey];\n            }\n        }\n\n        $request->replace($result);\n\n        return $request;\n    }", "label": 2}
{"code": "function openReply(id) {\n    // Swap out the reply link for the hide link\n    $('#rl' + id).hide();\n    $('#cr' + id).show();\n\n    // Add the reply li to the children ul.\n    var div = $(renderTemplate(replyTemplate, {id: id})).hide();\n    $('#cl' + id)\n      .prepend(div)\n      // Setup the submit handler for the reply form.\n      .find('#rf' + id)\n      .submit(function(event) {\n        event.preventDefault();\n        addComment($('#rf' + id));\n        closeReply(id);\n      })\n      .find('input[type=button]')\n      .click(function() {\n        closeReply(id);\n      });\n    div.slideDown('fast', function() {\n      $('#rf' + id).find('textarea').focus();\n    });\n  }", "label": 3}
{"code": "function generateCSVFieldValues(baseField, ff, downloadUrl, sub) {\n  var line = '';\n  var fieldValues = [];\n\n  if (ff) {\n    fieldValues = misc.filterOutNullData(ff.fieldValues);\n  }\n\n  if (baseField && baseField.repeating) {\n    for (var j = 0; j < baseField.fieldOptions.definition.maxRepeat; j++) {\n      line += generateCSVSingleValue(baseField, fieldValues[j], downloadUrl, sub._id);\n    }\n  } else {\n    line += generateCSVSingleValue(baseField, fieldValues[0], downloadUrl, sub._id);\n  }\n\n  return line;\n}", "label": 3}
{"code": "def check_dependencies(self):\n        \"Checks if the test program is available in the python environnement\"\n        if self.test_program == 'nose':\n            try:\n                import nose\n            except ImportError:\n                sys.exit('Nosetests is not available on your system. Please install it and try to run it again')\n        if self.test_program == 'py':\n            try:\n                import py\n            except:\n                sys.exit('py.test is not available on your system. Please install it and try to run it again')\n        if self.test_program == 'django':\n            try:\n                import django\n            except:\n                sys.exit('django is not available on your system. Please install it and try to run it again')\n        if self.test_program == 'phpunit':\n            try:\n                process = subprocess.check_call(['phpunit','--version']) \n            except:\n                sys.exit('phpunit is not available on your system. Please install it and try to run it again')\n        if self.test_program == 'tox':\n            try:\n                import tox\n            except ImportError:\n                sys.exit('tox is not available on your system. Please install it and try to run it again')", "label": 1}
{"code": "def interactor(options)\n      # TODO: remove dependency on Interactor (let session handle this)\n      case options\n      when :off\n        Interactor.enabled = false\n      when Hash\n        Interactor.options = options\n      end\n    end", "label": 4}
{"code": "public function remove($nameOrInstance)\n    {\n        if (is_callable($nameOrInstance)) {\n            $this->removeByInstance($nameOrInstance);\n        } elseif (is_string($nameOrInstance)) {\n            $this->removeByName($nameOrInstance);\n        }\n    }", "label": 2}
{"code": "def normalize_keys(mapping)\n      return mapping.inject({}) do |accu, pair|\n        name, value = pair\n        if Symbol === name\n          name = name.to_s\n        elsif name.respond_to?(:to_str)\n          name = name.to_str\n        else\n          raise TypeError,\n            \"Can't convert #{name.class} into String.\"\n        end\n        accu[name] = value\n        accu\n      end\n    end", "label": 4}
{"code": "def write_loop(requests, is_client: true, set_output_stream_done: nil)\n      GRPC.logger.debug('bidi-write-loop: starting')\n      count = 0\n      requests.each do |req|\n        GRPC.logger.debug(\"bidi-write-loop: #{count}\")\n        count += 1\n        payload = @marshal.call(req)\n        # Fails if status already received\n        begin\n          @req_view.send_initial_metadata unless @req_view.nil?\n          @call.run_batch(SEND_MESSAGE => payload)\n        rescue GRPC::Core::CallError => e\n          # This is almost definitely caused by a status arriving while still\n          # writing. Don't re-throw the error\n          GRPC.logger.warn('bidi-write-loop: ended with error')\n          GRPC.logger.warn(e)\n          break\n        end\n      end\n      GRPC.logger.debug(\"bidi-write-loop: #{count} writes done\")\n      if is_client\n        GRPC.logger.debug(\"bidi-write-loop: client sent #{count}, waiting\")\n        begin\n          @call.run_batch(SEND_CLOSE_FROM_CLIENT => nil)\n        rescue GRPC::Core::CallError => e\n          GRPC.logger.warn('bidi-write-loop: send close failed')\n          GRPC.logger.warn(e)\n        end\n        GRPC.logger.debug('bidi-write-loop: done')\n      end\n      GRPC.logger.debug('bidi-write-loop: finished')\n    rescue StandardError => e\n      GRPC.logger.warn('bidi-write-loop: failed')\n      GRPC.logger.warn(e)\n      if is_client\n        @call.cancel_with_status(GRPC::Core::StatusCodes::UNKNOWN,\n                                 \"GRPC bidi call error: #{e.inspect}\")\n      else\n        raise e\n      end\n    ensure\n      set_output_stream_done.call if is_client\n    end", "label": 4}
{"code": "func (l VirtualDeviceList) Disconnect(device types.BaseVirtualDevice) error {\n\treturn l.connectivity(device, false)\n}", "label": 5}
{"code": "public function setApplicationJobFilters($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Talent\\V4beta1\\ApplicationJobFilter::class);\n        $this->application_job_filters = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func newDriver(networkType string) *driver {\n\treturn &driver{name: networkType, networks: map[string]*hnsNetwork{}}\n}", "label": 5}
{"code": "def stroke_dasharray(*list)\n      if list.length.zero?\n        primitive 'stroke-dasharray none'\n      else\n        list.each do |x|\n          Kernel.raise ArgumentError, \"dash array elements must be > 0 (#{x} given)\" if x <= 0\n        end\n        primitive \"stroke-dasharray #{list.join(',')}\"\n      end\n    end", "label": 4}
{"code": "def get_initkwargs(cls, form_list, initial_dict=None,\n        instance_dict=None, condition_dict=None, *args, **kwargs):\n        \"\"\"\n        Creates a dict with all needed parameters for the form wizard instances.\n\n        * `form_list` - is a list of forms. The list entries can be single form\n          classes or tuples of (`step_name`, `form_class`). If you pass a list\n          of forms, the formwizard will convert the class list to\n          (`zero_based_counter`, `form_class`). This is needed to access the\n          form for a specific step.\n        * `initial_dict` - contains a dictionary of initial data dictionaries.\n          The key should be equal to the `step_name` in the `form_list` (or\n          the str of the zero based counter - if no step_names added in the\n          `form_list`)\n        * `instance_dict` - contains a dictionary of instance objects. This list\n          is only used when `ModelForm`s are used. The key should be equal to\n          the `step_name` in the `form_list`. Same rules as for `initial_dict`\n          apply.\n        * `condition_dict` - contains a dictionary of boolean values or\n          callables. If the value of for a specific `step_name` is callable it\n          will be called with the formwizard instance as the only argument.\n          If the return value is true, the step's form will be used.\n        \"\"\"\n        kwargs.update({\n            'initial_dict': initial_dict or {},\n            'instance_dict': instance_dict or {},\n            'condition_dict': condition_dict or {},\n        })\n        init_form_list = SortedDict()\n\n        assert len(form_list) > 0, 'at least one form is needed'\n\n        # walk through the passed form list\n        for i, form in enumerate(form_list):\n            if isinstance(form, (list, tuple)):\n                # if the element is a tuple, add the tuple to the new created\n                # sorted dictionary.\n                init_form_list[unicode(form[0])] = form[1]\n            else:\n                # if not, add the form with a zero based counter as unicode\n                init_form_list[unicode(i)] = form\n\n        # walk through the ne created list of forms\n        for form in init_form_list.itervalues():\n            if issubclass(form, formsets.BaseFormSet):\n                # if the element is based on BaseFormSet (FormSet/ModelFormSet)\n                # we need to override the form variable.\n                form = form.form\n            # check if any form contains a FileField, if yes, we need a\n            # file_storage added to the formwizard (by subclassing).\n            for field in form.base_fields.itervalues():\n                if (isinstance(field, forms.FileField) and\n                        not hasattr(cls, 'file_storage')):\n                    raise NoFileStorageConfigured\n\n        # build the kwargs for the formwizard instances\n        kwargs['form_list'] = init_form_list\n        return kwargs", "label": 1}
{"code": "function nodeExtent(graph, attribute) {\n  if (!isGraph(graph))\n    throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');\n\n  var attributes = [].concat(attribute);\n\n  var nodes = graph.nodes(),\n      node,\n      data,\n      value,\n      key,\n      a,\n      i,\n      l;\n\n  var results = {};\n\n  for (a = 0; a < attributes.length; a++) {\n    key = attributes[a];\n\n    results[key] = [Infinity, -Infinity];\n  }\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    node = nodes[i];\n    data = graph.getNodeAttributes(node);\n\n    for (a = 0; a < attributes.length; a++) {\n      key = attributes[a];\n      value = data[key];\n\n      if (value < results[key][0])\n        results[key][0] = value;\n\n      if (value > results[key][1])\n        results[key][1] = value;\n    }\n  }\n\n  return typeof attribute === 'string' ? results[attribute] : results;\n}", "label": 3}
{"code": "public function setDescription($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Trace\\V2\\TruncatableString::class);\n        $this->description = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def ips_for(name)\n      resolvers.each do |r|\n        ips = r.getaddresses(name)\n\n        return ips unless ips.nil? || ips.empty?\n      end\n\n      []\n    end", "label": 4}
{"code": "function escapestr(s) {\n            return s.replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, '\\\\\\'')\n                    .replace(/\"/g, '\\\\\"')\n                    .replace(/\\r/g, '\\\\r')\n                    .replace(/\\n/g, '\\\\n');\n        }", "label": 3}
{"code": "def run_cleanup(self, env, exit_code):\n        \"\"\"Run cleanup hook when configured.\"\"\"\n        output = []\n        if self.pipeline.data.hooks and len(self.pipeline.data.hooks.cleanup) > 0:\n            env.update({'PIPELINE_RESULT': 'FAILURE'})\n            env.update({'PIPELINE_SHELL_EXIT_CODE': str(exit_code)})\n            config = ShellConfig(script=self.pipeline.data.hooks.cleanup,\n                                 model=self.pipeline.model, env=env,\n                                 dry_run=self.pipeline.options.dry_run,\n                                 debug=self.pipeline.options.debug,\n                                 strict=self.pipeline.options.strict,\n                                 temporary_scripts_path=self.pipeline.options.temporary_scripts_path)\n            cleanup_shell = Bash(config)\n            for line in cleanup_shell.process():\n                output.append(line)\n                self.logger.info(\" | %s\", line)\n        return output", "label": 1}
{"code": "def crossmap(fas, reads, options, no_shrink, keepDB, threads, cluster, nodes):\n    \"\"\"\n    map all read sets against all fasta files\n    \"\"\"\n    if cluster is True:\n        threads = '48'\n    btc = []\n    for fa in fas:\n        btd = bowtiedb(fa, keepDB)\n        F, R, U = reads\n        if F is not False:\n            if U is False:\n                u = False\n            for i, f in enumerate(F):\n                r = R[i]\n                if U is not False:\n                    u = U[i]\n                sam = '%s/%s-vs-%s' % (os.getcwd(), \\\n                        fa.rsplit('/', 1)[-1], f.rsplit('/', 1)[-1].rsplit('.', 3)[0])\n                btc.append(bowtie(sam, btd, f, r, u, options, no_shrink, threads))\n        else:\n            f = False\n            r = False\n            for u in U:\n                sam = '%s/%s-vs-%s' % (os.getcwd(), \\\n                        fa.rsplit('/', 1)[-1], u.rsplit('/', 1)[-1].rsplit('.', 3)[0])\n                btc.append(bowtie(sam, btd, f, r, u, options, no_shrink, threads))\n    if cluster is False:\n        for i in btc:\n            p = subprocess.Popen(i, shell = True)\n            p.communicate()\n    else:\n        ID = ''.join(random.choice([str(i) for i in range(0, 9)]) for _ in range(5))\n        for node, commands in enumerate(chunks(btc, nodes), 1):\n            bs = open('%s/crossmap-qsub.%s.%s.sh' % (os.getcwd(), ID, node), 'w')\n            print('\\n'.join(commands), file=bs)\n            bs.close()\n            p = subprocess.Popen(\\\n                    'qsub -V -N crossmap %s' \\\n                        % (bs.name), \\\n                    shell = True)\n            p.communicate()", "label": 1}
{"code": "function () {\n\t\t\tvar args = slice.call(arguments),\n\t\t\t\tconstraint = options.args_map.getOrPut(args, function() {\n\t\t\t\t\treturn new Constraint(function () {\n\t\t\t\t\t\treturn getter_fn.apply(options.context, args);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\treturn constraint.get();\n\t\t}", "label": 3}
{"code": "def deletecols(X, cols):\n    \"\"\"\n    Delete columns from a numpy ndarry or recarray.\n\n    Can take a string giving a column name or comma-separated list of column \n    names, or a list of string column names.\n\n    Implemented by the tabarray method \n    :func:`tabular.tab.tabarray.deletecols`.\n\n    **Parameters**\n\n            **X** :  numpy recarray or ndarray with structured dtype\n\n                    The numpy array from which to delete columns.\n\n            **cols** :  string or list of strings\n\n                    Name or list of names of columns in `X`.  This can be\n                    a string giving a column name or comma-separated list of \n                    column names, or a list of string column names.\n\n    **Returns**\n\n            **out** :  numpy ndarray with structured dtype\n\n                    New numpy ndarray with structured dtype\n                    given by `X`, excluding the columns named in `cols`.\n\n    \"\"\"\n    if isinstance(cols, str):\n        cols = cols.split(',')\n    retain = [n for n in X.dtype.names if n not in cols]\n    if len(retain) > 0:\n        return X[retain]\n    else:\n        return None", "label": 1}
{"code": "public function getRetryDelay()\n    {\n        $metadata = array_filter($this->metadata, function ($metadataItem) {\n            return array_key_exists('retryDelay', $metadataItem);\n        });\n\n        if (count($metadata) === 0) {\n            return ['seconds' => 0, 'nanos' => 0];\n        }\n\n        return $metadata[0]['retryDelay'] + [\n            'seconds' => 0,\n            'nanos' => 0\n        ];\n    }", "label": 2}
{"code": "func entitiesFieldRename(field types.CustomFieldDef) {\n\tentities := Map.All(field.ManagedObjectType)\n\tfor _, e := range entities {\n\t\tentity := e.Entity()\n\t\tMap.WithLock(entity, func() {\n\t\t\taFields := entity.AvailableField\n\t\t\tfor i, aField := range aFields {\n\t\t\t\tif aField.Key == field.Key {\n\t\t\t\t\taFields[i].Name = field.Name\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}", "label": 5}
{"code": "def new_scope(names)\n      values = names.map { |n| self[n] }\n      self.class.new(names, values + extras, self)\n    end", "label": 4}
{"code": "function userExists(user) {\n  if (_.isEmpty(findUser(user, {refresh: true, throwIfNotFound: false}))) {\n    return false;\n  } else {\n    return true;\n  }\n}", "label": 3}
{"code": "public function renderPolicy() {\n        $policy = new \\SimpleXMLElement($this->_policy);\n\n        $siteControl = $policy->addChild('site-control');\n\n        if ($this->_siteControl == '') {\n            $this->setSiteControl();\n        }\n\n        $siteControl->addAttribute('permitted-cross-domain-policies', $this->_siteControl);\n\n        if (empty($this->_access)) {\n            throw new \\UnexpectedValueException('You must add a domain through addAllowedAccess()');\n        }\n\n        foreach ($this->_access as $access) {\n            $tmp = $policy->addChild('allow-access-from');\n            $tmp->addAttribute('domain', $access[0]);\n            $tmp->addAttribute('to-ports', $access[1]);\n            $tmp->addAttribute('secure', ($access[2] === true) ? 'true' : 'false');\n        }\n\n        return $policy;\n    }", "label": 2}
{"code": "public function setDegreeTypes($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::ENUM, \\Google\\Cloud\\Talent\\V4beta1\\DegreeType::class);\n        $this->degree_types = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def clip_units(unit)\n      Kernel.raise ArgumentError, \"Unknown clip unit #{unit}\" unless %w[userspace userspaceonuse objectboundingbox].include?(unit.downcase)\n      primitive \"clip-units #{unit}\"\n    end", "label": 4}
{"code": "public function setSkills($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Talent\\V4beta1\\Skill::class);\n        $this->skills = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n            if (this.zoomHor || this.pinchHor) {\n                this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n            }\n            if (this.zoomVert || this.pinchVert) {\n                this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n            }\n        }", "label": 3}
{"code": "function _gpfProcessDefineParamResolveBase (params) {\n    var Super = params[_GPF_DEFINE_PARAM_SUPER];\n    if (!(Super instanceof Function)) {\n        params[_GPF_DEFINE_PARAM_SUPER] = _gpfContext(Super.toString().split(\".\"));\n    }\n}", "label": 3}
{"code": "public function completeAuthorizationRequest(AuthorizationRequest $authRequest, ResponseInterface $response)\n    {\n        return $this->enabledGrantTypes[$authRequest->getGrantTypeId()]\n            ->completeAuthorizationRequest($authRequest)\n            ->generateHttpResponse($response);\n    }", "label": 2}
{"code": "function getOptions () {\n  return {\n    compress: ('compress' in program) ? program.compress : false,\n    debug: ('debug' in program) ? program.debug : false,\n    deploy: false,\n    grep: ('grep' in program) ? program.grep : false,\n    invert: ('invert' in program) ? program.invert : false,\n    maps: ('maps' in program) ? program.maps : false,\n    reload: ('reload' in program) ? program.reload : false,\n    script: ('script' in program) ? program.script : false,\n    serve: ('serve' in program) ? program.serve : false,\n    watch: false\n  };\n}", "label": 3}
{"code": "def is_program(self):\n        \"\"\"\n            A property which can be used to check if StatusObject uses program features or not.\n        \"\"\"\n        from automate.callables import Empty\n        return not (isinstance(self.on_activate, Empty)\n                    and isinstance(self.on_deactivate, Empty)\n                    and isinstance(self.on_update, Empty))", "label": 1}
{"code": "public function setErrorGroupStats($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\ErrorReporting\\V1beta1\\ErrorGroupStats::class);\n        $this->error_group_stats = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def get_img_hash(image, hash_size = 8):\n    \"\"\" Grayscale and shrink the image in one step \"\"\"\n\n    image = image.resize((hash_size + 1, hash_size), Image.ANTIALIAS, )\n\n    pixels = list(image.getdata())\n    #print('get_img_hash: pixels=', pixels)\n\n    # Compare adjacent pixels.\n    difference = []\n    for row in range(hash_size):\n        for col in range(hash_size):\n            pixel_left = image.getpixel((col, row))\n            pixel_right = image.getpixel((col + 1, row))\n            difference.append(pixel_left > pixel_right)\n\n    # Convert the binary array to a hexadecimal string.\n    decimal_value = 0\n    hex_string = []\n    for index, value in enumerate(difference):\n        if value:\n            decimal_value += 2**(index % 8)\n        if (index % 8) == 7:\n            hex_string.append(hex(decimal_value)[2:].rjust(2, '0'))\n            decimal_value = 0\n\n    return ''.join(hex_string)", "label": 1}
{"code": "public function setView($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Bigtable\\Admin\\V2\\Table_View::class);\n        $this->view = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "private void handleMultiChannelEncapResponse(\r\n\t\t\tSerialMessage serialMessage, int offset) {\r\n\t\tlogger.trace(\"Process Multi-channel Encapsulation\");\r\n\t\tCommandClass commandClass;\r\n\t\tZWaveCommandClass zwaveCommandClass;\r\n\t\tint endpointId = serialMessage.getMessagePayloadByte(offset);\r\n\t\tint commandClassCode = serialMessage.getMessagePayloadByte(offset + 2);\r\n\t\tcommandClass = CommandClass.getCommandClass(commandClassCode);\r\n\t\t\r\n\t\tif (commandClass == null) {\r\n\t\t\tlogger.error(String.format(\"Unsupported command class 0x%02x\", commandClassCode));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tlogger.debug(String.format(\"Node %d Requested Command Class = %s (0x%02x)\", this.getNode().getNodeId(), commandClass.getLabel() , commandClassCode));\r\n\t\tZWaveEndpoint endpoint = this.endpoints.get(endpointId);\r\n\t\t\r\n\t\tif (endpoint == null){\r\n\t\t\tlogger.error(\"Endpoint {} not found on node {}. Cannot set command classes.\", endpoint, this.getNode().getNodeId());\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tzwaveCommandClass = endpoint.getCommandClass(commandClass);\r\n\t\t\r\n\t\tif (zwaveCommandClass == null) {\r\n\t\t\tlogger.warn(String.format(\"CommandClass %s (0x%02x) not implemented by endpoint %d, fallback to main node.\", commandClass.getLabel(), commandClassCode, endpointId));\r\n\t\t\tzwaveCommandClass = this.getNode().getCommandClass(commandClass);\r\n\t\t}\r\n\t\t\r\n\t\tif (zwaveCommandClass == null) {\r\n\t\t\tlogger.error(String.format(\"CommandClass %s (0x%02x) not implemented by node %d.\", commandClass.getLabel(), commandClassCode, this.getNode().getNodeId()));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tlogger.debug(String.format(\"Node %d, Endpoint = %d, calling handleApplicationCommandRequest.\", this.getNode().getNodeId(), endpointId));\r\n\t\tzwaveCommandClass.handleApplicationCommandRequest(serialMessage, offset + 3, endpointId);\r\n\t}", "label": 0}
{"code": "public static base_responses add(nitro_service client, dospolicy resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tdospolicy addresources[] = new dospolicy[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new dospolicy();\n\t\t\t\taddresources[i].name = resources[i].name;\n\t\t\t\taddresources[i].qdepth = resources[i].qdepth;\n\t\t\t\taddresources[i].cltdetectrate = resources[i].cltdetectrate;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "func NetworkOptionLabels(labels map[string]string) NetworkOption {\n\treturn func(n *network) {\n\t\tn.labels = labels\n\t}\n}", "label": 5}
{"code": "public function setExcludedJobs($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::STRING);\n        $this->excluded_jobs = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "func (cl *Client) dopplegangerAddr(addr string) bool {\n\t_, ok := cl.dopplegangerAddrs[addr]\n\treturn ok\n}", "label": 5}
{"code": "func needsQuoting(text string) bool {\n\tfor _, r := range text {\n\t\tif !strconv.IsPrint(r) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "label": 5}
{"code": "def post(self, filepath):\n        \"\"\"\n        Write the given contents to the specified file. This is not\n        an append, all file contents will be replaced by the contents\n        given.\n        \"\"\"\n        try:\n            content = self.get_body_argument('content')\n            self.fs.write_file(filepath, content)\n            self.write({'msg': 'Updated file at {}'.format(filepath)})\n        except OSError:\n            raise tornado.web.HTTPError(404)", "label": 1}
{"code": "public static base_response unset(nitro_service client, sslservice resource, String[] args) throws Exception{\n\t\tsslservice unsetresource = new sslservice();\n\t\tunsetresource.servicename = resource.servicename;\n\t\treturn unsetresource.unset_resource(client,args);\n\t}", "label": 0}
{"code": "public function parameters(array $parameters)\n    {\n        $queryParams = [];\n        $this->config['configuration']['query']['parameterMode'] = $this->isAssoc($parameters)\n            ? 'named'\n            : 'positional';\n\n        foreach ($parameters as $name => $value) {\n            $param = $this->mapper->toParameter($value);\n\n            if ($this->config['configuration']['query']['parameterMode'] === 'named') {\n                $param += ['name' => $name];\n            }\n\n            $queryParams[] = $param;\n        }\n\n        $this->config['configuration']['query']['queryParameters'] = $queryParams;\n\n        return $this;\n    }", "label": 2}
{"code": "function getFilteredParamInfo(flapjack, options) {\n    if (!flapjack) { return {}; }\n\n    var aliases = this.getClientAliases(flapjack, options);\n    var params = this.getParameters(flapjack) || [];\n    params = params.filter(function (param) {\n        return ['$scope', 'defaults', 'initialModel'].indexOf(param) < 0;\n    });\n\n    return this.getParamInfo(params, aliases) || {};\n}", "label": 3}
{"code": "def active_knocks(obj):\n    \"\"\"\n    Checks whether knocks are enabled for the model given as argument\n\n    :param obj: model instance\n    :return True if knocks are active\n    \"\"\"\n    if not hasattr(_thread_locals, 'knock_enabled'):\n        return True\n    return _thread_locals.knock_enabled.get(obj.__class__, True)", "label": 1}
{"code": "func MyAutoIncrements(db XODB, schema string) ([]*MyAutoIncrement, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`table_name ` +\n\t\t`FROM information_schema.tables ` +\n\t\t`WHERE auto_increment IS NOT null AND table_schema = ?`\n\n\t// run query\n\tXOLog(sqlstr, schema)\n\tq, err := db.Query(sqlstr, schema)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer q.Close()\n\n\t// load results\n\tres := []*MyAutoIncrement{}\n\tfor q.Next() {\n\t\tmai := MyAutoIncrement{}\n\n\t\t// scan\n\t\terr = q.Scan(&mai.TableName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres = append(res, &mai)\n\t}\n\n\treturn res, nil\n}", "label": 5}
{"code": "public static <E> Collection<E> sampleWithoutReplacement(Collection<E> c, int n) {\r\n    return sampleWithoutReplacement(c, n, new Random());\r\n  }", "label": 0}
{"code": "def is_relevant(self, action, subject):\n        \"\"\"\n        Matches both the subject and action, not necessarily the conditions.\n        \"\"\"\n        return self.matches_action(action) and self.matches_subject(subject)", "label": 1}
{"code": "public function setInfoTypeStats($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\InfoTypeStats::class);\n        $this->info_type_stats = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "function(func, scope, args)\n{\n    var fixedArgs = Array.prototype.slice.call(arguments, 2);\n    return function()\n    {\n        var args = fixedArgs.concat(Array.prototype.slice.call(arguments, 0));\n        (/** @type {Function} */ func).apply(scope, args);\n    };\n}", "label": 3}
{"code": "def push_silent(text, can_suppress = false)\n      flush_merged_text\n      return if can_suppress && @options.suppress_eval?\n      newline = (text == \"end\") ? \";\" : \"\\n\"\n      @temple << [:code, \"#{resolve_newlines}#{text}#{newline}\"]\n      @output_line = @output_line + text.count(\"\\n\") + newline.count(\"\\n\")\n    end", "label": 4}
{"code": "public static String createClassName(String scenarioDescription) {\n        String[] words = scenarioDescription.trim().split(\" \");\n        String name = \"\";\n        for (int i = 0; i < words.length; i++) {\n            name += changeFirstLetterToCapital(words[i]);\n        }\n        return name;\n    }", "label": 0}
{"code": "def unvalidated_parm(self, parm: str) -> bool:\n        \"\"\"Return true if the pair name should be ignored\n\n        :param parm: string part of pair string:value\n        :return: True if it should be accepted\n        \"\"\"\n        return parm.startswith(\"_\") or parm == self.TYPE or parm in self.IGNORE or \\\n            (self.JSON_LD and parm.startswith('@'))", "label": 1}
{"code": "protected void appendWhereClause(StringBuffer where, Criteria crit, StringBuffer stmt)\r\n    {\r\n        if (where.length() == 0)\r\n        {\r\n            where = null;\r\n        }\r\n\r\n        if (where != null || (crit != null && !crit.isEmpty()))\r\n        {\r\n            stmt.append(\" WHERE \");\r\n            appendClause(where, crit, stmt);\r\n        }\r\n    }", "label": 0}
{"code": "function addWidgetForFilter (view, filter, editModeHint) {\n  var gridster = view._widgetsGridster;\n  var row = filter.row || 1;\n  var col = filter.col || 1;\n  var sizeX = filter.size_x || 3;\n  var sizeY = filter.size_y || 3;\n\n  var el = gridster.add_widget('<div class=\"widgetOuterFrame\"></div>', sizeX, sizeY, col, row);\n  var frameView = new WidgetFrameView({\n    model: filter\n  });\n\n  // render, and render content of widget frame\n  view.renderSubview(frameView, el[0]);\n  frameView.renderContent();\n\n  // link element and view so we can:\n  // a) on remove, get to the HTMLElement from the WidgetFrameView\n  // b) on resize, get to the WidgetFrameView from the HTMLElement\n  frameView.gridsterHook = el[0];\n  $(el[0]).data('spotWidgetFrameView', frameView);\n\n  // try to initialize and render possibly present data\n  // only follow editModeHint when the widget is configured, default to true\n  var chartView = frameView.widget;\n  chartView.model.updateConfiguration();\n  if (chartView.model.isConfigured) {\n    if (!filter.isInitialized) {\n      filter.initDataFilter();\n    }\n    if (!chartView.isInitialized) {\n      chartView.initChart();\n    }\n    chartView.update();\n\n    frameView.editMode = editModeHint;\n  } else {\n    // widget is not configured, ignore editModeHint\n    // and always go to edit mode\n    frameView.editMode = true;\n  }\n\n  filter.on('newData', function () {\n    chartView.update();\n  });\n}", "label": 3}
{"code": "def get_temporary_scripts_path(self):\n        \"\"\"\n        Get path for temporary scripts.\n\n        Returns:\n            str: path for temporary scripts or None if not set\n        \"\"\"\n        result = None\n        if len(self.config.temporary_scripts_path) > 0:\n            if os.path.isdir(self.config.temporary_scripts_path):\n                result = self.config.temporary_scripts_path\n        return result", "label": 1}
{"code": "function createType(attrs, opts) {\n  if (attrs === null) {\n    // Let's be helpful for this common error.\n    throw new Error('invalid type: null (did you mean \"null\"?)');\n  }\n  if (Type.isType(attrs)) {\n    return attrs;\n  }\n\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n\n  var type;\n  if (opts.typeHook && (type = opts.typeHook(attrs, opts))) {\n    if (!Type.isType(type)) {\n      throw new Error(f('invalid typehook return value: %j', type));\n    }\n    return type;\n  }\n\n  if (typeof attrs == 'string') { // Type reference.\n    attrs = qualify(attrs, opts.namespace);\n    type = opts.registry[attrs];\n    if (type) {\n      // Type was already defined, return it.\n      return type;\n    }\n    if (isPrimitive(attrs)) {\n      // Reference to a primitive type. These are also defined names by default\n      // so we create the appropriate type and it to the registry for future\n      // reference.\n      return opts.registry[attrs] = createType({type: attrs}, opts);\n    }\n    throw new Error(f('undefined type name: %s', attrs));\n  }\n\n  if (attrs.logicalType && opts.logicalTypes && !LOGICAL_TYPE) {\n    var DerivedType = opts.logicalTypes[attrs.logicalType];\n    if (DerivedType) {\n      var namespace = opts.namespace;\n      var registry = {};\n      Object.keys(opts.registry).forEach(function (key) {\n        registry[key] = opts.registry[key];\n      });\n      try {\n        return new DerivedType(attrs, opts);\n      } catch (err) {\n        if (opts.assertLogicalTypes) {\n          // The spec mandates that we fall through to the underlying type if\n          // the logical type is invalid. We provide this option to ease\n          // debugging.\n          throw err;\n        }\n        LOGICAL_TYPE = null;\n        opts.namespace = namespace;\n        opts.registry = registry;\n      }\n    }\n  }\n\n  if (Array.isArray(attrs)) { // Union.\n    var UnionType = opts.wrapUnions ? WrappedUnionType : UnwrappedUnionType;\n    type = new UnionType(attrs, opts);\n  } else { // New type definition.\n    type = (function (typeName) {\n      var Type = TYPES[typeName];\n      if (Type === undefined) {\n        throw new Error(f('unknown type: %j', typeName));\n      }\n      return new Type(attrs, opts);\n    })(attrs.type);\n  }\n  return type;\n}", "label": 3}
{"code": "@Deprecated\n\tpublic void setResolutions(List<Double> resolutions) {\n\t\tgetZoomLevels().clear();\n\t\tfor (Double resolution : resolutions) {\n\t\t\tgetZoomLevels().add(new ScaleInfo(1. / resolution));\n\t\t}\n\t}", "label": 0}
{"code": "def generate_background\n      background = MiniMagick::Image.open(fetch_config['background'])\n\n      if background.height != screenshot.size[1]\n        background.resize(\"#{screenshot.size[0]}x#{screenshot.size[1]}^\") # `^` says it should fill area\n        background.merge!([\"-gravity\", \"center\", \"-crop\", \"#{screenshot.size[0]}x#{screenshot.size[1]}+0+0\"]) # crop from center\n      end\n      background\n    end", "label": 4}
{"code": "public function addAttributes(array $attributes)\n    {\n        foreach ($attributes as $key => $value) {\n            $this->addAttribute($key, $value);\n        }\n    }", "label": 2}
{"code": "public function setRequests($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Vision\\V1\\AsyncAnnotateFileRequest::class);\n        $this->requests = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "private function pathId($name)\n    {\n        $parts = $this->splitName($name);\n        if ($parts[0] === '') {\n            return null;\n        }\n\n        return end($parts);\n    }", "label": 2}
{"code": "public function decodeID(string $globalID): string\n    {\n        [$type, $id] = self::decode($globalID);\n\n        return $id;\n    }", "label": 2}
{"code": "public LayerType toDto(Class<? extends com.vividsolutions.jts.geom.Geometry> geometryClass) {\n\t\tif (geometryClass == LineString.class) {\n\t\t\treturn LayerType.LINESTRING;\n\t\t} else if (geometryClass == MultiLineString.class) {\n\t\t\treturn LayerType.MULTILINESTRING;\n\t\t} else if (geometryClass == Point.class) {\n\t\t\treturn LayerType.POINT;\n\t\t} else if (geometryClass == MultiPoint.class) {\n\t\t\treturn LayerType.MULTIPOINT;\n\t\t} else if (geometryClass == Polygon.class) {\n\t\t\treturn LayerType.POLYGON;\n\t\t} else if (geometryClass == MultiPolygon.class) {\n\t\t\treturn LayerType.MULTIPOLYGON;\n\t\t} else {\n\t\t\treturn LayerType.GEOMETRY;\n\t\t}\n\t}", "label": 0}
{"code": "def extract_tokens(representation, separators=SEPARATOR_CHARACTERS):\n    \"\"\"Extracts durations tokens from a duration representation.\n\n    Parses the string representation incrementaly and raises\n    on first error met.\n\n    :param  representation: duration representation\n    :type   representation: string\n    \"\"\"\n    buff = \"\"\n    elements = []\n    last_index = 0\n    last_token = None\n\n    for index, c in enumerate(representation):\n        # if separator character is found, push\n        # the content of the buffer in the elements list\n        if c in separators:\n            if buff:\n                # If the last found token is invalid,\n                # raise and InvalidTokenError\n                if not valid_token(buff):\n                    raise InvalidTokenError(\n                        \"Duration representation {0} contains \"\n                        \"an invalid token: {1}\".format(representation, buff)\n                    )\n\n                # If buffer content is a separator word, for example\n                # \"and\", just ignore it\n                if not buff.strip() in SEPARATOR_TOKENS:\n                    elements.append(buff)\n\n            # Anyway, reset buffer and last token marker\n            # to their zero value\n            buff = \"\"\n            last_token = None\n        else:\n            token = compute_char_token(c)\n            if (token is not None and last_token is not None and token != last_token):\n                elements.append(buff)\n                buff = c\n            else:\n                buff += c\n\n            last_token = token\n\n    # push the content left in representation\n    # in the elements list\n    elements.append(buff)\n\n    return list(zip(elements[::2], elements[1::2]))", "label": 1}
{"code": "def stop(cls):\n        \"\"\"Stop the thread animation gracefully and reset_message\"\"\"\n        if AnimatedDecorator._enabled:\n            if cls.spinner.running:\n                cls.spinner.running = False\n                cls.animation.thread.join()\n\n            if any(cls.animation.messages):\n                cls.pop_message()\n\n            sys.stdout = sys.__stdout__", "label": 1}
{"code": "public void registerComponent(java.awt.Component c)\r\n    {\r\n        unregisterComponent(c);\r\n        if (recognizerAbstractClass == null)\r\n        {\r\n            hmDragGestureRecognizers.put(c,  \r\n                dragSource.createDefaultDragGestureRecognizer(c, \r\n                    dragWorker.getAcceptableActions(c), dgListener)\r\n                                        );\r\n        }\r\n        else\r\n        {\r\n            hmDragGestureRecognizers.put(c, \r\n                dragSource.createDragGestureRecognizer (recognizerAbstractClass,\r\n                    c, dragWorker.getAcceptableActions(c), dgListener)\r\n                                        );\r\n        }\r\n    }", "label": 0}
{"code": "func (l *connection) hasPreferredNetworkOver(r *connection) (left, ok bool) {\n\tvar ml multiLess\n\tml.NextBool(l.isPreferredDirection(), r.isPreferredDirection())\n\tml.NextBool(!l.utp(), !r.utp())\n\tml.NextBool(l.ipv6(), r.ipv6())\n\treturn ml.FinalOk()\n}", "label": 5}
{"code": "public void addFieldDescriptor(FieldDescriptor fld)\r\n    {\r\n        fld.setClassDescriptor(this); // BRJ\r\n        if (m_FieldDescriptions == null)\r\n        {\r\n            m_FieldDescriptions = new FieldDescriptor[1];\r\n            m_FieldDescriptions[0] = fld;\r\n        }\r\n        else\r\n        {\r\n            int size = m_FieldDescriptions.length;\r\n            FieldDescriptor[] tmpArray = new FieldDescriptor[size + 1];\r\n            System.arraycopy(m_FieldDescriptions, 0, tmpArray, 0, size);\r\n            tmpArray[size] = fld;\r\n            m_FieldDescriptions = tmpArray;\r\n            // 2. Sort fields according to their getOrder() Property\r\n            Arrays.sort(m_FieldDescriptions, FieldDescriptor.getComparator());\r\n        }\r\n\r\n        m_fieldDescriptorNameMap = null;\r\n        m_PkFieldDescriptors = null;\r\n        m_nonPkFieldDescriptors = null;\r\n        m_lockingFieldDescriptors = null;\r\n        m_RwFieldDescriptors = null;\r\n        m_RwNonPkFieldDescriptors = null;\r\n    }", "label": 0}
{"code": "func (s *Service) SetOption(args []byte) ([]byte, error) {\n\topts := bytes.SplitN(args, []byte{' '}, 2)\n\tkey := string(opts[0])\n\tval := string(opts[1])\n\n\tif Trace {\n\t\tfmt.Fprintf(os.Stderr, \"set option %q=%q\\n\", key, val)\n\t}\n\n\tswitch key {\n\tcase \"broadcastIP\": // TODO: const-ify\n\t\tif val == \"1\" {\n\t\t\tip := s.PrimaryIP()\n\t\t\tif ip == \"\" {\n\t\t\t\tlog.Printf(\"failed to find primary IP\")\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\tmsg := fmt.Sprintf(\"info-set guestinfo.ip %s\", ip)\n\t\t\t_, err := s.out.Request([]byte(msg))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\ts.SendGuestInfo()\n\t\t}\n\tdefault:\n\t\t// TODO: handle other options...\n\t}\n\n\treturn nil, nil\n}", "label": 5}
{"code": "func (ds *datastore) DeleteObjectAtomic(kvObject KVObject) error {\n\tif ds.sequential {\n\t\tds.Lock()\n\t\tdefer ds.Unlock()\n\t}\n\n\tif kvObject == nil {\n\t\treturn types.BadRequestErrorf(\"invalid KV Object : nil\")\n\t}\n\n\tprevious := &store.KVPair{Key: Key(kvObject.Key()...), LastIndex: kvObject.Index()}\n\n\tif kvObject.Skip() {\n\t\tgoto del_cache\n\t}\n\n\tif _, err := ds.store.AtomicDelete(Key(kvObject.Key()...), previous); err != nil {\n\t\tif err == store.ErrKeyExists {\n\t\t\treturn ErrKeyModified\n\t\t}\n\t\treturn err\n\t}\n\ndel_cache:\n\t// cleanup the cache only if AtomicDelete went through successfully\n\tif ds.cache != nil {\n\t\t// If persistent store is skipped, sequencing needs to\n\t\t// happen in cache.\n\t\treturn ds.cache.del(kvObject, kvObject.Skip())\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "function (value) {\n    const IllegalValue = this.$err.IllegalValue;\n    if (typeof value !== 'string') {\n      return value;\n    }\n    const result = value.replace(ENVVAR_PATTERN, function () {\n      const varname = arguments[1];\n      if (process.env[varname] === undefined) {\n        throw new IllegalValue(`Environment variable ${varname} was referenced but not set`);\n      }\n      return process.env[varname];\n    });\n\n    return result;\n  }", "label": 3}
{"code": "public List<List<IN>> classify(String str) {\r\n    ObjectBank<List<IN>> documents =\r\n      makeObjectBankFromString(str, plainTextReaderAndWriter);\r\n    List<List<IN>> result = new ArrayList<List<IN>>();\r\n\r\n    for (List<IN> document : documents) {\r\n      classify(document);\r\n\r\n      List<IN> sentence = new ArrayList<IN>();\r\n      for (IN wi : document) {\r\n        // TaggedWord word = new TaggedWord(wi.word(), wi.answer());\r\n        // sentence.add(word);\r\n        sentence.add(wi);\r\n      }\r\n      result.add(sentence);\r\n    }\r\n    return result;\r\n  }", "label": 0}
{"code": "def add_txn_opts!(command, read)\n      command.tap do |c|\n        # The read preference should be added for all read operations.\n        if read && txn_read_pref = txn_read_preference\n          Mongo::Lint.validate_underscore_read_preference(txn_read_pref)\n          txn_read_pref = txn_read_pref.dup\n          txn_read_pref[:mode] = txn_read_pref[:mode].to_s.gsub(/(_\\w)/) { |match| match[1].upcase }\n          Mongo::Lint.validate_camel_case_read_preference(txn_read_pref)\n          c['$readPreference'] = txn_read_pref\n        end\n\n        # The read concern should be added to any command that starts a transaction.\n        if starting_transaction?\n          # https://jira.mongodb.org/browse/SPEC-1161: transaction's\n          # read concern overrides collection/database/client read concerns,\n          # even if transaction's read concern is not set.\n          # Read concern here is the one sent to the server and may\n          # include afterClusterTime.\n          if rc = c[:readConcern]\n            rc = rc.dup\n            rc.delete(:level)\n          end\n          if txn_read_concern\n            if rc\n              rc.update(txn_read_concern)\n            else\n              rc = txn_read_concern.dup\n            end\n          end\n          if rc.nil? || rc.empty?\n            c.delete(:readConcern)\n          else\n            c[:readConcern ] = rc\n          end\n        end\n\n        # We need to send the read concern level as a string rather than a symbol.\n        if c[:readConcern] && c[:readConcern][:level]\n          c[:readConcern][:level] = c[:readConcern][:level].to_s\n        end\n\n        # The write concern should be added to any abortTransaction or commitTransaction command.\n        if (c[:abortTransaction] || c[:commitTransaction])\n          if @already_committed\n            wc = BSON::Document.new(c[:writeConcern] || txn_write_concern || {})\n            wc.merge!(w: :majority)\n            wc[:wtimeout] ||= 10000\n            c[:writeConcern] = wc\n          elsif txn_write_concern\n            c[:writeConcern] ||= txn_write_concern\n          end\n        end\n\n        # A non-numeric write concern w value needs to be sent as a string rather than a symbol.\n        if c[:writeConcern] && c[:writeConcern][:w] && c[:writeConcern][:w].is_a?(Symbol)\n          c[:writeConcern][:w] = c[:writeConcern][:w].to_s\n        end\n      end\n    end", "label": 4}
{"code": "public static authenticationvserver_stats get(nitro_service service, String name) throws Exception{\n\t\tauthenticationvserver_stats obj = new authenticationvserver_stats();\n\t\tobj.set_name(name);\n\t\tauthenticationvserver_stats response = (authenticationvserver_stats) obj.stat_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function setDictionary($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\CustomInfoType_Dictionary::class);\n        $this->writeOneof(2, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "public static <T, A extends Annotation> String getClassAnnotationValue(Class<T> classType, Class<A> annotationType, String attributeName) {\n\t\tString value = null;\n\t\tAnnotation annotation = classType.getAnnotation(annotationType);\n\t\tif (annotation != null) {\n\t\t\ttry {\n\t\t\t\tvalue = (String) annotation.annotationType().getMethod(attributeName).invoke(annotation);\n\t\t\t} catch (Exception ex) {}\n\t\t}\n\t\treturn value;\n\t}", "label": 0}
{"code": "def set_startup_mode(service_name, startup_type)\n      startup_code = SERVICE_START_TYPES.key(startup_type)\n      if startup_code.nil?\n        raise Puppet::Error.new(_(\"Unknown start type %{start_type}\") % {startup_type: startup_type.to_s})\n      end\n      open_service(service_name, SC_MANAGER_CONNECT, SERVICE_CHANGE_CONFIG) do |service|\n        # Currently the only thing puppet's API can really manage\n        # in this list is dwStartType (the third param). Thus no\n        # generic function was written to make use of all the params\n        # since the API as-is couldn't use them anyway\n        success = ChangeServiceConfigW(\n          service,\n          SERVICE_NO_CHANGE,  # dwServiceType\n          startup_code,       # dwStartType\n          SERVICE_NO_CHANGE,  # dwErrorControl\n          FFI::Pointer::NULL, # lpBinaryPathName\n          FFI::Pointer::NULL, # lpLoadOrderGroup\n          FFI::Pointer::NULL, # lpdwTagId\n          FFI::Pointer::NULL, # lpDependencies\n          FFI::Pointer::NULL, # lpServiceStartName\n          FFI::Pointer::NULL, # lpPassword\n          FFI::Pointer::NULL  # lpDisplayName\n        )\n        if success == FFI::WIN32_FALSE\n          raise Puppet::Util::Windows::Error.new(_(\"Failed to update service configuration\"))\n        end\n      end\n    end", "label": 4}
{"code": "def data=(values=[])\n      @tag_name = values.first.is_a?(Cell) ? :strCache : :strLit\n      values.each do |value|\n        v = value.is_a?(Cell) ? value.value : value\n        @pt << @type.new(:v => v)\n      end\n    end", "label": 4}
{"code": "def slice(index, num)\n      ensure_unpacked!\n      MultiEventStream.new(@unpacked_times.slice(index, num), @unpacked_records.slice(index, num))\n    end", "label": 4}
{"code": "public static base_response update(nitro_service client, nshttpparam resource) throws Exception {\n\t\tnshttpparam updateresource = new nshttpparam();\n\t\tupdateresource.dropinvalreqs = resource.dropinvalreqs;\n\t\tupdateresource.markhttp09inval = resource.markhttp09inval;\n\t\tupdateresource.markconnreqinval = resource.markconnreqinval;\n\t\tupdateresource.insnssrvrhdr = resource.insnssrvrhdr;\n\t\tupdateresource.nssrvrhdr = resource.nssrvrhdr;\n\t\tupdateresource.logerrresp = resource.logerrresp;\n\t\tupdateresource.conmultiplex = resource.conmultiplex;\n\t\tupdateresource.maxreusepool = resource.maxreusepool;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "def suggest(alias, max=3, cutoff=0.5):\n    \"\"\" Suggest a list of aliases which are similar enough\n    \"\"\"\n\n    aliases = matchers.keys()\n    similar = get_close_matches(alias, aliases, n=max, cutoff=cutoff)\n\n    return similar", "label": 1}
{"code": "def location\n      st = Position.new(0, 0)\n      en = Position.from_offset(code, code.length)\n      range = Range.new(st, en)\n      Location.new(filename, range)\n    end", "label": 4}
{"code": "public function setCustomStringFunctions(array $functions) : void\n    {\n        foreach ($functions as $name => $className) {\n            $this->addCustomStringFunction($name, $className);\n        }\n    }", "label": 2}
{"code": "def copy\n      ditto = self.class.new\n      @images.each { |f| ditto << f.copy }\n      ditto.scene = @scene\n      ditto.taint if tainted?\n      ditto\n    end", "label": 4}
{"code": "function clean(attribute) {\n    expect(arguments).to.have.length.below(\n      2,\n      'Invalid arguments length when cleaning an Entity attribute (it has ' +\n      'to be passed less than 2 arguments)'\n    );\n\n    var attributes = this.Entity.attributes;\n\n    if (attribute) {\n      expect(attribute).to.be.a(\n        'string',\n        'Invalid argument \"attribute\" when cleaning an Entity attribute (it ' +\n        'has to be a string)'\n      );\n\n      expect(attributes).to.have.ownProperty(\n        attribute,\n        'Invalid argument \"attribute\" when cleaning an Entity attribute ' +\n        '(this attribute does not exist in the Entity)'\n      );\n\n      var newAttributes = {};\n      newAttributes[attribute] = attributes[attribute];\n      attributes = newAttributes;\n    }\n\n    for (var attributeName in attributes) {\n      _attributeStorageValues[attributeName] = this[attributeName];\n      _attributeIsSet[attributeName] = false;\n    }\n  }", "label": 3}
{"code": "public function setValue($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\Value::class);\n        $this->value = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function(cb) {\n            git(repoDir, ['status'], function(err, stdout, stderr) {\n                if (err) {\n                    log.warn('git status failed on ' + repoDir + \":\", err.msg);\n                    var indexFile = path.join(repoDir, '.git', 'index');\n                    path.exists(indexFile, function(exists) {\n                        if (exists) {\n                            fs.unlink(indexFile, function(err) {\n                                if (err) {\n                                    log.warn('removing file ' + indexFile + ' failed with:', err);\n                                }\n                                else {\n                                    log.info('removed index file: ' + indexFile);\n                                }\n                                cb(err, {status: {stdout: stdout, stderr: stderr}, removeIndex: 'remove git index ' + indexFile + ', result ' + err});\n                            });\n                            return;\n                        }\n                        log.warn('No index file ' + indexFile);\n                        cb(err, {status: {stdout: stdout, stderr: stderr}, removeIndex: 'no index present'});\n                    });\n                    return;\n                }\n                cb(null, {status: {stdout: stdout, stderr: stderr}});\n            });\n        }", "label": 3}
{"code": "def set_roles(role, reason = nil)\n      role_ids = role_id_array(role)\n      API::Server.update_member(@bot.token, @server.id, @user.id, roles: role_ids, reason: reason)\n    end", "label": 4}
{"code": "def check(line, queries):\n    \"\"\"\n    check that at least one of\n    queries is in list, l\n    \"\"\"\n    line = line.strip()\n    spLine = line.replace('.', ' ').split()\n    matches = set(spLine).intersection(queries)\n    if len(matches) > 0:\n        return matches, line.split('\\t')\n    return matches, False", "label": 1}
{"code": "function( tmp ) {\r\n      return tmp.val.length <= tmp.arg || messages.maxLength.replace( '{count}', tmp.arg );\r\n    }", "label": 3}
{"code": "def process_indent(line)\n      return unless line.tabs <= @template_tabs && @template_tabs > 0\n\n      to_close = @template_tabs - line.tabs\n      to_close.times {|i| close unless to_close - 1 - i == 0 && continuation_script?(line.text)}\n    end", "label": 4}
{"code": "func (f *Fpdf) SetY(y float64) {\n\t// dbg(\"SetY x %.2f, lMargin %.2f\", f.x, f.lMargin)\n\tf.x = f.lMargin\n\tif y >= 0 {\n\t\tf.y = y\n\t} else {\n\t\tf.y = f.h + y\n\t}\n}", "label": 5}
{"code": "function formatError(error, stack) {\n  if (origPrepareStackTrace) {\n    return origPrepareStackTrace(error, stack);\n  }\n  return [\n    error.toString(),\n    stack\n      .map(function (frame) {\n        return 'at ' + frame.toString();\n      })\n      .map(padLeft)\n      .join('\\n')\n  ].join('\\n');\n}", "label": 3}
{"code": "public static base_response delete(nitro_service client, route resource) throws Exception {\n\t\troute deleteresource = new route();\n\t\tdeleteresource.network = resource.network;\n\t\tdeleteresource.netmask = resource.netmask;\n\t\tdeleteresource.gateway = resource.gateway;\n\t\tdeleteresource.td = resource.td;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "def local_users(self):\n        \"\"\"Returns an array of user ids for users on the filesystem\"\"\"\n        # Any users on the machine will have an entry inside of the userdata\n        # folder. As such, the easiest way to find a list of all users on the\n        # machine is to just list the folders inside userdata\n        userdirs = filter(self._is_user_directory, os.listdir(self.userdata_location()))\n        # Exploits the fact that the directory is named the same as the user id\n        return map(lambda userdir: user.User(self, int(userdir)), userdirs)", "label": 1}
{"code": "func (r *Registry) AddHandler(h RegisterObject) {\n\tr.m.Lock()\n\tr.handlers[h.Reference()] = h\n\tr.m.Unlock()\n}", "label": 5}
{"code": "def parse_fasta_annotations(fastas, annot_tables, trans_table):\n    \"\"\"\n    parse gene call information from Prodigal fasta output\n    \"\"\"\n    if annot_tables is not False:\n        annots = {}\n        for table in annot_tables:\n            for cds in open(table):\n                ID, start, end, strand = cds.strip().split()\n                annots[ID] = [start, end, int(strand)]\n    for fasta in fastas:\n        for seq in parse_fasta(fasta):\n            if ('# ;gc_cont' not in seq[0] and '# ID=' not in seq[0]) and annot_tables is False:\n                print('# specify fasta from Prodigal or annotations table (-t)', file=sys.stderr)\n                exit()\n            if 'ID=' in seq[0]:\n                ID = seq[0].rsplit('ID=', 1)[1].split(';', 1)[0]\n                contig = seq[0].split()[0].split('>')[1].rsplit('_%s' % (ID), 1)[0]\n            else:\n                contig = seq[0].split()[0].split('>')[1].rsplit('_', 1)[0]\n            locus = seq[0].split()[0].split('>')[1]\n            # annotation info from Prodigal\n            if ('# ;gc_cont' in seq[0] or '# ID=' in seq[0]):\n                info = seq[0].split(' # ')\n                start, end, strand = int(info[1]), int(info[2]), info[3]\n                if strand == '1':\n                    strand = 1\n                else:\n                    strand = -1\n                product = [''.join(info[4].split()[1:])]\n            # annotation info from table\n            else:\n                start, end, strand = annots[locus]\n                product = seq[0].split(' ', 1)[1]\n            info = {'transl_table':[trans_table], \\\n                    'translation':[seq[1]], \\\n                    'product':product}\n            yield contig, [locus, [start, end, strand], info]", "label": 1}
{"code": "public static cachecontentgroup get(nitro_service service, String name) throws Exception{\n\t\tcachecontentgroup obj = new cachecontentgroup();\n\t\tobj.set_name(name);\n\t\tcachecontentgroup response = (cachecontentgroup) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def list_modules\n      internal_module_groups = { BOLTLIB_PATH => 'Plan Language Modules',\n                                 MODULES_PATH => 'Packaged Modules' }\n\n      in_bolt_compiler do\n        # NOTE: Can replace map+to_h with transform_values when Ruby 2.4\n        #       is the minimum supported version.\n        Puppet.lookup(:current_environment).modules_by_path.map do |path, modules|\n          module_group = internal_module_groups[path]\n\n          values = modules.map do |mod|\n            mod_info = { name: (mod.forge_name || mod.name),\n                         version: mod.version }\n            mod_info[:internal_module_group] = module_group unless module_group.nil?\n\n            mod_info\n          end\n\n          [path, values]\n        end.to_h\n      end\n    end", "label": 4}
{"code": "private function formatTimestampFromApi(array $timestamp)\n    {\n        $timestamp += [\n            'seconds' => 0,\n            'nanos' => 0\n        ];\n\n        $dt = $this->createDateTimeFromSeconds($timestamp['seconds']);\n\n        return $this->formatTimeAsString($dt, $timestamp['nanos']);\n    }", "label": 2}
{"code": "public function setLegacyAbac($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Container\\V1\\LegacyAbac::class);\n        $this->legacy_abac = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def firestore scope: nil, timeout: nil, client_config: nil\n      Google::Cloud.firestore @project, @keyfile,\n                              scope: scope, timeout: (timeout || @timeout),\n                              client_config: client_config\n    end", "label": 4}
{"code": "function (event) {\n                var\n                    reader = event.target,\n                    buffer,\n                    len,\n                    result,\n                    idx;\n                _gpfAssert(reader === this._reader, \"Unexpected change of reader\");\n                if (reader.error) {\n                    gpfFireEvent.call(this,\n                        gpfI.IReadableStream.ERROR,\n                        {\n                            // According to W3C\n                            // http://www.w3.org/TR/domcore/#interface-domerror\n                            error: {\n                                name: reader.error.name,\n                                message: reader.error.message\n                            }\n                        },\n                        this._eventsHandler\n                    );\n                } else if (reader.readyState === FileReader.DONE) {\n                    buffer = new Int8Array(reader.result);\n                    len = buffer.length;\n                    result = [];\n                    for (idx = 0; idx < len; ++idx) {\n                        result.push(buffer[idx]);\n                    }\n                    gpfFireEvent.call(this, gpfI.IReadableStream.EVENT_DATA, {buffer: result}, this._eventsHandler);\n                }\n            }", "label": 3}
{"code": "public function updateBreakpoint(Breakpoint $breakpoint, array $options = [])\n    {\n        $this->connection->updateBreakpoint([\n            'debuggeeId' => $this->id,\n            'id' => $breakpoint->id(),\n            'breakpoint' => $breakpoint->info()\n        ] + $options);\n    }", "label": 2}
{"code": "def image?(new_file)\n      content_type = model.content_type || new_file.content_type\n      content_type.to_s.start_with? \"image\"\n    end", "label": 4}
{"code": "def create(*args)\n      raise_authentication_error unless authenticated?\n      arguments(args) do\n        assert_required :note, :scopes\n      end\n\n      post_request('/authorizations', arguments.params)\n    end", "label": 4}
{"code": "def set_value(request, name, value):\n    \"\"\"\n    For manual shortcut links to perform set value actions\n    \"\"\"\n    obj = service.system.namespace.get(name, None)\n    if not obj or service.read_only:\n        raise Http404\n    obj.status = value\n    if service.redirect_from_setters:\n        return HttpResponseRedirect(reverse('set_ready', args=(name, value)))\n    else:\n        return set_ready(request, name, value)", "label": 1}
{"code": "public static void unsetCurrentPersistenceBroker(PBKey key, PersistenceBrokerInternal broker)\r\n            throws PBFactoryException\r\n    {\r\n        HashMap map = (HashMap) currentBrokerMap.get();\r\n        WeakHashMap set = null;\r\n        if(map != null)\r\n        {\r\n            set = (WeakHashMap) map.get(key);\r\n            if(set != null)\r\n            {\r\n                set.remove(broker);\r\n                if(set.isEmpty())\r\n                {\r\n                    map.remove(key);\r\n                }\r\n            }\r\n            if(map.isEmpty())\r\n            {\r\n                currentBrokerMap.set(null);\r\n                synchronized(lock) {\r\n                    loadedHMs.remove(map);\r\n                }\r\n            }\r\n        }\r\n    }", "label": 0}
{"code": "def i18n_klass(klass)\n      klass.model_name.respond_to?(:i18n_key) ? klass.model_name.i18n_key : klass.name.underscore\n    end", "label": 4}
{"code": "func EndpointOptionGeneric(generic map[string]interface{}) EndpointOption {\n\treturn func(ep *endpoint) {\n\t\tfor k, v := range generic {\n\t\t\tep.generic[k] = v\n\t\t}\n\t}\n}", "label": 5}
{"code": "func newClientConn(ctx context.Context,\n\tconn net.Conn,\n\tnodeAddress string,\n\tconfig *ssh.ClientConfig) (ssh.Conn, <-chan ssh.NewChannel, <-chan *ssh.Request, error) {\n\n\ttype response struct {\n\t\tconn   ssh.Conn\n\t\tchanCh <-chan ssh.NewChannel\n\t\treqCh  <-chan *ssh.Request\n\t\terr    error\n\t}\n\n\trespCh := make(chan response, 1)\n\tgo func() {\n\t\tconn, chans, reqs, err := ssh.NewClientConn(conn, nodeAddress, config)\n\t\trespCh <- response{conn, chans, reqs, err}\n\t}()\n\n\tselect {\n\tcase resp := <-respCh:\n\t\tif resp.err != nil {\n\t\t\treturn nil, nil, nil, trace.Wrap(resp.err, \"failed to connect to %q\", nodeAddress)\n\t\t}\n\t\treturn resp.conn, resp.chanCh, resp.reqCh, nil\n\tcase <-ctx.Done():\n\t\terrClose := conn.Close()\n\t\tif errClose != nil {\n\t\t\tlog.Error(errClose)\n\t\t}\n\t\t// drain the channel\n\t\tresp := <-respCh\n\t\treturn nil, nil, nil, trace.ConnectionProblem(resp.err, \"failed to connect to %q\", nodeAddress)\n\t}\n}", "label": 5}
{"code": "function() {\n\t\t\tthis._timeout_id = false; // Make it clear that I don't have a timeout set\n\t\t\tvar new_targets = filter(get_dom_array(this.targets), isAnyElement); // update the list of targets\n\n\t\t\tif(has(options, \"onChange\")) {\n\t\t\t\toptions.onChange.call(this, curr_value, last_value);\n\t\t\t}\n\n\t\t\t// For every target, update the attribute\n\t\t\teach(new_targets, function(target) {\n\t\t\t\tsetter.call(this, target, curr_value, last_value);\n\t\t\t}, this);\n\n\t\t\t// track the last value so that next time we call diff\n\t\t\tlast_value = curr_value;\n\t\t}", "label": 3}
{"code": "def _reduce_22(val, _values, result)\n n = val[0]; result = n.count('.') > 0 ? n.to_f : n.to_i \n    result\nend", "label": 4}
{"code": "public Future<HazeltaskTask<GROUP>> addPendingTaskAsync(HazeltaskTask<GROUP> task) {\n        return pendingTask.putAsync(task.getId(), task);\n    }", "label": 0}
{"code": "public boolean isDeleted(Identity id)\r\n    {\r\n        ObjectEnvelope envelope = buffer.getByIdentity(id);\r\n\r\n        return (envelope != null && envelope.needsDelete());\r\n    }", "label": 0}
{"code": "def create_measure_period_v1_data_criteria(doc,measure_period,v1_data_criteria_by_id)\n\n      attributes = doc[:attributes]\n      attributes.keys.each {|key| attributes[key.to_s] = attributes[key]}\n      \n      measure_period_key = attributes['MEASUREMENT_PERIOD'][:id]\n      measure_start_key = attributes['MEASUREMENT_START_DATE'][:id]\n      measure_end_key = attributes['MEASUREMENT_END_DATE'][:id]\n      \n      @measure_period_v1_keys = {measure_start: measure_start_key, measure_end: measure_end_key, measure_period: measure_period_key}\n      \n      type = 'variable'\n      code_list_id,negation_code_list_id,property,status,field_values,effective_time,inline_code_list,children_criteria,derivation_operator,temporal_references,subset_operators=nil\n      \n      #####\n      ##\n      ######### SET MEASURE PERIOD\n      ##\n      #####\n      \n      measure_period_id = HQMF::Document::MEASURE_PERIOD_ID\n      value = measure_period\n      measure_criteria = HQMF::DataCriteria.new(measure_period_id,measure_period_id,nil,measure_period_id,code_list_id,children_criteria,derivation_operator,measure_period_id,status,\n                                                value,field_values,effective_time,inline_code_list, false, nil, temporal_references,subset_operators,nil,nil)\n      \n      # set the measure period data criteria for all measure period keys\n      v1_data_criteria_by_id[measure_period_key] = measure_criteria\n      v1_data_criteria_by_id[measure_start_key] = measure_criteria\n      v1_data_criteria_by_id[measure_end_key] = measure_criteria\n      @measure_period_criteria = measure_criteria\n      \n    end", "label": 4}
{"code": "def upsert(self):\n        \"\"\"\n        The main event of the utility. Create or update a Cloud Formation\n        stack. Injecting properties where needed\n\n        Args:\n            None\n\n        Returns:\n            True if the stack create/update is started successfully else\n            False if the start goes off in the weeds.\n\n        Exits:\n            If the user asked for a dryrun exit(with a code 0) the thing here. There is no\n            point continuing after that point.\n\n        \"\"\"\n\n        required_parameters = []\n        self._stackParameters = []\n\n        try:\n            self._initialize_upsert()\n        except Exception:\n            return False\n\n        try:\n            available_parameters = self._parameters.keys()\n\n            for parameter_name in self._template.get('Parameters', {}):\n                required_parameters.append(str(parameter_name))\n\n            logging.info(' required parameters: ' + str(required_parameters))\n            logging.info('available parameters: ' + str(available_parameters))\n\n            parameters = []\n            for required_parameter in required_parameters:\n                parameter = {}\n                parameter['ParameterKey'] = str(required_parameter)\n\n                required_parameter = str(required_parameter)\n                if required_parameter in self._parameters:\n                    parameter['ParameterValue'] = self._parameters[required_parameter]\n                else:\n                    parameter['ParameterValue'] = self._parameters[required_parameter.lower()]\n\n                parameters.append(parameter)\n\n            if not self._analyze_stuff():\n                sys.exit(1)\n\n            if self._config.get('dryrun', False):\n                logging.info('Generating change set')\n                set_id = self._generate_change_set(parameters)\n                if set_id:\n                    self._describe_change_set(set_id)\n\n                logging.info('This was a dryrun')\n                sys.exit(0)\n\n            self._tags.append({\"Key\": \"CODE_VERSION_SD\", \"Value\": self._config.get('codeVersion')})\n            self._tags.append({\"Key\": \"ANSWER\", \"Value\": str(42)})\n            if self._updateStack:\n                stack = self._cloudFormation.update_stack(\n                    StackName=self._config.get('environment', {}).get('stack_name', None),\n                    TemplateURL=self._templateUrl,\n                    Parameters=parameters,\n                    Capabilities=['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM'],\n                    Tags=self._tags,\n                    ClientRequestToken=str(uuid.uuid4())\n                )\n                logging.info('existing stack ID: {}'.format(stack.get('StackId', 'unknown')))\n            else:\n                stack = self._cloudFormation.create_stack(\n                    StackName=self._config.get('environment', {}).get('stack_name', None),\n                    TemplateURL=self._templateUrl,\n                    Parameters=parameters,\n                    Capabilities=['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM'],\n                    Tags=self._tags,\n                    ClientRequestToken=str(uuid.uuid4())\n                )\n                logging.info('new stack ID: {}'.format(stack.get('StackId', 'unknown')))\n        except Exception as x:\n            if self._verbose:\n                logging.error(x, exc_info=True)\n            else:\n                logging.error(x, exc_info=False)\n\n            return False\n\n        return True", "label": 1}
{"code": "def routes(rails_router)\n      load!\n      Router.new(router: rails_router, namespaces: namespaces).apply\n    end", "label": 4}
{"code": "func (this *summaryMetricsSource) addLabeledIntMetric(metrics *MetricSet, metric *Metric, labels map[string]string, value *uint64) {\n\tif value == nil {\n\t\tglog.V(9).Infof(\"skipping labeled metric %s (%v) because the value was nil\", metric.Name, labels)\n\t\treturn\n\t}\n\n\tval := LabeledMetric{\n\t\tName:   metric.Name,\n\t\tLabels: labels,\n\t\tMetricValue: MetricValue{\n\t\t\tValueType:  ValueInt64,\n\t\t\tMetricType: metric.Type,\n\t\t\tIntValue:   int64(*value),\n\t\t},\n\t}\n\tmetrics.LabeledMetrics = append(metrics.LabeledMetrics, val)\n}", "label": 5}
{"code": "def get_neg_one_task_agent(generators, market, nOffer, maxSteps):\n    \"\"\" Returns a task-agent tuple whose action is always minus one.\n    \"\"\"\n    env = pyreto.discrete.MarketEnvironment(generators, market, nOffer)\n    task = pyreto.discrete.ProfitTask(env, maxSteps=maxSteps)\n    agent = pyreto.util.NegOneAgent(env.outdim, env.indim)\n    return task, agent", "label": 1}
{"code": "func NewEventResize(width, height int) *EventResize {\n\treturn &EventResize{t: time.Now(), w: width, h: height}\n}", "label": 5}
{"code": "public function index()\n    {\n        $entries = WinkPage::when(request()->has('search'), function ($q) {\n            $q->where('title', 'LIKE', '%'.request('search').'%');\n        })\n            ->orderBy('created_at', 'DESC')\n            ->paginate(30);\n\n        return PagesResource::collection($entries);\n    }", "label": 2}
{"code": "public static function locateConfigFile(string $path)\n    {\n        $dir_path = realpath($path);\n\n        if ($dir_path === false) {\n            throw new ConfigException('Config not found for path ' . $path);\n        }\n\n        if (!is_dir($dir_path)) {\n            $dir_path = dirname($dir_path);\n        }\n\n        do {\n            $maybe_path = $dir_path . DIRECTORY_SEPARATOR . Config::DEFAULT_FILE_NAME;\n\n            if (file_exists($maybe_path) || file_exists($maybe_path .= '.dist')) {\n                return $maybe_path;\n            }\n\n            $dir_path = dirname($dir_path);\n        } while (dirname($dir_path) !== $dir_path);\n        return null;\n    }", "label": 2}
{"code": "public static autoscaleaction[] get(nitro_service service) throws Exception{\n\t\tautoscaleaction obj = new autoscaleaction();\n\t\tautoscaleaction[] response = (autoscaleaction[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def report(options)\n      report = HamlLint::Report.new(reporter: options[:reporter], fail_level: options[:fail_level])\n      report.start(@files)\n      process_files(report)\n      report\n    end", "label": 4}
{"code": "private boolean isSpecial(final char chr) {\n\t\treturn ((chr == '.') || (chr == '?') || (chr == '*') || (chr == '^') || (chr == '$') || (chr == '+')\n\t\t\t\t|| (chr == '[') || (chr == ']') || (chr == '(') || (chr == ')') || (chr == '|') || (chr == '\\\\')\n\t\t\t\t|| (chr == '&'));\n\t}", "label": 0}
{"code": "public function reload(array $options = [])\n    {\n        return $this->policy = $this->connection->getPolicy([\n            'resource' => $this->resource\n        ] + $options + $this->options['args']);\n    }", "label": 2}
{"code": "def list(self, filter=None, type=None, sort=None, limit=None, page=None): # pylint: disable=redefined-builtin\n        \"\"\"Get a list of packages.\n\n        :param filter: (optional) Filters to apply as a string list.\n        :param type: (optional) `union` or `inter` as string.\n        :param sort: (optional) Sort fields to apply as string list.\n        :param limit: (optional) Limit returned list length.\n        :param page: (optional) Page to return.\n        :return: :class:`packages.Page <packages.Page>` object\n        \"\"\"\n        schema = PackageSchema(exclude=('testlist', 'extra_cli_args', 'agent_id', 'options', 'note'))\n        resp = self.service.list(self.base, filter, type, sort, limit, page)\n        ps, l = self.service.decode(schema, resp, many=True, links=True)\n        return Page(ps, l)", "label": 1}
{"code": "function (dependencies) {\n            this._dependsOn = dependencies[this._name] || [];\n            this._dependencyOf = [];\n            Object.keys(dependencies).forEach(function (name) {\n                var nameDependencies = dependencies[name];\n                if (nameDependencies.indexOf(this._name) !== NOT_FOUND) {\n                    this._dependencyOf.push(name);\n                }\n            }, this);\n        }", "label": 3}
{"code": "function colorize(color, str) {\n  return str\n      .split('\\n')\n      .map(part => color(part))\n      .join('\\n');\n}", "label": 3}
{"code": "function modelOrCollectionOnOrOnce(modelType, type, args, _this, _modelOrCollection) {\n        var modelEvents = getModelAndCollectionEvents(modelType, _this);\n        var ev = args[0];\n        var cb = args[1];\n        var ctx = args[2];\n        modelEvents[ev] = {\n            type: type,\n            ev: ev,\n            cb: cb,\n            ctx: ctx\n        };\n\n        function _on(modelOrCollection) {\n            _this[type === 'on' ? 'listenTo' : 'listenToOnce'](modelOrCollection, ev, cb, ctx);\n        }\n        if (modelEvents.__bound) {\n            if (_modelOrCollection) {\n                _on(_modelOrCollection);\n            } else {\n                getModelOrCollections(modelType, _this, _on);\n            }\n        }\n    }", "label": 3}
{"code": "func GetFactory(identifier string) *BeeFactoryInterface {\n\tfactory, ok := factories[identifier]\n\tif ok {\n\t\treturn factory\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public static base_responses enable(nitro_service client, String id[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (id != null && id.length > 0) {\n\t\t\tInterface enableresources[] = new Interface[id.length];\n\t\t\tfor (int i=0;i<id.length;i++){\n\t\t\t\tenableresources[i] = new Interface();\n\t\t\t\tenableresources[i].id = id[i];\n\t\t\t}\n\t\t\tresult = perform_operation_bulk_request(client, enableresources,\"enable\");\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def macaroon(self, version, expiry, caveats, ops):\n        ''' Takes a macaroon with the given version from the oven,\n        associates it with the given operations and attaches the given caveats.\n        There must be at least one operation specified.\n        The macaroon will expire at the given time - a time_before first party\n        caveat will be added with that time.\n\n        @return: a new Macaroon object.\n        '''\n        if len(ops) == 0:\n            raise ValueError('cannot mint a macaroon associated '\n                             'with no operations')\n\n        ops = canonical_ops(ops)\n        root_key, storage_id = self.root_keystore_for_ops(ops).root_key()\n\n        id = self._new_macaroon_id(storage_id, expiry, ops)\n\n        id_bytes = six.int2byte(LATEST_VERSION) + \\\n            id.SerializeToString()\n\n        if macaroon_version(version) < MACAROON_V2:\n            # The old macaroon format required valid text for the macaroon id,\n            # so base64-encode it.\n            id_bytes = raw_urlsafe_b64encode(id_bytes)\n\n        m = Macaroon(\n            root_key,\n            id_bytes,\n            self.location,\n            version,\n            self.namespace,\n        )\n        m.add_caveat(checkers.time_before_caveat(expiry), self.key,\n                     self.locator)\n        m.add_caveats(caveats, self.key, self.locator)\n        return m", "label": 1}
{"code": "function MessageEmitter(ptcl, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this._ptcl = ptcl;\n  this._strict = !!opts.strictErrors;\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._timeout = utils.getOption(opts, 'timeout', 10000);\n  this._prefix = normalizedPrefix(opts.scope);\n\n  this._cache = opts.cache || {};\n  var fgpt = opts.serverFingerprint;\n  var adapter;\n  if (fgpt) {\n    adapter = this._cache[fgpt];\n  }\n  if (!adapter) {\n    // This might happen even if the server fingerprint option was set, in\n    // cases where the cache doesn't contain the corresponding adapter.\n    fgpt = ptcl.getFingerprint();\n    adapter = this._cache[fgpt] = new Adapter(ptcl, ptcl, fgpt);\n  }\n  this._adapter = adapter;\n\n  this._registry = new Registry(this, PREFIX_LENGTH);\n  this._destroyed = false;\n  this._interrupted = false;\n  this.once('_eot', function (pending) { this.emit('eot', pending); });\n}", "label": 3}
{"code": "func (r *Registry) Put(item mo.Reference) mo.Reference {\n\tr.m.Lock()\n\n\tref := item.Reference()\n\tif ref.Type == \"\" || ref.Value == \"\" {\n\t\tref = r.newReference(item)\n\t\tr.setReference(item, ref)\n\t}\n\n\tif me, ok := item.(mo.Entity); ok {\n\t\tme.Entity().ConfigStatus = types.ManagedEntityStatusGreen\n\t\tme.Entity().OverallStatus = types.ManagedEntityStatusGreen\n\t\tme.Entity().EffectiveRole = []int32{-1} // Admin\n\t}\n\n\tr.objects[ref] = item\n\n\tr.m.Unlock()\n\n\tr.applyHandlers(func(o RegisterObject) {\n\t\to.PutObject(item)\n\t})\n\n\treturn item\n}", "label": 5}
{"code": "private boolean relevant(File currentLogFile, GregorianCalendar lastRelevantDate) {\n\t\tString fileName=currentLogFile.getName();\n\t\tPattern p = Pattern.compile(APPENER_DATE_DEFAULT_PATTERN);\n\t\tMatcher m = p.matcher(fileName);\n\t\tif(m.find()){\n\t\t\tint year=Integer.parseInt(m.group(1));\n\t\t\tint month=Integer.parseInt(m.group(2));\n\t\t\tint dayOfMonth=Integer.parseInt(m.group(3));\n\t\t\tGregorianCalendar fileDate=new GregorianCalendar(year, month, dayOfMonth);\n\t\t\tfileDate.add(Calendar.MONTH,-1); //Because of Calendar save the month such that January is 0\n\t\t\treturn fileDate.compareTo(lastRelevantDate)>0;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}", "label": 0}
{"code": "func (process *TeleportProcess) registerWithAuthServer(role teleport.Role, eventName string) {\n\tserviceName := strings.ToLower(role.String())\n\tprocess.RegisterCriticalFunc(fmt.Sprintf(\"register.%v\", serviceName), func() error {\n\t\tconnector, err := process.reconnectToAuthService(role)\n\t\tif err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tprocess.onExit(fmt.Sprintf(\"auth.client.%v\", serviceName), func(interface{}) {\n\t\t\tprocess.Debugf(\"Closed client for %v.\", role)\n\t\t\terr := connector.Client.Close()\n\t\t\tif err != nil {\n\t\t\t\tprocess.Debugf(\"Failed to close client: %v\", err)\n\t\t\t}\n\t\t})\n\t\tprocess.BroadcastEvent(Event{Name: eventName, Payload: connector})\n\t\treturn nil\n\t})\n}", "label": 5}
{"code": "func parseAuthorizedKeys(bytes []byte, allowedLogins []string) (services.CertAuthority, services.Role, error) {\n\tpubkey, comment, _, _, err := ssh.ParseAuthorizedKey(bytes)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\n\tcomments, err := url.ParseQuery(comment)\n\tif err != nil {\n\t\treturn nil, nil, trace.Wrap(err)\n\t}\n\tclusterName := comments.Get(\"clustername\")\n\tif clusterName == \"\" {\n\t\treturn nil, nil, trace.BadParameter(\"no clustername provided\")\n\t}\n\n\t// create a new certificate authority\n\tca := services.NewCertAuthority(\n\t\tservices.UserCA,\n\t\tclusterName,\n\t\tnil,\n\t\t[][]byte{ssh.MarshalAuthorizedKey(pubkey)},\n\t\tnil)\n\n\t// transform old allowed logins into roles\n\trole := services.RoleForCertAuthority(ca)\n\trole.SetLogins(services.Allow, allowedLogins)\n\tca.AddRole(role.GetName())\n\n\treturn ca, role, nil\n}", "label": 5}
{"code": "def create(*args)\n      arguments(args, required: [:user, :repo, :number])\n\n      params             = arguments.params\n      params[\"accept\"] ||= PREVIEW_MEDIA\n\n      post_request(\"/repos/#{arguments.user}/#{arguments.repo}/pulls/#{arguments.number}/reviews\", params)\n    end", "label": 4}
{"code": "def add_method(self, m, **kwargs):\n        \"\"\"Add an instance method or function\n\n        Args:\n            m: The instance method or function to store\n        \"\"\"\n        if isinstance(m, types.FunctionType):\n            self['function', id(m)] = m\n        else:\n            f, obj = get_method_vars(m)\n            wrkey = (f, id(obj))\n            self[wrkey] = obj", "label": 1}
{"code": "private static void writeToLog(Logger logger, Level level, String pattern, Exception exception) {\n    if (level == Level.ERROR) {\n      logger.error(pattern, exception);\n    } else if (level == Level.INFO) {\n      logger.info(pattern);\n    } else if (level == Level.DEBUG) {\n      logger.debug(pattern);\n    }\n  }", "label": 0}
{"code": "func lineFromConsole() (string, error) {\n\tbytes, _, err := bufio.NewReader(os.Stdin).ReadLine()\n\treturn string(bytes), err\n}", "label": 5}
{"code": "def match_variant_sequence_to_reference_context(\n        variant_sequence,\n        reference_context,\n        min_transcript_prefix_length,\n        max_transcript_mismatches,\n        include_mismatches_after_variant=False,\n        max_trimming_attempts=2):\n    \"\"\"\n    Iteratively trim low-coverage subsequences of a variant sequence\n    until it either matches the given reference context or there\n    are too few nucleotides left in the variant sequence.\n\n    Parameters\n    ----------\n    variant_sequence : VariantSequence\n        Assembled sequence from RNA reads, will need to be to be reverse\n        complemented if matching against a reference transcript on the\n        negative strand.\n\n    reference_context : ReferenceContext\n        Sequence of reference transcript before the variant and associated\n        metadata.\n\n    min_transcript_prefix_length : int\n        Minimum number of nucleotides we try to match against a reference\n        transcript.\n\n    max_transcript_mismatches : int\n        Maximum number of nucleotide differences between reference transcript\n        sequence and the variant sequence.\n\n    include_mismatches_after_variant : bool\n        Set to true if the number of mismatches after the variant locus should\n        count toward the total max_transcript_mismatches, which by default\n        only counts mismatches before the variant locus.\n\n    max_trimming_attempts : int\n        How many times do we try trimming the VariantSequence to higher\n        levels of coverage before giving up?\n\n    Returns VariantSequenceInReadingFrame or None\n    \"\"\"\n    variant_sequence_in_reading_frame = None\n\n    # if we can't get the variant sequence to match this reference\n    # context then keep trimming it by coverage until either\n    for i in range(max_trimming_attempts + 1):\n        # check the reverse-complemented prefix if the reference context is\n        # on the negative strand since variant sequence is aligned to\n        # genomic DNA (positive strand)\n        variant_sequence_too_short = (\n            (reference_context.strand == \"+\" and\n                len(variant_sequence.prefix) < min_transcript_prefix_length) or\n            (reference_context.strand == \"-\" and\n                len(variant_sequence.suffix) < min_transcript_prefix_length)\n        )\n        if variant_sequence_too_short:\n            logger.info(\n                \"Variant sequence %s shorter than min allowed %d (iter=%d)\",\n                variant_sequence,\n                min_transcript_prefix_length,\n                i + 1)\n            return None\n\n        variant_sequence_in_reading_frame = \\\n            VariantSequenceInReadingFrame.from_variant_sequence_and_reference_context(\n                variant_sequence=variant_sequence,\n                reference_context=reference_context)\n\n        if variant_sequence_in_reading_frame is None:\n            return None\n\n        n_mismatch_before_variant = (\n            variant_sequence_in_reading_frame.number_mismatches_before_variant)\n        n_mismatch_after_variant = (\n            variant_sequence_in_reading_frame.number_mismatches_after_variant)\n\n        logger.info(\"Iter #%d/%d: %s\" % (\n            i + 1,\n            max_trimming_attempts + 1,\n            variant_sequence_in_reading_frame))\n\n        total_mismatches = n_mismatch_before_variant\n        if include_mismatches_after_variant:\n            total_mismatches += n_mismatch_after_variant\n        if total_mismatches <= max_transcript_mismatches:\n            # if we got a variant sequence + reading frame with sufficiently\n            # few mismatches then call it a day\n            return variant_sequence_in_reading_frame\n\n        logger.info(\n            (\"Too many mismatches (%d) between variant sequence %s and \"\n             \"reference context %s (attempt=%d/%d)\"),\n            n_mismatch_before_variant,\n            variant_sequence,\n            reference_context,\n            i + 1,\n            max_trimming_attempts + 1)\n        # if portions of the sequence are supported by only 1 read\n        # then try trimming to 2 to see if the better supported\n        # subsequence can be better matched against the reference\n        current_min_coverage = variant_sequence.min_coverage()\n        logger.info(\n            \"Trimming to subsequence covered by at least %d reads\",\n            current_min_coverage + 1)\n        variant_sequence = variant_sequence.trim_by_coverage(\n            current_min_coverage + 1)\n    return None", "label": 1}
{"code": "function makeObjectID() {\n    return hexString(8, Date.now() / 1000) +\n        hexString(6, machineId) +\n        hexString(4, processId) +\n        hexString(6, counter++); // a 3-byte counter, starting with a random value.\n}", "label": 3}
{"code": "def find_rule(condition):\n        \"\"\"\n        Find rule for given condition.\n\n        Args:\n            condition (str): Python condition as string.\n\n        Returns:\n            str, list, function: found rule name, list of AST tokens for condition\n                                 and verification function.\n        \"\"\"\n        final_condition = re.sub('{{.*}}', '42', condition)\n        ast_tokens = Condition.get_tokens(final_condition)\n        ast_compressed_tokens = Condition.compress_tokens(ast_tokens)\n\n        name = 'undefined'\n        function = lambda tokens: False\n\n        if len(ast_compressed_tokens) > 0:\n            for rule in Condition.RULES:\n                if Condition.match_tokens(ast_compressed_tokens, rule['types']):\n                    name = rule['name']\n                    function = rule['evaluate']\n                    break\n        return name, ast_tokens, function", "label": 1}
{"code": "def __parse_fc_data(fc_data):\n    \"\"\"Parse the forecast data from the xml section.\"\"\"\n    from buienradar.buienradar import condition_from_code\n    fc = []\n    for daycnt in range(1, 6):\n        daysection = __BRDAYFC % daycnt\n        if daysection in fc_data:\n            tmpsect = fc_data[daysection]\n            fcdatetime = datetime.now(pytz.timezone(__TIMEZONE))\n            fcdatetime = fcdatetime.replace(hour=12,\n                                            minute=0,\n                                            second=0,\n                                            microsecond=0)\n            # add daycnt days\n            fcdatetime = fcdatetime + timedelta(days=daycnt)\n            code = tmpsect.get(__BRICOON, []).get(__BRID)\n            fcdata = {\n                CONDITION: condition_from_code(code),\n                TEMPERATURE: __get_float(tmpsect, __BRMAXTEMP),\n                MIN_TEMP: __get_float(tmpsect, __BRMINTEMP),\n                MAX_TEMP: __get_float(tmpsect, __BRMAXTEMP),\n                SUN_CHANCE: __get_int(tmpsect, __BRKANSZON),\n                RAIN_CHANCE: __get_int(tmpsect, __BRKANSREGEN),\n                RAIN: __get_float(tmpsect, __BRMAXMMREGEN),\n                SNOW: __get_float(tmpsect, __BRSNEEUWCMS),\n                WINDFORCE: __get_int(tmpsect, __BRWINDKRACHT),\n                DATETIME: fcdatetime,\n            }\n            fcdata[CONDITION][IMAGE] = tmpsect.get(__BRICOON, []).get(__BRTEXT)\n\n            fc.append(fcdata)\n    return fc", "label": 1}
{"code": "func (e *localExec) Wait() (*ExecResult, error) {\n\tif e.Cmd.Process == nil {\n\t\te.Ctx.Errorf(\"no process\")\n\t}\n\n\t// wait for the command to complete, then figure out if the command\n\t// successfully exited or if it exited in failure\n\texecResult, err := collectLocalStatus(e.Cmd, e.Cmd.Wait())\n\n\t// emit the result of execution to the audit log\n\temitExecAuditEvent(e.Ctx, e.GetCommand(), execResult, err)\n\n\treturn execResult, trace.Wrap(err)\n}", "label": 5}
{"code": "func (t *Torrent) worstBadConn() *connection {\n\twcs := worseConnSlice{t.unclosedConnsAsSlice()}\n\theap.Init(&wcs)\n\tfor wcs.Len() != 0 {\n\t\tc := heap.Pop(&wcs).(*connection)\n\t\tif c.stats.ChunksReadWasted.Int64() >= 6 && c.stats.ChunksReadWasted.Int64() > c.stats.ChunksReadUseful.Int64() {\n\t\t\treturn c\n\t\t}\n\t\t// If the connection is in the worst half of the established\n\t\t// connection quota and is older than a minute.\n\t\tif wcs.Len() >= (t.maxEstablishedConns+1)/2 {\n\t\t\t// Give connections 1 minute to prove themselves.\n\t\t\tif time.Since(c.completedHandshake) > time.Minute {\n\t\t\t\treturn c\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}", "label": 5}
{"code": "@Override\n\tpublic void format(final StringBuffer sbuf, final LoggingEvent event) {\n\t\tfor (int i = 0; i < patternConverters.length; i++) {\n\t\t\tfinal int startField = sbuf.length();\n\t\t\tpatternConverters[i].format(event, sbuf);\n\t\t\tpatternFields[i].format(startField, sbuf);\n\t\t}\n\t}", "label": 0}
{"code": "def display_report(report)\n      super\n\n      File.write(ConfigurationLoader::AUTO_GENERATED_FILE, config_file_contents)\n      log.log \"Created #{ConfigurationLoader::AUTO_GENERATED_FILE}.\"\n      log.log \"Run `haml-lint --config #{ConfigurationLoader::AUTO_GENERATED_FILE}`\" \\\n        \", or add `inherits_from: #{ConfigurationLoader::AUTO_GENERATED_FILE}` in a \" \\\n        '.haml-lint.yml file.'\n    end", "label": 4}
{"code": "function validateDuplicateName(cb) {\n    var formId = formData._id;\n    var formName = formData.name;\n\n    if (!formName) {\n      return cb(new Error(\"No form name passed\"));\n    }\n\n    var query = {};\n\n    //If there is a form id, then the query to the form model must exclude the current form id that is being updated.\n    if (formId) {\n      query.name = formName;\n      //Excluding the formId that is being updated.\n      query[\"_id\"] = {\"$nin\": [formId]};\n    } else { //Just checking that the form name exists as a form is being created\n      query.name = formName;\n    }\n\n    formModel.count(query, function(err, count) {\n      if (err) {\n        return cb(err);\n      }\n\n      //If the number of found forms is > 0, then there is another form with the same name. Do not save the form.\n      if (count > 0) {\n        return cb(new Error(\"Form with name \" + formName + \" already exists found.\"));\n      } else {//No duplicates, can proceed with saving the form.\n        return cb();\n      }\n    });\n  }", "label": 3}
{"code": "func (proxy *ProxyClient) ConnectToCluster(ctx context.Context, clusterName string, quiet bool) (auth.ClientI, error) {\n\tdialer := func(ctx context.Context, network, _ string) (net.Conn, error) {\n\t\treturn proxy.dialAuthServer(ctx, clusterName)\n\t}\n\n\tif proxy.teleportClient.SkipLocalAuth {\n\t\treturn auth.NewTLSClient(auth.ClientConfig{\n\t\t\tDialContext: dialer,\n\t\t\tTLS:         proxy.teleportClient.TLS,\n\t\t})\n\t}\n\n\t// Because Teleport clients can't be configured (yet), they take the default\n\t// list of cipher suites from Go.\n\ttlsConfig := utils.TLSConfig(nil)\n\tlocalAgent := proxy.teleportClient.LocalAgent()\n\tpool, err := localAgent.GetCerts()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttlsConfig.RootCAs = pool\n\tkey, err := localAgent.GetKey()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err, \"failed to fetch TLS key for %v\", proxy.teleportClient.Username)\n\t}\n\tif len(key.TLSCert) != 0 {\n\t\ttlsCert, err := tls.X509KeyPair(key.TLSCert, key.Priv)\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err, \"failed to parse TLS cert and key\")\n\t\t}\n\t\ttlsConfig.Certificates = append(tlsConfig.Certificates, tlsCert)\n\t}\n\tif len(tlsConfig.Certificates) == 0 {\n\t\treturn nil, trace.BadParameter(\"no TLS keys found for user %v, please relogin to get new credentials\", proxy.teleportClient.Username)\n\t}\n\tclt, err := auth.NewTLSClient(auth.ClientConfig{\n\t\tDialContext: dialer,\n\t\tTLS:         tlsConfig,\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn clt, nil\n}", "label": 5}
{"code": "def invite(invite)\n      code = resolve_invite_code(invite)\n      Invite.new(JSON.parse(API::Invite.resolve(token, code)), self)\n    end", "label": 4}
{"code": "function (str, options, cb) {\n    var ECT = this.engine;\n    var tmpl = this.cache(options) || this.cache(options, new ECT({ root: { page: str }}));\n    tmpl.render('page', options, cb);\n  }", "label": 3}
{"code": "def trim_variant_sequences(variant_sequences, min_variant_sequence_coverage):\n    \"\"\"\n    Trim VariantSequences to desired coverage and then combine any\n    subsequences which get generated.\n    \"\"\"\n    n_total = len(variant_sequences)\n    trimmed_variant_sequences = [\n        variant_sequence.trim_by_coverage(min_variant_sequence_coverage)\n        for variant_sequence in variant_sequences\n    ]\n    collapsed_variant_sequences = collapse_substrings(trimmed_variant_sequences)\n    n_after_trimming = len(collapsed_variant_sequences)\n    logger.info(\n        \"Kept %d/%d variant sequences after read coverage trimming to >=%dx\",\n        n_after_trimming,\n        n_total,\n        min_variant_sequence_coverage)\n    return collapsed_variant_sequences", "label": 1}
{"code": "func (r *Registry) SessionManager() *SessionManager {\n\treturn r.Get(r.content().SessionManager.Reference()).(*SessionManager)\n}", "label": 5}
{"code": "def can_process_matrix(entry, matrix_tags):\n        \"\"\"\n        Check given matrix tags to be in the given list of matric tags.\n\n        Args:\n            entry (dict): matrix item (in yaml).\n            matrix_tags (list): represents --matrix-tags defined by user in command line.\n        Returns:\n            bool: True when matrix entry can be processed.\n        \"\"\"\n        if len(matrix_tags) == 0:\n            return True\n\n        count = 0\n        if 'tags' in entry:\n            for tag in matrix_tags:\n                if tag in entry['tags']:\n                    count += 1\n\n        return count > 0", "label": 1}
{"code": "public static String pad(String str, int totalChars) {\r\n    if (str == null) {\r\n      str = \"null\";\r\n    }\r\n    int slen = str.length();\r\n    StringBuilder sb = new StringBuilder(str);\r\n    for (int i = 0; i < totalChars - slen; i++) {\r\n      sb.append(' ');\r\n    }\r\n    return sb.toString();\r\n  }", "label": 0}
{"code": "func NetworkOptionInternalNetwork() NetworkOption {\n\treturn func(n *network) {\n\t\tif n.generic == nil {\n\t\t\tn.generic = make(map[string]interface{})\n\t\t}\n\t\tn.internal = true\n\t\tn.generic[netlabel.Internal] = true\n\t}\n}", "label": 5}
{"code": "def valid_elf_file?(path)\n      # A light-weight way to check if is a valid ELF file\n      # Checks at least one phdr should present.\n      File.open(path) { |f| ELFTools::ELFFile.new(f).each_segments.first }\n      true\n    rescue ELFTools::ELFError\n      false\n    end", "label": 4}
{"code": "def _update_counts_after_update\n      self.class.after_commit_counter_cache.each do |counter|\n        # figure out whether the applicable counter cache changed (this can happen\n        # with dynamic column names)\n        counter_cache_name_was = counter.counter_cache_name_for(counter.previous_model(self))\n        counter_cache_name = counter.counter_cache_name_for(self)\n\n        if counter.first_level_relation_changed?(self) ||\n            (counter.delta_column && counter.attribute_changed?(self, counter.delta_column)) ||\n            counter_cache_name != counter_cache_name_was\n\n          # increment the counter cache of the new value\n          counter.change_counter_cache(self, :increment => true, :counter_column => counter_cache_name)\n          # decrement the counter cache of the old value\n          counter.change_counter_cache(self, :increment => false, :was => true, :counter_column => counter_cache_name_was)\n        end\n      end\n    end", "label": 4}
{"code": "function resizeCanvasToDisplaySize(canvas, multiplier) {\n    multiplier = multiplier || 1;\n    var width  = canvas.clientWidth  * multiplier | 0;\n    var height = canvas.clientHeight * multiplier | 0;\n    if (canvas.width !== width ||  canvas.height !== height) {\n      canvas.width  = width;\n      canvas.height = height;\n      return true;\n    }\n    return false;\n  }", "label": 3}
{"code": "func (a *AuthWithRoles) hasRemoteBuiltinRole(name string) bool {\n\tif _, ok := a.checker.(RemoteBuiltinRoleSet); !ok {\n\t\treturn false\n\t}\n\tif !a.checker.HasRole(name) {\n\t\treturn false\n\t}\n\n\treturn true\n}", "label": 5}
{"code": "func (b *GRPCBroker) Close() error {\n\tb.streamer.Close()\n\tb.o.Do(func() {\n\t\tclose(b.doneCh)\n\t})\n\treturn nil\n}", "label": 5}
{"code": "public static auditsyslogpolicy_lbvserver_binding[] get(nitro_service service, String name) throws Exception{\n\t\tauditsyslogpolicy_lbvserver_binding obj = new auditsyslogpolicy_lbvserver_binding();\n\t\tobj.set_name(name);\n\t\tauditsyslogpolicy_lbvserver_binding response[] = (auditsyslogpolicy_lbvserver_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (m *Martini) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n\tm.createContext(res, req).run()\n}", "label": 5}
{"code": "function _gpfPathMatchApply (pathMatcher) {\n    /*jshint validthis:true*/\n    if (pathMatcher.match(this.parts)) {\n        this.result = !pathMatcher.negative;\n        return false; // Stop the main loop\n    }\n    return _gpfPathMatchAfterApplyNonMatching.call(this, pathMatcher);\n}", "label": 3}
{"code": "def get_from_config_setting_cascade(self, sec_param_list, default=None, warn_on_none_level=logging.WARN):\n        \"\"\"return the first non-None setting from a series where each\n        element in `sec_param_list` is a section, param pair suitable for\n        a get_config_setting call.\n\n        Note that non-None values for overrides for this ConfigWrapper instance will cause\n            this call to only evaluate the first element in the cascade.\n        \"\"\"\n        for section, param in sec_param_list:\n            r = self.get_config_setting(section, param, default=None, warn_on_none_level=None)\n            if r is not None:\n                return r\n        section, param = sec_param_list[-1]\n        if default is None:\n            _warn_missing_setting(section, param, self._config_filename, warn_on_none_level)\n        return default", "label": 1}
{"code": "def trigger_action_by_name(method_sym, custom_dir, from_action, *arguments)\n      # First, check if there is a predefined method in the actions folder\n      class_ref = class_reference_from_action_name(method_sym)\n      unless class_ref\n        class_ref = class_reference_from_action_alias(method_sym)\n        # notify action that it has been used by alias\n        if class_ref.respond_to?(:alias_used)\n          orig_action = method_sym.to_s\n          arguments = [{}] if arguments.empty?\n          class_ref.alias_used(orig_action, arguments.first)\n        end\n      end\n\n      # It's important to *not* have this code inside the rescue block\n      # otherwise all NameErrors will be caught and the error message is\n      # confusing\n      begin\n        return self.try_switch_to_lane(method_sym, arguments)\n      rescue LaneNotAvailableError\n        # We don't actually handle this here yet\n        # We just try to use a user configured lane first\n        # and only if there is none, we're gonna check for the\n        # built-in actions\n      end\n\n      if class_ref\n        if class_ref.respond_to?(:run)\n          # Action is available, now execute it\n          return self.execute_action(method_sym, class_ref, arguments, custom_dir: custom_dir, from_action: from_action)\n        else\n          UI.user_error!(\"Action '#{method_sym}' of class '#{class_name}' was found, but has no `run` method.\")\n        end\n      end\n\n      # No lane, no action, let's at least show the correct error message\n      if Fastlane.plugin_manager.plugin_is_added_as_dependency?(PluginManager.plugin_prefix + method_sym.to_s)\n        # That's a plugin, but for some reason we can't find it\n        UI.user_error!(\"Plugin '#{method_sym}' was not properly loaded, make sure to follow the plugin docs for troubleshooting: #{PluginManager::TROUBLESHOOTING_URL}\")\n      elsif Fastlane::Actions.formerly_bundled_actions.include?(method_sym.to_s)\n        # This was a formerly bundled action which is now a plugin.\n        UI.verbose(caller.join(\"\\n\"))\n        UI.user_error!(\"The action '#{method_sym}' is no longer bundled with fastlane. You can install it using `fastlane add_plugin #{method_sym}`\")\n      else\n        # So there is no plugin under that name, so just show the error message generated by the lane switch\n        UI.verbose(caller.join(\"\\n\"))\n        UI.user_error!(\"Could not find action, lane or variable '#{method_sym}'. Check out the documentation for more details: https://docs.fastlane.tools/actions\")\n      end\n    end", "label": 4}
{"code": "function type(d) {\n    // The '+' notation parses the string as a Number.\n    d.sepalLength = +d.sepalLength;\n    d.sepalWidth = +d.sepalWidth;\n    return d;\n  }", "label": 3}
{"code": "protected String buildErrorSetMsg(Object obj, Object value, Field aField)\r\n    {\r\n        String eol = SystemUtils.LINE_SEPARATOR;\r\n        StringBuffer buf = new StringBuffer();\r\n        buf\r\n                .append(eol + \"[try to set 'object value' in 'target object'\")\r\n                .append(eol + \"target obj class: \" + (obj != null ? obj.getClass().getName() : null))\r\n                .append(eol + \"target field name: \" + (aField != null ? aField.getName() : null))\r\n                .append(eol + \"target field type: \" + (aField != null ? aField.getType() : null))\r\n                .append(eol + \"target field declared in: \" + (aField != null ? aField.getDeclaringClass().getName() : null))\r\n                .append(eol + \"object value class: \" + (value != null ? value.getClass().getName() : null))\r\n                .append(eol + \"object value: \" + (value != null ? value : null))\r\n                .append(eol + \"]\");\r\n        return buf.toString();\r\n    }", "label": 0}
{"code": "def split_docstring(docstring):\n    \"\"\"\n    Separates the method's description and paramter's\n\n    :return: Return description string and list of fields strings\n    \"\"\"\n    docstring_list = [line.strip() for line in docstring.splitlines()]\n    description_list = list(\n        takewhile(lambda line: not (line.startswith(':') or\n                                    line.startswith('@inherit')), docstring_list))\n    description = ' '.join(description_list).strip()\n    first_field_line_number = len(description_list)\n\n    fields = []\n    if first_field_line_number >= len(docstring_list):\n        return description, fields  # only description, without any field\n    last_field_lines = [docstring_list[first_field_line_number]]\n\n    for line in docstring_list[first_field_line_number + 1:]:\n        if line.strip().startswith(':') or line.strip().startswith('@inherit'):\n            fields.append(' '.join(last_field_lines))\n            last_field_lines = [line]\n        else:\n            last_field_lines.append(line)\n\n    fields.append(' '.join(last_field_lines))\n    return description, fields", "label": 1}
{"code": "def wait_for_start(self):\n        \"\"\"\n        Wait for the container to start.\n\n        By default this will wait for the log lines matching the patterns\n        passed in the ``wait_patterns`` parameter of the constructor using an\n        UnorderedMatcher. For more advanced checks for container startup, this\n        method should be overridden.\n        \"\"\"\n        if self.wait_matchers:\n            matcher = UnorderedMatcher(*self.wait_matchers)\n            self.wait_for_logs_matching(matcher, timeout=self.wait_timeout)", "label": 1}
{"code": "function(captions) {\n        var SMPTE_TT_BODY = '';\n        //\n        SMPTE_TT_BODY += SMPTE_TT.header.join('\\n') + '\\n';\n        captions.forEach(function(caption) {\n            if (caption.text.length > 0 && validateText(caption.text)) {\n                if ((/&/.test(caption.text)) && (!(/&amp;/.test(caption.text)) || !(/&gt;/.test(caption.text)) || !(/&lt;/.test(caption.text)))) {\n                    caption.text = caption.text.replace(/&/g, '&amp;');\n                }\n                if ((/</.test(caption.text)) && !(/&lt;/.test(caption.text))) {\n                    caption.text = caption.text.replace(/</g, '&lt;');\n                }\n                if ((/>/.test(caption.text)) && !(/&gt;/.test(caption.text))) {\n                    caption.text = caption.text.replace(/>/g, '&gt;');\n                }\n                SMPTE_TT_BODY += SMPTE_TT.lineTemplate.replace('{startTime}', module.exports.formatTime(caption.startTimeMicro))\n                    .replace('{endTime}', module.exports.formatTime(caption.endTimeMicro))\n                    .replace('{text}', module.exports.renderMacros(macros.fixItalics(macros.cleanMacros(caption.text)))) + '\\n';\n            }\n        });\n\n        return SMPTE_TT_BODY + SMPTE_TT.footer.join('\\n') + '\\n';\n    }", "label": 3}
{"code": "private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n\t\tif (to.equals(from))\n\t\t\treturn true;\n\n\t\tif (from instanceof TypeVariable) {\n\t\t\treturn to.equals(typeMap.get(((TypeVariable<?>) from).getName()));\n\t\t}\n\n\t\treturn false;\n\t}", "label": 0}
{"code": "func ParseEndpointConnectivity(epOptions map[string]interface{}) (*EndpointConnectivity, error) {\n\tif epOptions == nil {\n\t\treturn nil, nil\n\t}\n\n\tec := &EndpointConnectivity{}\n\n\tif opt, ok := epOptions[netlabel.PortMap]; ok {\n\t\tif bs, ok := opt.([]types.PortBinding); ok {\n\t\t\tec.PortBindings = bs\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"Invalid endpoint configuration\")\n\t\t}\n\t}\n\n\tif opt, ok := epOptions[netlabel.ExposedPorts]; ok {\n\t\tif ports, ok := opt.([]types.TransportPort); ok {\n\t\t\tec.ExposedPorts = ports\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"Invalid endpoint configuration\")\n\t\t}\n\t}\n\treturn ec, nil\n}", "label": 5}
{"code": "def list_item(name, identifier={:index => 0}, &block)\n      standard_methods(name, identifier, 'list_item_for', &block)\n      define_method(name) do\n        return platform.list_item_text_for identifier.clone unless block_given?\n        self.send(\"#{name}_element\").text\n      end\n    end", "label": 4}
{"code": "def mimetype(wobj)\n      s = @epub.mimetype\n      if !s.nil? && !wobj.nil?\n        wobj.print s\n      end\n    end", "label": 4}
{"code": "function(close) {\n\t\t\t\tvar w = $('#sidepanels').width();\n\t\t\t\tvar deltaX = (w > 2 || close ? 2 : SIDEPANEL_OPENWIDTH) - w;\n\t\t\t\tchangeSidePanelWidth(deltaX);\n\t\t\t}", "label": 3}
{"code": "def truncate(value: Decimal, n_digits: int) -> Decimal:\n    \"\"\"Truncates a value to a number of decimals places\"\"\"\n    return Decimal(math.trunc(value * (10 ** n_digits))) / (10 ** n_digits)", "label": 1}
{"code": "public ClassDescriptor getSuperClassDescriptor()\r\n    {\r\n        if (!m_superCldSet)\r\n        {\r\n            if(getBaseClass() != null)\r\n            {\r\n                m_superCld = getRepository().getDescriptorFor(getBaseClass());\r\n                if(m_superCld.isAbstract() || m_superCld.isInterface())\r\n                {\r\n                    throw new MetadataException(\"Super class mapping only work for real class, but declared super class\" +\r\n                            \" is an interface or is abstract. Declared class: \" + m_superCld.getClassNameOfObject());\r\n                }\r\n            }\r\n            m_superCldSet = true;\r\n        }\r\n\r\n        return m_superCld;\r\n    }", "label": 0}
{"code": "def mkdir(self, target_folder):\n        \"\"\"\n        Create a folder on S3.\n\n        Examples\n        --------\n            >>> s3utils.mkdir(\"path/to/my_folder\")\n            Making directory: path/to/my_folder\n        \"\"\"\n        self.printv(\"Making directory: %s\" % target_folder)\n        self.k.key = re.sub(r\"^/|/$\", \"\", target_folder) + \"/\"\n        self.k.set_contents_from_string('')\n        self.k.close()", "label": 1}
{"code": "public function bufferFullVariable()\n    {\n        if (!$this->bufferFullVariableIndex) {\n            $this->bufferFullVariableIndex = $this->nextIndex++;\n            $this->variables[] = new Variable('', '', [\n                'status' => new StatusMessage(\n                    true,\n                    StatusMessage::REFERENCE_VARIABLE_VALUE,\n                    new FormatMessage(\n                        self::BUFFER_FULL_MESSAGE\n                    )\n                )\n            ]);\n        }\n        return new Variable('', '', [\n            'varTableIndex' => $this->bufferFullVariableIndex\n        ]);\n    }", "label": 2}
{"code": "private function get_headers($httpType, $cookies)\n    {\n        // Common header flags.\n        $headers = [];\n        $headers[] = 'Dnt: 1';\n        $headers[] = 'Connection: keep-alive';\n        $headers[] = 'Accept-Language: it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4';\n        $headers[] = 'User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36';\n\n        // Add additional headers based on the type of request.\n        switch ($httpType) {\n        case 'origin':\n          $headers[] = 'Origin: '.self::MY_TELEGRAM_URL;\n          $headers[] = 'Accept-Encoding: gzip, deflate, br';\n          $headers[] = 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8';\n          $headers[] = 'Accept: application/json, text/javascript, */*; q=0.01';\n          $headers[] = 'Referer: '.self::MY_TELEGRAM_URL.'/auth';\n          $headers[] = 'X-Requested-With: XMLHttpRequest';\n        break;\n        case 'refer':\n          $headers[] = 'Accept-Encoding: gzip, deflate, sdch, br';\n          $headers[] = 'Upgrade-Insecure-Requests: 1';\n          $headers[] = 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8';\n          $headers[] = 'Referer: '.self::MY_TELEGRAM_URL;\n          $headers[] = 'Cache-Control: max-age=0';\n        break;\n        case 'app':\n          $headers[] = 'Origin: '.self::MY_TELEGRAM_URL;\n          $headers[] = 'Accept-Encoding: gzip, deflate, br';\n          $headers[] = 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8';\n          $headers[] = 'Accept: */*';\n          $headers[] = 'Referer: '.self::MY_TELEGRAM_URL.'/apps';\n          $headers[] = 'X-Requested-With: XMLHttpRequest';\n        break;\n        }\n\n        // Add every cookie to the header.\n        foreach ($cookies as $cookie) {\n            $headers[] = 'Cookie: '.$cookie;\n        }\n\n        return $headers;\n    }", "label": 2}
{"code": "protected List<CRFDatum> extractDatumSequence(int[][][] allData, int beginPosition, int endPosition,\r\n      List<IN> labeledWordInfos) {\r\n    List<CRFDatum> result = new ArrayList<CRFDatum>();\r\n    int beginContext = beginPosition - windowSize + 1;\r\n    if (beginContext < 0) {\r\n      beginContext = 0;\r\n    }\r\n    // for the beginning context, add some dummy datums with no features!\r\n    // TODO: is there any better way to do this?\r\n    for (int position = beginContext; position < beginPosition; position++) {\r\n      List<Collection<String>> cliqueFeatures = new ArrayList<Collection<String>>();\r\n      for (int i = 0; i < windowSize; i++) {\r\n        // create a feature list\r\n        cliqueFeatures.add(Collections.<String>emptyList());\r\n      }\r\n      CRFDatum<Collection<String>, String> datum = new CRFDatum<Collection<String>, String>(cliqueFeatures,\r\n              labeledWordInfos.get(position).get(AnswerAnnotation.class));\r\n      result.add(datum);\r\n    }\r\n    // now add the real datums\r\n    for (int position = beginPosition; position <= endPosition; position++) {\r\n      List<Collection<String>> cliqueFeatures = new ArrayList<Collection<String>>();\r\n      for (int i = 0; i < windowSize; i++) {\r\n        // create a feature list\r\n        Collection<String> features = new ArrayList<String>();\r\n        for (int j = 0; j < allData[position][i].length; j++) {\r\n          features.add(featureIndex.get(allData[position][i][j]));\r\n        }\r\n        cliqueFeatures.add(features);\r\n      }\r\n      CRFDatum<Collection<String>,String> datum = new CRFDatum<Collection<String>,String>(cliqueFeatures,\r\n              labeledWordInfos.get(position).get(AnswerAnnotation.class));\r\n      result.add(datum);\r\n    }\r\n    return result;\r\n  }", "label": 0}
{"code": "def initialize_copy(other)\n      @inclusions = other.inclusions.dup\n      @scoping_options = other.scoping_options\n      @documents = other.documents.dup\n      @context = nil\n      super\n    end", "label": 4}
{"code": "function stringify(obj, opts) {\n  EXPORT_ATTRS = opts && opts.exportAttrs;\n  var noDeref = opts && opts.noDeref;\n\n  // Since JS objects are unordered, this implementation (unfortunately)\n  // relies on engines returning properties in the same order that they are\n  // inserted in. This is not in the JS spec, but can be \"somewhat\" safely\n  // assumed (more here: http://stackoverflow.com/q/5525795/1062617).\n  return (function (registry) {\n    return JSON.stringify(obj, function (key, value) {\n      if (value) {\n        if (\n          typeof value == 'object' &&\n          value.hasOwnProperty('default') &&\n          !value.hasOwnProperty('logicalType')\n        ) {\n          // This is a field.\n          if (EXPORT_ATTRS) {\n            return {\n              name: value.name,\n              type: value.type,\n              'default': value['default'],\n              order: value.order !== 'ascending' ? value.order : undefined,\n              aliases: value.aliases.length ? value.aliases : undefined\n            };\n          } else {\n            return {name: value.name, type: value.type};\n          }\n        } else if (value.aliases) {\n          // This is a named type (enum, fixed, record, error).\n          var name = value.name;\n          if (name) {\n            // If the type is anonymous, we always dereference it.\n            if (noDeref || registry[name]) {\n              return name;\n            }\n            registry[name] = true;\n          }\n          if (!EXPORT_ATTRS || !value.aliases.length) {\n            value.aliases = undefined;\n          }\n        }\n      }\n      return value;\n    });\n  })({});\n}", "label": 3}
{"code": "public static base_responses add(nitro_service client, appfwxmlcontenttype resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tappfwxmlcontenttype addresources[] = new appfwxmlcontenttype[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new appfwxmlcontenttype();\n\t\t\t\taddresources[i].xmlcontenttypevalue = resources[i].xmlcontenttypevalue;\n\t\t\t\taddresources[i].isregex = resources[i].isregex;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public function addCommand($command)\n    {\n        if (is_string($command)) {\n            $command = $this->app->make($command);\n        }\n\n        if ($command instanceof Command) {\n            $command->setLaravel($this->app);\n        }\n\n        $this->console->add($command);\n    }", "label": 2}
{"code": "def merge_attributes!(attributes)\n      @attributes.merge!(attributes) do |_, v1, v2|\n        v1 = v1.strip\n        v2 = v2.strip\n        v1_split = v1.shellsplit\n        v2_split = v2.shellsplit\n        if (v2_split - v1_split).empty? || v1_split.first(v2_split.size) == v2_split\n          v1\n        elsif v2_split.first(v1_split.size) == v1_split\n          v2\n        else\n          \"#{v1} #{v2}\"\n        end\n      end\n    end", "label": 4}
{"code": "protected function isGeoradiusReadOnly(CommandInterface $command)\n    {\n        $arguments = $command->getArguments();\n        $argc = count($arguments);\n        $startIndex = $command->getId() === 'GEORADIUS' ? 5 : 4;\n\n        if ($argc > $startIndex) {\n            for ($i = $startIndex; $i < $argc; ++$i) {\n                $argument = strtoupper($arguments[$i]);\n                if ($argument === 'STORE' || $argument === 'STOREDIST') {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }", "label": 2}
{"code": "def all_files\n      `git ls-files`.\n        split(/\\n/).\n        map { |relative_file| File.expand_path(relative_file) }.\n        reject { |file| File.directory?(file) } # Exclude submodule directories\n    end", "label": 4}
{"code": "public Set<Map.Entry<E,Double>> entrySet() {\r\n    return new AbstractSet<Map.Entry<E,Double>>() {\r\n      @Override\r\n      public Iterator<Entry<E, Double>> iterator() {\r\n        return new Iterator<Entry<E,Double>>() {\r\n          final Iterator<Entry<E,MutableInteger>> inner = map.entrySet().iterator();\r\n\r\n          public boolean hasNext() {\r\n            return inner.hasNext();\r\n          }\r\n\r\n          public Entry<E, Double> next() {\r\n            return new Map.Entry<E,Double>() {\r\n              final Entry<E,MutableInteger> e = inner.next();\r\n\r\n              public E getKey() {\r\n                return e.getKey();\r\n              }\r\n\r\n              public Double getValue() {\r\n                return e.getValue().doubleValue();\r\n              }\r\n\r\n              public Double setValue(Double value) {\r\n                final double old = e.getValue().doubleValue();\r\n                e.getValue().set(value.intValue());\r\n                totalCount = totalCount - (int)old + value.intValue();\r\n                return old;\r\n              }\r\n            };\r\n          }\r\n\r\n          public void remove() {\r\n            throw new UnsupportedOperationException();\r\n          }\r\n        };\r\n      }\r\n\r\n      @Override\r\n      public int size() {\r\n        return map.size();\r\n      }\r\n    };\r\n  }", "label": 0}
{"code": "def persist(conditions = nil)\n      run_callbacks(:save) do\n        self.hash_key = SecureRandom.uuid if hash_key.blank?\n\n        # Add an exists check to prevent overwriting existing records with new ones\n        if new_record?\n          conditions ||= {}\n          (conditions[:unless_exists] ||= []) << self.class.hash_key\n        end\n\n        # Add an optimistic locking check if the lock_version column exists\n        if self.class.attributes[:lock_version]\n          conditions ||= {}\n          self.lock_version = (lock_version || 0) + 1\n          # Uses the original lock_version value from ActiveModel::Dirty in case user changed lock_version manually\n          (conditions[:if] ||= {})[:lock_version] = changes[:lock_version][0] if changes[:lock_version][0]\n        end\n\n        attributes_dumped = Dumping.dump_attributes(attributes, self.class.attributes)\n\n        begin\n          Dynamoid.adapter.write(self.class.table_name, attributes_dumped, conditions)\n          @new_record = false\n          true\n        rescue Dynamoid::Errors::ConditionalCheckFailedException => e\n          if new_record?\n            raise Dynamoid::Errors::RecordNotUnique.new(e, self)\n          else\n            raise Dynamoid::Errors::StaleObjectError.new(self, 'persist')\n          end\n        end\n      end\n    end", "label": 4}
{"code": "def oaiset_url(self):\n        \"\"\"Return the OAISet URL for given community.\n\n        :returns: URL of corresponding OAISet.\n        :rtype: str\n        \"\"\"\n        return url_for(\n            'invenio_oaiserver.response',\n            verb='ListRecords',\n            metadataPrefix='oai_dc', set=self.oaiset_spec, _external=True)", "label": 1}
{"code": "function (path, errorMessage) {\n  if (!shell.test('-e', path)) {\n    shell.echo('Error: ' + errorMessage);\n    shell.exit(1);\n  }\n}", "label": 3}
{"code": "def check_repository_existence(params):\n    \"\"\"Check repository existence.\n\n    :param argparse.Namespace params: parameters\n    \"\"\"\n    repodir = os.path.join(params.outdir, params.name)\n    if os.path.isdir(repodir):\n        raise Conflict(\n            'Package repository \"{0}\" has already exists.'.format(repodir))", "label": 1}
{"code": "function partition(left, right)\n    {\n      var pivot = map.values[ Math.floor((right + left) / 2) ];\n      var i = left;\n      var j = right;\n\n      while (i <= j)\n      {\n        while (comparator( map.values[i], pivot ) < 0)\n        {\n          i++;\n        }\n        while (comparator( map.values[j], pivot ) > 0)\n        {\n          j--;\n        }\n\n        if (i <= j)\n        {\n          swap( map.values, i, j );\n          swap( map.keys, i, j );\n          i++;\n          j--;\n        }\n      }\n\n      return i;\n    }", "label": 3}
{"code": "public function setPartialFailures($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Rpc\\Status::class);\n        $this->partial_failures = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def action(set, name, options = {}, &block)\n      warn \"Warning: method `#{name}` already defined\" if controller.method_defined?(name)\n\n      set << ControllerAction.new(name, options)\n      title = options.delete(:title)\n\n      controller do\n        before_action(only: [name]) { @page_title = title } if title\n        define_method(name, &block || Proc.new {})\n      end\n    end", "label": 4}
{"code": "def key?(key)\n      if @entries.key?(key) && (@entries[key].nil? || @entries[key].expired?)\n        self.delete(key)\n      end\n      @entries.key?(key)\n    end", "label": 4}
{"code": "public function setWorkExperienceFilter($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Talent\\V4beta1\\WorkExperienceFilter::class);\n        $this->work_experience_filter = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public boolean absolute(int row) throws PersistenceBrokerException\r\n    {\r\n        // 1. handle the special cases first.\r\n        if (row == 0)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        if (row == 1)\r\n        {\r\n            m_activeIteratorIndex = 0;\r\n            m_activeIterator = (OJBIterator) m_rsIterators.get(m_activeIteratorIndex);\r\n            m_activeIterator.absolute(1);\r\n            return true;\r\n        }\r\n        if (row == -1)\r\n        {\r\n            m_activeIteratorIndex = m_rsIterators.size();\r\n            m_activeIterator = (OJBIterator) m_rsIterators.get(m_activeIteratorIndex);\r\n            m_activeIterator.absolute(-1);\r\n            return true;\r\n        }\r\n\r\n        // now do the real work.\r\n        boolean movedToAbsolute = false;\r\n        boolean retval = false;\r\n        setNextIterator();\r\n\r\n        // row is positive, so index from beginning.\r\n        if (row > 0)\r\n        {\r\n            int sizeCount = 0;\r\n            Iterator it = m_rsIterators.iterator();\r\n            OJBIterator temp = null;\r\n            while (it.hasNext() && !movedToAbsolute)\r\n            {\r\n                temp = (OJBIterator) it.next();\r\n                if (temp.size() < row)\r\n                {\r\n                    sizeCount += temp.size();\r\n                }\r\n                else\r\n                {\r\n                    // move to the offset - sizecount\r\n                    m_currentCursorPosition = row - sizeCount;\r\n                    retval = temp.absolute(m_currentCursorPosition);\r\n                    movedToAbsolute = true;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // row is negative, so index from end\r\n        else if (row < 0)\r\n        {\r\n            int sizeCount = 0;\r\n            OJBIterator temp = null;\r\n            for (int i = m_rsIterators.size(); ((i >= 0) && !movedToAbsolute); i--)\r\n            {\r\n                temp = (OJBIterator) m_rsIterators.get(i);\r\n                if (temp.size() < row)\r\n                {\r\n                    sizeCount += temp.size();\r\n                }\r\n                else\r\n                {\r\n                    // move to the offset - sizecount\r\n                    m_currentCursorPosition = row + sizeCount;\r\n                    retval = temp.absolute(m_currentCursorPosition);\r\n                    movedToAbsolute = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return retval;\r\n    }", "label": 0}
{"code": "public void forAllMemberTags(String template, Properties attributes) throws XDocletException\r\n    {\r\n        if (getCurrentField() != null) {\r\n            forAllMemberTags(template, attributes, FOR_FIELD, XDocletTagshandlerMessages.ONLY_CALL_FIELD_NOT_NULL, new String[]{\"forAllMemberTags\"});\r\n        }\r\n        else if (getCurrentMethod() != null) {\r\n            forAllMemberTags(template, attributes, FOR_METHOD, XDocletTagshandlerMessages.ONLY_CALL_METHOD_NOT_NULL, new String[]{\"forAllMemberTags\"});\r\n        }\r\n    }", "label": 0}
{"code": "function _gpfDefineProcessParamsAndCallCore (params, processFunction) {\n    processFunction(\"\", Object, params);\n    return _gpfDefineCore.apply(null, params);\n}", "label": 3}
{"code": "def initializing_reader(key)\n      ck = convert_key(key)\n      regular_writer(ck, self.class.new) unless key?(ck)\n      regular_reader(ck)\n    end", "label": 4}
{"code": "public function url_stat($path, $flags)\n    {\n        $client = $this->openPath($path);\n\n        // if directory\n        if ($this->isDirectory($this->file)) {\n            return $this->urlStatDirectory();\n        }\n\n        return $this->urlStatFile();\n    }", "label": 2}
{"code": "func (s *server) GetSessions(namespace string) ([]Session, error) {\n\tprefix := activePrefix(namespace)\n\n\tresult, err := s.bk.GetRange(context.TODO(), prefix, backend.RangeEnd(prefix), MaxSessionSliceLength)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tout := make(Sessions, 0, len(result.Items))\n\n\tfor i := range result.Items {\n\t\tvar session Session\n\t\tif err := json.Unmarshal(result.Items[i].Value, &session); err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tout = append(out, session)\n\t}\n\tsort.Stable(out)\n\treturn out, nil\n}", "label": 5}
{"code": "public static sslparameter get(nitro_service service) throws Exception{\n\t\tsslparameter obj = new sslparameter();\n\t\tsslparameter[] response = (sslparameter[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "function (options) {\n  EventEmitter.call(this);\n\n  var self = this;\n\n  self.options = _.extend({\n    user: '',\n    password: '',\n    userAgent: null,\n    url: null,\n    debug: false,\n    parser: JSONBigInt\n  }, options || {});\n\n  self._req = null;\n\n  self.parser = new JSONParser(self.options.parser);\n  self.parser.on('object', function (object) {\n    self.emit('object', object);\n    if (object.error) self.emit('error', new Error('Stream response error: ' + (object.error.message || '-')));\n    else if (object['delete']) self.emit('delete', object);\n    else if (object.body || object.text) self.emit('tweet', object);\n  });\n  self.parser.on('error', function (err) {\n    self.emit('error', err);\n  });\n}", "label": 3}
{"code": "public function setExtra($hash)\n    {\n        $rev = strpos($hash, '_rev');\n        $this->rev = false;\n        if ($rev !== false) {\n            $hash = substr($hash, 0, $rev);\n            $this->rev = true;\n        }\n        $this->hash_name = $hash;\n    }", "label": 2}
{"code": "def extract_drawing_filepath\n      # Read drawing relationship ID from the sheet.\n      sheet_filepath = \"xl/#{@sheetfile}\"\n      drawing = parse_xml(sheet_filepath).css('drawing').first\n      return if drawing.nil?\n\n      drawing_rid = drawing.attributes['id'].value\n\n      # Read sheet rels to find drawing file's location.\n      sheet_rels_filepath = expand_to_rels_path(sheet_filepath)\n      parse_xml(sheet_rels_filepath).css(\"Relationship[@Id='#{drawing_rid}']\").first.attributes['Target'].value\n    end", "label": 4}
{"code": "def ensure_fastfile\n      return true if FastlaneCore::FastlaneFolder.setup?\n\n      create = UI.confirm('Could not find fastlane in current directory. Make sure to have your fastlane configuration files inside a folder called \"fastlane\". Would you like to set fastlane up?')\n      if create\n        Fastlane::Setup.start\n      end\n      return false\n    end", "label": 4}
{"code": "def _store_documentation(self, path, html, overwrite, quiet):\n        \"\"\"\n        Stores all documents on the file system.\n\n        Target location is **path**. File name is the lowercase name of the document + .rst.\n        \"\"\"\n\n        echo(\"Storing groundwork application documents\\n\")\n        echo(\"Application: %s\" % self.app.name)\n        echo(\"Number of documents: %s\\n\" % len(self.app.documents.get()))\n\n        if not os.path.isabs(path):\n            path = os.path.abspath(path)\n\n        if not os.path.isdir(path):\n            echo(\"Path %s is not a directory!\" % path)\n            sys.exit(1)\n\n        if not os.path.exists(path):\n            echo(\"Path %s does not exist\" % path)\n            sys.exit(1)\n\n        for dirpath, dirnames, files in os.walk(path):\n            if files:\n                echo(\"Path %s is not empty!\\n\" % path)\n                if not overwrite:\n                    sys.exit(1)\n\n        documents = []\n        for key, document in self.app.documents.get().items():\n            file_extension = \".html\" if html else \".rst\"\n\n            # lowers the name, removes all whitespaces and adds the file extension\n            file_name_parts = key.lower().split()\n            file_name = \"\".join(file_name_parts)\n            file_name += file_extension\n            documents.append((file_name, document))\n\n        echo(\"Going to write to following files:\")\n        for document in documents:\n            echo(\"  %s\" % document[0])\n\n        echo(\"\\nTarget directory: %s\" % path)\n        answer = None\n        while answer not in [\"N\", \"Y\"] and not quiet:\n            answer = prompt(\"Shall we go on? [Y]es, [N]o: \").upper()\n\n        if answer == \"N\":\n            sys.exit(0)\n\n        for document in documents:\n            try:\n                with open(os.path.join(path, document[0]), \"w\") as doc_file:\n                    doc_rendered = Environment().from_string(document[1].content).render(app=self.app,\n                                                                                         plugin=document[1].plugin)\n                    if html:\n                        output = publish_parts(doc_rendered, writer_name=\"html\")['whole']\n                    else:\n                        output = doc_rendered\n\n                    doc_file.write(output)\n            except Exception as e:\n                echo(\"%s error occurred: %s\" % (document[0], e))\n            else:\n                echo(\"%s stored.\" % document[0])", "label": 1}
{"code": "def unlock(item)\n      SidekiqUniqueJobs::UniqueArgs.digest(item)\n      SidekiqUniqueJobs::Locksmith.new(item).unlock\n    end", "label": 4}
{"code": "def check_files\n      @external_urls = {}\n\n      process_files.each do |item|\n        @external_urls.merge!(item[:external_urls])\n        @failures.concat(item[:failures])\n      end\n\n      # TODO: lazy. if we're checking only external links,\n      # we'll just trash all the failed tests. really, we should\n      # just not run those other checks at all.\n      if @options[:external_only]\n        @failures = []\n        validate_urls\n      elsif !@options[:disable_external]\n        validate_urls\n      end\n    end", "label": 4}
{"code": "private void initPrefixStatsField(String field) {\n    if (!singlePositionPrefix.containsKey(field)) {\n      singlePositionPrefix.put(field, new HashSet<String>());\n    }\n    if (!multiplePositionPrefix.containsKey(field)) {\n      multiplePositionPrefix.put(field, new HashSet<String>());\n    }\n    if (!setPositionPrefix.containsKey(field)) {\n      setPositionPrefix.put(field, new HashSet<String>());\n    }\n  }", "label": 0}
{"code": "function (cb) {\n            fs.readFile(path.resolve(__dirname, \"dose_form_groups.txt\"), \"UTF-8\", function (err, doseForms) {\n                if (err) return cb(err);\n                // each group is a new line in the file\n                doseFormGroups = doseForms.toString().split(\"\\n\").filter(function (form) {\n                    // ignore empty lines\n                    return form.length > 0;\n                });\n                cb();\n            });\n        }", "label": 3}
{"code": "func (e *Encoder) reflectMarshaler(v reflect.Value) bool {\n\tif !v.Type().Implements(marshalerType) {\n\t\tif v.Kind() != reflect.Ptr && v.CanAddr() && v.Addr().Type().Implements(marshalerType) {\n\t\t\tv = v.Addr()\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\tm := v.Interface().(Marshaler)\n\tdata, err := m.MarshalBencode()\n\tif err != nil {\n\t\tpanic(&MarshalerError{v.Type(), err})\n\t}\n\te.write(data)\n\treturn true\n}", "label": 5}
{"code": "function () {\n            var series = this,\n              segments = [],\n              segment = [],\n              keys = [],\n              xAxis = this.xAxis,\n              yAxis = this.yAxis,\n              stack = yAxis.stacks[this.stackKey],\n              pointMap = {},\n              plotX,\n              plotY,\n              points = this.points,\n              connectNulls = this.options.connectNulls,\n              i,\n              x;\n\n            if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue\n                // Create a map where we can quickly look up the points by their X value.\n                for (i = 0; i < points.length; i++) {\n                    pointMap[points[i].x] = points[i];\n                }\n\n                // Sort the keys (#1651)\n                for (x in stack) {\n                    if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n                        keys.push(+x);\n                    }\n                }\n                keys.sort(function (a, b) {\n                    return a - b;\n                });\n\n                each(keys, function (x) {\n                    var y = 0,\n                      stackPoint;\n\n                    if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836\n                        return;\n\n                        // The point exists, push it to the segment\n                    } else if (pointMap[x]) {\n                        segment.push(pointMap[x]);\n\n                        // There is no point for this X value in this series, so we\n                        // insert a dummy point in order for the areas to be drawn\n                        // correctly.\n                    } else {\n\n                        // Loop down the stack to find the series below this one that has\n                        // a value (#1991)\n                        for (i = series.index; i <= yAxis.series.length; i++) {\n                            stackPoint = stack[x].points[i + ',' + x];\n                            if (stackPoint) {\n                                y = stackPoint[1];\n                                break;\n                            }\n                        }\n\n                        plotX = xAxis.translate(x);\n                        plotY = yAxis.toPixels(y, true);\n                        segment.push({\n                            y: null,\n                            plotX: plotX,\n                            clientX: plotX,\n                            plotY: plotY,\n                            yBottom: plotY,\n                            onMouseOver: noop\n                        });\n                    }\n                });\n\n                if (segment.length) {\n                    segments.push(segment);\n                }\n\n            } else {\n                Series.prototype.getSegments.call(this);\n                segments = this.segments;\n            }\n\n            this.segments = segments;\n        }", "label": 3}
{"code": "def update(*args)\n      arguments(args, required: [:user, :repo, :label_name]) do\n        permit VALID_LABEL_INPUTS\n        assert_required VALID_LABEL_INPUTS\n      end\n\n      patch_request(\"/repos/#{arguments.user}/#{arguments.repo}/labels/#{arguments.label_name}\", arguments.params)\n    end", "label": 4}
{"code": "def files\n      result = form.select_files.map { |label, id| { id: id, text: label } }\n      render json: result\n    end", "label": 4}
{"code": "public static base_responses add(nitro_service client, snmpcommunity resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tsnmpcommunity addresources[] = new snmpcommunity[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new snmpcommunity();\n\t\t\t\taddresources[i].communityname = resources[i].communityname;\n\t\t\t\taddresources[i].permissions = resources[i].permissions;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "def machine(name, provider, boxes, data_path, env)\n      # Load the configuration for the machine\n      results = machine_config(name, provider, boxes, data_path)\n      box             = results[:box]\n      config          = results[:config]\n      config_errors   = results[:config_errors]\n      config_warnings = results[:config_warnings]\n      provider_cls    = results[:provider_cls]\n      provider_options = results[:provider_options]\n\n      # If there were warnings or errors we want to output them\n      if !config_warnings.empty? || !config_errors.empty?\n        # The color of the output depends on whether we have warnings\n        # or errors...\n        level  = config_errors.empty? ? :warn : :error\n        output = Util::TemplateRenderer.render(\n          \"config/messages\",\n          warnings: config_warnings,\n          errors: config_errors).chomp\n        env.ui.send(level, I18n.t(\"vagrant.general.config_upgrade_messages\",\n                               name: name,\n                               output: output))\n\n        # If we had errors, then we bail\n        raise Errors::ConfigUpgradeErrors if !config_errors.empty?\n      end\n\n      # Get the provider configuration from the final loaded configuration\n      provider_config = config.vm.get_provider_config(provider)\n\n      # Create machine data directory if it doesn't exist\n      # XXX: Permissions error here.\n      FileUtils.mkdir_p(data_path)\n\n      # Create the machine and cache it for future calls. This will also\n      # return the machine from this method.\n      return Machine.new(name, provider, provider_cls, provider_config,\n        provider_options, config, data_path, box, env, self)\n    end", "label": 4}
{"code": "public Point3d[] getVertices() {\n        Point3d[] vtxs = new Point3d[numVertices];\n        for (int i = 0; i < numVertices; i++) {\n            vtxs[i] = pointBuffer[vertexPointIndices[i]].pnt;\n        }\n        return vtxs;\n    }", "label": 0}
{"code": "def lookup_accessor(accessor, options = {})\n      headers = extract_headers!(options)\n      json = client.post(\"/v1/auth/token/lookup-accessor\", JSON.fast_generate(\n        accessor: accessor,\n      ), headers)\n      return Secret.decode(json)\n    end", "label": 4}
{"code": "func RestartBee(bee *BeeInterface) {\n\t(*bee).Stop()\n\n\t(*bee).SetSigChan(make(chan bool))\n\t(*bee).Start()\n\tgo func(mod *BeeInterface) {\n\t\tstartBee(mod, 0)\n\t}(bee)\n}", "label": 5}
{"code": "protected function sendGroupsChangeParticipants($groupId, $participant, $tag, $id)\n    {\n        $participants = new ProtocolNode('participant', ['jid' => $this->getJID($participant)], null, '');\n\n        $childHash = [];\n        $child = new ProtocolNode($tag, $childHash, [$participants], '');\n\n        $node = new ProtocolNode('iq',\n            [\n                'id'    => $id,\n                'type'  => 'set',\n                'xmlns' => 'w:g2',\n                'to'    => $this->getJID($groupId),\n            ], [$child], '');\n\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "def _get_pv_array_construct(self):\n        \"\"\" Returns a construct for an array of PV generator data.\n        \"\"\"\n        bus_no = integer.setResultsName(\"bus_no\")\n        s_rating = real.setResultsName(\"s_rating\") # MVA\n        v_rating = real.setResultsName(\"v_rating\") # kV\n        p = real.setResultsName(\"p\") # p.u.\n        v = real.setResultsName(\"v\") # p.u.\n        q_max = Optional(real).setResultsName(\"q_max\") # p.u.\n        q_min = Optional(real).setResultsName(\"q_min\") # p.u.\n        v_max = Optional(real).setResultsName(\"v_max\") # p.u.\n        v_min = Optional(real).setResultsName(\"v_min\") # p.u.\n        # Loss participation coefficient\n        lp_coeff = Optional(real).setResultsName(\"lp_coeff\")\n        status = Optional(boolean).setResultsName(\"status\")\n\n        pv_data = bus_no + s_rating + v_rating + p + v + q_max + \\\n            q_min + v_max + v_min + lp_coeff + status + scolon\n\n        pv_data.setParseAction(self.push_pv)\n\n        pv_array = Literal(\"PV.con\") + \"=\" + \"[\" + \"...\" + \\\n            ZeroOrMore(pv_data + Optional(\"]\" + scolon))\n\n        return pv_array", "label": 1}
{"code": "def find_objdump(arch)\n      [\n        which('objdump'),\n        which(arch_specific_objdump(arch))\n      ].find { |bin| objdump_arch_supported?(bin, arch) }\n    end", "label": 4}
{"code": "def setup(self, helper=None, **run_kwargs):\n        \"\"\"\n        Creates the container, starts it, and waits for it to completely start.\n\n        :param helper:\n            The resource helper to use, if one was not provided when this\n            container definition was created.\n        :param **run_kwargs: Keyword arguments passed to :meth:`.run`.\n\n        :returns:\n            This container definition instance. Useful for creating and setting\n            up a container in a single step::\n\n                con = ContainerDefinition('conny', 'nginx').setup(helper=dh)\n        \"\"\"\n        if self.created:\n            return\n\n        self.set_helper(helper)\n        self.run(**run_kwargs)\n        self.wait_for_start()\n        return self", "label": 1}
{"code": "public static sslservice_sslpolicy_binding[] get(nitro_service service, String servicename) throws Exception{\n\t\tsslservice_sslpolicy_binding obj = new sslservice_sslpolicy_binding();\n\t\tobj.set_servicename(servicename);\n\t\tsslservice_sslpolicy_binding response[] = (sslservice_sslpolicy_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func ImageManifestPath(root string, appName types.ACName) string {\n\treturn filepath.Join(AppPath(root, appName), aci.ManifestFile)\n}", "label": 5}
{"code": "func LoadFromFile(filename string) (*MetaInfo, error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\treturn Load(f)\n}", "label": 5}
{"code": "public boolean accept(String str) {\r\n    int k = str.length() - 1;\r\n    char c = str.charAt(k);\r\n    while (k >= 0 && !Character.isDigit(c)) {\r\n      k--;\r\n      if (k >= 0) {\r\n        c = str.charAt(k);\r\n      }\r\n    }\r\n    if (k < 0) {\r\n      return false;\r\n    }\r\n    int j = k;\r\n    c = str.charAt(j);\r\n    while (j >= 0 && Character.isDigit(c)) {\r\n      j--;\r\n      if (j >= 0) {\r\n        c = str.charAt(j);\r\n      }\r\n    }\r\n    j++;\r\n    k++;\r\n    String theNumber = str.substring(j, k);\r\n    int number = Integer.parseInt(theNumber);\r\n    for (Pair<Integer,Integer> p : ranges) {\r\n      int low = p.first().intValue();\r\n      int high = p.second().intValue();\r\n      if (number >= low && number <= high) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }", "label": 0}
{"code": "func (l *KeyLock) Unlock() error {\n\terr := l.keyLock.Unlock()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "label": 5}
{"code": "public static function loadFromName($name, array $config, Request $request = null)\n    {\n        /*\n        * Use the driver class basename without \"Driver\" if we're dealing with a\n        * DriverInterface object.\n        */\n        if (class_exists($name) && is_subclass_of($name, DriverInterface::class)) {\n            $name = preg_replace('#(Driver$)#', '', basename(str_replace('\\\\', '/', $name)));\n        }\n        /*\n         * Use the driver name constant if we try to load a driver by it's\n         * fully qualified class name.\n         */\n        if (class_exists($name) && is_subclass_of($name, HttpDriver::class)) {\n            $name = $name::DRIVER_NAME;\n        }\n        if (is_null($request)) {\n            $request = Request::createFromGlobals();\n        }\n        foreach (self::getAvailableDrivers() as $driver) {\n            /** @var HttpDriver $driver */\n            $driver = new $driver($request, $config, new Curl());\n            if ($driver->getName() === $name) {\n                return $driver;\n            }\n        }\n\n        return new NullDriver($request, [], new Curl());\n    }", "label": 2}
{"code": "function write(myLocale) {\n    try {\n        stats = fs.lstatSync(directory);\n    } catch(e) {\n        fs.mkdirSync(directory, 0755);\n    }\n    fs.writeFile(locate(myLocale), JSON.stringify(locales[myLocale], null, \"\\t\"));\n}", "label": 3}
{"code": "private static void updateSniffingLoggersLevel(Logger logger) {\n\n\t\tInputStream settingIS = FoundationLogger.class\n\t\t\t\t.getResourceAsStream(\"/sniffingLogger.xml\");\n\t\tif (settingIS == null) {\n\t\t\tlogger.debug(\"file sniffingLogger.xml not found in classpath\");\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tSAXBuilder builder = new SAXBuilder();\n\t\t\t\tDocument document = builder.build(settingIS);\n\t\t\t\tsettingIS.close();\n\t\t\t\tElement rootElement = document.getRootElement();\n\t\t\t\tList<Element> sniffingloggers = rootElement\n\t\t\t\t\t\t.getChildren(\"sniffingLogger\");\n\t\t\t\tfor (Element sniffinglogger : sniffingloggers) {\n\t\t\t\t\tString loggerName = sniffinglogger.getAttributeValue(\"id\");\n\t\t\t\t\tLogger.getLogger(loggerName).setLevel(Level.TRACE);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\t\"cannot load the sniffing logger configuration file. error is: \"\n\t\t\t\t\t\t\t\t+ e, e);\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Problem parsing sniffingLogger.xml\", e);\n\t\t\t}\n\t\t}\n\n\t}", "label": 0}
{"code": "public static byte[] getContentBytes(String stringUrl) throws IOException {\n    URL url = new URL(stringUrl);\n    byte[] data = MyStreamUtils.readContentBytes(url.openStream());\n    return data;\n  }", "label": 0}
{"code": "def dom_id(record, prefix = nil)\n      if record_id = record_key_for_dom_id(record)\n        \"#{dom_class(record, prefix)}#{JOIN}#{record_id}\"\n      else\n        dom_class(record, prefix || NEW)\n      end\n    end", "label": 4}
{"code": "protected function getFilenameForRevision(string $revision): string\n    {\n        $ext = pathinfo($this->filename, PATHINFO_EXTENSION);\n\n        return substr_replace($this->filename, '-'.$revision, -strlen($ext) - 1, 0);\n    }", "label": 2}
{"code": "private void prefetchRelationships(Query query)\r\n    {\r\n        List prefetchedRel;\r\n        Collection owners;\r\n        String relName;\r\n        RelationshipPrefetcher[] prefetchers;\r\n\r\n        if (query == null || query.getPrefetchedRelationships() == null || query.getPrefetchedRelationships().isEmpty())\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!supportsAdvancedJDBCCursorControl())\r\n        {\r\n            logger.info(\"prefetching relationships requires JDBC level 2.0\");\r\n            return;\r\n        }\r\n\r\n        // prevent releasing of DBResources\r\n        setInBatchedMode(true);\r\n\r\n        prefetchedRel = query.getPrefetchedRelationships();\r\n        prefetchers = new RelationshipPrefetcher[prefetchedRel.size()];\r\n\r\n        // disable auto retrieve for all prefetched relationships\r\n        for (int i = 0; i < prefetchedRel.size(); i++)\r\n        {\r\n            relName = (String) prefetchedRel.get(i);\r\n            prefetchers[i] = getBroker().getRelationshipPrefetcherFactory()\r\n                    .createRelationshipPrefetcher(getQueryObject().getClassDescriptor(), relName);\r\n            prefetchers[i].prepareRelationshipSettings();\r\n        }\r\n\r\n        // materialize ALL owners of this Iterator\r\n        owners = getOwnerObjects();\r\n\r\n        // prefetch relationships and associate with owners\r\n        for (int i = 0; i < prefetchedRel.size(); i++)\r\n        {\r\n            prefetchers[i].prefetchRelationship(owners);\r\n        }\r\n\r\n        // reset auto retrieve for all prefetched relationships\r\n        for (int i = 0; i < prefetchedRel.size(); i++)\r\n        {\r\n            prefetchers[i].restoreRelationshipSettings();\r\n        }\r\n\r\n        try\r\n        {\r\n            getRsAndStmt().m_rs.beforeFirst(); // reposition resultset jdbc 2.0\r\n        }\r\n        catch (SQLException e)\r\n        {\r\n            logger.error(\"beforeFirst failed !\", e);\r\n        }\r\n\r\n        setInBatchedMode(false);\r\n        setHasCalledCheck(false);\r\n    }", "label": 0}
{"code": "public function iterate($parameters = null, $hydrationMode = self::HYDRATE_OBJECT)\n    {\n        $this->setHint(self::HINT_INTERNAL_ITERATION, true);\n\n        return parent::iterate($parameters, $hydrationMode);\n    }", "label": 2}
{"code": "func (l *LoadBalancer) RemoveBackend(b NetAddr) {\n\tl.Lock()\n\tdefer l.Unlock()\n\tl.currentIndex = -1\n\tfor i := range l.backends {\n\t\tif l.backends[i].Equals(b) {\n\t\t\tl.backends = append(l.backends[:i], l.backends[i+1:]...)\n\t\t\tl.dropConnections(b)\n\t\t\treturn\n\t\t}\n\t}\n}", "label": 5}
{"code": "func timestampFrame(message string) {\n\tconst (\n\t\tsaveCursor    = \"7\"\n\t\trestoreCursor = \"8\"\n\t)\n\tsz, err := term.GetWinsize(0)\n\tif err != nil {\n\t\treturn\n\t}\n\tesc := func(s string) {\n\t\tos.Stdout.Write([]byte(\"\\x1b\" + s))\n\t}\n\tesc(saveCursor)\n\tdefer esc(restoreCursor)\n\n\t// move cursor to -10:0\n\tesc(fmt.Sprintf(\"[%d;%df\", 0, int(sz.Width)-len(message)))\n\tos.Stdout.WriteString(message)\n}", "label": 5}
{"code": "public function sendPresenceUnsubscription($to)\n    {\n        $node = new ProtocolNode('presence', ['type' => 'unsubscribe', 'to' => $this->getJID($to)], null, '');\n        $this->sendNode($node);\n    }", "label": 2}
{"code": "public static dnsaddrec[] get(nitro_service service) throws Exception{\n\t\tdnsaddrec obj = new dnsaddrec();\n\t\tdnsaddrec[] response = (dnsaddrec[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public static base_response delete(nitro_service client, snmpgroup resource) throws Exception {\n\t\tsnmpgroup deleteresource = new snmpgroup();\n\t\tdeleteresource.name = resource.name;\n\t\tdeleteresource.securitylevel = resource.securitylevel;\n\t\treturn deleteresource.delete_resource(client);\n\t}", "label": 0}
{"code": "def process_rgb_bytes(bytes_in, width, height, quality=DEFAULT_JPEG_QUALITY):\n    \"\"\"Generates an optimized JPEG from RGB bytes.\n\n    :param bytes bytes_in: the input image's bytes\n    :param int width: the width of the input image\n    :param int height: the height of the input image\n    :param int quality: the output JPEG quality (default 95)\n\n    :returns: Optimized JPEG bytes\n    :rtype: bytes\n\n    :raises ValueError: the given width and height is not coherent with the\n                        ``bytes_in`` length.\n\n    .. code:: python\n\n        import pyguetzli\n\n        # 2x2px RGB image\n        #                |    red    |   green   |\n        image_pixels  = b\"\\\\xFF\\\\x00\\\\x00\\\\x00\\\\xFF\\\\x00\"\n        image_pixels += b\"\\\\x00\\\\x00\\\\xFF\\\\xFF\\\\xFF\\\\xFF\"\n        #                |   blue    |   white   |\n\n        optimized_jpeg = pyguetzli.process_rgb_bytes(image_pixels, 2, 2)\n    \"\"\"\n    if len(bytes_in) != width * height * 3:\n        raise ValueError(\"bytes_in length is not coherent with given width and height\")  # noqa\n\n    bytes_out_p = ffi.new(\"char**\")\n    bytes_out_p_gc = ffi.gc(bytes_out_p, lib.guetzli_free_bytes)\n\n    length = lib.guetzli_process_rgb_bytes(\n            bytes_in,\n            width,\n            height,\n            bytes_out_p_gc,\n            quality\n            )\n\n    bytes_out = ffi.cast(\"char*\", bytes_out_p_gc[0])\n    return ffi.unpack(bytes_out, length)", "label": 1}
{"code": "function (options) {\n\n            if (typeof options === 'object') {\n\n                // Add implementation-specific method prefix (dashboard or app)\n                options.name = this.prefix + '.' + options.name;\n                return this.transport.send(options);\n            }  else {\n                throw new Error('Transport options must be an object.');\n            }\n        }", "label": 3}
{"code": "def split_fasta(f, id2f):\n    \"\"\"\n    split fasta file into separate fasta files based on list of scaffolds\n    that belong to each separate file\n    \"\"\"\n    opened = {}\n    for seq in parse_fasta(f):\n        id = seq[0].split('>')[1].split()[0]\n        if id not in id2f:\n            continue\n        fasta = id2f[id]\n        if fasta not in opened:\n            opened[fasta] = '%s.fa' % fasta\n        seq[1] += '\\n'\n        with open(opened[fasta], 'a+') as f_out:\n            f_out.write('\\n'.join(seq))", "label": 1}
{"code": "def shutdown(self, collector, success):\n        \"\"\"Shutdown of the application.\"\"\"\n        self.event.delegate(success)\n        if collector is not None:\n            collector.queue.put(None)\n            collector.join()\n        if not success:\n            sys.exit(1)", "label": 1}
{"code": "function() {\n    var client = this;\n    var cconf = this.config.client;\n\n    return router(function(app) {\n      app.get(cconf.process_login_url, client.auth_process_login.bind(client));\n      app.get(cconf.login_url, client.login.bind(client));\n      app.get(cconf.logout_url, client.logout.bind(client));\n    });\n  }", "label": 3}
{"code": "func (b *BoxLayout) HandleEvent(ev tcell.Event) bool {\n\tswitch ev.(type) {\n\tcase *EventWidgetContent:\n\t\t// This can only have come from one of our children.\n\t\tb.changed = true\n\t\tb.PostEventWidgetContent(b)\n\t\treturn true\n\t}\n\tfor _, c := range b.cells {\n\t\tif c.widget.HandleEvent(ev) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, spilloverpolicy resource) throws Exception {\n\t\tspilloverpolicy addresource = new spilloverpolicy();\n\t\taddresource.name = resource.name;\n\t\taddresource.rule = resource.rule;\n\t\taddresource.action = resource.action;\n\t\taddresource.comment = resource.comment;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "public void linkMtoN(Object obj, CollectionDescriptor cod, boolean insert)\n    {\n        Object referencedObjects = cod.getPersistentField().get(obj);\n        storeAndLinkMtoN(true, obj, cod, referencedObjects, insert);\n    }", "label": 0}
{"code": "public function applyGroupAttributes(array $attributes)\n    {\n        if (isset($attributes['middleware'])) {\n            $this->middleware($attributes['middleware']);\n        }\n\n        if (isset($attributes['driver'])) {\n            $this->driver($attributes['driver']);\n        }\n\n        if (isset($attributes['recipient'])) {\n            $this->recipient($attributes['recipient']);\n        }\n\n        if (isset($attributes['stop_conversation']) && $attributes['stop_conversation'] === true) {\n            $this->stopsConversation();\n        }\n\n        if (isset($attributes['skip_conversation']) && $attributes['skip_conversation'] === true) {\n            $this->skipsConversation();\n        }\n    }", "label": 2}
{"code": "func overlayRender(cfg RunConfig, treeStoreID string, cdir string, dest string, appName string) error {\n\tcachedTreePath := cfg.TreeStore.GetRootFS(treeStoreID)\n\tmc, err := prepareOverlay(cachedTreePath, treeStoreID, cdir, dest, appName, cfg.MountLabel,\n\t\tcfg.RktGid, common.DefaultRegularDirPerm)\n\tif err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"problem preparing overlay directories\"), err)\n\t}\n\tif err = overlay.Mount(mc); err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"problem mounting overlay filesystem\"), err)\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "protected function getColumnsDefinition()\n    {\n        $config  = $this->config->get('datatables.columns');\n        $allowed = ['excess', 'escape', 'raw', 'blacklist', 'whitelist'];\n\n        return array_replace_recursive(array_only($config, $allowed), $this->columnDef);\n    }", "label": 2}
{"code": "func generateCert() (cert []byte, privateKey []byte, err error) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tserialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)\n\tsn, err := rand.Int(rand.Reader, serialNumberLimit)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\thost := \"localhost\"\n\n\ttemplate := &x509.Certificate{\n\t\tSubject: pkix.Name{\n\t\t\tCommonName:   host,\n\t\t\tOrganization: []string{\"HashiCorp\"},\n\t\t},\n\t\tDNSNames: []string{host},\n\t\tExtKeyUsage: []x509.ExtKeyUsage{\n\t\t\tx509.ExtKeyUsageClientAuth,\n\t\t\tx509.ExtKeyUsageServerAuth,\n\t\t},\n\t\tKeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment | x509.KeyUsageKeyAgreement | x509.KeyUsageCertSign,\n\t\tBasicConstraintsValid: true,\n\t\tSerialNumber:          sn,\n\t\tNotBefore:             time.Now().Add(-30 * time.Second),\n\t\tNotAfter:              time.Now().Add(262980 * time.Hour),\n\t\tIsCA:                  true,\n\t}\n\n\tder, err := x509.CreateCertificate(rand.Reader, template, template, key.Public(), key)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar certOut bytes.Buffer\n\tif err := pem.Encode(&certOut, &pem.Block{Type: \"CERTIFICATE\", Bytes: der}); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tkeyBytes, err := x509.MarshalECPrivateKey(key)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar keyOut bytes.Buffer\n\tif err := pem.Encode(&keyOut, &pem.Block{Type: \"EC PRIVATE KEY\", Bytes: keyBytes}); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert = certOut.Bytes()\n\tprivateKey = keyOut.Bytes()\n\n\treturn cert, privateKey, nil\n}", "label": 5}
{"code": "def _get_line_array_construct(self):\n        \"\"\" Returns a construct for an array of line data.\n        \"\"\"\n        from_bus = integer.setResultsName(\"fbus\")\n        to_bus = integer.setResultsName(\"tbus\")\n        s_rating = real.setResultsName(\"s_rating\") # MVA\n        v_rating = real.setResultsName(\"v_rating\") # kV\n        f_rating = real.setResultsName(\"f_rating\") # Hz\n        length = real.setResultsName(\"length\") # km (Line only)\n        v_ratio = real.setResultsName(\"v_ratio\") # kV/kV (Transformer only)\n        r = real.setResultsName(\"r\") # p.u. or Ohms/km\n        x = real.setResultsName(\"x\") # p.u. or Henrys/km\n        b = real.setResultsName(\"b\") # p.u. or Farads/km (Line only)\n        tap_ratio = real.setResultsName(\"tap\") # p.u./p.u. (Transformer only)\n        phase_shift = real.setResultsName(\"shift\") # degrees (Transformer only)\n        i_limit = Optional(real).setResultsName(\"i_limit\") # p.u.\n        p_limit = Optional(real).setResultsName(\"p_limit\") # p.u.\n        s_limit = Optional(real).setResultsName(\"s_limit\") # p.u.\n        status = Optional(boolean).setResultsName(\"status\")\n\n        line_data = from_bus + to_bus + s_rating + v_rating + \\\n            f_rating + length + v_ratio + r + x + b + tap_ratio + \\\n            phase_shift + i_limit + p_limit + s_limit + status + scolon\n\n        line_data.setParseAction(self.push_line)\n\n        line_array = Literal(\"Line.con\") + \"=\" + \"[\" + \"...\" + \\\n            ZeroOrMore(line_data + Optional(\"]\" + scolon))\n\n        return line_array", "label": 1}
{"code": "def remove(self, resource, **kwargs):\n        \"\"\"\n        Remove an instance of this resource type.\n        \"\"\"\n        log.info(\n            \"Removing {} '{}'...\".format(self._model_name, resource.name))\n        resource.remove(**kwargs)\n        self._ids.remove(resource.id)", "label": 1}
{"code": "public boolean evaluate(Object feature) {\n\t\t// Checks to ensure that the attribute has been set\n\t\tif (attribute == null) {\n\t\t\treturn false;\n\t\t}\n\t\t// Note that this converts the attribute to a string\n\t\t// for comparison. Unlike the math or geometry filters, which\n\t\t// require specific types to function correctly, this filter\n\t\t// using the mandatory string representation in Java\n\t\t// Of course, this does not guarantee a meaningful result, but it\n\t\t// does guarantee a valid result.\n\t\t// LOGGER.finest(\"pattern: \" + pattern);\n\t\t// LOGGER.finest(\"string: \" + attribute.getValue(feature));\n\t\t// return attribute.getValue(feature).toString().matches(pattern);\n\t\tObject value = attribute.evaluate(feature);\n\n\t\tif (null == value) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMatcher matcher = getMatcher();\n\t\tmatcher.reset(value.toString());\n\n\t\treturn matcher.matches();\n\t}", "label": 0}
{"code": "public static nsappflowcollector[] get(nitro_service service) throws Exception{\n\t\tnsappflowcollector obj = new nsappflowcollector();\n\t\tnsappflowcollector[] response = (nsappflowcollector[])obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "private function normalizeFeatures(array $features)\n    {\n        $results = [];\n\n        foreach ($features as $feature) {\n            $featureName = array_key_exists($feature, $this->featureShortNames)\n                ? $this->featureShortNames[$feature]\n                : $feature;\n\n            $results[$featureName] = true;\n        }\n\n        return $results;\n    }", "label": 2}
{"code": "function process(payload) {\n  payload = payload.toLowerCase();\n\n  var advA48 = address.process(payload.substr(4,12));\n  advA48.advHeader = header.process(payload.substr(0,4));\n  advA48.advData = data.process(payload.substr(16));\n  return advA48;\n}", "label": 3}
{"code": "func (s *Strings) UnmarshalJSON(data []byte) error {\n\tif len(data) == 0 {\n\t\treturn nil\n\t}\n\tvar stringVar string\n\tif err := json.Unmarshal(data, &stringVar); err == nil {\n\t\t*s = []string{stringVar}\n\t\treturn nil\n\t}\n\tvar stringsVar []string\n\tif err := json.Unmarshal(data, &stringsVar); err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\t*s = stringsVar\n\treturn nil\n}", "label": 5}
{"code": "func (t *TeleportClusterNameMarshaler) Unmarshal(bytes []byte, opts ...MarshalOption) (ClusterName, error) {\n\tvar clusterName ClusterNameV2\n\n\tif len(bytes) == 0 {\n\t\treturn nil, trace.BadParameter(\"missing resource data\")\n\t}\n\n\tcfg, err := collectOptions(opts)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tif cfg.SkipValidation {\n\t\tif err := utils.FastUnmarshal(bytes, &clusterName); err != nil {\n\t\t\treturn nil, trace.BadParameter(err.Error())\n\t\t}\n\t} else {\n\t\terr = utils.UnmarshalWithSchema(GetClusterNameSchema(\"\"), &clusterName, bytes)\n\t\tif err != nil {\n\t\t\treturn nil, trace.BadParameter(err.Error())\n\t\t}\n\t}\n\n\terr = clusterName.CheckAndSetDefaults()\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tif cfg.ID != 0 {\n\t\tclusterName.SetResourceID(cfg.ID)\n\t}\n\tif !cfg.Expires.IsZero() {\n\t\tclusterName.SetExpiry(cfg.Expires)\n\t}\n\n\treturn &clusterName, nil\n}", "label": 5}
{"code": "public function setOp($var)\n    {\n        GPBUtil::checkEnum($var, \\Google\\Cloud\\Firestore\\V1\\StructuredQuery_UnaryFilter_Operator::class);\n        $this->op = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "protected function checkFilters()\n    {\n        $current = $this->prepareForReturn($this->current);\n\n        foreach ($this->filters as $tuple) {\n            $result = call_user_func(\n                $tuple[0],\n                $current->copy(),\n                $this->key,\n                $this\n            );\n\n            if ($result === static::END_ITERATION) {\n                return static::END_ITERATION;\n            }\n\n            if (!$result) {\n                return false;\n            }\n        }\n\n        return true;\n    }", "label": 2}
{"code": "def read(value = nil)\n      clone.tap do |criteria|\n        criteria.options.merge!(read: value)\n      end\n    end", "label": 4}
{"code": "def method_rules\n      [\n        Rule.new(:error, 40..41, \"Description\", \"You should include a description for your method.\", proc do |json|\n          json[:body_md] && json[:body_md].empty?\n        end),\n        Rule.new(:warning, 43..45, \"Params\", \"You should give a 'type' for the param, yes, ruby is duck-typey but it's useful for newbies to the language, use `@param [Type] name`.\", proc do |json|\n          json[:param_couplets] && json[:param_couplets].flat_map(&:values).include?(nil)\n        end),\n        Rule.new(:warning, 43..45, \"Unknown Param\", \"You should give a 'type' for the param, yes, ruby is duck-typey but it's useful for newbies to the language, use `@param [Type] name`.\", proc do |json|\n          json[:param_couplets] && json[:param_couplets].flat_map(&:values).include?(\"Unknown\")\n        end),\n        Rule.new(:warning, 46, \"Return Type\", \"If the function has no useful return value, use ` @return  [void]` - this will be ignored by documentation generators.\", proc do |json|\n          return_hash = json[:tags].find { |tag| tag[:name] == \"return\" }\n          !(return_hash && return_hash[:types] && !return_hash[:types].first.empty?)\n        end)\n      ]\n    end", "label": 4}
{"code": "private function validateMd5()\n    {\n        return static function (callable $handler) {\n            return function (\n                CommandInterface $c,\n                RequestInterface $r = null\n            ) use ($handler) {\n                if ($c->getName() !== 'ReceiveMessage') {\n                    return $handler($c, $r);\n                }\n\n                return $handler($c, $r)\n                    ->then(\n                        function ($result) use ($c, $r) {\n                            foreach ((array) $result['Messages'] as $msg) {\n                                $bodyMd5 = self::calculateBodyMd5($msg);\n                                if (isset($msg['MD5OfBody'])\n                                    && $bodyMd5 !== $msg['MD5OfBody']\n                                ) {\n                                    throw new SqsException(\n                                        sprintf(\n                                            'MD5 mismatch. Expected %s, found %s',\n                                            $msg['MD5OfBody'],\n                                            $bodyMd5\n                                        ),\n                                        $c,\n                                        [\n                                            'code' => 'ClientChecksumMismatch',\n                                            'request' => $r\n                                        ]\n                                    );\n                                }\n\n                                if (isset($msg['MD5OfMessageAttributes'])) {\n                                    $messageAttributesMd5 = self::calculateMessageAttributesMd5($msg);\n                                    if ($messageAttributesMd5 !== $msg['MD5OfMessageAttributes']) {\n                                        throw new SqsException(\n                                            sprintf(\n                                                'Attribute MD5 mismatch. Expected %s, found %s',\n                                                $msg['MD5OfMessageAttributes'],\n                                                $messageAttributesMd5\n                                                    ? $messageAttributesMd5\n                                                    : 'No Attributes'\n                                            ),\n                                            $c,\n                                            [\n                                                'code' => 'ClientChecksumMismatch',\n                                                'request' => $r\n                                            ]\n                                        );\n                                    }\n                                } else if (isset($msg['MessageAttributes'])) {\n                                    throw new SqsException(\n                                        sprintf(\n                                            'No Attribute MD5 found. Expected %s',\n                                            self::calculateMessageAttributesMd5($msg)\n                                        ),\n                                        $c,\n                                        [\n                                            'code' => 'ClientChecksumMismatch',\n                                            'request' => $r\n                                        ]\n                                    );\n                                }\n                            }\n                            return $result;\n                        }\n                    );\n            };\n        };\n    }", "label": 2}
{"code": "func deletePod(p *pkgPod.Pod) bool {\n\tpodState := p.State()\n\tif podState != pkgPod.ExitedGarbage && podState != pkgPod.Garbage && podState != pkgPod.ExitedDeleting {\n\t\tstderr.Errorf(\"non-garbage pod %q (status %q), skipped\", p.UUID, p.State())\n\t\treturn false\n\t}\n\n\tif podState == pkgPod.ExitedGarbage {\n\t\ts, err := imagestore.NewStore(storeDir())\n\t\tif err != nil {\n\t\t\tstderr.PrintE(\"cannot open store\", err)\n\t\t\treturn false\n\t\t}\n\t\tdefer s.Close()\n\n\t\tts, err := treestore.NewStore(treeStoreDir(), s)\n\t\tif err != nil {\n\t\t\tstderr.PrintE(\"cannot open store\", err)\n\t\t\treturn false\n\t\t}\n\n\t\tif globalFlags.Debug {\n\t\t\tstage0.InitDebug()\n\t\t}\n\n\t\tif newMount, err := mountPodStage1(ts, p); err == nil {\n\t\t\tif err = stage0.GC(p.Path(), p.UUID, globalFlags.LocalConfigDir); err != nil {\n\t\t\t\tstderr.PrintE(fmt.Sprintf(\"problem performing stage1 GC on %q\", p.UUID), err)\n\t\t\t}\n\t\t\t// Linux <4.13 allows an overlay fs to be mounted over itself, so let's\n\t\t\t// unmount it here to avoid problems when running stage0.MountGC\n\t\t\tif p.UsesOverlay() && newMount {\n\t\t\t\tstage1Mnt := common.Stage1RootfsPath(p.Path())\n\t\t\t\tif err := syscall.Unmount(stage1Mnt, 0); err != nil && err != syscall.EBUSY {\n\t\t\t\t\tstderr.PrintE(\"error unmounting stage1\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstderr.PrintE(\"skipping stage1 GC\", err)\n\t\t}\n\n\t\t// unmount all leftover mounts\n\t\tif err := stage0.MountGC(p.Path(), p.UUID.String()); err != nil {\n\t\t\tstderr.PrintE(fmt.Sprintf(\"GC of leftover mounts for pod %q failed\", p.UUID), err)\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// remove the rootfs first; if this fails (eg. due to busy mountpoints), pod manifest\n\t// is left in place and clean-up can be re-tried later.\n\trootfsPath, err := p.Stage1RootfsPath()\n\tif err == nil {\n\t\tif e := os.RemoveAll(rootfsPath); e != nil {\n\t\t\tstderr.PrintE(fmt.Sprintf(\"unable to remove pod rootfs %q\", p.UUID), e)\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// finally remove all remaining pieces\n\tif err := os.RemoveAll(p.Path()); err != nil {\n\t\tstderr.PrintE(fmt.Sprintf(\"unable to remove pod %q\", p.UUID), err)\n\t\treturn false\n\t}\n\n\treturn true\n}", "label": 5}
{"code": "private boolean checkTagAndParam(XDoc doc, String tagName, String paramName, String paramValue)\r\n    {\r\n        if (tagName == null) {\r\n            return true;\r\n        }\r\n        if (!doc.hasTag(tagName)) {\r\n            return false;\r\n        }\r\n        if (paramName == null) {\r\n            return true;\r\n        }\r\n        if (!doc.getTag(tagName).getAttributeNames().contains(paramName)) {\r\n            return false;\r\n        }\r\n        return (paramValue == null) || paramValue.equals(doc.getTagAttributeValue(tagName, paramName));\r\n    }", "label": 0}
{"code": "func AllocatePorts(portMapper *portmapper.PortMapper, bindings []types.PortBinding, containerIP net.IP) ([]types.PortBinding, error) {\n\tbs := make([]types.PortBinding, 0, len(bindings))\n\tfor _, c := range bindings {\n\t\tb := c.GetCopy()\n\t\tif err := allocatePort(portMapper, &b, containerIP); err != nil {\n\t\t\t// On allocation failure, release previously allocated ports. On cleanup error, just log a warning message\n\t\t\tif cuErr := ReleasePorts(portMapper, bs); cuErr != nil {\n\t\t\t\tlogrus.Warnf(\"Upon allocation failure for %v, failed to clear previously allocated port bindings: %v\", b, cuErr)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tbs = append(bs, b)\n\t}\n\treturn bs, nil\n}", "label": 5}
{"code": "function buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning, flags, typeFlags) {\n                var parentSymbol;\n                function appendParentTypeArgumentsAndSymbolName(symbol) {\n                    if (parentSymbol) {\n                        // Write type arguments of instantiated class/interface here\n                        if (flags & 1 /* WriteTypeParametersOrArguments */) {\n                            if (symbol.flags & 16777216 /* Instantiated */) {\n                                buildDisplayForTypeArgumentsAndDelimiters(getTypeParametersOfClassOrInterface(parentSymbol), symbol.mapper, writer, enclosingDeclaration);\n                            }\n                            else {\n                                buildTypeParameterDisplayFromSymbol(parentSymbol, writer, enclosingDeclaration);\n                            }\n                        }\n                        appendPropertyOrElementAccessForSymbol(symbol, writer);\n                    }\n                    else {\n                        appendSymbolNameOnly(symbol, writer);\n                    }\n                    parentSymbol = symbol;\n                }\n                // const the writer know we just wrote out a symbol.  The declaration emitter writer uses\n                // this to determine if an import it has previously seen (and not written out) needs\n                // to be written to the file once the walk of the tree is complete.\n                //\n                // NOTE(cyrusn): This approach feels somewhat unfortunate.  A simple pass over the tree\n                // up front (for example, during checking) could determine if we need to emit the imports\n                // and we could then access that data during declaration emit.\n                writer.trackSymbol(symbol, enclosingDeclaration, meaning);\n                function walkSymbol(symbol, meaning) {\n                    if (symbol) {\n                        var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, !!(flags & 2 /* UseOnlyExternalAliasing */));\n                        if (!accessibleSymbolChain ||\n                            needsQualification(accessibleSymbolChain[0], enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {\n                            // Go up and add our parent.\n                            walkSymbol(getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol), getQualifiedLeftMeaning(meaning));\n                        }\n                        if (accessibleSymbolChain) {\n                            for (var _i = 0, accessibleSymbolChain_1 = accessibleSymbolChain; _i < accessibleSymbolChain_1.length; _i++) {\n                                var accessibleSymbol = accessibleSymbolChain_1[_i];\n                                appendParentTypeArgumentsAndSymbolName(accessibleSymbol);\n                            }\n                        }\n                        else {\n                            // If we didn't find accessible symbol chain for this symbol, break if this is external module\n                            if (!parentSymbol && ts.forEach(symbol.declarations, hasExternalModuleSymbol)) {\n                                return;\n                            }\n                            // if this is anonymous type break\n                            if (symbol.flags & 2048 /* TypeLiteral */ || symbol.flags & 4096 /* ObjectLiteral */) {\n                                return;\n                            }\n                            appendParentTypeArgumentsAndSymbolName(symbol);\n                        }\n                    }\n                }\n                // Get qualified name if the symbol is not a type parameter\n                // and there is an enclosing declaration or we specifically\n                // asked for it\n                var isTypeParameter = symbol.flags & 262144 /* TypeParameter */;\n                var typeFormatFlag = 128 /* UseFullyQualifiedType */ & typeFlags;\n                if (!isTypeParameter && (enclosingDeclaration || typeFormatFlag)) {\n                    walkSymbol(symbol, meaning);\n                    return;\n                }\n                return appendParentTypeArgumentsAndSymbolName(symbol);\n            }", "label": 3}
{"code": "def update!(resource, author, params, extra_log_info = {})\n      perform_action!(:update, resource, author, extra_log_info) do\n        resource.update!(params)\n        resource\n      end\n    end", "label": 4}
{"code": "private String getFullUrl(String url) {\n        return url.startsWith(\"https://\") || url.startsWith(\"http://\") ? url : transloadit.getHostUrl() + url;\n    }", "label": 0}
{"code": "func (s *PresenceService) UpsertLocalClusterName(name string) error {\n\t_, err := s.Put(context.TODO(), backend.Item{\n\t\tKey:   backend.Key(localClusterPrefix, valPrefix),\n\t\tValue: []byte(name),\n\t})\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "public static base_responses add(nitro_service client, snmptrap resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tsnmptrap addresources[] = new snmptrap[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\taddresources[i] = new snmptrap();\n\t\t\t\taddresources[i].trapclass = resources[i].trapclass;\n\t\t\t\taddresources[i].trapdestination = resources[i].trapdestination;\n\t\t\t\taddresources[i].version = resources[i].version;\n\t\t\t\taddresources[i].destport = resources[i].destport;\n\t\t\t\taddresources[i].communityname = resources[i].communityname;\n\t\t\t\taddresources[i].srcip = resources[i].srcip;\n\t\t\t\taddresources[i].severity = resources[i].severity;\n\t\t\t}\n\t\t\tresult = add_bulk_request(client, addresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public static route[] get(nitro_service service, route_args args) throws Exception{\n\t\troute obj = new route();\n\t\toptions option = new options();\n\t\toption.set_args(nitro_util.object_to_string_withoutquotes(args));\n\t\troute[] response = (route[])obj.get_resources(service, option);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func (ca *CertAuthorityV2) GetID() CertAuthID {\n\treturn CertAuthID{Type: ca.Spec.Type, DomainName: ca.Metadata.Name}\n}", "label": 5}
{"code": "function _gpfDefineInterface(name, definition) {\n        var interfaceDefinition = { $interface: \"gpf.interfaces.I\" + name };\n        Object.keys(definition).forEach(function (methodName) {\n            interfaceDefinition[methodName] = _gpfCreateAbstractFunction(definition[methodName]);\n        });\n        return _gpfDefine(interfaceDefinition);\n    }", "label": 3}
{"code": "func NewObjectManager(client *vim25.Client, ref ...types.ManagedObjectReference) *ObjectManager {\n\tmref := *client.ServiceContent.VStorageObjectManager\n\n\tif len(ref) == 1 {\n\t\tmref = ref[0]\n\t}\n\n\tm := ObjectManager{\n\t\tManagedObjectReference: mref,\n\t\tc:                      client,\n\t\tisVC:                   mref.Type == \"VcenterVStorageObjectManager\",\n\t}\n\n\treturn &m\n}", "label": 5}
{"code": "public static Method getGetterPropertyMethod(Class<?> type,\r\n\t\t\tString propertyName) {\r\n\t\tString sourceMethodName = \"get\"\r\n\t\t\t\t+ BeanUtils.capitalizePropertyName(propertyName);\r\n\r\n\t\tMethod sourceMethod = BeanUtils.getMethod(type, sourceMethodName);\r\n\r\n\t\tif (sourceMethod == null) {\r\n\t\t\tsourceMethodName = \"is\"\r\n\t\t\t\t\t+ BeanUtils.capitalizePropertyName(propertyName);\r\n\t\t\tsourceMethod = BeanUtils.getMethod(type, sourceMethodName);\r\n\t\t\tif (sourceMethod != null\r\n\t\t\t\t\t&& sourceMethod.getReturnType() != Boolean.TYPE) {\r\n\t\t\t\tsourceMethod = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn sourceMethod;\r\n\t}", "label": 0}
{"code": "def diff_renderer\n      @diff_renderer ||= if current_version.item_type.include? \"Decidim::Proposals\"\n                           Decidim::Proposals::DiffRenderer.new(current_version)\n                         elsif current_version.item_type.include? \"Decidim::Accountability\"\n                           Decidim::Accountability::DiffRenderer.new(current_version)\n                         end\n    end", "label": 4}
{"code": "def delete_marked_communities():\n    \"\"\"Delete communities after holdout time.\"\"\"\n    # TODO: Delete the community ID from all records metadata first\n    raise NotImplementedError()\n    Community.query.filter_by(\n        Community.delete_time > datetime.utcnow()).delete()\n    db.session.commit()", "label": 1}
{"code": "function (err, result) {\n\n\t\t// if login is successful, we record the user's account in cache\n\t\tif (err) {\n\t\t\tLOG.warn(err.toString());\n\t\t\tresult = {code: err.code, msg: err.message};\n\t\t}\n\t\telse {\n\t\t\tif (result.code === 0) {\n\t\t\t\tLOG.warn('login success, result: ');\n\t\t\t\tLOG.warn(result);\n\n\t\t\t\tvar data = {\n\t\t\t\t\taccount: user_data.account,\n\t\t\t\t\tgroups: result.data.groups,\n\t\t\t\t\tlastStatus: result.data.lastStatus,\n\t\t\t\t\tpermissions: []\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_initSession(event.data.login_id, event.session, data);\n\n\t\t\t\t/*\n\t\t\t\t// todo: read permssion from DB\n\t\t\t\t//event.session['_permissions'] = result.data.permissions;\n\t\t\t\tvar xx = [];\n\t\t\t\tvar onSuccess = function(dat){\n\t\t\t\t\t//console.log(dat.permission);\n\t\t\t\t\tif (dat === null) {\n\t\t\t\t\t\tconsole.log(\"no permission\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (var i in dat.permission) {\n\t\t\t\t\t\t\t//console.log(\"pushing: \" + dat.permission[i]);\n\t\t\t\t\t\t\txx.push(dat.permission[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//event.done(\"get group\", {\"status\": \"success\", \"data\": data});\n\t\t\t\t};\n\t\t\t\tvar onFail = function(dat){\n\t\t\t\t\t//event.done(\"get group\", {\"status\": \"failure\", \"data\": data});\n\t\t\t\t};\n\t\t\t\tfor (var i in event.session['_groups']) {\n\t\t\t\t\t//console.log(\"getting: \" + event.session['_groups'][i]);\n\t\t\t\t\tSR.DB.getData(groupPermissionDB, {\"group\": event.session['_groups'][i], part: \"group\"}, onSuccess, onFail);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\t// TODO: login at once to all local accounts\n\t\t\t\t// NOTE: need to query all local login account name & password, then perform individual logins\n\t\t\t\tl_login_local_accounts(user_data.account);\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t//LOG.warn('event before sending login response:');\n\t\t//LOG.warn(event);\n\t\t\n\t\t//if (result.data) delete result.data;\n\t\t// return response regardless success or fail\n\t\tevent.done('SR_LOGIN_RESPONSE', result);\n\t}", "label": 3}
{"code": "func applyListenIP(ip net.IP, cfg *service.Config) {\n\tlisteningAddresses := []*utils.NetAddr{\n\t\t&cfg.Auth.SSHAddr,\n\t\t&cfg.Auth.SSHAddr,\n\t\t&cfg.Proxy.SSHAddr,\n\t\t&cfg.Proxy.WebAddr,\n\t\t&cfg.SSH.Addr,\n\t\t&cfg.Proxy.ReverseTunnelListenAddr,\n\t}\n\tfor _, addr := range listeningAddresses {\n\t\treplaceHost(addr, ip.String())\n\t}\n}", "label": 5}
{"code": "func ReadCertificateChain(certificateChainBytes []byte) ([]*x509.Certificate, error) {\n\t// build the certificate chain next\n\tvar certificateBlock *pem.Block\n\tvar remainingBytes []byte = bytes.TrimSpace(certificateChainBytes)\n\tvar certificateChain [][]byte\n\n\tfor {\n\t\tcertificateBlock, remainingBytes = pem.Decode(remainingBytes)\n\t\tif certificateBlock == nil || certificateBlock.Type != pemBlockCertificate {\n\t\t\treturn nil, trace.NotFound(\"no PEM data found\")\n\t\t}\n\t\tcertificateChain = append(certificateChain, certificateBlock.Bytes)\n\n\t\tif len(remainingBytes) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// build a concatenated certificate chain\n\tvar buf bytes.Buffer\n\tfor _, cc := range certificateChain {\n\t\t_, err := buf.Write(cc)\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t}\n\n\t// parse the chain and get a slice of x509.Certificates.\n\tx509Chain, err := x509.ParseCertificates(buf.Bytes())\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn x509Chain, nil\n}", "label": 5}
{"code": "private PersistenceBrokerException createException(final Exception ex, String message, final Object objectToIdentify, Class topLevelClass, Class realClass, Object[] pks)\r\n    {\r\n        final String eol = SystemUtils.LINE_SEPARATOR;\r\n        StringBuffer msg = new StringBuffer();\r\n        if(message == null)\r\n        {\r\n            msg.append(\"Unexpected error: \");\r\n        }\r\n        else\r\n        {\r\n            msg.append(message).append(\" :\");\r\n        }\r\n        if(topLevelClass != null) msg.append(eol).append(\"objectTopLevelClass=\").append(topLevelClass.getName());\r\n        if(realClass != null) msg.append(eol).append(\"objectRealClass=\").append(realClass.getName());\r\n        if(pks != null) msg.append(eol).append(\"pkValues=\").append(ArrayUtils.toString(pks));\r\n        if(objectToIdentify != null) msg.append(eol).append(\"object to identify: \").append(objectToIdentify);\r\n        if(ex != null)\r\n        {\r\n            // add causing stack trace\r\n            Throwable rootCause = ExceptionUtils.getRootCause(ex);\r\n            if(rootCause != null)\r\n            {\r\n                msg.append(eol).append(\"The root stack trace is --> \");\r\n                String rootStack = ExceptionUtils.getStackTrace(rootCause);\r\n                msg.append(eol).append(rootStack);\r\n            }\r\n\r\n            return new PersistenceBrokerException(msg.toString(), ex);\r\n        }\r\n        else\r\n        {\r\n            return new PersistenceBrokerException(msg.toString());\r\n        }\r\n    }", "label": 0}
{"code": "function checkValueSubmitted(submittedField, fieldDefinition, visible, cb) {\n        if (!fieldDefinition.required) {\n          return cb(undefined, null);\n        }\n\n        var valueSubmitted = submittedField && submittedField.fieldValues && (submittedField.fieldValues.length > 0);\n        //No value submitted is only an error if the field is visible.\n\n        //If the field value has been marked as not required, then don't fail a no-value submission\n        var valueRequired = requiredFieldMap[fieldDefinition._id] && requiredFieldMap[fieldDefinition._id].valueRequired;\n\n        if (!valueSubmitted && visible && valueRequired) {\n          return cb(undefined, \"No value submitted for field \" + fieldDefinition.name);\n        }\n        return cb(undefined, null);\n\n      }", "label": 3}
{"code": "def solve(self, solver_klass=None):\n        \"\"\" Solves an optimal power flow and returns a results dictionary.\n        \"\"\"\n        # Start the clock.\n        t0 = time()\n\n        # Build an OPF model with variables and constraints.\n        om = self._construct_opf_model(self.case)\n        if om is None:\n            return {\"converged\": False, \"output\": {\"message\": \"No Ref Bus.\"}}\n\n        # Call the specific solver.\n#        if self.opt[\"verbose\"]:\n#            print '\\nPYLON Version %s, %s', \"0.4.2\", \"April 2010\"\n        if solver_klass is not None:\n            result = solver_klass(om, opt=self.opt).solve()\n        elif self.dc:\n#            if self.opt[\"verbose\"]:\n#                print ' -- DC Optimal Power Flow\\n'\n            result = DCOPFSolver(om, opt=self.opt).solve()\n        else:\n#            if self.opt[\"verbose\"]:\n#                print ' -- AC Optimal Power Flow\\n'\n            result = PIPSSolver(om, opt=self.opt).solve()\n\n        result[\"elapsed\"] = time() - t0\n\n        if self.opt.has_key(\"verbose\"):\n            if self.opt[\"verbose\"]:\n                logger.info(\"OPF completed in %.3fs.\" % result[\"elapsed\"])\n\n        return result", "label": 1}
{"code": "public <T> T handleResponse(Response response, Type returnType) throws ApiException {\n        if (response.isSuccessful()) {\n            if (returnType == null || response.code() == 204) {\n                // returning null if the returnType is not defined,\n                // or the status code is 204 (No Content)\n                return null;\n            } else {\n                return deserialize(response, returnType);\n            }\n        } else {\n            String respBody = null;\n            if (response.body() != null) {\n                try {\n                    respBody = response.body().string();\n                } catch (IOException e) {\n                    throw new ApiException(response.message(), e, response.code(), response.headers().toMultimap());\n                }\n            }\n            throw new ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);\n        }\n    }", "label": 0}
{"code": "def stop(self, failover=False):\n        \"\"\"Stops the scheduler driver.\n\n        If the 'failover' flag is set to False then it is expected that this\n        framework will never reconnect to Mesos and all of its executors and\n        tasks can be terminated.  Otherwise, all executors and tasks will\n        remain running (for some framework specific failover timeout) allowing\n        the scheduler to reconnect (possibly in the same process, or from a\n        different process, for example, on a different machine.)\n        \"\"\"\n        logging.info('Stops Scheduler Driver')\n        return self.driver.stop(failover)", "label": 1}
{"code": "public static function invisibilityOfElementLocated(WebDriverBy $by)\n    {\n        return new static(\n            function (WebDriver $driver) use ($by) {\n                try {\n                    return !$driver->findElement($by)->isDisplayed();\n                } catch (NoSuchElementException $e) {\n                    return true;\n                } catch (StaleElementReferenceException $e) {\n                    return true;\n                }\n            }\n        );\n    }", "label": 2}
{"code": "func (p *PoolData) CopyTo(dstP *PoolData) error {\n\tdstP.ParentKey = p.ParentKey\n\tdstP.Pool = types.GetIPNetCopy(p.Pool)\n\n\tif p.Range != nil {\n\t\tdstP.Range = &AddressRange{}\n\t\tdstP.Range.Sub = types.GetIPNetCopy(p.Range.Sub)\n\t\tdstP.Range.Start = p.Range.Start\n\t\tdstP.Range.End = p.Range.End\n\t}\n\n\tdstP.RefCount = p.RefCount\n\treturn nil\n}", "label": 5}
{"code": "func NewInviteToken(token, signupURL string, expires time.Time) *InviteTokenV3 {\n\ttok := InviteTokenV3{\n\t\tKind:    KindInviteToken,\n\t\tVersion: V3,\n\t\tMetadata: Metadata{\n\t\t\tName: token,\n\t\t},\n\t\tSpec: InviteTokenSpecV3{\n\t\t\tURL: signupURL,\n\t\t},\n\t}\n\tif !expires.IsZero() {\n\t\ttok.Metadata.SetExpiry(expires)\n\t}\n\treturn &tok\n}", "label": 5}
{"code": "public List<Object> getAll(int dataSet) throws SerializationException {\r\n\t\tList<Object> result = new ArrayList<Object>();\r\n\t\tfor (Iterator<DataSet> i = dataSets.iterator(); i.hasNext();) {\r\n\t\t\tDataSet ds = i.next();\r\n\t\t\tDataSetInfo info = ds.getInfo();\r\n\t\t\tif (info.getDataSetNumber() == dataSet) {\r\n\t\t\t\tresult.add(getData(ds));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}", "label": 0}
{"code": "def server_streamer(req, metadata: {})\n      raise_error_if_already_executed\n      ops = {\n        SEND_MESSAGE => @marshal.call(req),\n        SEND_CLOSE_FROM_CLIENT => nil\n      }\n      @send_initial_md_mutex.synchronize do\n        # Metadata might have already been sent if this is an operation view\n        unless @metadata_sent\n          ops[SEND_INITIAL_METADATA] = @metadata_to_send.merge!(metadata)\n        end\n        @metadata_sent = true\n      end\n\n      begin\n        @call.run_batch(ops)\n      rescue GRPC::Core::CallError => e\n        receive_and_check_status # checks for Cancelled\n        raise e\n      rescue => e\n        set_input_stream_done\n        raise e\n      ensure\n        set_output_stream_done\n      end\n\n      replies = enum_for(:each_remote_read_then_finish)\n      return replies unless block_given?\n      replies.each { |r| yield r }\n    end", "label": 4}
{"code": "def process_line(line) # :nodoc:\n      file_tasks, args = line.split(\":\", 2)\n      return if args.nil?\n      dependents = args.split.map { |d| respace(d) }\n      file_tasks.scan(/\\S+/) do |file_task|\n        file_task = respace(file_task)\n        file file_task => dependents\n      end\n    end", "label": 4}
{"code": "function (parts) {\n        var result,\n            context = {\n                parts: parts,\n                startPos: 0\n            };\n        result = this._matchStart(context) || this._matchEnd(context);\n        return result !== _GPF_PATHMATCH_KO;\n    }", "label": 3}
{"code": "def execute(event)\n      old_chain = @chain\n      @bot.debug 'Executing bare chain'\n      result = execute_bare(event)\n\n      @chain_args ||= []\n\n      @bot.debug \"Found chain args #{@chain_args}, preliminary result #{result}\"\n\n      @chain_args.each do |arg|\n        case arg.first\n        when 'repeat'\n          new_result = ''\n          executed_chain = divide_chain(old_chain).last\n\n          arg[1].to_i.times do\n            chain_result = CommandChain.new(executed_chain, @bot).execute(event)\n            new_result += chain_result if chain_result\n          end\n\n          result = new_result\n          # TODO: more chain arguments\n        end\n      end\n\n      result\n    end", "label": 4}
{"code": "function generatePKP (privateKey, dicPopl, idProvoz, idPokl, poradCis, datTrzby, celkTrzba) {\n  const options = [dicPopl, idProvoz, idPokl, poradCis, datTrzby, celkTrzba]\n  const strToHash = options.join('|')\n  const sign = crypto.createSign('RSA-SHA256')\n  sign.write(strToHash)\n  sign.end()\n  return sign.sign(privateKey, 'base64')\n}", "label": 3}
{"code": "func (r *DrvRegistry) IPAM(name string) (ipamapi.Ipam, *ipamapi.Capability) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\ti, ok := r.ipamDrivers[name]\n\tif !ok {\n\t\treturn nil, nil\n\t}\n\n\treturn i.driver, i.capability\n}", "label": 5}
{"code": "function () {\n            var series = this,\n              seriesOptions = series.options,\n              chart = series.chart,\n              axisOptions;\n\n            each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis\n\n                each(chart[AXIS], function (axis) { // loop through the chart's axis objects\n                    axisOptions = axis.options;\n\n                    // apply if the series xAxis or yAxis option mathches the number of the\n                    // axis, or if undefined, use the first axis\n                    if ((seriesOptions[AXIS] === axisOptions.index) ||\n                      (seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||\n                      (seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {\n\n                        // register this series in the axis.series lookup\n                        axis.series.push(series);\n\n                        // set this series.xAxis or series.yAxis reference\n                        series[AXIS] = axis;\n\n                        // mark dirty for redraw\n                        axis.isDirty = true;\n                    }\n                });\n\n                // The series needs an X and an Y axis\n                if (!series[AXIS] && series.optionalAxis !== AXIS) {\n                    error(18, true);\n                }\n\n            });\n        }", "label": 3}
{"code": "protected static function tagsForListener($job)\n    {\n        return collect(\n            [static::extractListener($job), static::extractEvent($job),\n        ])->map(function ($job) {\n            return static::from($job);\n        })->collapse()->unique()->toArray();\n    }", "label": 2}
{"code": "function copySymbol(symbol, meaning) {\n                if (symbol.flags & meaning) {\n                    var id = symbol.name;\n                    // We will copy all symbol regardless of its reserved name because\n                    // symbolsToArray will check whether the key is a reserved name and\n                    // it will not copy symbol with reserved name to the array\n                    if (!symbols[id]) {\n                        symbols[id] = symbol;\n                    }\n                }\n            }", "label": 3}
{"code": "public static base_response add(nitro_service client, dnsaaaarec resource) throws Exception {\n\t\tdnsaaaarec addresource = new dnsaaaarec();\n\t\taddresource.hostname = resource.hostname;\n\t\taddresource.ipv6address = resource.ipv6address;\n\t\taddresource.ttl = resource.ttl;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def ancestors\n      node  = self\n      nodes = []\n      nodes << node = node.parent while node.parent\n      nodes\n    end", "label": 4}
{"code": "def port=(new_port)\n      if new_port != nil && new_port.respond_to?(:to_str)\n        new_port = Addressable::URI.unencode_component(new_port.to_str)\n      end\n\n      if new_port.respond_to?(:valid_encoding?) && !new_port.valid_encoding?\n        raise InvalidURIError, \"Invalid encoding in port\"\n      end\n\n      if new_port != nil && !(new_port.to_s =~ /^\\d+$/)\n        raise InvalidURIError,\n          \"Invalid port number: #{new_port.inspect}\"\n      end\n\n      @port = new_port.to_s.to_i\n      @port = nil if @port == 0\n\n      # Reset dependent values\n      remove_instance_variable(:@authority) if defined?(@authority)\n      remove_instance_variable(:@normalized_port) if defined?(@normalized_port)\n      remove_composite_values\n\n      # Ensure we haven't created an invalid URI\n      validate()\n    end", "label": 4}
{"code": "function fakeField(field) {\n  const def = _.get(field, 'is.def') || field.def;\n\n  if (!def)\n    throw new Error(\n      'No field.def property to fake on! ' + JSON.stringify(field)\n    );\n\n  switch (def.name) {\n    case 'integer':\n    case 'float':\n    case 'double':\n    case 'number':\n      return faker.random.number();\n\n    case 'email':\n      return faker.internet.email();\n\n    case 'url':\n      return faker.internet.url();\n\n    case 'date':\n      const date = faker.date.past();\n      date.setMilliseconds(0);\n      return date;\n\n    case 'image':\n      return faker.image.avatar();\n\n    case 'link':\n    case 'mongoid':\n      let i = 24,\n        s = '';\n      while (i--) s += faker.random.number(15).toString(16);\n      return ObjectId(s);\n\n    case 'boolean':\n      return faker.random.boolean();\n\n    case 'array':\n      return _.range(2).map(() => fakeField(field.of));\n\n    case 'object':\n      const key = def.name === 'link' ? 'link.def.fields' : 'fields';\n\n      return _.reduce(\n        _.get(field, key),\n        (out, value, key) => {\n          out[key] = fakeField(value);\n          return out;\n        },\n        {}\n      );\n\n    // default to string\n    default:\n      return faker.name.lastName();\n  }\n}", "label": 3}
{"code": "func (f *Fpdf) GetImageInfo(imageStr string) (info *ImageInfoType) {\n\treturn f.images[imageStr]\n}", "label": 5}
{"code": "public function setMasterConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dataproc\\V1\\InstanceGroupConfig::class);\n        $this->master_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "func (s *Server) StartTunnel() error {\n\ttunnel := &http.Server{\n\t\tAddr:    fmt.Sprintf(\"%s:%d\", s.URL.Hostname(), s.Tunnel),\n\t\tHandler: http.HandlerFunc(s.proxy),\n\t}\n\n\tl, err := net.Listen(\"tcp\", tunnel.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif s.Tunnel == 0 {\n\t\ts.Tunnel = l.Addr().(*net.TCPAddr).Port\n\t}\n\n\t// Set client proxy port (defaults to vCenter host port 80 in real life)\n\tq := s.URL.Query()\n\tq.Set(\"GOVMOMI_TUNNEL_PROXY_PORT\", strconv.Itoa(s.Tunnel))\n\ts.URL.RawQuery = q.Encode()\n\n\tgo tunnel.Serve(l)\n\n\treturn nil\n}", "label": 5}
{"code": "def masked_authenticity_token(session, form_options: {}) # :doc:\n        action, method = form_options.values_at(:action, :method)\n\n        raw_token = if per_form_csrf_tokens && action && method\n          action_path = normalize_action_path(action)\n          per_form_csrf_token(session, action_path, method)\n        else\n          real_csrf_token(session)\n        end\n\n        one_time_pad = SecureRandom.random_bytes(AUTHENTICITY_TOKEN_LENGTH)\n        encrypted_csrf_token = xor_byte_strings(one_time_pad, raw_token)\n        masked_token = one_time_pad + encrypted_csrf_token\n        Base64.strict_encode64(masked_token)\n      end", "label": 4}
{"code": "function(properties, startingValue, compareFunction)\n  {\n    var comparator = compareFunction || compare;\n    var resolver = createPropertyResolver( properties );\n    var min = startingValue;\n\n    for (var i = 0; i < this.length; i++)\n    {\n      var resolved = resolver( this[ i ] );\n\n      if ( comparator( min, resolved, false ) > 0 )\n      {\n        min = resolved;\n      }\n    }\n\n    return min;\n  }", "label": 3}
{"code": "func (m *MockIndex) ConcreteRet() chan<- bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ConcreteRet\")\n\tret0, _ := ret[0].(chan<- bool)\n\treturn ret0\n}", "label": 5}
{"code": "public function getValue( $key, $fallback = null ) {\n\t\treturn array_key_exists( $key, $this->state )\n\t\t\t? $this->state[ $key ]\n\t\t\t: $fallback;\n\t}", "label": 2}
{"code": "def matches_tag_set?(tag_set)\n      tag_set.keys.all? do |k|\n        tags[k] && tags[k] == tag_set[k]\n      end\n    end", "label": 4}
{"code": "public static double I0(double x) {\r\n        double ans;\r\n        double ax = Math.abs(x);\r\n\r\n        if (ax < 3.75) {\r\n            double y = x / 3.75;\r\n            y = y * y;\r\n            ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492\r\n                    + y * (0.2659732 + y * (0.360768e-1 + y * 0.45813e-2)))));\r\n        } else {\r\n            double y = 3.75 / ax;\r\n            ans = (Math.exp(ax) / Math.sqrt(ax)) * (0.39894228 + y * (0.1328592e-1\r\n                    + y * (0.225319e-2 + y * (-0.157565e-2 + y * (0.916281e-2\r\n                    + y * (-0.2057706e-1 + y * (0.2635537e-1 + y * (-0.1647633e-1\r\n                    + y * 0.392377e-2))))))));\r\n        }\r\n\r\n        return ans;\r\n    }", "label": 0}
{"code": "func niceNum(val float64, round bool) float64 {\n\tvar nf float64\n\n\texp := int(math.Floor(math.Log10(val)))\n\tf := val / math.Pow10(exp)\n\tif round {\n\t\tswitch {\n\t\tcase f < 1.5:\n\t\t\tnf = 1\n\t\tcase f < 3.0:\n\t\t\tnf = 2\n\t\tcase f < 7.0:\n\t\t\tnf = 5\n\t\tdefault:\n\t\t\tnf = 10\n\t\t}\n\t} else {\n\t\tswitch {\n\t\tcase f <= 1:\n\t\t\tnf = 1\n\t\tcase f <= 2.0:\n\t\t\tnf = 2\n\t\tcase f <= 5.0:\n\t\t\tnf = 5\n\t\tdefault:\n\t\t\tnf = 10\n\t\t}\n\t}\n\treturn nf * math.Pow10(exp)\n}", "label": 5}
{"code": "function _linkSocialAccount(){\n    return BB.bind(this)\n            .then(_loadUserFromToken)\n            .then(_getUserSocialDetails)\n            .then(_linkIdentity)\n            .catch(function(){\n\n                return _createSocialAccount.call(this); // Could not link account. Create one instead.\n            });\n}", "label": 3}
{"code": "def create_view(name, version: nil, sql_definition: nil, materialized: false)\n      if version.present? && sql_definition.present?\n        raise(\n          ArgumentError,\n          \"sql_definition and version cannot both be set\",\n        )\n      end\n\n      if version.blank? && sql_definition.blank?\n        version = 1\n      end\n\n      sql_definition ||= definition(name, version)\n\n      if materialized\n        Scenic.database.create_materialized_view(\n          name,\n          sql_definition,\n          no_data: no_data(materialized),\n        )\n      else\n        Scenic.database.create_view(name, sql_definition)\n      end\n    end", "label": 4}
{"code": "def page(opts = {})\n      class_name = opts.is_a?(Hash) ? opts.fetch(:class, nil) : opts\n      puts get_android_inspect class_name\n      nil\n    end", "label": 4}
{"code": "public static Class getClass(String className, boolean initialize) throws ClassNotFoundException\r\n    {\r\n        return Class.forName(className, initialize, getClassLoader());\r\n    }", "label": 0}
{"code": "function() {\n            var modules,\n                first = arguments[0],\n                arrayRequest = false;\n\n            if(system.isArray(first)){\n                modules = first;\n                arrayRequest = true;\n            }else{\n                modules = slice.call(arguments, 0);\n            }\n\n            return this.defer(function(dfd) {\n                require(modules, function() {\n                    var args = arguments;\n                    setTimeout(function() {\n                        if(args.length > 1 || arrayRequest){\n                            dfd.resolve(slice.call(args, 0));\n                        }else{\n                            dfd.resolve(args[0]);\n                        }\n                    }, 1);\n                }, function(err){\n                    dfd.reject(err);\n                });\n            }).promise();\n        }", "label": 3}
{"code": "public function setPermissionsAttribute(array $permissions = [])\n    {\n        foreach ($permissions as $key => $value) {\n            $permissions[$key] = (bool) $value;\n        }\n        $this->attributes['permissions'] = json_encode($permissions ?? []);\n    }", "label": 2}
{"code": "func MsQueryColumns(args *internal.ArgType, inspect []string) ([]*models.Column, error) {\n\tvar err error\n\n\t// process inspect -- cannot have 'order by' in a CREATE VIEW\n\tins := []string{}\n\tfor _, l := range inspect {\n\t\tif !strings.HasPrefix(strings.ToUpper(l), \"ORDER BY \") {\n\t\t\tins = append(ins, l)\n\t\t}\n\t}\n\n\t// create temporary view xoid\n\txoid := \"_xo_\" + internal.GenRandomID()\n\tviewq := `CREATE VIEW ` + xoid + ` AS ` + strings.Join(ins, \"\\n\")\n\tmodels.XOLog(viewq)\n\t_, err = args.DB.Exec(viewq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// load columns\n\tcols, err := models.MsTableColumns(args.DB, args.Schema, xoid)\n\n\t// drop inspect view\n\tdropq := `DROP VIEW ` + xoid\n\tmodels.XOLog(dropq)\n\t_, _ = args.DB.Exec(dropq)\n\n\t// load column information\n\treturn cols, err\n}", "label": 5}
{"code": "def horizontal_frame_padding\n      padding = fetch_config['padding']\n      if padding.kind_of?(String) && padding.split('x').length == 2\n        padding = padding.split('x')[0]\n        padding = padding.to_i unless padding.end_with?('%')\n      end\n      return scale_padding(padding)\n    end", "label": 4}
{"code": "func (self *Queue) Oldest() *QueueCursor {\n\tcursor := self.newCursor()\n\tcursor.init = func(buf *pktque.Buf, videoidx int) pktque.BufPos {\n\t\treturn buf.Head\n\t}\n\treturn cursor\n}", "label": 5}
{"code": "function getClientAliases(flapjack, options) {\n    options = options || {};\n    var aliases = getAliases('client', flapjack);\n    return _.extend({}, aliases, options.clientAliases);\n}", "label": 3}
{"code": "def needkwargs(*argnames):\n    \"\"\"Function decorator which checks that the decorated function is called\n    with a set of required kwargs.\n\n    Args:\n        *argnames: String keyword argument names.\n\n    Raises:\n        ValueError: If a required kwarg is missing in the decorated function\n            call.\n    \"\"\"\n    required = set(argnames)\n\n    def decorator(func):\n        def inner(*args, **kwargs):\n            missing = required - set(kwargs)\n            if missing:\n                err = \"%s kwargs are missing.\" % list(missing)\n                raise ValueError(err)\n            return func(*args, **kwargs)\n        return inner\n    return decorator", "label": 1}
{"code": "def pprint(sequence, keys=None):\n    \"\"\"\n    Print sequence as ascii table to stdout.\n\n    Args:\n        sequence (list or tuple): a sequence with a dictionary each entry.\n        keys (list): optional list of keys to order columns as well as to filter for them.\n    \"\"\"\n    if len(sequence) > 0:\n        columns = calculate_columns(sequence)\n        row_format = calculate_row_format(columns, keys)\n        header = row_format % dict([(key, key.title()) for key in columns])\n        separator = row_format % dict([(key, '-' * columns[key]) for key in columns])\n\n        print(separator)\n        print(header)\n        print(separator)\n\n        for row in sequence:\n            print(row_format % row)\n\n        print(separator)", "label": 1}
{"code": "def _qmed_from_descriptors_1999(self, as_rural=False):\n        \"\"\"\n        Return QMED estimation based on FEH catchment descriptors, 1999 methodology.\n\n        Methodology source: FEH, Vol. 3, p. 14\n\n        :param as_rural: assume catchment is fully rural. Default: false.\n        :type as_rural: bool\n        :return: QMED in m\u00b3/s\n        :rtype: float\n        \"\"\"\n        try:\n            qmed_rural = 1.172 * self.catchment.descriptors.dtm_area ** self._area_exponent() \\\n                         * (self.catchment.descriptors.saar / 1000.0) ** 1.560 \\\n                         * self.catchment.descriptors.farl ** 2.642 \\\n                         * (self.catchment.descriptors.sprhost / 100.0) ** 1.211 * \\\n                         0.0198 ** self._residual_soil()\n            if as_rural:\n                return qmed_rural\n            else:\n                return qmed_rural * self.urban_adj_factor()\n        except (TypeError, KeyError):\n            raise InsufficientDataError(\"Catchment `descriptors` attribute must be set first.\")", "label": 1}
{"code": "def lookup_class_properties(klass)\n      all_classes = []\n      while klass != Object\n        all_classes << klass\n        klass = klass.superclass\n      end\n      class_properties = {}\n      # Go back down class heirachry top to down\n      all_classes.reverse.each do |k|\n        class_properties.merge!(k.class_properties)\n      end\n      class_properties\n    end", "label": 4}
{"code": "function (context) {\n        var replacements;\n        if (context) {\n            replacements = {};\n            _gpfObjectForEach(context, function (value, key) {\n                replacements[\"{\" + key + \"}\"] = value.toString();\n            });\n            this.message = _gpfStringReplaceEx(this.message, replacements);\n        }\n    }", "label": 3}
{"code": "private function deleteSubfolder($path, $params)\n    {\n        // Use a key that adds a trailing slash if needed.\n        $prefix = rtrim($params['Key'], '/') . '/';\n        $result = $this->getClient()->listObjects([\n            'Bucket'  => $params['Bucket'],\n            'Prefix'  => $prefix,\n            'MaxKeys' => 1\n        ]);\n\n        // Check if the bucket contains keys other than the placeholder\n        if ($contents = $result['Contents']) {\n            return (count($contents) > 1 || $contents[0]['Key'] != $prefix)\n                ? $this->triggerError('Subfolder is not empty')\n                : $this->unlink(rtrim($path, '/') . '/');\n        }\n\n        return $result['CommonPrefixes']\n            ? $this->triggerError('Subfolder contains nested folders')\n            : true;\n    }", "label": 2}
{"code": "def get(self, request, *args, **kwargs):\n        \"\"\"\n        This method handles GET requests.\n\n        If a GET request reaches this point, the wizard assumes that the user\n        just starts at the first step or wants to restart the process.\n        The data of the wizard will be resetted before rendering the first step.\n        \"\"\"\n        self.storage.reset()\n\n        # reset the current step to the first step.\n        self.storage.current_step = self.steps.first\n        return self.render(self.get_form())", "label": 1}
{"code": "public function marshalValue($value)\n    {\n        $type = gettype($value);\n\n        // Handle string values.\n        if ($type === 'string') {\n            if ($value === '') {\n                return $this->handleInvalid('empty strings are invalid');\n            }\n\n            return ['S' => $value];\n        }\n\n        // Handle number values.\n        if ($type === 'integer'\n            || $type === 'double'\n            || $value instanceof NumberValue\n        ) {\n            return ['N' => (string) $value];\n        }\n\n        // Handle boolean values.\n        if ($type === 'boolean') {\n            return ['BOOL' => $value];\n        }\n\n        // Handle null values.\n        if ($type === 'NULL') {\n            return ['NULL' => true];\n        }\n\n        // Handle set values.\n        if ($value instanceof SetValue) {\n            if (count($value) === 0) {\n                return $this->handleInvalid('empty sets are invalid');\n            }\n            $previousType = null;\n            $data = [];\n            foreach ($value as $v) {\n                $marshaled = $this->marshalValue($v);\n                $setType = key($marshaled);\n                if (!$previousType) {\n                    $previousType = $setType;\n                } elseif ($setType !== $previousType) {\n                    return $this->handleInvalid('sets must be uniform in type');\n                }\n                $data[] = current($marshaled);\n            }\n\n            return [$previousType . 'S' => array_values(array_unique($data))];\n        }\n\n        // Handle list and map values.\n        $dbType = 'L';\n        if ($value instanceof \\stdClass) {\n            $type = 'array';\n            $dbType = 'M';\n        }\n        if ($type === 'array' || $value instanceof \\Traversable) {\n            $data = [];\n            $index = 0;\n            foreach ($value as $k => $v) {\n                if ($v = $this->marshalValue($v)) {\n                    $data[$k] = $v;\n                    if ($dbType === 'L' && (!is_int($k) || $k != $index++)) {\n                        $dbType = 'M';\n                    }\n                }\n            }\n            return [$dbType => $data];\n        }\n\n        // Handle binary values.\n        if (is_resource($value) || $value instanceof StreamInterface) {\n            $value = $this->binary($value);\n        }\n        if ($value instanceof BinaryValue) {\n            return ['B' => (string) $value];\n        }\n\n        // Handle invalid values.\n        return $this->handleInvalid('encountered unexpected value');\n    }", "label": 2}
{"code": "def min_order_amount(self) -> Money:\n        \"\"\"Minimum amount to place an order.\"\"\"\n        return self._fetch('minimum order amount', self.market.code)(self._min_order_amount)()", "label": 1}
{"code": "function (member) {\n            member = _gpfEncodeAttributeMember(member);\n            var result = this._members[member];\n            if (undefined === result || !(result instanceof _gpfA.Array)) {\n                return _gpfEmptyMemberArray;\n            }\n            return result;\n        }", "label": 3}
{"code": "def get_child_by_name(self, name):\n        \"\"\"\n        find the child object by name and return the object\n        \"\"\"\n        for c in self.child_nodes:\n            if c.name == name:\n                return c\n        return None", "label": 1}
{"code": "function removeFailedPredicate(predicates, items) {\n\treturn items.filter((_,i) => predicates[i]===true);\n}", "label": 3}
{"code": "def targets_relative_to_pwd(targets)\n      targets.map do |t|\n        if Pathname.new(t).absolute?\n          Pathname.new(t).relative_path_from(Pathname.pwd)\n        else\n          t\n        end\n      end\n    end", "label": 4}
{"code": "public List<DbComment> getComments(String entityId, String entityType) {\n        return repositoryHandler.getComments(entityId, entityType);\n    }", "label": 0}
{"code": "def save_data_file\n      File.open(file_path(Phonelib::Core::FILE_MAIN_DATA), 'wb+') do |f|\n        Marshal.dump(@data, f)\n      end\n    end", "label": 4}
{"code": "public List<Dependency> getModuleAncestors(final String moduleName, final String moduleVersion) throws GrapesCommunicationException {\n        final Client client = getClient();\n        final WebResource resource = client.resource(serverURL).path(RequestUtils.getArtifactAncestors(moduleName, moduleVersion));\n        final ClientResponse response = resource.queryParam(ServerAPI.SCOPE_COMPILE_PARAM, \"true\")\n                .queryParam(ServerAPI.SCOPE_PROVIDED_PARAM, \"true\")\n                .queryParam(ServerAPI.SCOPE_RUNTIME_PARAM, \"true\")\n                .queryParam(ServerAPI.SCOPE_TEST_PARAM, \"true\")\n                .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);\n\n        client.destroy();\n        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){\n            final String message = String.format(FAILED_TO_GET_MODULE, \"get module ancestors\", moduleName, moduleVersion);\n            if(LOG.isErrorEnabled()) {\n                LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, message, response.getStatus()));\n            }\n            throw new GrapesCommunicationException(message, response.getStatus());\n        }\n\n        return response.getEntity(new GenericType<List<Dependency>>(){});\n    }", "label": 0}
{"code": "def move(self):\n\t\t\"\"\"Swaps two nodes\"\"\"\n\t\ta = random.randint(0, len(self.state) - 1)\n\t\tb = random.randint(0, len(self.state) - 1)\n\t\tself.state[[a,b]] = self.state[[b,a]]", "label": 1}
{"code": "func (f *file) lintRanges() {\n\tf.walk(func(node ast.Node) bool {\n\t\trs, ok := node.(*ast.RangeStmt)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\n\t\tif isIdent(rs.Key, \"_\") && (rs.Value == nil || isIdent(rs.Value, \"_\")) {\n\t\t\tp := f.errorf(rs.Key, 1, category(\"range-loop\"), \"should omit values from range; this loop is equivalent to `for range ...`\")\n\n\t\t\tnewRS := *rs // shallow copy\n\t\t\tnewRS.Value = nil\n\t\t\tnewRS.Key = nil\n\t\t\tp.ReplacementLine = f.firstLineOf(&newRS, rs)\n\n\t\t\treturn true\n\t\t}\n\n\t\tif isIdent(rs.Value, \"_\") {\n\t\t\tp := f.errorf(rs.Value, 1, category(\"range-loop\"), \"should omit 2nd value from range; this loop is equivalent to `for %s %s range ...`\", f.render(rs.Key), rs.Tok)\n\n\t\t\tnewRS := *rs // shallow copy\n\t\t\tnewRS.Value = nil\n\t\t\tp.ReplacementLine = f.firstLineOf(&newRS, rs)\n\t\t}\n\n\t\treturn true\n\t})\n}", "label": 5}
{"code": "func getInfoFromTrueType(fileStr string, msgWriter io.Writer, embed bool, encList encListType) (info fontInfoType, err error) {\n\tvar ttf TtfType\n\tttf, err = TtfParse(fileStr)\n\tif err != nil {\n\t\treturn\n\t}\n\tif embed {\n\t\tif !ttf.Embeddable {\n\t\t\terr = fmt.Errorf(\"font license does not allow embedding\")\n\t\t\treturn\n\t\t}\n\t\tinfo.Data, err = ioutil.ReadFile(fileStr)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tinfo.OriginalSize = len(info.Data)\n\t}\n\tk := 1000.0 / float64(ttf.UnitsPerEm)\n\tinfo.FontName = ttf.PostScriptName\n\tinfo.Bold = ttf.Bold\n\tinfo.Desc.ItalicAngle = int(ttf.ItalicAngle)\n\tinfo.IsFixedPitch = ttf.IsFixedPitch\n\tinfo.Desc.Ascent = round(k * float64(ttf.TypoAscender))\n\tinfo.Desc.Descent = round(k * float64(ttf.TypoDescender))\n\tinfo.UnderlineThickness = round(k * float64(ttf.UnderlineThickness))\n\tinfo.UnderlinePosition = round(k * float64(ttf.UnderlinePosition))\n\tinfo.Desc.FontBBox = fontBoxType{\n\t\tround(k * float64(ttf.Xmin)),\n\t\tround(k * float64(ttf.Ymin)),\n\t\tround(k * float64(ttf.Xmax)),\n\t\tround(k * float64(ttf.Ymax)),\n\t}\n\t// printf(\"FontBBox\\n\")\n\t// dump(info.Desc.FontBBox)\n\tinfo.Desc.CapHeight = round(k * float64(ttf.CapHeight))\n\tinfo.Desc.MissingWidth = round(k * float64(ttf.Widths[0]))\n\tvar wd int\n\tfor j := 0; j < len(info.Widths); j++ {\n\t\twd = info.Desc.MissingWidth\n\t\tif encList[j].name != \".notdef\" {\n\t\t\tuv := encList[j].uv\n\t\t\tpos, ok := ttf.Chars[uint16(uv)]\n\t\t\tif ok {\n\t\t\t\twd = round(k * float64(ttf.Widths[pos]))\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(msgWriter, \"Character %s is missing\\n\", encList[j].name)\n\t\t\t}\n\t\t}\n\t\tinfo.Widths[j] = wd\n\t}\n\t// printf(\"getInfoFromTrueType/FontBBox\\n\")\n\t// dump(info.Desc.FontBBox)\n\treturn\n}", "label": 5}
{"code": "def get_cited_dois(file):\n    \"\"\"\n    Get the DOIs of the papers cited in a plaintext file. The file should \\\n            have one citation per line.\n\n    .. note::\n\n        This function is also used as a backend tool by most of the others \\\n        citations processors, to factorize the code.\n\n    :param file: Either the path to the plaintext file or the content of a \\\n            plaintext file. It can also be a parsed list of plaintext \\\n            citations and, in this case, no preprocessing is done.\n    :returns: A dict of cleaned plaintext citations and their associated DOI.\n    \"\"\"\n    # If file is not a pre-processed list of plaintext citations\n    if not isinstance(file, list):\n        # It is either a path to a plaintext file or the content of a plaintext\n        # file, we need some pre-processing to get a list of citations.\n        plaintext_citations = get_plaintext_citations(file)\n    else:\n        # Else, we passed a list of plaintext citations.\n        plaintext_citations = file\n    dois = {}\n    crossref_queue = []\n\n    # Try to get the DOI directly from the citation\n    for citation in plaintext_citations[:]:\n        # Some citations already contain a DOI so try to match it directly\n        matched_dois = doi.extract_from_text(citation)\n        if len(matched_dois) > 0:\n            # Add the DOI and go on\n            dois[citation] = next(iter(matched_dois))\n            continue\n        # Same thing for arXiv id\n        matched_arxiv = arxiv.extract_from_text(citation)\n        if len(matched_arxiv) > 0:\n            # Add the associated DOI and go on\n            dois[citation] = arxiv.to_doi(next(iter(matched_arxiv)))\n            continue\n        # If no match found, stack it for next step\n        # Note to remove URLs in the citation as the plaintext citations can\n        # contain URLs and they are bad for the CrossRef API.\n        crossref_queue.append(tools.remove_urls(citation))\n\n    # Do batch with remaining papers, to prevent from the timeout of CrossRef\n    for batch in tools.batch(crossref_queue, CROSSREF_MAX_BATCH_SIZE):\n        batch = [i for i in batch]\n        try:\n            # Fetch results from CrossRef\n            request = requests.post(CROSSREF_LINKS_API_URL, json=batch)\n            for result in request.json()[\"results\"]:\n                # Try to get a DOI\n                try:\n                    dois[result[\"text\"]] = result[\"doi\"]\n                except KeyError:\n                    # Or set it to None\n                    dois[result[\"text\"]] = None\n        except (RequestException, ValueError, KeyError):\n            # If an exception occurred, set all the DOIs to None for the\n            # current batch\n            for i in batch:\n                dois[i] = None\n    return dois", "label": 1}
{"code": "public static String get(MessageKey key) {\n        return data.getProperty(key.toString(), key.toString());\n    }", "label": 0}
{"code": "def _get_bus_array_construct(self):\n        \"\"\" Returns a construct for an array of bus data.\n        \"\"\"\n        bus_no = integer.setResultsName(\"bus_no\")\n        v_base = real.setResultsName(\"v_base\") # kV\n        v_magnitude = Optional(real).setResultsName(\"v_magnitude\")\n        v_angle = Optional(real).setResultsName(\"v_angle\") # radians\n        area = Optional(integer).setResultsName(\"area\") # not used yet\n        region = Optional(integer).setResultsName(\"region\") # not used yet\n\n        bus_data = bus_no + v_base + v_magnitude + v_angle + \\\n            area + region + scolon\n\n        bus_data.setParseAction(self.push_bus)\n\n        bus_array = Literal(\"Bus.con\") + \"=\" + \"[\" + \"...\" + \\\n            ZeroOrMore(bus_data + Optional(\"]\" + scolon))\n\n        # Sort buses according to their name (bus_no)\n        bus_array.setParseAction(self.sort_buses)\n\n        return bus_array", "label": 1}
{"code": "func NewWithConfig(ctx context.Context, cfg Config) (*LiteBackend, error) {\n\tif err := cfg.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvar connectorURL string\n\tif !cfg.Memory {\n\t\t// Ensure that the path to the root directory exists.\n\t\terr := os.MkdirAll(cfg.Path, defaultDirMode)\n\t\tif err != nil {\n\t\t\treturn nil, trace.ConvertSystemError(err)\n\t\t}\n\t\tfullPath := filepath.Join(cfg.Path, defaultDBFile)\n\t\tconnectorURL = fmt.Sprintf(\"file:%v?_busy_timeout=%v&_sync=%v\", fullPath, cfg.BusyTimeout, cfg.Sync)\n\t} else {\n\t\tconnectorURL = fmt.Sprintf(\"file:%v?mode=memory\", cfg.MemoryName)\n\t}\n\tdb, err := sql.Open(BackendName, connectorURL)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err, \"error opening URI: %v\", connectorURL)\n\t}\n\t// serialize access to sqlite to avoid database is locked errors\n\tdb.SetMaxOpenConns(1)\n\tbuf, err := backend.NewCircularBuffer(ctx, cfg.BufferSize)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tcloseCtx, cancel := context.WithCancel(ctx)\n\twatchStarted, signalWatchStart := context.WithCancel(ctx)\n\tl := &LiteBackend{\n\t\tConfig:           cfg,\n\t\tdb:               db,\n\t\tEntry:            log.WithFields(log.Fields{trace.Component: BackendName}),\n\t\tclock:            cfg.Clock,\n\t\tbuf:              buf,\n\t\tctx:              closeCtx,\n\t\tcancel:           cancel,\n\t\twatchStarted:     watchStarted,\n\t\tsignalWatchStart: signalWatchStart,\n\t}\n\tl.Debugf(\"Connected to: %v, poll stream period: %v\", connectorURL, cfg.PollStreamPeriod)\n\tif err := l.createSchema(); err != nil {\n\t\treturn nil, trace.Wrap(err, \"error creating schema: %v\", connectorURL)\n\t}\n\tif err := l.showPragmas(); err != nil {\n\t\tl.Warningf(\"Failed to show pragma settings: %v.\", err)\n\t}\n\tgo l.runPeriodicOperations()\n\treturn l, nil\n}", "label": 5}
{"code": "def _init_contoh(self, makna_label):\n        \"\"\"Memproses contoh yang ada dalam makna.\n\n        :param makna_label: BeautifulSoup untuk makna yang ingin diproses.\n        :type makna_label: BeautifulSoup\n        \"\"\"\n\n        indeks = makna_label.text.find(': ')\n        if indeks != -1:\n            contoh = makna_label.text[indeks + 2:].strip()\n            self.contoh = contoh.split('; ')\n        else:\n            self.contoh = []", "label": 1}
{"code": "private void addIncludes(DBHandling handling, FileSet fileSet) throws BuildException\r\n    {\r\n        DirectoryScanner scanner  = fileSet.getDirectoryScanner(getProject());\r\n        String[]         files    = scanner.getIncludedFiles();\r\n        StringBuffer     includes = new StringBuffer();\r\n\r\n        for (int idx = 0; idx < files.length; idx++)\r\n        {\r\n            if (idx > 0)\r\n            {\r\n                includes.append(\",\");\r\n            }\r\n            includes.append(files[idx]);\r\n        }\r\n        try\r\n        {\r\n            handling.addDBDefinitionFiles(fileSet.getDir(getProject()).getAbsolutePath(), includes.toString());\r\n        }\r\n        catch (IOException ex)\r\n        {\r\n            throw new BuildException(ex);\r\n        }\r\n    }", "label": 0}
{"code": "public void add(K key, V value) {\r\n    if (treatCollectionsAsImmutable) {\r\n      Collection<V> newC = cf.newCollection();\r\n      Collection<V> c = map.get(key);\r\n      if (c != null) {\r\n        newC.addAll(c);\r\n      }\r\n      newC.add(value);\r\n      map.put(key, newC); // replacing the old collection\r\n    } else {\r\n      Collection<V> c = map.get(key);\r\n      if (c == null) {\r\n        c = cf.newCollection();\r\n        map.put(key, c);\r\n      }\r\n      c.add(value); // modifying the old collection\r\n    }\r\n  }", "label": 0}
{"code": "func (h *portForwardProxy) removeStreamPair(requestID string) {\n\th.streamPairsLock.Lock()\n\tdefer h.streamPairsLock.Unlock()\n\n\tdelete(h.streamPairs, requestID)\n}", "label": 5}
{"code": "func (h *AuthHandlers) CreateIdentityContext(sconn *ssh.ServerConn) (IdentityContext, error) {\n\tidentity := IdentityContext{\n\t\tTeleportUser: sconn.Permissions.Extensions[utils.CertTeleportUser],\n\t\tCertificate:  []byte(sconn.Permissions.Extensions[utils.CertTeleportUserCertificate]),\n\t\tLogin:        sconn.User(),\n\t}\n\n\tclusterName, err := h.AccessPoint.GetClusterName()\n\tif err != nil {\n\t\treturn IdentityContext{}, trace.Wrap(err)\n\t}\n\n\tcertificate, err := identity.GetCertificate()\n\tif err != nil {\n\t\treturn IdentityContext{}, trace.Wrap(err)\n\t}\n\tif certificate.ValidBefore != 0 {\n\t\tidentity.CertValidBefore = time.Unix(int64(certificate.ValidBefore), 0)\n\t}\n\n\tcertAuthority, err := h.authorityForCert(services.UserCA, certificate.SignatureKey)\n\tif err != nil {\n\t\treturn IdentityContext{}, trace.Wrap(err)\n\t}\n\tidentity.CertAuthority = certAuthority\n\n\troleSet, err := h.fetchRoleSet(certificate, certAuthority, identity.TeleportUser, clusterName.GetClusterName())\n\tif err != nil {\n\t\treturn IdentityContext{}, trace.Wrap(err)\n\t}\n\tidentity.RoleSet = roleSet\n\n\treturn identity, nil\n}", "label": 5}
{"code": "function(file, options, callback) {\n        fs.readFile(file, options, function(err, data) {\n            if (err) {\n                return callback(err);\n            }\n            module.exports.parse(data.toString(), function(parseErr, lines) {\n                if (parseErr) {\n                    return callback(parseErr);\n                }\n                callback(undefined, lines);\n            });\n        });\n    }", "label": 3}
{"code": "public function rsyncValidate(CommandData $commandData) {\n    if (preg_match(\"/^@prod/\", $commandData->input()->getArgument('target'))) {\n      throw new \\Exception(dt('Per !file, you may never rsync to the production site.', ['!file' => __FILE__]));\n    }\n  }", "label": 2}
{"code": "def read_json_escape_char\n      str = @reader.read\n      str += @reader.read\n      str += @reader.read\n      str += @reader.read\n      if RUBY_VERSION >= '1.9'\n        str.hex.chr(Encoding::UTF_8)\n      else\n        str.hex.chr\n      end\n    end", "label": 4}
{"code": "public function encodeValue($value)\n    {\n        $type = gettype($value);\n\n        switch ($type) {\n            case 'boolean':\n                return ['booleanValue' => $value];\n                break;\n\n            case 'integer':\n                return ['integerValue' => $value];\n                break;\n\n            case 'double':\n                return ['doubleValue' => $value];\n                break;\n\n            case 'string':\n                return ['stringValue' => $value];\n                break;\n\n            case 'resource':\n                return ['bytesValue' => stream_get_contents($value)];\n                break;\n\n            case 'object':\n                return $this->encodeObjectValue($value);\n                break;\n\n            case 'array':\n                if (!empty($value) && $this->isAssoc($value)) {\n                    return $this->encodeAssociativeArrayValue($value);\n                }\n\n                return ['arrayValue' => $this->encodeArrayValue($value)];\n                break;\n\n            case 'NULL':\n                // @todo encode this in a way such that is compatible with a potential future REST transport.\n                return ['nullValue' => NullValue::NULL_VALUE];\n                break;\n\n            // @codeCoverageIgnoreStart\n            default:\n                throw new \\RuntimeException(sprintf(\n                    'Invalid value type %s',\n                    $type\n                ));\n                break;\n            // @codeCoverageIgnoreEnd\n        }\n    }", "label": 2}
{"code": "func (m *MockIndex) GetTwo(arg0, arg1 string) (interface{}, interface{}) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetTwo\", arg0, arg1)\n\tret0, _ := ret[0].(interface{})\n\tret1, _ := ret[1].(interface{})\n\treturn ret0, ret1\n}", "label": 5}
{"code": "def zipfiles(self, path=None, arcdirname='data'):\n        \"\"\"Returns a .zip archive of selected rasters.\"\"\"\n        if path:\n            fp = open(path, 'w+b')\n        else:\n            prefix = '%s-' % arcdirname\n            fp = tempfile.NamedTemporaryFile(prefix=prefix, suffix='.zip')\n        with zipfile.ZipFile(fp, mode='w') as zf:\n            for obj in self:\n                img = obj.image\n                arcname = os.path.join(arcdirname, os.path.basename(img.name))\n                try:\n                    zf.write(img.path, arcname=arcname)\n                except OSError:\n                    img.seek(0)\n                    zf.writestr(arcname, img.read())\n                    img.close()\n        fp.seek(0)\n        zobj = self.model(image=fp)\n        return [zobj]", "label": 1}
{"code": "def read_attribute(name)\n      field = fields[name.to_s]\n      raw = read_raw_attribute(name)\n      field ? field.demongoize(raw) : raw\n    end", "label": 4}
{"code": "func bufferFromReader(r io.Reader) (b *bytes.Buffer, err error) {\n\tb = new(bytes.Buffer)\n\t_, err = b.ReadFrom(r)\n\treturn\n}", "label": 5}
{"code": "function CDNUp(bucket, options) {\n  options = options || {};\n\n  this.sharding = !!options.sharding;\n  this.urls = arrayify(options.url || options.urls);\n  this.mime = options.mime || {};\n  this.check = options.check;\n  this.bucket = bucket;\n  this.client = pkgcloud.storage.createClient(options.pkgcloud || {});\n  this.acl = options.acl;\n  this.subdomain = options.subdomain;\n}", "label": 3}
{"code": "def restore(self):\n        \"\"\"\n        This method constructs the restoring beam and then adds the convolution to the residual.\n        \"\"\"\n        clean_beam, beam_params = beam_fit(self.psf_data, self.cdelt1, self.cdelt2)\n\n        if np.all(np.array(self.psf_data_shape)==2*np.array(self.dirty_data_shape)):\n            self.restored = np.fft.fftshift(np.fft.irfft2(np.fft.rfft2(conv.pad_array(self.model))*np.fft.rfft2(clean_beam)))\n            self.restored = self.restored[self.dirty_data_shape[0]/2:-self.dirty_data_shape[0]/2,\n                            self.dirty_data_shape[1]/2:-self.dirty_data_shape[1]/2]\n        else:\n            self.restored = np.fft.fftshift(np.fft.irfft2(np.fft.rfft2(self.model)*np.fft.rfft2(clean_beam)))\n        self.restored += self.residual\n        self.restored = self.restored.astype(np.float32)\n\n        return beam_params", "label": 1}
{"code": "def create_branch(name, sha_or_ref = \"HEAD\")\n      case sha_or_ref\n      when Rugged::Object\n        target = sha_or_ref.oid\n      else\n        target = rev_parse_oid(sha_or_ref)\n      end\n\n      branches.create(name, target)\n    end", "label": 4}
{"code": "func apiVersionValid(c *vim25.Client, minVersionString string) error {\n\tif minVersionString == \"-\" {\n\t\t// Disable version check\n\t\treturn nil\n\t}\n\n\tapiVersion := c.ServiceContent.About.ApiVersion\n\tif isDevelopmentVersion(apiVersion) {\n\t\treturn nil\n\t}\n\n\trealVersion, err := ParseVersion(apiVersion)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing API version %q: %s\", apiVersion, err)\n\t}\n\n\tminVersion, err := ParseVersion(minVersionString)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error parsing %s=%q: %s\", envMinAPIVersion, minVersionString, err)\n\t}\n\n\tif !minVersion.Lte(realVersion) {\n\t\terr = fmt.Errorf(\"require API version %q, connected to API version %q (set %s to override)\",\n\t\t\tminVersionString,\n\t\t\tc.ServiceContent.About.ApiVersion,\n\t\t\tenvMinAPIVersion)\n\t\treturn err\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "func (c *CertChecker) CheckHostKey(addr string, remote net.Addr, key ssh.PublicKey) error {\n\terr := validate(key)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\n\treturn c.CertChecker.CheckHostKey(addr, remote, key)\n}", "label": 5}
{"code": "def _delete_action(self, payload):\n        \"\"\"Bulk delete action.\n\n        :param payload: Decoded message body.\n        :returns: Dictionary defining an Elasticsearch bulk 'delete' action.\n        \"\"\"\n        index, doc_type = payload.get('index'), payload.get('doc_type')\n        if not (index and doc_type):\n            record = Record.get_record(payload['id'])\n            index, doc_type = self.record_to_index(record)\n\n        return {\n            '_op_type': 'delete',\n            '_index': index,\n            '_type': doc_type,\n            '_id': payload['id'],\n        }", "label": 1}
{"code": "function loadPdfTemplate(params, cb) {\n  logger.debug(\"renderPDF loadPdfTemplate\", params);\n\n  //Already have a compiled template, no need to compile it again.\n  if (pdfTemplate) {\n    return cb(null, pdfTemplate);\n  } else {\n    readAndCompileTemplate(function(err, compiledTemplate) {\n      pdfTemplate = compiledTemplate;\n      return cb(err, pdfTemplate);\n    });\n  }\n}", "label": 3}
{"code": "def agg_dims(arr, stat):\n    \"\"\"Returns a 1D array with higher dimensions aggregated using stat fn.\n\n    Arguments:\n    arr -- ndarray\n    stat -- numpy or numpy.ma function as str to call\n    \"\"\"\n    axis = None\n    if arr.ndim > 2:\n        axis = 1\n        arr = arr.reshape(arr.shape[0], -1)\n    module = np.ma if hasattr(arr, 'mask') else np\n    return getattr(module, stat)(arr, axis)", "label": 1}
{"code": "public double get(int index) {\r\n\t// overridden for performance only.\r\n\tif (index >= size || index < 0)\r\n\t\tthrow new IndexOutOfBoundsException(\"Index: \"+index+\", Size: \"+size);\r\n\treturn elements[index];\r\n}", "label": 0}
{"code": "public Response deleteTemplate(String id)\n            throws RequestException, LocalOperationException {\n        Request request = new Request(this);\n        return new Response(request.delete(\"/templates/\" + id, new HashMap<String, Object>()));\n    }", "label": 0}
{"code": "func (f *DatastoreFile) Stat() (os.FileInfo, error) {\n\t// TODO: consider using Datastore.Stat() instead\n\tu, p, err := f.d.downloadTicket(f.ctx, f.name, &soap.Download{Method: \"HEAD\"})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres, err := f.d.Client().DownloadRequest(f.ctx, u, p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, statusError(res)\n\t}\n\n\tf.length = res.ContentLength\n\n\treturn &fileStat{f, res.Header}, nil\n}", "label": 5}
{"code": "def maybe_make_path_relative_to_app_root(app_root, abs_path)\n      if Dir.logical_pwd == app_root && File.dirname(abs_path) == app_root\n        File.basename(abs_path)\n      else\n        abs_path\n      end\n    end", "label": 4}
{"code": "function () {\n    var filter = this.collection.parent.filter;\n    if (!filter || !this.isFilled) {\n      return false;\n    }\n\n    filter.releaseDataFilter();\n    if (this.type === 'partition') {\n      var partition = filter.partitions.get(this.rank, 'rank');\n      filter.partitions.remove(partition);\n    } else if (this.type === 'aggregate') {\n      var aggregate = filter.aggregates.get(this.rank, 'rank');\n      filter.aggregates.remove(aggregate);\n    }\n    this.isFilled = false;\n    return true;\n  }", "label": 3}
{"code": "function(e){\n            // TAB - switch to another input\n            if(e.which == 9){\n              $newSelect.trigger('close');\n              return;\n            }\n\n            // ARROW DOWN WHEN SELECT IS CLOSED - open select options\n            if(e.which == 40 && !options.is(':visible')){\n              $newSelect.trigger('open');\n              return;\n            }\n\n            // ENTER WHEN SELECT IS CLOSED - submit form\n            if(e.which == 13 && !options.is(':visible')){\n              return;\n            }\n\n            e.preventDefault();\n\n            // CASE WHEN USER TYPE LETTERS\n            var letter = String.fromCharCode(e.which).toLowerCase(),\n                nonLetters = [9,13,27,38,40];\n            if (letter && (nonLetters.indexOf(e.which) === -1)) {\n              filterQuery.push(letter);\n\n              var string = filterQuery.join(''),\n                  newOption = options.find('li').filter(function() {\n                    return $(this).text().toLowerCase().indexOf(string) === 0;\n                  })[0];\n\n              if (newOption) {\n                activateOption(options, newOption);\n              }\n            }\n\n            // ENTER - select option and close when select options are opened\n            if (e.which == 13) {\n              var activeOption = options.find('li.selected:not(.disabled)')[0];\n              if(activeOption){\n                $(activeOption).trigger('click');\n                if (!multiple) {\n                  $newSelect.trigger('close');\n                }\n              }\n            }\n\n            // ARROW DOWN - move to next not disabled option\n            if (e.which == 40) {\n              if (options.find('li.selected').length) {\n                newOption = options.find('li.selected').next('li:not(.disabled)')[0];\n              } else {\n                newOption = options.find('li:not(.disabled)')[0];\n              }\n              activateOption(options, newOption);\n            }\n\n            // ESC - close options\n            if (e.which == 27) {\n              $newSelect.trigger('close');\n            }\n\n            // ARROW UP - move to previous not disabled option\n            if (e.which == 38) {\n              newOption = options.find('li.selected').prev('li:not(.disabled)')[0];\n              if(newOption)\n                activateOption(options, newOption);\n            }\n\n            // Automaticaly clean filter query so user can search again by starting letters\n            setTimeout(function(){ filterQuery = []; }, 1000);\n          }", "label": 3}
{"code": "func GetChain(id string) *Chain {\n\tfor _, c := range chains {\n\t\tif c.Name == id {\n\t\t\treturn &c\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "function Intercom(appId, apiKey, options) {\n  // Overload the contractor\n  // Parse out single option objects\n  if (_.isObject(appId) && !_.isString(appId) && ((appId.apiKey && appId.appId) || appId.personalAccessToken)) {\n    apiKey = appId.apiKey || '';\n    options = _.omit(appId, 'apiKey', 'appId');\n    appId = appId.appId || appId.personalAccessToken;\n  }\n\n  // Preform some sane validation checks and throw errors\n  // We need the appId\n  if (!appId) {\n    throw new IntercomError('Invalid App ID: ' + appId);\n  }\n\n  // Copy over the relavant data\n  this.appId = appId;\n  this.apiKey = apiKey || '';\n\n  // Extend the defaults\n  this.options = _.defaults(options || {}, Intercom.defaultOptions);\n\n  // Contruct the endpoint with the correct auth from the appId and apiKey\n  this.endpoint = this.options.endpoint;\n}", "label": 3}
{"code": "public String login(String token, Authentication authentication) {\n\t\tif (null == token) {\n\t\t\treturn login(authentication);\n\t\t}\n\t\ttokens.put(token, new TokenContainer(authentication));\n\t\treturn token;\n\t}", "label": 0}
{"code": "public function load(array $args)\n    {\n        $result = $this->client->getObject([\n            'Bucket' => $args['Bucket'],\n            'Key' => $args['Key'] . $this->suffix\n        ]);\n\n        $metadataHeaders = json_decode($result['Body'], true);\n        $envelope = new MetadataEnvelope();\n        $constantValues = MetadataEnvelope::getConstantValues();\n\n        foreach ($constantValues as $constant) {\n            if (!empty($metadataHeaders[$constant])) {\n                $envelope[$constant] = $metadataHeaders[$constant];\n            }\n        }\n\n        return $envelope;\n    }", "label": 2}
{"code": "def _advance_pattern_generators(self,p):\n        \"\"\"\n        Advance the parameters for each generator for this\n        presentation.\n\n        Picks a position for each generator that is accepted by\n        __distance_valid for all combinations.  Returns a new list of\n        the generators, with some potentially omitted due to failure\n        to meet the constraints.\n        \"\"\"\n\n        valid_generators = []\n        for g in p.generators:\n\n            for trial in range(self.max_trials):\n                # Generate a new position and add generator if it's ok\n\n                if np.alltrue([self.__distance_valid(g,v,p) for v in valid_generators]):\n                    valid_generators.append(g)\n                    break\n\n                g.force_new_dynamic_value('x')\n                g.force_new_dynamic_value('y')\n\n            else:\n                self.warning(\"Unable to place pattern %s subject to given constraints\" %\n                             g.name)\n\n        return valid_generators", "label": 1}
{"code": "function (count, total, rounded) {\n        var scale;\n        if (rounded) {\n            scale = this._0digitsScale;\n        } else {\n            scale = this._2digitsScale;\n        }\n        return Math.floor(this._percentage * scale * count / total) / scale;\n    }", "label": 3}
{"code": "public void setAttribute(String strKey, Object value)\r\n    {\r\n        this.propertyChangeDelegate.firePropertyChange(strKey,\r\n            hmAttributes.put(strKey, value), value);\r\n    }", "label": 0}
{"code": "private String long2string(Long value, DateTimeFormat fmt) {\n        // for html5 inputs, use \"\" for no value\n        if (value == null) return \"\";\n        Date date = UTCDateBox.utc2date(value);\n        return date != null ? fmt.format(date) : null;\n    }", "label": 0}
{"code": "function process(data) {\n  var result = '';\n  for(var cChar = 0; cChar < data.length; cChar += 2) {\n    result += String.fromCharCode(parseInt(data.substr(cChar,2),16));\n  }\n  return result;\n}", "label": 3}
{"code": "public function setEvaluatedExpressions($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Debugger\\V2\\Variable::class);\n        $this->evaluated_expressions = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public function dir_readdir()\n    {\n        $object = $this->directoryIterator->current();\n        if ($object) {\n            $this->directoryIterator->next();\n            return $object->name();\n        }\n\n        return false;\n    }", "label": 2}
{"code": "public static ResourceBundle getCurrentResourceBundle(String locale) {\n\t\ttry {\n\t\t\tif (null != locale && !locale.isEmpty()) {\n\t\t\t\treturn getCurrentResourceBundle(LocaleUtils.toLocale(locale));\n\t\t\t}\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\t// do nothing\n\t\t}\n\t\treturn getCurrentResourceBundle((Locale) null);\n\t}", "label": 0}
{"code": "function(obj) {\n            if (!obj) {\n                return null;\n            }\n\n            if (typeof obj == 'function') {\n                return obj.prototype.__moduleId__;\n            }\n\n            if (typeof obj == 'string') {\n                return null;\n            }\n\n            return obj.__moduleId__;\n        }", "label": 3}
{"code": "@Override\r\n  public void randomize(int randomSeed) {\r\n    Random rand = new Random(randomSeed);\r\n    for(int j = size - 1; j > 0; j --){\r\n      int randIndex = rand.nextInt(j);\r\n      \r\n      int [] tmp = data[randIndex];\r\n      data[randIndex] = data[j];\r\n      data[j] = tmp;\r\n      \r\n      int tmpl = labels[randIndex];\r\n      labels[randIndex] = labels[j];\r\n      labels[j] = tmpl;\r\n      \r\n      float tmpw = weights[randIndex];\r\n      weights[randIndex] = weights[j];\r\n      weights[j] = tmpw;\r\n    }\r\n  }", "label": 0}
{"code": "func (c *Call) MaxTimes(n int) *Call {\n\tc.maxCalls = n\n\tif c.minCalls == 1 {\n\t\tc.minCalls = 0\n\t}\n\treturn c\n}", "label": 5}
{"code": "public static String objectToColumnString(Object object, String delimiter, String[] fieldNames)\r\n          throws IllegalAccessException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException\r\n  {\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < fieldNames.length; i++) {\r\n      if (sb.length() > 0) {\r\n        sb.append(delimiter);\r\n      }\r\n      try {\r\n        Field field = object.getClass().getDeclaredField(fieldNames[i]);\r\n        sb.append(field.get(object)) ;\r\n      } catch (IllegalAccessException ex) {\r\n        Method method = object.getClass().getDeclaredMethod(\"get\" + StringUtils.capitalize(fieldNames[i]));\r\n        sb.append(method.invoke(object));\r\n      }\r\n    }\r\n    return sb.toString();\r\n  }", "label": 0}
{"code": "def validates_with(*args, &block)\n      options = args.extract_options!\n      options[:class] = self.class\n\n      args.each do |klass|\n        validator = klass.new(options, &block)\n        validator.validate(self)\n      end\n    end", "label": 4}
{"code": "def find(*args)\n      id = args.first\n      return super if args.count != 1 || id.unfriendly_id?\n      first_by_friendly_id(id).tap {|result| return result unless result.nil?}\n      return super if potential_primary_key?(id)\n      raise_not_found_exception id\n      \n    end", "label": 4}
{"code": "def _handle_mac(self, keycode):\r\n        \"\"\"Mac key event handler\"\"\"\r\n        key = self._keyname(unichr(keycode))\r\n        self._output(type=\"keys\", key=key, realkey=key)", "label": 1}
{"code": "public void deleteArtifact(final String gavc, final String user, final String password) throws GrapesCommunicationException, AuthenticationException{\n        final Client client = getClient(user, password);\n        final WebResource resource = client.resource(serverURL).path(RequestUtils.getArtifactPath(gavc));\n        final ClientResponse response = resource.delete(ClientResponse.class);\n\n        client.destroy();\n        if(ClientResponse.Status.OK.getStatusCode() != response.getStatus()){\n            final String message = \"Failed to DELETE artifact \" + gavc;\n            if(LOG.isErrorEnabled()) {\n                LOG.error(String.format(HTTP_STATUS_TEMPLATE_MSG, message, response.getStatus()));\n            }\n            throw new GrapesCommunicationException(message, response.getStatus());\n        }\n    }", "label": 0}
{"code": "public static double J0(double x) {\r\n        double ax;\r\n\r\n        if ((ax = Math.abs(x)) < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\r\n                    + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\r\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\r\n                    + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\r\n\r\n            return ans1 / ans2;\r\n        } else {\r\n            double z = 8.0 / ax;\r\n            double y = z * z;\r\n            double xx = ax - 0.785398164;\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    - y * 0.934935152e-7)));\r\n\r\n            return Math.sqrt(0.636619772 / ax) *\r\n                    (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\r\n        }\r\n    }", "label": 0}
{"code": "def compare(ctx, commands):\n    \"\"\" Run 'show | compare' for set commands.\n\n    @param ctx: The click context paramter, for receiving the object dictionary\n              | being manipulated by other previous functions. Needed by any\n              | function with the @click.pass_context decorator.\n    @type ctx: click.Context\n    @param commands: The Junos set commands that will be put into a candidate\n                   | configuration and used to create the 'show | compare'\n                   | against the running configuration. much like the commands\n                   | parameter for the commit() function, this can be one of\n                   | three things: a string containing a single command, a\n                   | string containing a comma separated list of commands, or\n                   | a string containing a filepath location for a file with\n                   | commands on each line.\n    @type commands: str\n\n    @returns: None. Functions part of click relating to the command group\n            | 'main' do not return anything. Click handles passing context\n            | between the functions and maintaing command order and chaining.\n    \"\"\"\n    mp_pool = multiprocessing.Pool(multiprocessing.cpu_count() * 2)\n    for ip in ctx.obj['hosts']:\n        mp_pool.apply_async(wrap.open_connection, args=(ip,\n                            ctx.obj['conn']['username'],\n                            ctx.obj['conn']['password'],\n                            wrap.compare, [commands],\n                            ctx.obj['out'],\n                            ctx.obj['conn']['connect_timeout'],\n                            ctx.obj['conn']['session_timeout'],\n                            ctx.obj['conn']['port']), callback=write_out)\n    mp_pool.close()\n    mp_pool.join()", "label": 1}
{"code": "def makedir(dir_name):\n    \"\"\"\n     \"Strong\" directory maker.\n\n    \"Strong\" version of `os.mkdir`.  If `dir_name` already exists, this deletes \n    it first.\n\n    **Parameters**\n\n        **dir_name** :  string\n\n            Path to a file directory that may or may not already exist.\n\n    **See Also:**\n\n        :func:`tabular.io.delete`, \n        `os <http://docs.python.org/library/os.html>`_\n\n    \"\"\"\n    if os.path.exists(dir_name):\n        delete(dir_name)\n    os.mkdir(dir_name)", "label": 1}
{"code": "func ConvertPortBindings(portBindings []types.PortBinding) ([]json.RawMessage, error) {\n\tvar pbs []json.RawMessage\n\n\t// Enumerate through the port bindings specified by the user and convert\n\t// them into the internal structure matching the JSON blob that can be\n\t// understood by the HCS.\n\tfor _, elem := range portBindings {\n\t\tproto := strings.ToUpper(elem.Proto.String())\n\t\tif proto != \"TCP\" && proto != \"UDP\" {\n\t\t\treturn nil, fmt.Errorf(\"invalid protocol %s\", elem.Proto.String())\n\t\t}\n\n\t\tif elem.HostPort != elem.HostPortEnd {\n\t\t\treturn nil, fmt.Errorf(\"Windows does not support more than one host port in NAT settings\")\n\t\t}\n\n\t\tif len(elem.HostIP) != 0 {\n\t\t\treturn nil, fmt.Errorf(\"Windows does not support host IP addresses in NAT settings\")\n\t\t}\n\n\t\tencodedPolicy, err := json.Marshal(hcsshim.NatPolicy{\n\t\t\tType:         \"NAT\",\n\t\t\tExternalPort: elem.HostPort,\n\t\t\tInternalPort: elem.Port,\n\t\t\tProtocol:     elem.Proto.String(),\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpbs = append(pbs, encodedPolicy)\n\t}\n\treturn pbs, nil\n}", "label": 5}
{"code": "def content_type(type = nil, params={})\n      return response['Content-Type'] unless type\n      default = params.delete :default\n      mime_type = mime_type(type) || default\n      fail \"Unknown media type: %p\" % type if mime_type.nil?\n      mime_type = mime_type.dup\n      unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type }\n        params[:charset] = params.delete('charset') || settings.default_encoding\n      end\n      params.delete :charset if mime_type.include? 'charset'\n      unless params.empty?\n        mime_type << (mime_type.include?(';') ? ', ' : ';')\n        mime_type << params.map { |kv| kv.join('=') }.join(', ')\n      end\n      response['Content-Type'] = mime_type\n    end", "label": 4}
{"code": "func NewEventMouse(x, y int, btn ButtonMask, mod ModMask) *EventMouse {\n\treturn &EventMouse{t: time.Now(), x: x, y: y, btn: btn, mod: mod}\n}", "label": 5}
{"code": "def _find_matcher(self, alias):\n        \"\"\" Finds a matcher based on the given alias or raises an error if no\n            matcher could be found.\n        \"\"\"\n        matcher = lookup(alias)\n        if not matcher:\n            msg = 'Matcher \"%s\" not found' % alias\n\n            # Try to find similarly named matchers to help the user\n            similar = suggest(alias, max=3, cutoff=0.5)\n            if len(similar) > 1:\n                last = similar.pop()\n                msg += '. Perhaps you meant to use %s or %s?' % (', '.join(similar), last)\n            elif len(similar) > 0:\n                msg += '. Perhaps you meant to use %s?' % similar.pop()\n\n            raise KeyError(msg)\n\n        return matcher", "label": 1}
{"code": "public static function modelName($project, $location, $model)\n    {\n        return self::getModelNameTemplate()->render([\n            'project' => $project,\n            'location' => $location,\n            'model' => $model,\n        ]);\n    }", "label": 2}
{"code": "def assume_role_credentials_from_config(opts = {})\n      p = opts.delete(:profile) || @profile_name\n      chain_config = opts.delete(:chain_config)\n      credentials = assume_role_from_profile(@parsed_credentials, p, opts, chain_config)\n      if @parsed_config\n        credentials ||= assume_role_from_profile(@parsed_config, p, opts, chain_config)\n      end\n      credentials\n    end", "label": 4}
{"code": "def fetch_closed_orders_since(self, since: int) -> List[Order]:\n        \"\"\"Fetch closed orders since the given timestamp.\"\"\"\n        return self._fetch_orders_since(self._closed_orders_since, since)", "label": 1}
{"code": "func (s *SyncString) Set(v string) {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.string = v\n}", "label": 5}
{"code": "func (r *DrvRegistry) Driver(name string) (driverapi.Driver, *driverapi.Capability) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\td, ok := r.drivers[name]\n\tif !ok {\n\t\treturn nil, nil\n\t}\n\n\treturn d.driver, &d.capability\n}", "label": 5}
{"code": "public function mutateRow($rowKey, Mutations $mutations, array $options = [])\n    {\n        $this->gapicClient->mutateRow(\n            $this->tableName,\n            $rowKey,\n            $mutations->toProto(),\n            $options + $this->options\n        );\n    }", "label": 2}
{"code": "def extract_observations\n      has_observation = false\n      # look for observation data in separate section but create a population for it if it exists\n      observation_section = @doc.xpath('/cda:QualityMeasureDocument/cda:component/cda:measureObservationSection',\n                                       HQMF2::Document::NAMESPACES)\n      unless observation_section.empty?\n        observation_section.xpath('cda:definition', HQMF2::Document::NAMESPACES).each do |criteria_def|\n          criteria_id = 'OBSERV'\n          criteria = PopulationCriteria.new(criteria_def, @document, @id_generator)\n          criteria.type = 'OBSERV'\n          # This section constructs a human readable id.  The first IPP will be IPP, the second will be IPP_1, etc.\n          # This allows the populations to be more readable.  The alternative would be to have the hqmf ids in the\n          # populations, which would work, but is difficult to read the populations.\n          if @ids_by_hqmf_id[\"#{criteria.hqmf_id}\"]\n            criteria.create_human_readable_id(@ids_by_hqmf_id[criteria.hqmf_id])\n          else\n            criteria.create_human_readable_id(population_id_with_counter(criteria_id))\n            @ids_by_hqmf_id[\"#{criteria.hqmf_id}\"] = criteria.id\n          end\n\n          @population_criteria << criteria\n          has_observation = true\n        end\n      end\n      has_observation\n    end", "label": 4}
{"code": "def text(value)\n      return ele_index static_text_class, value if value.is_a? Numeric\n\n      ele_by_json_visible_contains static_text_class, value\n    end", "label": 4}
{"code": "def numBlast(blast, numHits, evalueT = False, bitT = False, sort = False):\n    \"\"\"\n    parse b6 output\n    \"\"\"\n    if sort is True:\n        for hit in numBlast_sort(blast, numHits, evalueT, bitT):\n            yield hit\n        return\n    header = ['#query', 'target', 'pident', 'alen', 'mismatch', 'gapopen',\n              'qstart', 'qend', 'tstart', 'tend', 'evalue', 'bitscore']\n    yield header\n    prev, hits = None, []\n    for line in blast:\n        line = line.strip().split('\\t')\n        ID = line[0]\n        line[10], line[11] = float(line[10]), float(line[11])\n        evalue, bit = line[10], line[11]\n        if ID != prev:\n            if len(hits) > 0:\n                # column is 1 + line index\n                for hit in top_hits(hits, numHits, 11, True):\n                    yield hit\n            hits = []\n        if evalueT == False and bitT == False:\n            hits.append(line)\n        elif evalue <= evalueT and bitT == False:\n            hits.append(line)\n        elif evalue <= evalueT and bit >= bitT:\n            hits.append(line)\n        elif evalueT == False and bit >= bitT:\n            hits.append(line)\n        prev = ID\n    for hit in top_hits(hits, numHits, 11, True):\n        yield hit", "label": 1}
{"code": "def create(self, name, *args, **kwargs):\n        \"\"\"\n        Create an instance of this resource type.\n        \"\"\"\n        resource_name = self._resource_name(name)\n        log.info(\n            \"Creating {} '{}'...\".format(self._model_name, resource_name))\n        resource = self.collection.create(*args, name=resource_name, **kwargs)\n        self._ids.add(resource.id)\n        return resource", "label": 1}
{"code": "def _build_jacobian(self, Ybus, V, pv, pq, pvpq):\n        \"\"\" Returns the Jacobian matrix.\n        \"\"\"\n        pq_col = [[i] for i in pq]\n        pvpq_col = [[i] for i in pvpq]\n\n        dS_dVm, dS_dVa = self.case.dSbus_dV(Ybus, V)\n\n        J11 = dS_dVa[pvpq_col, pvpq].real\n\n        J12 = dS_dVm[pvpq_col, pq].real\n        J21 = dS_dVa[pq_col, pvpq].imag\n        J22 = dS_dVm[pq_col, pq].imag\n\n        J = vstack([\n            hstack([J11, J12]),\n            hstack([J21, J22])\n        ], format=\"csr\")\n\n        return J", "label": 1}
{"code": "def wrap_arity(callable, from:, to:, name:, last: false)\n      arity = get_arity(callable)\n      if arity == to || arity < 0\n        # It already matches, return it as is\n        callable\n      elsif arity == from\n        # It has the old arity, so wrap it with an arity converter\n        message =\"#{name} with #{from} arguments is deprecated, it now accepts #{to} arguments, see:\"\n        backtrace = caller(0, 20)\n        # Find the first line in the trace that isn't library internals:\n        user_line = backtrace.find {|l| l !~ /lib\\/graphql/ }\n        warn(message + \"\\n\" + user_line + \"\\n\")\n        wrapper = last ? LastArgumentsWrapper : FirstArgumentsWrapper\n        wrapper.new(callable, from)\n      else\n        raise \"Can't wrap #{callable} (arity: #{arity}) to have arity #{to}\"\n      end\n    end", "label": 4}
{"code": "private static void setFields(final Object from, final Object to,\r\n\t                              final Field[] fields, final boolean accessible,\r\n\t                              final Map objMap, final Map metadataMap)\r\n\t{\r\n\t\tfor (int f = 0, fieldsLength = fields.length; f < fieldsLength; ++f)\r\n\t\t{\r\n\t\t\tfinal Field field = fields[f];\r\n\t\t\tfinal int modifiers = field.getModifiers();\r\n\t\t\tif ((Modifier.STATIC & modifiers) != 0) continue;\r\n\t\t\tif ((Modifier.FINAL & modifiers) != 0)\r\n\t\t\t\tthrow new ObjectCopyException(\"cannot set final field [\" + field.getName() + \"] of class [\" + from.getClass().getName() + \"]\");\r\n\t\t\tif (!accessible && ((Modifier.PUBLIC & modifiers) == 0))\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tfield.setAccessible(true);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (SecurityException e)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new ObjectCopyException(\"cannot access field [\" + field.getName() + \"] of class [\" + from.getClass().getName() + \"]: \" + e.toString(), e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tcloneAndSetFieldValue(field, from, to, objMap, metadataMap);\r\n\t\t\t}\r\n\t\t\tcatch (Exception e)\r\n\t\t\t{\r\n\t\t\t\tthrow new ObjectCopyException(\"cannot set field [\" + field.getName() + \"] of class [\" + from.getClass().getName() + \"]: \" + e.toString(), e);\r\n\t\t\t}\r\n\t\t}\r\n\t}", "label": 0}
{"code": "def relevant_options_digest(options)\n      options = options.reject { |key, _| NON_CHANGING.include?(key) }\n      options = options.to_s.gsub(/[^a-z]+/i, '_')\n      # We must avoid making file names too long for some filesystems to handle\n      # If they are short, we can leave them human-readable\n      options.length <= 32 ? options : Digest::SHA1.hexdigest(options)\n    end", "label": 4}
{"code": "def delete(self):\n        \"\"\"Delete resource from the API server\n        \"\"\"\n        res = self.session.delete(self.href)\n        self.emit('deleted', self)\n        return res", "label": 1}
{"code": "func encode(body interface{}) io.Reader {\n\tvar b bytes.Buffer\n\terr := json.NewEncoder(&b).Encode(body)\n\tif err != nil {\n\t\treturn errorReader{err}\n\t}\n\treturn &b\n}", "label": 5}
{"code": "func (bee *Bee) Stop() {\n\tif !bee.IsRunning() {\n\t\treturn\n\t}\n\tlog.Println(bee.Name(), \"stopping gracefully!\")\n\n\tclose(bee.SigChan)\n\tbee.waitGroup.Wait()\n\tbee.Running = false\n\tlog.Println(bee.Name(), \"stopped gracefully!\")\n}", "label": 5}
{"code": "public RedwoodConfiguration hideChannels(final Object[] channels){\r\n     tasks.add(new Runnable() { public void run() { Redwood.hideChannels(channels); } });\r\n    return this;\r\n  }", "label": 0}
{"code": "func newInterface(nlh *netlink.Handle, config *networkConfiguration) (*bridgeInterface, error) {\n\tvar err error\n\ti := &bridgeInterface{nlh: nlh}\n\n\t// Initialize the bridge name to the default if unspecified.\n\tif config.BridgeName == \"\" {\n\t\tconfig.BridgeName = DefaultBridgeName\n\t}\n\n\t// Attempt to find an existing bridge named with the specified name.\n\ti.Link, err = nlh.LinkByName(config.BridgeName)\n\tif err != nil {\n\t\tlogrus.Debugf(\"Did not find any interface with name %s: %v\", config.BridgeName, err)\n\t} else if _, ok := i.Link.(*netlink.Bridge); !ok {\n\t\treturn nil, fmt.Errorf(\"existing interface %s is not a bridge\", i.Link.Attrs().Name)\n\t}\n\treturn i, nil\n}", "label": 5}
{"code": "public function setPendingVersions($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\Dlp\\V2\\StoredInfoTypeVersion::class);\n        $this->pending_versions = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def generate(params={}, recall={}, options={})\n      merged = recall.merge(params)\n      if options[:processor]\n        processor = options[:processor]\n      elsif options[:parameterize]\n        # TODO: This is sending me into fits trying to shoe-horn this into\n        # the existing API. I think I've got this backwards and processors\n        # should be a set of 4 optional blocks named :validate, :transform,\n        # :match, and :restore. Having to use a singleton here is a huge\n        # code smell.\n        processor = Object.new\n        class <<processor\n          attr_accessor :block\n          def transform(name, value)\n            block.call(name, value)\n          end\n        end\n        processor.block = options[:parameterize]\n      else\n        processor = nil\n      end\n      result = self.expand(merged, processor)\n      result.to_s if result\n    end", "label": 4}
{"code": "function setChecklist(Class, item) {\n  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var checklist = getChecklist(Class);\n\n  if (checklist) {\n    // $FlowFixMe\n    checklist[item] = value;\n  }\n}", "label": 3}
{"code": "function parseField(fieldKey, fieldData, options) {\n  let parseFn = contents => ({ contents: contents });\n  let contents = fieldData;\n  // Check to see if options.fieldParsers contains this key\n  if (options.fieldParsers.hasOwnProperty(fieldKey)) {\n    const parserKey = options.fieldParsers[fieldKey];\n    parseFn = options.parsers[parserKey].parseFn;\n    contents = typeof fieldData === 'string' ? fieldData : fieldData.contents;\n  }\n  // Check to see if there is a manually-added parser in the data\n  if (typeof fieldData === 'object' && fieldData.hasOwnProperty('parser')) {\n    if (options.parsers.hasOwnProperty(fieldData.parser)) {\n      parseFn = options.parsers[fieldData.parser].parseFn;\n    } else {\n      DrizzleError.error(\n        new DrizzleError(\n          `parser '${fieldData.parser}' set on field '${fieldKey}' not defined`,\n          DrizzleError.LEVELS.WARN\n        ),\n        options.debug\n      );\n    }\n    contents = fieldData.contents;\n    if (!fieldData.hasOwnProperty('contents')) {\n      // TODO again\n    }\n  }\n  return parseFn(contents);\n}", "label": 3}
{"code": "function fromEuler (q, euler) {\n  var x = euler[0]\n  var y = euler[1]\n  var z = euler[2]\n  var cx = Math.cos(x / 2)\n  var cy = Math.cos(y / 2)\n  var cz = Math.cos(z / 2)\n  var sx = Math.sin(x / 2)\n  var sy = Math.sin(y / 2)\n  var sz = Math.sin(z / 2)\n\n  q[0] = sx * cy * cz + cx * sy * sz\n  q[1] = cx * sy * cz - sx * cy * sz\n  q[2] = cx * cy * sz + sx * sy * cz\n  q[3] = cx * cy * cz - sx * sy * sz\n\n  return q\n}", "label": 3}
{"code": "public boolean getBooleanProperty(String name, boolean defaultValue)\r\n    {\r\n        return PropertyHelper.toBoolean(_properties.getProperty(name), defaultValue);\r\n    }", "label": 0}
{"code": "def detect_data_file(input, file_name=\"\"):\n    \"\"\" Detects the format of a network data file according to the\n        file extension and the header.\n    \"\"\"\n    _, ext = os.path.splitext(file_name)\n\n    if ext == \".m\":\n        line = input.readline() # first line\n        if line.startswith(\"function\"):\n            type = \"matpower\"\n            logger.info(\"Recognised MATPOWER data file.\")\n        elif line.startswith(\"Bus.con\" or line.startswith(\"%\")):\n            type = \"psat\"\n            logger.info(\"Recognised PSAT data file.\")\n        else:\n            type = \"unrecognised\"\n        input.seek(0) # reset buffer for parsing\n\n    elif (ext == \".raw\") or (ext == \".psse\"):\n        type = \"psse\"\n        logger.info(\"Recognised PSS/E data file.\")\n\n    elif (ext == \".pkl\") or (ext == \".pickle\"):\n        type = \"pickle\"\n        logger.info(\"Recognised pickled case.\")\n\n    else:\n        type = None\n\n    return type", "label": 1}
{"code": "def retrieve_cash_drawer_shift(location_id, shift_id, opts = {})\n      data, _status_code, _headers = retrieve_cash_drawer_shift_with_http_info(location_id, shift_id, opts)\n      return data\n    end", "label": 4}
{"code": "public function warmup()\n    {\n        $toCreate = $this->config['lock']->synchronize(function () {\n            $item = $this->cacheItemPool->getItem($this->cacheKey);\n            $data = (array) $item->get() ?: $this->initialize();\n            $count = $this->getSessionCount($data);\n            $toCreate = [];\n\n            if ($count < $this->config['minSessions']) {\n                $toCreate = $this->buildToCreateList($this->config['minSessions'] - $count);\n                $data['toCreate'] += $toCreate;\n                $this->cacheItemPool->save($item->set($data));\n            }\n\n            return $toCreate;\n        });\n\n        if (!$toCreate) {\n            return 0;\n        }\n\n        $createdSessions = [];\n        $exception = null;\n\n        try {\n            $createdSessions = $this->createSessions(count($toCreate));\n        } catch (\\Exception $exception) {\n        }\n\n        $this->config['lock']->synchronize(function () use ($toCreate, $createdSessions) {\n            $item = $this->cacheItemPool->getItem($this->cacheKey);\n            $data = $item->get();\n            $data['queue'] = array_merge($data['queue'], $createdSessions);\n\n            // Now that we've created the sessions, we can remove them from\n            // the list of intent.\n            foreach ($toCreate as $id => $time) {\n                unset($data['toCreate'][$id]);\n            }\n\n            $this->cacheItemPool->save($item->set($data));\n        });\n\n        if ($exception) {\n            throw $exception;\n        }\n\n        return count($toCreate);\n    }", "label": 2}
{"code": "public static function simplifyCNF(array $clauses)\n    {\n        $cloned_clauses = [];\n\n        // avoid strict duplicates\n        foreach ($clauses as $clause) {\n            $unique_clause = clone $clause;\n            foreach ($unique_clause->possibilities as $var_id => $possibilities) {\n                if (count($possibilities)) {\n                    $unique_clause->possibilities[$var_id] = array_unique($possibilities);\n                }\n            }\n            $cloned_clauses[$clause->getHash()] = $unique_clause;\n        }\n\n        // remove impossible types\n        foreach ($cloned_clauses as $clause_a) {\n            if (count($clause_a->possibilities) !== 1 || count(array_values($clause_a->possibilities)[0]) !== 1) {\n                continue;\n            }\n\n            if (!$clause_a->reconcilable || $clause_a->wedge) {\n                continue;\n            }\n\n            $clause_var = array_keys($clause_a->possibilities)[0];\n            $only_type = array_pop(array_values($clause_a->possibilities)[0]);\n            $negated_clause_type = self::negateType($only_type);\n\n            foreach ($cloned_clauses as $clause_b) {\n                if ($clause_a === $clause_b || !$clause_b->reconcilable || $clause_b->wedge) {\n                    continue;\n                }\n\n                if (isset($clause_b->possibilities[$clause_var]) &&\n                    in_array($negated_clause_type, $clause_b->possibilities[$clause_var], true)\n                ) {\n                    $clause_b->possibilities[$clause_var] = array_filter(\n                        $clause_b->possibilities[$clause_var],\n                        /**\n                         * @param string $possible_type\n                         *\n                         * @return bool\n                         */\n                        function ($possible_type) use ($negated_clause_type) {\n                            return $possible_type !== $negated_clause_type;\n                        }\n                    );\n\n                    if (count($clause_b->possibilities[$clause_var]) === 0) {\n                        unset($clause_b->possibilities[$clause_var]);\n                        $clause_b->impossibilities = null;\n                    }\n                }\n            }\n        }\n\n        $deduped_clauses = [];\n\n        // avoid strict duplicates\n        foreach ($cloned_clauses as $clause) {\n            $deduped_clauses[$clause->getHash()] = clone $clause;\n        }\n\n        $deduped_clauses = array_filter(\n            $deduped_clauses,\n            /**\n             * @return bool\n             */\n            function (Clause $clause) {\n                return count($clause->possibilities) || $clause->wedge;\n            }\n        );\n\n        $simplified_clauses = [];\n\n        foreach ($deduped_clauses as $clause_a) {\n            $is_redundant = false;\n\n            foreach ($deduped_clauses as $clause_b) {\n                if ($clause_a === $clause_b\n                    || !$clause_b->reconcilable\n                    || $clause_b->wedge\n                    || $clause_a->wedge\n                ) {\n                    continue;\n                }\n\n                if ($clause_a->contains($clause_b)) {\n                    $is_redundant = true;\n                    break;\n                }\n            }\n\n            if (!$is_redundant) {\n                $simplified_clauses[] = $clause_a;\n            }\n        }\n\n        return $simplified_clauses;\n    }", "label": 2}
{"code": "def id_from_object(object, type, ctx)\n      if @id_from_object_proc.nil?\n        raise(NotImplementedError, \"Can't generate an ID for #{object.inspect} of type #{type}, schema's `id_from_object` must be defined\")\n      else\n        @id_from_object_proc.call(object, type, ctx)\n      end\n    end", "label": 4}
{"code": "def inspect\n      meths = %w[id pos source expr hit_condition hit_count hit_value enabled?]\n      values = meths.map { |field| \"#{field}: #{send(field)}\" }.join(\", \")\n      \"#<Byebug::Breakpoint #{values}>\"\n    end", "label": 4}
{"code": "def post(self, *args, **kwargs):\n        \"\"\"\n        Do a redirect if user presses the prev. step button. The rest of this\n        is super'd from FormWizard.\n        \"\"\"\n        prev_step = self.request.POST.get('wizard_prev_step', None)\n        if prev_step and prev_step in self.get_form_list():\n            self.storage.current_step = prev_step\n            return redirect(self.url_name, step=prev_step)\n        return super(NamedUrlWizardView, self).post(*args, **kwargs)", "label": 1}
{"code": "public function queryResults(array $options = [])\n    {\n        $timeoutMs = $this->pluck('initialTimeoutMs', $options, false) ?: 0;\n        $queryResultsOptions = $options;\n        $options['timeoutMs'] = $timeoutMs;\n\n        return new QueryResults(\n            $this->connection,\n            $this->identity['jobId'],\n            $this->identity['projectId'],\n            $this->connection->getQueryResults($options + $this->identity),\n            $this->mapper,\n            $this,\n            $queryResultsOptions\n        );\n    }", "label": 2}
{"code": "protected static function registerWatchers($app)\n    {\n        foreach (config('telescope.watchers') as $key => $watcher) {\n            if (is_string($key) && $watcher === false) {\n                continue;\n            }\n\n            if (is_array($watcher) && ! ($watcher['enabled'] ?? true)) {\n                continue;\n            }\n\n            $watcher = $app->make(is_string($key) ? $key : $watcher, [\n                'options' => is_array($watcher) ? $watcher : [],\n            ]);\n\n            static::$watchers[] = get_class($watcher);\n\n            $watcher->register($app);\n        }\n    }", "label": 2}
{"code": "def is_valid(isbn_id):\n    \"\"\"\n    Check that a given string is a valid ISBN.\n\n    :param isbn_id: the isbn to be checked.\n    :returns: boolean indicating whether the isbn is valid or not.\n\n    >>> is_valid(\"978-3-16-148410-0\")\n    True\n\n    >>> is_valid(\"9783161484100\")\n    True\n\n    >>> is_valid(\"9783161484100aa\")\n    False\n\n    >>> is_valid(\"abcd\")\n    False\n\n    >>> is_valid(\"0136091814\")\n    True\n\n    >>> is_valid(\"0136091812\")\n    False\n\n    >>> is_valid(\"9780136091817\")\n    False\n\n    >>> is_valid(\"123456789X\")\n    True\n    \"\"\"\n    return (\n        (not isbnlib.notisbn(isbn_id)) and (\n            isbnlib.get_canonical_isbn(isbn_id) == isbn_id or\n            isbnlib.mask(isbnlib.get_canonical_isbn(isbn_id)) == isbn_id)\n    )", "label": 1}
{"code": "func (l VirtualDeviceList) CreateSCSIController(name string) (types.BaseVirtualDevice, error) {\n\tctypes := SCSIControllerTypes()\n\n\tif name == \"\" || name == \"scsi\" {\n\t\tname = ctypes.Type(ctypes[0])\n\t} else if name == \"virtualscsi\" {\n\t\tname = \"pvscsi\" // ovf VirtualSCSI mapping\n\t}\n\n\tfound := ctypes.Select(func(device types.BaseVirtualDevice) bool {\n\t\treturn l.Type(device) == name\n\t})\n\n\tif len(found) == 0 {\n\t\treturn nil, fmt.Errorf(\"unknown SCSI controller type '%s'\", name)\n\t}\n\n\tc, ok := found[0].(types.BaseVirtualSCSIController)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"invalid SCSI controller type '%s'\", name)\n\t}\n\n\tscsi := c.GetVirtualSCSIController()\n\tscsi.BusNumber = l.newSCSIBusNumber()\n\tscsi.Key = l.NewKey()\n\tscsi.ScsiCtlrUnitNumber = 7\n\treturn c.(types.BaseVirtualDevice), nil\n}", "label": 5}
{"code": "def validate_process_steps(prop, value):\n    \"\"\" Default validation for Process Steps data structure \"\"\"\n\n    if value is not None:\n        validate_type(prop, value, (dict, list))\n\n        procstep_keys = set(_complex_definitions[prop])\n\n        for idx, procstep in enumerate(wrap_value(value)):\n            ps_idx = prop + '[' + str(idx) + ']'\n            validate_type(ps_idx, procstep, dict)\n\n            for ps_prop, ps_val in iteritems(procstep):\n                ps_key = '.'.join((ps_idx, ps_prop))\n\n                if ps_prop not in procstep_keys:\n                    _validation_error(prop, None, value, ('keys: {0}'.format(','.join(procstep_keys))))\n\n                if ps_prop != 'sources':\n                    validate_type(ps_key, ps_val, string_types)\n                else:\n                    validate_type(ps_key, ps_val, (string_types, list))\n\n                    for src_idx, src_val in enumerate(wrap_value(ps_val)):\n                        src_key = ps_key + '[' + str(src_idx) + ']'\n                        validate_type(src_key, src_val, string_types)", "label": 1}
{"code": "def get_zero_task_agent(generators, market, nOffer, maxSteps):\n    \"\"\" Returns a task-agent tuple whose action is always zero.\n    \"\"\"\n    env = pyreto.discrete.MarketEnvironment(generators, market, nOffer)\n    task = pyreto.discrete.ProfitTask(env, maxSteps=maxSteps)\n    agent = pyreto.util.ZeroAgent(env.outdim, env.indim)\n    return task, agent", "label": 1}
{"code": "public static vlan_nsip6_binding[] get(nitro_service service, Long id) throws Exception{\n\t\tvlan_nsip6_binding obj = new vlan_nsip6_binding();\n\t\tobj.set_id(id);\n\t\tvlan_nsip6_binding response[] = (vlan_nsip6_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function setReportLocation($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\ErrorReporting\\V1beta1\\SourceLocation::class);\n        $this->report_location = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function (member, attribute) {\n            _gpfAssertAttributeOnly(attribute);\n            member = _gpfEncodeAttributeMember(member);\n            var array = this._members[member];\n            if (undefined === array) {\n                array = this._members[member] = new _gpfA.Array();\n            }\n            array._array.push(attribute);\n            ++this._count;\n        }", "label": 3}
{"code": "def TreeCollectionStore(repos_dict=None,\n                        repos_par=None,\n                        with_caching=True,\n                        assumed_doc_version=None,\n                        git_ssh=None,\n                        pkey=None,\n                        git_action_class=TreeCollectionsGitAction,\n                        mirror_info=None,\n                        infrastructure_commit_author='OpenTree API <api@opentreeoflife.org>'):\n    \"\"\"Factory function for a _TreeCollectionStore object.\n\n    A wrapper around the _TreeCollectionStore class instantiation for\n    the most common use case: a singleton _TreeCollectionStore.\n    If you need distinct _TreeCollectionStore objects, you'll need to\n    call that class directly.\n    \"\"\"\n    global _THE_TREE_COLLECTION_STORE\n    if _THE_TREE_COLLECTION_STORE is None:\n        _THE_TREE_COLLECTION_STORE = _TreeCollectionStore(repos_dict=repos_dict,\n                                                          repos_par=repos_par,\n                                                          with_caching=with_caching,\n                                                          assumed_doc_version=assumed_doc_version,\n                                                          git_ssh=git_ssh,\n                                                          pkey=pkey,\n                                                          git_action_class=git_action_class,\n                                                          mirror_info=mirror_info,\n                                                          infrastructure_commit_author=infrastructure_commit_author)\n    return _THE_TREE_COLLECTION_STORE", "label": 1}
{"code": "func (d Datastore) UploadFile(ctx context.Context, file string, path string, param *soap.Upload) error {\n\tu, p, err := d.uploadTicket(ctx, path, param)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn d.Client().UploadFile(ctx, file, u, p)\n}", "label": 5}
{"code": "public static sslocspresponder get(nitro_service service, String name) throws Exception{\n\t\tsslocspresponder obj = new sslocspresponder();\n\t\tobj.set_name(name);\n\t\tsslocspresponder response = (sslocspresponder) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "def stop\n      # if called via run_till_terminated_or_interrupted,\n      #   signal stop_server_thread and dont do anything\n      if @stop_server.nil? == false && @stop_server == false\n        @stop_server = true\n        @stop_server_cv.broadcast\n        return\n      end\n      @run_mutex.synchronize do\n        fail 'Cannot stop before starting' if @running_state == :not_started\n        return if @running_state != :running\n        transition_running_state(:stopping)\n        deadline = from_relative_time(@poll_period)\n        @server.shutdown_and_notify(deadline)\n      end\n      @pool.stop\n    end", "label": 4}
{"code": "public function setSelectedRegions($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::ENUM, \\Google\\Cloud\\Monitoring\\V3\\UptimeCheckRegion::class);\n        $this->selected_regions = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "public static base_responses update(nitro_service client, dnssrvrec resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tdnssrvrec updateresources[] = new dnssrvrec[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new dnssrvrec();\n\t\t\t\tupdateresources[i].domain = resources[i].domain;\n\t\t\t\tupdateresources[i].target = resources[i].target;\n\t\t\t\tupdateresources[i].priority = resources[i].priority;\n\t\t\t\tupdateresources[i].weight = resources[i].weight;\n\t\t\t\tupdateresources[i].port = resources[i].port;\n\t\t\t\tupdateresources[i].ttl = resources[i].ttl;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function prev(index, lines) {\n    while (index--) {\n      var line = lines[index].trim();\n\n      if (line && !/^(\\/\\/|\\/\\*)/.test(line)) {\n        return { line: line, index: index };\n      }\n    }\n\n    return {};\n  }", "label": 3}
{"code": "def search_in_rubric(self, **kwargs):\n        \"\"\"Firms search in rubric\n\n        http://api.2gis.ru/doc/firms/searches/searchinrubric/\n        \"\"\"\n\n        point = kwargs.pop('point', False)\n        if point:\n            kwargs['point'] = '%s,%s' % point\n\n        bound = kwargs.pop('bound', False)\n        if bound:\n            kwargs['bound[point1]'] = bound[0]\n            kwargs['bound[point2]'] = bound[1]\n\n        filters = kwargs.pop('filters', False)\n        if filters:\n            for k, v in filters.items():\n                kwargs['filters[%s]' % k] = v\n\n        return self._search_in_rubric(**kwargs)", "label": 1}
{"code": "def value(key, context)\n      overrides_for(context).each { |conf| return conf[key] if conf.key?(key) }\n      options.fetch(key)\n    end", "label": 4}
{"code": "public function longRunningOperations(array $options = [])\n    {\n        if (is_null($this->lroResource)) {\n            throw new \\BadMethodCallException('This service does list support listing operations.');\n        }\n\n        $resultLimit = $this->pluck('resultLimit', $options, false) ?: 0;\n\n        $options['name'] = $this->lroResource .'/operations';\n\n        return new ItemIterator(\n            new PageIterator(\n                function (array $operation) {\n                    return $this->resumeOperation($operation['name'], $operation);\n                },\n                [$this->lroConnection, 'operations'],\n                $options,\n                [\n                    'itemsKey' => 'operations',\n                    'resultLimit' => $resultLimit\n                ]\n            )\n        );\n    }", "label": 2}
{"code": "private static InputStream findStreamInClasspathOrFileSystem(String fn) throws FileNotFoundException {\r\n    // ms 10-04-2010:\r\n    // - even though this may look like a regular file, it may be a path inside a jar in the CLASSPATH\r\n    // - check for this first. This takes precedence over the file system.\r\n    InputStream is = IOUtils.class.getClassLoader().getResourceAsStream(fn);\r\n    // if not found in the CLASSPATH, load from the file system\r\n    if (is == null) is = new FileInputStream(fn);\r\n    return is;\r\n  }", "label": 0}
{"code": "func PgOpfamilyByOpfmethodOpfnameOpfnamespace(db XODB, opfmethod pgtypes.Oid, opfname pgtypes.Name, opfnamespace pgtypes.Oid) (*PgOpfamily, error) {\n\tvar err error\n\n\t// sql query\n\tconst sqlstr = `SELECT ` +\n\t\t`tableoid, cmax, xmax, cmin, xmin, oid, ctid, opfmethod, opfname, opfnamespace, opfowner ` +\n\t\t`FROM pg_catalog.pg_opfamily ` +\n\t\t`WHERE opfmethod = $1 AND opfname = $2 AND opfnamespace = $3`\n\n\t// run query\n\tXOLog(sqlstr, opfmethod, opfname, opfnamespace)\n\tpo := PgOpfamily{}\n\n\terr = db.QueryRow(sqlstr, opfmethod, opfname, opfnamespace).Scan(&po.Tableoid, &po.Cmax, &po.Xmax, &po.Cmin, &po.Xmin, &po.Oid, &po.Ctid, &po.Opfmethod, &po.Opfname, &po.Opfnamespace, &po.Opfowner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &po, nil\n}", "label": 5}
{"code": "function checkAvailable(map, command, logType, logMsg) {\n        if (map[command]) {\n            const prefix = logType === 'error' ? 'ERROR' : 'WARNING';\n            forum.emit(logType, `${prefix}, ${command} is already registered: ${logMsg}`);\n            return false;\n        }\n        return true;\n    }", "label": 3}
{"code": "def filter!(type, base = settings)\n      filter! type, base.superclass if base.superclass.respond_to?(:filters)\n      base.filters[type].each { |args| process_route(*args) }\n    end", "label": 4}
{"code": "public function setOutputAudioConfig($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dialogflow\\V2\\OutputAudioConfig::class);\n        $this->output_audio_config = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "public static nsrpcnode[] get(nitro_service service, String ipaddress[]) throws Exception{\n\t\tif (ipaddress !=null && ipaddress.length>0) {\n\t\t\tnsrpcnode response[] = new nsrpcnode[ipaddress.length];\n\t\t\tnsrpcnode obj[] = new nsrpcnode[ipaddress.length];\n\t\t\tfor (int i=0;i<ipaddress.length;i++) {\n\t\t\t\tobj[i] = new nsrpcnode();\n\t\t\t\tobj[i].set_ipaddress(ipaddress[i]);\n\t\t\t\tresponse[i] = (nsrpcnode) obj[i].get_resource(service);\n\t\t\t}\n\t\t\treturn response;\n\t\t}\n\t\treturn null;\n\t}", "label": 0}
{"code": "def add_kv_store(self, key, value):\n        \"\"\"Add a key-value store entry.\n\n        :param key: string\n        :param value: string\n        \"\"\"\n        data = {\n            'operation': 'STORE',\n            'key': key,\n            'value': value\n        }\n        return self.post(self.make_url(\"/useragent-kv\"), data=to_json(data),\n                         headers=self.default_headers).text", "label": 1}
{"code": "def add_text_field_factory(name, options = {}, &block)\n      stored, more_like_this = options[:stored], options[:more_like_this]\n      field_factory = FieldFactory::Static.new(name, Type::TextType.instance, options, &block)\n      @text_field_factories[name] = field_factory\n      @text_field_factories_cache[field_factory.name] = field_factory\n      if stored\n        @stored_field_factories_cache[field_factory.name] << field_factory\n      end\n      if more_like_this\n        @more_like_this_field_factories_cache[field_factory.name] << field_factory\n      end\n    end", "label": 4}
{"code": "def create_profile!\n      cert = certificate_to_use\n      bundle_id = Sigh.config[:app_identifier]\n      name = Sigh.config[:provisioning_name] || [bundle_id, profile_type.pretty_type].join(' ')\n\n      unless Sigh.config[:skip_fetch_profiles]\n        if Spaceship.provisioning_profile.all.find { |p| p.name == name }\n          UI.error(\"The name '#{name}' is already taken, using another one.\")\n          name += \" #{Time.now.to_i}\"\n        end\n      end\n\n      UI.important(\"Creating new provisioning profile for '#{Sigh.config[:app_identifier]}' with name '#{name}' for '#{Sigh.config[:platform]}' platform\")\n      profile = profile_type.create!(name: name,\n                                bundle_id: bundle_id,\n                              certificate: cert,\n                                      mac: Sigh.config[:platform].to_s == 'macos',\n                             sub_platform: Sigh.config[:platform].to_s == 'tvos' ? 'tvOS' : nil,\n                            template_name: Sigh.config[:template_name])\n      profile\n    end", "label": 4}
{"code": "def handle_r(tokens, options)\n      dd_tokens = dealias_and_disambiguate_times(tokens, options)\n      get_anchor(dd_tokens, options)\n    end", "label": 4}
{"code": "public static <E, C extends Counter<E>> C saferL2Normalize(C c) {\r\n    return scale(c, 1.0 / saferL2Norm(c));\r\n  }", "label": 0}
{"code": "func (t *FpdfTpl) Serialize() ([]byte, error) {\n\tb := new(bytes.Buffer)\n\tenc := gob.NewEncoder(b)\n\terr := enc.Encode(t)\n\n\treturn b.Bytes(), err\n}", "label": 5}
{"code": "def handle_message(consumer, delivery_info, properties, payload)\n      serializer = consumer.get_serializer || Hutch::Config[:serializer]\n      logger.debug {\n        spec   = serializer.binary? ? \"#{payload.bytesize} bytes\" : \"#{payload}\"\n        \"message(#{properties.message_id || '-'}): \" +\n        \"routing key: #{delivery_info.routing_key}, \" +\n        \"consumer: #{consumer}, \" +\n        \"payload: #{spec}\"\n      }\n\n      message = Message.new(delivery_info, properties, payload, serializer)\n      consumer_instance = consumer.new.tap { |c| c.broker, c.delivery_info = @broker, delivery_info }\n      with_tracing(consumer_instance).handle(message)\n      @broker.ack(delivery_info.delivery_tag)\n    rescue => ex\n      acknowledge_error(delivery_info, properties, @broker, ex)\n      handle_error(properties, payload, consumer, ex)\n    end", "label": 4}
{"code": "public void deleteLicense(final String licName) {\n        final DbLicense dbLicense = getLicense(licName);\n\n        repoHandler.deleteLicense(dbLicense.getName());\n\n        final FiltersHolder filters = new FiltersHolder();\n        final LicenseIdFilter licenseIdFilter = new LicenseIdFilter(licName);\n        filters.addFilter(licenseIdFilter);\n\n        for (final DbArtifact artifact : repoHandler.getArtifacts(filters)) {\n            repoHandler.removeLicenseFromArtifact(artifact, licName, this);\n        }\n    }", "label": 0}
{"code": "func Dial(socket string) (net.Conn, error) {\n\tconn, err := winio.DialPipe(defaults.WindowsOpenSSHNamedPipe, nil)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\treturn conn, nil\n}", "label": 5}
{"code": "def getdir(self, section, option, raw=False, vars=None, fallback=\"\", validate=False):\n        \"\"\"\n        A convenience method which coerces the option in the specified section to a directory.\n        \"\"\"\n        v = self.get(section, option, raw=raw, vars=vars, fallback=fallback)\n        v = self._convert_to_path(v)\n        return v if not validate or os.path.isdir(v) else fallback", "label": 1}
{"code": "private List<Point2D> merge(final List<Point2D> one, final List<Point2D> two) {\n        final Set<Point2D> oneSet = new HashSet<Point2D>(one);\n        for (Point2D item : two) {\n            if (!oneSet.contains(item)) {\n                one.add(item);\n            }\n        }\n        return one;\n    }", "label": 0}
{"code": "public static vpnvserver_vpnnexthopserver_binding[] get(nitro_service service, String name) throws Exception{\n\t\tvpnvserver_vpnnexthopserver_binding obj = new vpnvserver_vpnnexthopserver_binding();\n\t\tobj.set_name(name);\n\t\tvpnvserver_vpnnexthopserver_binding response[] = (vpnvserver_vpnnexthopserver_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "func NoServiceErrorf(format string, params ...interface{}) error {\n\treturn noService(fmt.Sprintf(format, params...))\n}", "label": 5}
{"code": "public String getPrefixStatsMultiplePositionPrefixAttribute(String field) {\n    return String.join(MtasToken.DELIMITER, multiplePositionPrefix.get(field));\n  }", "label": 0}
{"code": "def render_links(tags)\n      [ :amphtml, :canonical, :prev, :next, :image_src ].each do |tag_name|\n        href = meta_tags.extract(tag_name)\n        if href.present?\n          @normalized_meta_tags[tag_name] = href\n          tags << Tag.new(:link, rel: tag_name, href: href)\n        end\n      end\n    end", "label": 4}
{"code": "public static long count(nitro_service service, Long td) throws Exception{\n\t\tnstrafficdomain_bridgegroup_binding obj = new nstrafficdomain_bridgegroup_binding();\n\t\tobj.set_td(td);\n\t\toptions option = new options();\n\t\toption.set_count(true);\n\t\tnstrafficdomain_bridgegroup_binding response[] = (nstrafficdomain_bridgegroup_binding[]) obj.get_resources(service,option);\n\t\tif (response != null) {\n\t\t\treturn response[0].__count;\n\t\t}\n\t\treturn 0;\n\t}", "label": 0}
{"code": "public function getImportedExternalPageLinks($pageNumber)\n\t{\n\t\t$links = [];\n\n\t\t$reader = $this->getPdfReader($this->currentReaderId);\n\t\t$parser = $reader->getParser();\n\n\t\t$page = $reader->getPage($pageNumber);\n\t\t$page->getPageDictionary();\n\n\t\t$annotations = $page->getAttribute('Annots');\n\t\tif ($annotations instanceof PdfIndirectObjectReference) {\n\t\t\t$annotations = PdfType::resolve($parser->getIndirectObject($annotations->value), $parser);\n\t\t}\n\n\t\tif ($annotations instanceof PdfArray) {\n\n\t\t\t$getAttribute = function ($array, $key) {\n\t\t\t\tif (isset($array[$key]->value)) {\n\t\t\t\t\treturn $array[$key]->value;\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t};\n\n\t\t\tforeach ($annotations->value as $annotation) {\n\t\t\t\t$annotation = PdfType::resolve($annotation, $parser)->value;\n\n\t\t\t\t/* Skip over any annotations that aren't links */\n\t\t\t\t$type = $getAttribute($annotation, 'Type');\n\t\t\t\t$subtype = $getAttribute($annotation, 'Subtype');\n\t\t\t\tif ($type !== 'Annot' || $subtype !== 'Link' || !isset($annotation['A'])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Calculate the link positioning */\n\t\t\t\t$position = $getAttribute($annotation, 'Rect');\n\n\t\t\t\tif (count($position) !== 4) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$x1 = $getAttribute($position, 0) / Mpdf::SCALE;\n\t\t\t\t$y1 = $getAttribute($position, 1) / Mpdf::SCALE;\n\t\t\t\t$x2 = $getAttribute($position, 2) / Mpdf::SCALE;\n\t\t\t\t$y2 = $getAttribute($position, 3) / Mpdf::SCALE;\n\t\t\t\t$width = $x2 - $x1;\n\t\t\t\t$height = $y2 - $y1;\n\n\t\t\t\t$link = $annotation['A'] instanceof PdfIndirectObjectReference ? PdfType::resolve($annotation['A'], $parser)->value : $getAttribute($annotation, 'A');\n\n\t\t\t\tif (isset($link['URI'])) {\n\t\t\t\t\t$links[] = [\n\t\t\t\t\t\t'x' => $x1,\n\t\t\t\t\t\t'y' => $y1,\n\t\t\t\t\t\t'width' => $width,\n\t\t\t\t\t\t'height' => $height,\n\t\t\t\t\t\t'url' => $getAttribute($link, 'URI')\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $links;\n\t}", "label": 2}
{"code": "def set_matrix_dimensions(self, bounds, xdensity, ydensity):\n        \"\"\"\n        Change the dimensions of the matrix into which the pattern\n        will be drawn.  Users of this class should call this method\n        rather than changing the bounds, xdensity, and ydensity\n        parameters directly.  Subclasses can override this method to\n        update any internal data structures that may depend on the\n        matrix dimensions.\n        \"\"\"\n        self.bounds = bounds\n        self.xdensity = xdensity\n        self.ydensity = ydensity\n        scs = SheetCoordinateSystem(bounds, xdensity, ydensity)\n        for of in self.output_fns:\n            if isinstance(of, TransferFn):\n                of.initialize(SCS=scs, shape=scs.shape)", "label": 1}
{"code": "public void addAppenderEvent(final Category cat, final Appender appender) {\n\n\t\tupdateDefaultLayout(appender);\n\n\t\tif (appender instanceof FoundationFileRollingAppender) {\n\t\t\tfinal FoundationFileRollingAppender timeSizeRollingAppender = (FoundationFileRollingAppender) appender;\n\n\t\t\t// update the appender with default vales such as logging pattern, file size etc.\n\t\t\t//updateDefaultTimeAndSizeRollingAppender(timeSizeRollingAppender);\n\n\t\t\t// read teh proeprties and determine if archiving should be enabled.\n\t\t\tupdateArchivingSupport(timeSizeRollingAppender);\n\n\t\t\t// by default add the rolling file listener to enable application\n\t\t\t// state.\n\t\t\ttimeSizeRollingAppender.setFileRollEventListener(FoundationRollEventListener.class.getName());\n\n\t\t\tboolean rollOnStartup = true;\n\n\t\t\tif (FoundationLogger.log4jConfigProps != null && FoundationLogger.log4jConfigProps.containsKey(FoundationLoggerConstants.Foundation_ROLL_ON_STARTUP.toString())) {\n\t\t\t\trollOnStartup = Boolean.valueOf(FoundationLogger.log4jConfigProps.getProperty(FoundationLoggerConstants.Foundation_ROLL_ON_STARTUP.toString()));\n\t\t\t}\n\n\t\t\ttimeSizeRollingAppender.setRollOnStartup(rollOnStartup);\n\n\t\t\t// refresh the appender\n\t\t\ttimeSizeRollingAppender.activateOptions();\n\n\t\t\t\n\t\t//\ttimeSizeRollingAppender.setOriginalLayout(); //So application state will not make any problems\n\n\t\t}else if(!(appender instanceof FoundationFileRollingAppender) && (appender instanceof TimeAndSizeRollingAppender)){ //TimeAndSizeRollingAppender\n\t\t\tfinal TimeAndSizeRollingAppender timeSizeRollingAppender = (TimeAndSizeRollingAppender) appender;\n\n\t\t\t// update the appender with default vales such as logging pattern, file size etc.\n\t\t\tupdateDefaultTimeAndSizeRollingAppender(timeSizeRollingAppender);\n\n\t\t\t// read teh proeprties and determine if archiving should be enabled.\n\t\t\tupdateArchivingSupport(timeSizeRollingAppender);\n\n\t\t\t// by default add the rolling file listener to enable application\n\t\t\t// state.\n\t\t\ttimeSizeRollingAppender.setFileRollEventListener(FoundationRollEventListener.class.getName());\n\n\t\t\tboolean rollOnStartup = true;\n\n\t\t\tif (FoundationLogger.log4jConfigProps != null && FoundationLogger.log4jConfigProps.containsKey(FoundationLoggerConstants.Foundation_ROLL_ON_STARTUP.toString())) {\n\t\t\t\trollOnStartup = Boolean.valueOf(FoundationLogger.log4jConfigProps.getProperty(FoundationLoggerConstants.Foundation_ROLL_ON_STARTUP.toString()));\n\t\t\t}\n\n\t\t\ttimeSizeRollingAppender.setRollOnStartup(rollOnStartup);\n\n\t\t\t// refresh the appender\n\t\t\ttimeSizeRollingAppender.activateOptions();\n\n\t\t\t\n\t\t//\ttimeSizeRollingAppender.setOriginalLayout();\n\t\t}\n\t\tif ( ! (appender instanceof org.apache.log4j.AsyncAppender))\n            initiateAsyncSupport(appender);\n\n\t}", "label": 0}
{"code": "protected function incrementCurrentDateUntilValid()\n    {\n        $attempts = 0;\n\n        do {\n            $this->current = $this->current->add($this->dateInterval);\n\n            $this->validationResult = null;\n\n            if (++$attempts > static::NEXT_MAX_ATTEMPTS) {\n                throw new RuntimeException('Could not find next valid date.');\n            }\n        } while ($this->validateCurrentDate() === false);\n    }", "label": 2}
{"code": "function (data, pluginNames) {\n    logger('runPlugins input', data);\n    var plugins = pluginNames.map(function (pn) { return pluginRegistry[pn]; }),\n      applyPlugin = function (oldData, plugin) { return plugin(oldData); };\n    // Use reduce to apply all the plugins to the data\n    var output = plugins.reduce(applyPlugin, data);\n    logger('runPlugins output', output);\n    return output;\n  }", "label": 3}
{"code": "def raw_content\n      return if pseudo_license?\n      unless File.exist?(path)\n        raise Licensee::InvalidLicense, \"'#{key}' is not a valid license key\"\n      end\n\n      @raw_content ||= File.read(path, encoding: 'utf-8')\n    end", "label": 4}
{"code": "public static function error_multi_line( $message_lines ) {\n\t\tif ( ! isset( self::get_runner()->assoc_args['completions'] ) && is_array( $message_lines ) ) {\n\t\t\tself::$logger->error_multi_line( array_map( array( __CLASS__, 'error_to_string' ), $message_lines ) );\n\t\t}\n\t}", "label": 2}
{"code": "func (dm *DjangoMigration) Delete(db XODB) error {\n\tvar err error\n\n\t// if doesn't exist, bail\n\tif !dm._exists {\n\t\treturn nil\n\t}\n\n\t// if deleted, bail\n\tif dm._deleted {\n\t\treturn nil\n\t}\n\n\t// sql query\n\tconst sqlstr = `DELETE FROM django.django_migrations WHERE id = :1`\n\n\t// run query\n\tXOLog(sqlstr, dm.ID)\n\t_, err = db.Exec(sqlstr, dm.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// set deleted\n\tdm._deleted = true\n\n\treturn nil\n}", "label": 5}
{"code": "func EncodeClusterName(clusterName string) string {\n\t// hex is used to hide \".\" that will prevent wildcard *. entry to match\n\treturn fmt.Sprintf(\"%v.%v\", hex.EncodeToString([]byte(clusterName)), teleport.APIDomain)\n}", "label": 5}
{"code": "func (s *Store) GetRemote(aciURL string) (*Remote, error) {\n\tvar remote *Remote\n\n\terr := s.db.Do(func(tx *sql.Tx) error {\n\t\tvar err error\n\n\t\tremote, err = GetRemote(tx, aciURL)\n\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn remote, nil\n}", "label": 5}
{"code": "def get(self):\n        \"\"\"\n        Return details for the filesystem, including configured volumes.\n        \"\"\"\n        res = self.fs.get_filesystem_details()\n        res = res.to_dict()\n        self.write(res)", "label": 1}
{"code": "func NewReporterWatcher(ctx context.Context, component string, w Watcher) *ReporterWatcher {\n\trw := &ReporterWatcher{\n\t\tWatcher:   w,\n\t\tComponent: component,\n\t}\n\tgo rw.watch(ctx)\n\treturn rw\n}", "label": 5}
{"code": "public static base_response add(nitro_service client, filteraction resource) throws Exception {\n\t\tfilteraction addresource = new filteraction();\n\t\taddresource.name = resource.name;\n\t\taddresource.qual = resource.qual;\n\t\taddresource.servicename = resource.servicename;\n\t\taddresource.value = resource.value;\n\t\taddresource.respcode = resource.respcode;\n\t\taddresource.page = resource.page;\n\t\treturn addresource.add_resource(client);\n\t}", "label": 0}
{"code": "def box_cox(table):\n    \"\"\"\n    box-cox transform table\n    \"\"\"\n    from scipy.stats import boxcox as bc\n    t = []\n    for i in table:\n        if min(i) == 0:\n            scale = min([j for j in i if j != 0]) * 10e-10\n        else:\n            scale = 0\n        t.append(np.ndarray.tolist(bc(np.array([j + scale for j in i]))[0]))\n    return t", "label": 1}
{"code": "def unregister(self, shared_object):\n        \"\"\"\n        Unregisters an existing shared object, so that this shared object is no longer available.\n\n        This function is mainly used during plugin deactivation.\n\n        :param shared_object: Name of the shared_object\n        \"\"\"\n        if shared_object not in self._shared_objects.keys():\n            self.log.warning(\"Can not unregister shared object %s\" % shared_object)\n        else:\n            del (self._shared_objects[shared_object])\n            self.log.debug(\"Shared object %s got unregistered\" % shared_object)", "label": 1}
{"code": "function getHeaderItems (uid, currentDate, prvniZaslani, overeni) {\n  return {\n    attributes: {\n      uuid_zpravy: uid,\n      dat_odesl: formatDate(currentDate),\n      prvni_zaslani: formatBool(prvniZaslani, true),\n      overeni: formatBool(overeni, false)\n    }\n  }\n}", "label": 3}
{"code": "def format_request_email_body(increq, **ctx):\n    \"\"\"Format the email message body for inclusion request notification.\n\n    :param increq: Inclusion request object for which the request is made.\n    :type increq: `invenio_communities.models.InclusionRequest`\n    :param ctx: Optional extra context parameters passed to formatter.\n    :type ctx: dict.\n    :returns: Email message body.\n    :rtype: str\n    \"\"\"\n    template = current_app.config[\"COMMUNITIES_REQUEST_EMAIL_BODY_TEMPLATE\"],\n    return format_request_email_templ(increq, template, **ctx)", "label": 1}
{"code": "public static String getGroupId(final String gavc) {\n        final int splitter = gavc.indexOf(':');\n        if(splitter == -1){\n            return gavc;\n        }\n        return gavc.substring(0, splitter);\n    }", "label": 0}
{"code": "public function setCloudRepo($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\DevTools\\Source\\V1\\CloudRepoSourceContext::class);\n        $this->writeOneof(1, $var);\n\n        return $this;\n    }", "label": 2}
{"code": "func (r *Resource) WithParameter(name string, value string) *Resource {\n\tparameter := url.Values{}\n\tparameter.Set(name, value)\n\tr.u.RawQuery = parameter.Encode()\n\treturn r\n}", "label": 5}
{"code": "private function updateResultPointer(array &$coll, $index, $dqlAlias, $oneToOne)\n    {\n        if ($coll === null) {\n            unset($this->resultPointers[$dqlAlias]); // Ticket #1228\n\n            return;\n        }\n\n        if ($oneToOne) {\n            $this->resultPointers[$dqlAlias] =& $coll;\n\n            return;\n        }\n\n        if ($index !== false) {\n            $this->resultPointers[$dqlAlias] =& $coll[$index];\n\n            return;\n        }\n\n        if (! $coll) {\n            return;\n        }\n\n        end($coll);\n        $this->resultPointers[$dqlAlias] =& $coll[key($coll)];\n    }", "label": 2}
{"code": "function Grid(props) {\n  const grid = new contrib.grid({...props, screen: { append: () => {} }});\n  const children = props.children instanceof Array ? props.children : [props.children];\n  return React.createElement(props.component || 'element', {}, children.map((child, key) => {\n    const props = child.props;\n    const options = grid.set(props.row, props.col, props.rowSpan || 1, props.colSpan || 1, x => x, props.options);\n    options.key = key;\n    return React.cloneElement(child, options);\n  }));\n}", "label": 3}
{"code": "def noise_gaussian(self, mean, std):\n        \"\"\"Create a gaussian noise variable\"\"\"\n        assert std > 0\n        ng = self.sym.sym('ng_{:d}'.format(len(self.scope['ng'])))\n        self.scope['ng'].append(ng)\n        return mean + std*ng", "label": 1}
{"code": "func ParsePrivateKeyPEM(bytes []byte) (crypto.Signer, error) {\n\tblock, _ := pem.Decode(bytes)\n\tif block == nil {\n\t\treturn nil, trace.BadParameter(\"expected PEM-encoded block\")\n\t}\n\treturn ParsePrivateKeyDER(block.Bytes)\n}", "label": 5}
{"code": "def blazer_json_escape(s)\n      if Rails::VERSION::STRING < \"4.1\"\n        result = s.to_s.gsub(JSON_ESCAPE_REGEXP, JSON_ESCAPE)\n        s.html_safe? ? result.html_safe : result\n      else\n        json_escape(s)\n      end\n    end", "label": 4}
{"code": "def optimize_svg_for_uri_escaping!(svg)\n      # Remove comments, xml meta, and doctype\n      svg.gsub!(/<!--.*?-->|<\\?.*?\\?>|<!.*?>/m, '')\n      # Replace consecutive whitespace and newlines with a space\n      svg.gsub!(/\\s+/, ' ')\n      # Collapse inter-tag whitespace\n      svg.gsub!('> <', '><')\n      # Replace \" with '\n      svg.gsub!(/([\\w:])=\"(.*?)\"/, \"\\\\1='\\\\2'\")\n      svg.strip!\n    end", "label": 4}
{"code": "func (s *PresenceService) GetLocalClusterName() (string, error) {\n\titem, err := s.Get(context.TODO(), backend.Key(localClusterPrefix, valPrefix))\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn string(item.Value), nil\n}", "label": 5}
{"code": "function (level, message, tag, data) {\n\n        var env = Shared.config('environment');\n        var levels = ['fatal', 'error', 'warn', 'info', 'debug', 'trace'];\n        var logLevelConfig = env.logLevel || \"info\";\n\n        if (logLevelConfig == \"none\") {\n            return;\n        }\n\n        var logLevel = levels.indexOf(logLevelConfig) >= 0 ? logLevelConfig : 'info';\n\n        // Set default error logging\n        if (_.isObject(message) && _.isEmpty(data)) {\n            if (message.message && _.isString(message.message)) {\n                data = message.stack || \"\";\n                message = message.message;\n            }\n            else {\n                data = message;\n                message = null;\n            }\n        }\n\n        //Output\n        if (levels.indexOf(level) <= levels.indexOf(logLevel)) {\n            var logString = \"\";\n\n            if (env.logFormat === 'json') {\n                logString = JSON.stringify({\n                    timestamp: new Date().toISOString(),\n                    level,\n                    tag,\n                    message,\n                    data,\n                    hostname: Shared.getCurrentHostId(),\n                    pid: process.pid,\n                    mode: env.mode\n                });\n            } else {\n                if (_.isObject(data)) {\n                    data = Util.inspect(data, {showHidden: false, depth: null});\n                }\n\n                logString += new Date().toISOString() + ' ';\n                logString += '[' + level + ']';\n                logString += tag == \"default\" ? \"\" : ' [' + tag + ']';\n                logString += !_.isString(message) ? \"\" : ': ' + message;\n                logString += data ? ' --> ' + data : \"\";\n            }\n\n            if ([\"error\", \"fatal\"].indexOf(level) >= 0) {\n                _outputLog(\"error\", logString);\n            } else if (level == \"warn\") {\n                _outputLog(\"warn\", logString);\n            } else {\n                _outputLog(\"info\", logString);\n            }\n        }\n    }", "label": 3}
{"code": "def delete(community):\n    \"\"\"Delete a community.\"\"\"\n    deleteform = DeleteCommunityForm(formdata=request.values)\n    ctx = mycommunities_ctx()\n    ctx.update({\n        'deleteform': deleteform,\n        'is_new': False,\n        'community': community,\n    })\n\n    if deleteform.validate_on_submit():\n        community.delete()\n        db.session.commit()\n        flash(\"Community was deleted.\", category='success')\n        return redirect(url_for('.index'))\n    else:\n        flash(\"Community could not be deleted.\", category='warning')\n        return redirect(url_for('.edit', community_id=community.id))", "label": 1}
{"code": "func (e *podEnv) loadNets() ([]activeNet, error) {\n\tif e.netsLoadList.None() {\n\t\tstderr.Printf(\"networking namespace with loopback only\")\n\t\treturn nil, nil\n\t}\n\n\tnets, err := e.newNetLoader().loadNets(e.netsLoadList)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnetSlice := make([]activeNet, 0, len(nets))\n\tfor _, net := range nets {\n\t\tnetSlice = append(netSlice, net)\n\t}\n\tsort.Sort(byFilename(netSlice))\n\n\tmissing := missingNets(e.netsLoadList, netSlice)\n\tif len(missing) > 0 {\n\t\treturn nil, fmt.Errorf(\"networks not found: %v\", strings.Join(missing, \", \"))\n\t}\n\n\t// Add the runtime args to the network instances.\n\t// We don't do this earlier because we also load networks in other contexts\n\tfor _, n := range nets {\n\t\tn.runtime.Args = e.netsLoadList.SpecificArgs(n.conf.Name)\n\t}\n\treturn netSlice, nil\n}", "label": 5}
{"code": "public function waitUntilComplete(array $options = [])\n    {\n        $options += $this->queryResultsOptions;\n        $maxRetries = $this->pluck('maxRetries', $options, false);\n        $this->wait(\n            function () {\n                return $this->isComplete();\n            },\n            function () use ($options) {\n                return $this->reload($options);\n            },\n            $this->job,\n            $maxRetries\n        );\n    }", "label": 2}
{"code": "def unauth(request):\n    \"\"\"\n    logout and remove all session data\n    \"\"\"\n    if check_key(request):\n        api = get_api(request)\n        request.session.clear()\n        logout(request)\n    return HttpResponseRedirect(reverse('main'))", "label": 1}
{"code": "def render_raw(*args)\n      params = arguments(args).params\n      params['data'] = args.shift\n      params['raw'] = true\n      params['accept'] = params.fetch('accept') { 'text/plain' }\n\n      post_request(\"markdown/raw\", params)\n    end", "label": 4}
{"code": "public function delete(array $options = [])\n    {\n        return $this->connection->deleteSession($options + [\n            'name' => $this->name(),\n            'database' => $this->database\n        ]);\n    }", "label": 2}
{"code": "func EnsureJumpRule(fromChain, toChain string) error {\n\tvar (\n\t\ttable = Filter\n\t\targs  = []string{\"-j\", toChain}\n\t)\n\n\tif Exists(table, fromChain, args...) {\n\t\terr := RawCombinedOutput(append([]string{\"-D\", fromChain}, args...)...)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to remove jump to %s rule in %s chain: %s\", toChain, fromChain, err.Error())\n\t\t}\n\t}\n\n\terr := RawCombinedOutput(append([]string{\"-I\", fromChain}, args...)...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to insert jump to %s rule in %s chain: %s\", toChain, fromChain, err.Error())\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "def depend_on(path)\n      if environment.absolute_path?(path) && environment.stat(path)\n        @dependencies << environment.build_file_digest_uri(path)\n      else\n        resolve(path)\n      end\n      nil\n    end", "label": 4}
{"code": "function parseRequirements(file) {\n  if (!file) {\n    return {};\n  }\n  file = file.trim();\n  if (file === '') {\n    return {};\n  }\n  const versions = {};\n  file.split('\\n').forEach((line) => {\n    line = line.trim();\n\n    if (line.startsWith('-e')) {\n      // editable special dependency\n      const branchSeparator = line.indexOf('@');\n      const name = line.slice(0, branchSeparator).trim();\n      versions[name] = line.slice(branchSeparator).trim();\n      return;\n    }\n\n    if (line.startsWith('#') || line.startsWith('-')) {\n      return; // skip\n    }\n    const versionSeparator = line.search(/[\\^~=>!]/);\n    if (versionSeparator >= 0) {\n      const name = line.slice(0, versionSeparator).trim();\n      versions[name] = line.slice(versionSeparator).trim();\n    } else {\n      versions[line] = '';\n    }\n  });\n  return versions;\n}", "label": 3}
{"code": "private function deserializeResult($operation, $type, $serializer, array $mappers)\n    {\n        $mappers = array_filter($mappers, function ($mapper) use ($type) {\n            return $mapper['typeUrl'] === $type;\n        });\n\n        if (count($mappers) === 0) {\n            throw new \\RuntimeException(sprintf('No mapper exists for operation response type %s.', $type));\n        }\n\n        $mapper = current($mappers);\n        $message = $mapper['message'];\n\n        $response = new $message();\n        $anyResponse = $operation->getLastProtoResponse()->getResponse();\n\n        if (is_null($anyResponse)) {\n            return null;\n        }\n\n        $response->mergeFromString($anyResponse->getValue());\n\n        return $serializer->encodeMessage($response);\n    }", "label": 2}
{"code": "function diff(arr, remove) {\n  if (arr == null) {\n    return [];\n  }\n\n  if (remove == null) {\n    return arr;\n  }\n\n  var res = [];\n  var len = arr.length;\n  var i = 0;\n\n  while (i < len) {\n    var ele = arr[i++];\n\n    if (remove.indexOf(ele) === -1) {\n      res.push(ele);\n    }\n  }\n\n  return res;\n}", "label": 3}
{"code": "public Object getRealObjectIfMaterialized(Object objectOrProxy)\r\n    {\r\n        if(isNormalOjbProxy(objectOrProxy))\r\n        {\r\n            String msg;\r\n\r\n            try\r\n            {\r\n                IndirectionHandler handler = getIndirectionHandler(objectOrProxy);\r\n\r\n                return handler.alreadyMaterialized() ? handler.getRealSubject() : null;\r\n            }\r\n            catch(ClassCastException e)\r\n            {\r\n                // shouldn't happen but still ...\r\n                msg = \"The InvocationHandler for the provided Proxy was not an instance of \" + IndirectionHandler.class.getName();\r\n                log.error(msg);\r\n                throw new PersistenceBrokerException(msg, e);\r\n            }\r\n            catch(IllegalArgumentException e)\r\n            {\r\n                msg = \"Could not retrieve real object for given Proxy: \" + objectOrProxy;\r\n                log.error(msg);\r\n                throw new PersistenceBrokerException(msg, e);\r\n            }\r\n            catch(PersistenceBrokerException e)\r\n            {\r\n                log.error(\"Could not retrieve real object for given Proxy: \" + objectOrProxy);\r\n                throw e;\r\n            }\r\n        }\r\n        else if(isVirtualOjbProxy(objectOrProxy))\r\n        {\r\n            try\r\n            {\r\n                VirtualProxy proxy = (VirtualProxy) objectOrProxy;\r\n\r\n                return proxy.alreadyMaterialized() ? proxy.getRealSubject() : null;\r\n            }\r\n            catch(PersistenceBrokerException e)\r\n            {\r\n                log.error(\"Could not retrieve real object for VirtualProxy: \" + objectOrProxy);\r\n                throw e;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return objectOrProxy;\r\n        }\r\n    }", "label": 0}
{"code": "func (tl TypeLoader) LoadEnums(args *ArgType) (map[string]*Enum, error) {\n\tvar err error\n\n\t// not supplied, so bail\n\tif tl.EnumList == nil {\n\t\treturn nil, nil\n\t}\n\n\t// load enums\n\tenumList, err := tl.EnumList(args.DB, args.Schema)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// process enums\n\tenumMap := map[string]*Enum{}\n\tfor _, e := range enumList {\n\t\tenumTpl := &Enum{\n\t\t\tName:              SingularizeIdentifier(e.EnumName),\n\t\t\tSchema:            args.Schema,\n\t\t\tValues:            []*EnumValue{},\n\t\t\tEnum:              e,\n\t\t\tReverseConstNames: args.UseReversedEnumConstNames,\n\t\t}\n\n\t\terr = tl.LoadEnumValues(args, enumTpl)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tenumMap[enumTpl.Name] = enumTpl\n\t\targs.KnownTypeMap[enumTpl.Name] = true\n\t}\n\n\t// generate enum templates\n\tfor _, e := range enumMap {\n\t\terr = args.ExecuteTemplate(EnumTemplate, e.Name, \"\", e)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn enumMap, nil\n}", "label": 5}
{"code": "def create(cls, entry):\n        \"\"\"\n        Factory that creates an bot config from an entry in INSTALLED_APPS.\n        \"\"\"\n        # trading_bots.example.bot.ExampleBot\n        try:\n            # If import_module succeeds, entry is a path to a bot module,\n            # which may specify a bot class with a default_bot attribute.\n            # Otherwise, entry is a path to a bot class or an error.\n            module = import_module(entry)\n\n        except ImportError:\n            # Track that importing as a bot module failed. If importing as a\n            # bot class fails too, we'll trigger the ImportError again.\n            module = None\n\n            mod_path, _, cls_name = entry.rpartition('.')\n\n            # Raise the original exception when entry cannot be a path to an\n            # bot config class.\n            if not mod_path:\n                raise\n\n        else:\n            try:\n                # If this works, the bot module specifies a bot class.\n                entry = module.default_bot\n            except AttributeError:\n                # Otherwise, it simply uses the default bot registry class.\n                return cls(f'{entry}.Bot', module)\n            else:\n                mod_path, _, cls_name = entry.rpartition('.')\n\n        # If we're reaching this point, we must attempt to load the bot\n        # class located at <mod_path>.<cls_name>\n        mod = import_module(mod_path)\n        try:\n            bot_cls = getattr(mod, cls_name)\n        except AttributeError:\n            if module is None:\n                # If importing as an bot module failed, that error probably\n                # contains the most informative traceback. Trigger it again.\n                import_module(entry)\n            raise\n\n        # Check for obvious errors. (This check prevents duck typing, but\n        # it could be removed if it became a problem in practice.)\n        if not issubclass(bot_cls, Bot):\n            raise ImproperlyConfigured(\n                \"'%s' isn't a subclass of Bot.\" % entry)\n\n        # Entry is a path to an bot config class.\n        return cls(entry, mod, bot_cls.label)", "label": 1}
{"code": "def with_value(self, key, val):\n        ''' Return a copy of the AuthContext object with the given key and\n        value added.\n        '''\n        new_dict = dict(self._dict)\n        new_dict[key] = val\n        return AuthContext(new_dict)", "label": 1}
{"code": "def update_settings(instance_id, settings)\n      params = {\n        :instance_id => instance_id\n      }\n\n      instance = Models::RegistryInstance[params] || Models::RegistryInstance.new(params)\n      instance.settings = settings\n      instance.save\n    end", "label": 4}
{"code": "def connection(api, options = {})\n      connection_options = default_options(options)\n      connection_options.merge!(builder: stack(options.merge!(api: api)))\n      if options[:connection_options]\n        connection_options.deep_merge!(options[:connection_options])\n      end\n      if ENV['DEBUG']\n        p \"Connection options : \\n\"\n        pp connection_options\n      end\n      Faraday.new(connection_options)\n    end", "label": 4}
{"code": "@SuppressWarnings(\"deprecation\")\n\tpublic static boolean timeEquals(java.util.Date d1, java.util.Date d2) {\n        if (d1 == null || d2 == null) {\n            return false;\n        }\n\n        return d1.getHours() == d2.getHours()\n                && d1.getMinutes() == d2.getMinutes()\n                && d1.getSeconds() == d2.getSeconds();\n    }", "label": 0}
{"code": "def _trim_xpath(self, xpath, prop):\n        \"\"\" Removes primitive type tags from an XPATH \"\"\"\n\n        xroot = self._get_xroot_for(prop)\n\n        if xroot is None and isinstance(xpath, string_types):\n            xtags = xpath.split(XPATH_DELIM)\n\n            if xtags[-1] in _iso_tag_primitives:\n                xroot = XPATH_DELIM.join(xtags[:-1])\n\n        return xroot", "label": 1}
{"code": "func (a *AuthServer) NewWatcher(ctx context.Context, watch services.Watch) (services.Watcher, error) {\n\treturn a.GetCache().NewWatcher(ctx, watch)\n}", "label": 5}
{"code": "private function completeOwningSide(AssociationMetadata $property, $targetObject)\n    {\n        // add this object on the owning side as well, for obvious infinite recursion\n        // reasons this is only done when called on the inverse side.\n        if ($property->isOwningSide()) {\n            return;\n        }\n\n        $mappedByField    = $property->getMappedBy();\n        $targetMetadata   = self::$entityManager->getClassMetadata($property->getTargetEntity());\n        $targetProperty   = $targetMetadata->getProperty($mappedByField);\n        $setterMethodName = ($targetProperty instanceof ToManyAssociationMetadata ? 'add' : 'set') . $mappedByField;\n\n        $targetObject->{$setterMethodName}($this);\n    }", "label": 2}
{"code": "public function setAction($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Debugger\\V2\\ListBreakpointsRequest_BreakpointActionValue::class);\n        $this->action = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "def handleRequest(self, req):\n        \"\"\"handles a request by calling the appropriete method the service exposes\"\"\"\n        name = req[\"method\"]\n        params = req[\"params\"]\n        id=req[\"id\"]\n        obj=None\n        try: #to get a callable obj \n            obj = getMethodByName(self.service, name)\n        except MethodNameNotAllowed,e:\n            self.sendResponse(id, None, e)\n        except:\n            self.sendResponse(id, None, MethodNotFound())\n        if obj:\n            try: #to call the object with parameters\n                rslt = obj(*params)\n                self.sendResponse(id, rslt, None)\n            except TypeError: # wrong arguments\n                #todo what if the TypeError was not thrown directly by the callable obj\n                s=getTracebackStr()\n                self.sendResponse(id, None, InvalidMethodParameters())\n            except: #error inside the callable object\n                s=getTracebackStr()\n                self.sendResponse(id, None, s)", "label": 1}
{"code": "public void addClass(ClassDescriptorDef classDef)\r\n    {\r\n        classDef.setOwner(this);\r\n        // Regardless of the format of the class name, we're using the fully qualified format\r\n        // This is safe because of the package & class naming constraints of the Java language\r\n        _classDefs.put(classDef.getQualifiedName(), classDef);\r\n    }", "label": 0}
{"code": "def fetch(table, cols=\"*\", where=(), group=\"\", order=(), limit=(), **kwargs):\r\n    \"\"\"Convenience wrapper for database SELECT and fetch all.\"\"\"\r\n    return select(table, cols, where, group, order, limit, **kwargs).fetchall()", "label": 1}
{"code": "function(viewOptions) {\n      var view = this;\n      if (!_.isEmpty(this.behaviors)) {\n        view.__behaviorInstances = {};\n        _.each(this.behaviors, function(behaviorDefinition, alias) {\n          if (!_.has(behaviorDefinition, 'behavior')) {\n            behaviorDefinition = {behavior: behaviorDefinition};\n          }\n          var BehaviorClass = behaviorDefinition.behavior;\n          if (!(BehaviorClass && _.isFunction(BehaviorClass))) {\n            throw new Error('Incorrect behavior definition. Expected key \"behavior\" to be a class but instead got ' +\n              String(BehaviorClass));\n          }\n\n          var behaviorOptions = _.pick(behaviorDefinition, function(value, key) {\n            return key !== 'behavior';\n          });\n          behaviorOptions.view = view;\n          behaviorOptions.alias = alias;\n          var behaviorAttributes = behaviorDefinition.attributes || {};\n          var behaviorInstance = view.__behaviorInstances[alias] = new BehaviorClass(behaviorAttributes, behaviorOptions, viewOptions);\n          // Add the behavior's mixin fields to the view's public API\n          if (behaviorInstance.mixin) {\n            var mixin = _.result(behaviorInstance, 'mixin');\n            _.each(mixin, function(field, fieldName) {\n              // Default to a view's field over a behavior mixin\n              if (_.isUndefined(view[fieldName])) {\n                if (_.isFunction(field)) {\n                  // Behavior mixin functions will be behavior-scoped - the context will be the behavior.\n                  view[fieldName] = _.bind(field, behaviorInstance);\n                } else {\n                  view[fieldName] = field;\n                }\n              }\n            });\n          }\n        });\n      }\n    }", "label": 3}
{"code": "func AppInfoPath(root string, appName types.ACName) string {\n\treturn filepath.Join(AppsInfoPath(root), appName.String())\n}", "label": 5}
{"code": "public static Object newInstance(String className, Class type, Object arg) throws InstantiationException,\r\n                                                                                      IllegalAccessException,\r\n                                                                                      IllegalArgumentException,\r\n                                                                                      InvocationTargetException,\r\n                                                                                      NoSuchMethodException,\r\n                                                                                      SecurityException,\r\n                                                                                      ClassNotFoundException\r\n    {\r\n        return newInstance(className, new Class[]{type}, new Object[]{arg});\r\n    }", "label": 0}
{"code": "public static double HighAccuracyFunction(double x) {\n        if (x < -8 || x > 8)\n            return 0;\n\n        double sum = x;\n        double term = 0;\n\n        double nextTerm = x;\n        double pwr = x * x;\n        double i = 1;\n\n        // Iterate until adding next terms doesn't produce\n        // any change within the current numerical accuracy.\n\n        while (sum != term) {\n            term = sum;\n\n            // Next term\n            nextTerm *= pwr / (i += 2);\n\n            sum += nextTerm;\n        }\n\n        return 0.5 + sum * Math.exp(-0.5 * pwr - 0.5 * Constants.Log2PI);\n    }", "label": 0}
{"code": "def get_abs_and_rel_path(path)\n      original_path = Pathname.new(path)\n      root_dir_path = Pathname.new(File.expand_path(Dir.pwd))\n\n      if original_path.absolute?\n        [path, original_path.relative_path_from(root_dir_path)]\n      else\n        [root_dir_path + original_path, path]\n      end\n    end", "label": 4}
{"code": "func (s *PresenceService) GetTrustedClusters() ([]services.TrustedCluster, error) {\n\tstartKey := backend.Key(trustedClustersPrefix)\n\tresult, err := s.GetRange(context.TODO(), startKey, backend.RangeEnd(startKey), backend.NoLimit)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tout := make([]services.TrustedCluster, len(result.Items))\n\tfor i, item := range result.Items {\n\t\ttc, err := services.GetTrustedClusterMarshaler().Unmarshal(item.Value,\n\t\t\tservices.WithResourceID(item.ID), services.WithExpires(item.Expires))\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tout[i] = tc\n\t}\n\n\tsort.Sort(services.SortedTrustedCluster(out))\n\treturn out, nil\n}", "label": 5}
{"code": "function WebService(options) {\n    this.options = opts(this, options);\n    if(!this.options.apiroot) this.options.apiroot = \"https://api.cloudmine.io\";\n\n    var src = this.options.appid;\n    if (options.savelogin) {\n      if (!this.options.email) this.options.email = retrieve('email', src);\n      if (!this.options.username) this.options.username = retrieve('username', src);\n      if (!this.options.session_token) this.options.session_token = retrieve('session_token', src);\n    }\n\n    this.options.user_token = retrieve('ut', src) || store('ut', this.keygen(), src);\n  }", "label": 3}
{"code": "public function setShotLabelAnnotations($var)\n    {\n        $arr = GPBUtil::checkRepeatedField($var, \\Google\\Protobuf\\Internal\\GPBType::MESSAGE, \\Google\\Cloud\\VideoIntelligence\\V1beta2\\LabelAnnotation::class);\n        $this->shot_label_annotations = $arr;\n\n        return $this;\n    }", "label": 2}
{"code": "def dIbr_dV(Yf, Yt, V):\n    \"\"\" Computes partial derivatives of branch currents w.r.t. voltage.\n\n        Ray Zimmerman, \"dIbr_dV.m\", MATPOWER, version 4.0b1,\n        PSERC (Cornell), http://www.pserc.cornell.edu/matpower/\n    \"\"\"\n#        nb = len(V)\n\n    Vnorm = div(V, abs(V))\n    diagV = spdiag(V)\n    diagVnorm = spdiag(Vnorm)\n    dIf_dVa = Yf * 1j * diagV\n    dIf_dVm = Yf * diagVnorm\n    dIt_dVa = Yt * 1j * diagV\n    dIt_dVm = Yt * diagVnorm\n\n    # Compute currents.\n    If = Yf * V\n    It = Yt * V\n\n    return dIf_dVa, dIf_dVm, dIt_dVa, dIt_dVm, If, It", "label": 1}
{"code": "func (c *Client) GenerateToken(req GenerateTokenRequest) (string, error) {\n\tout, err := c.PostJSON(c.Endpoint(\"tokens\"), req)\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\tvar token string\n\tif err := json.Unmarshal(out.Bytes(), &token); err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn token, nil\n}", "label": 5}
{"code": "public static base_responses update(nitro_service client, snmpmanager resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tsnmpmanager updateresources[] = new snmpmanager[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tupdateresources[i] = new snmpmanager();\n\t\t\t\tupdateresources[i].ipaddress = resources[i].ipaddress;\n\t\t\t\tupdateresources[i].netmask = resources[i].netmask;\n\t\t\t\tupdateresources[i].domainresolveretry = resources[i].domainresolveretry;\n\t\t\t}\n\t\t\tresult = update_bulk_request(client, updateresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "function() {\n\t\t\tvar t = this;\n\t\t\t\n\t\t\tsetTimeout(function() {\n\t\t\t\tt.$obj.removeClass(t.factory.classes.play);\n\t\t\t}, this.factory.timer.interval);\n\t\t}", "label": 3}
{"code": "def relationships\n      r = Relationships.new\n      @worksheets.each do |sheet|\n        r << Relationship.new(sheet, WORKSHEET_R, WORKSHEET_PN % (r.size+1))\n      end\n      pivot_tables.each_with_index do |pivot_table, index|\n        r << Relationship.new(pivot_table.cache_definition, PIVOT_TABLE_CACHE_DEFINITION_R, PIVOT_TABLE_CACHE_DEFINITION_PN % (index+1))\n      end\n      r << Relationship.new(self, STYLES_R,  STYLES_PN)\n      if use_shared_strings\n          r << Relationship.new(self, SHARED_STRINGS_R, SHARED_STRINGS_PN)\n      end\n      r\n    end", "label": 4}
{"code": "func NewDatacenter(f *Folder) *Datacenter {\n\tdc := &Datacenter{\n\t\tisESX: f.Self == esx.RootFolder.Self,\n\t}\n\n\tif dc.isESX {\n\t\tdc.Datacenter = esx.Datacenter\n\t}\n\n\tf.putChild(dc)\n\n\tdc.createFolders()\n\n\treturn dc\n}", "label": 5}
{"code": "@SuppressWarnings(\"unchecked\")\r\n  public static <E> E[] filter(E[] elems, Filter<E> filter) {\r\n    List<E> filtered = new ArrayList<E>();\r\n    for (E elem: elems) {\r\n      if (filter.accept(elem)) {\r\n        filtered.add(elem);\r\n      }\r\n    }\r\n    return (filtered.toArray((E[]) Array.newInstance(elems.getClass().getComponentType(), filtered.size())));\r\n  }", "label": 0}
{"code": "def prepend(middleware, *args, &blk)\n      stack.unshift [middleware, args, blk]\n      stack.uniq!\n    end", "label": 4}
{"code": "func (t *Torrent) KnownSwarm() (ks []Peer) {\n\t// Add pending peers to the list\n\tt.peers.Each(func(peer Peer) {\n\t\tks = append(ks, peer)\n\t})\n\n\t// Add half-open peers to the list\n\tfor _, peer := range t.halfOpen {\n\t\tks = append(ks, peer)\n\t}\n\n\t// Add active peers to the list\n\tfor conn := range t.conns {\n\n\t\tks = append(ks, Peer{\n\t\t\tId:     conn.PeerID,\n\t\t\tIP:     conn.remoteAddr.IP,\n\t\t\tPort:   int(conn.remoteAddr.Port),\n\t\t\tSource: conn.Discovery,\n\t\t\t// > If the connection is encrypted, that's certainly enough to set SupportsEncryption.\n\t\t\t// > But if we're not connected to them with an encrypted connection, I couldn't say\n\t\t\t// > what's appropriate. We can carry forward the SupportsEncryption value as we\n\t\t\t// > received it from trackers/DHT/PEX, or just use the encryption state for the\n\t\t\t// > connection. It's probably easiest to do the latter for now.\n\t\t\t// https://github.com/anacrolix/torrent/pull/188\n\t\t\tSupportsEncryption: conn.headerEncrypted,\n\t\t})\n\t}\n\n\treturn\n}", "label": 5}
{"code": "function(connect, options) {\n          return [\n            require('connect-livereload')(),\n            // Default middlewares\n            // Serve static files.\n            connect.static(options.base),\n            // Make empty directories browsable.\n            connect.directory(options.base)\n          ];\n        }", "label": 3}
{"code": "public function send(string $payload = null, string $header = null)\n    {\n        if (is_null($header)) {\n            $this->relay->send($header, Relay::PAYLOAD_CONTROL | Relay::PAYLOAD_NONE);\n        } else {\n            $this->relay->send($header, Relay::PAYLOAD_CONTROL | Relay::PAYLOAD_RAW);\n        }\n\n        $this->relay->send($payload, Relay::PAYLOAD_RAW);\n    }", "label": 2}
{"code": "func (b *BoltBackend) CompareAndSwapVal(bucket []string, key string, newData []byte, prevData []byte, ttl time.Duration) error {\n\tif len(prevData) == 0 {\n\t\treturn trace.BadParameter(\"missing prevData parameter, to atomically create item, use CreateVal method\")\n\t}\n\tv := &kv{\n\t\tCreated: b.clock.Now().UTC(),\n\t\tValue:   newData,\n\t\tTTL:     ttl,\n\t}\n\tnewEncodedData, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn trace.Wrap(err)\n\t}\n\terr = b.db.Update(func(tx *bolt.Tx) error {\n\t\tbkt, err := GetBucket(tx, bucket)\n\t\tif err != nil {\n\t\t\tif trace.IsNotFound(err) {\n\t\t\t\treturn trace.CompareFailed(\"key %q is not found\", key)\n\t\t\t}\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tcurrentData := bkt.Get([]byte(key))\n\t\tif currentData == nil {\n\t\t\t_, err := GetBucket(tx, append(bucket, key))\n\t\t\tif err == nil {\n\t\t\t\treturn trace.BadParameter(\"key %q is a bucket\", key)\n\t\t\t}\n\t\t\treturn trace.CompareFailed(\"%v %v is not found\", bucket, key)\n\t\t}\n\t\tvar currentVal kv\n\t\tif err := json.Unmarshal(currentData, &currentVal); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tif bytes.Compare(prevData, currentVal.Value) != 0 {\n\t\t\treturn trace.CompareFailed(\"%q is not matching expected value\", key)\n\t\t}\n\t\treturn boltErr(bkt.Put([]byte(key), newEncodedData))\n\t})\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "public static sslciphersuite get(nitro_service service, String ciphername) throws Exception{\n\t\tsslciphersuite obj = new sslciphersuite();\n\t\tobj.set_ciphername(ciphername);\n\t\tsslciphersuite response = (sslciphersuite) obj.get_resource(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "protected FieldDescriptor getFieldDescriptor(TableAlias aTableAlias, PathInfo aPathInfo)\r\n    {\r\n        FieldDescriptor fld = null;\r\n        String colName = aPathInfo.column;\r\n\r\n        if (aTableAlias != null)\r\n        {\r\n            fld = aTableAlias.cld.getFieldDescriptorByName(colName);\r\n            if (fld == null)\r\n            {\r\n                ObjectReferenceDescriptor ord = aTableAlias.cld.getObjectReferenceDescriptorByName(colName);\r\n                if (ord != null)\r\n                {\r\n                    fld = getFldFromReference(aTableAlias, ord);\r\n                }\r\n                else\r\n                {\r\n                    fld = getFldFromJoin(aTableAlias, colName);\r\n                }\r\n            }\r\n        }\r\n\r\n        return fld;\r\n    }", "label": 0}
{"code": "def run_rsem(job, star_bams, univ_options, rsem_options):\n    \"\"\"\n    This module will run rsem on the RNA Bam file.\n\n    ARGUMENTS\n    1. star_bams: Dict of input STAR bams\n         star_bams\n              +- 'rnaAligned.toTranscriptome.out.bam': <JSid>\n    2. univ_options: Dict of universal arguments used by almost all tools\n         univ_options\n                +- 'dockerhub': <dockerhub to use>\n    3. rsem_options: Dict of parameters specific to rsem\n         rsem_options\n              |- 'index_tar': <JSid for the rsem index tarball>\n              +- 'n': <number of threads to allocate>\n\n    RETURN VALUES\n    1. output_file: <Jsid of rsem.isoforms.results>\n\n    This module corresponds to node 9 on the tree\n    \"\"\"\n    job.fileStore.logToMaster('Running rsem index on %s' % univ_options['patient'])\n    work_dir = job.fileStore.getLocalTempDir()\n    input_files = {\n        'star_transcriptome.bam': star_bams['rnaAligned.toTranscriptome.out.bam'],\n        'rsem_index.tar.gz': rsem_options['index_tar']}\n    input_files = get_files_from_filestore(job, input_files, work_dir, docker=True)\n    parameters = ['--paired-end',\n                  '-p', str(rsem_options['n']),\n                  '--bam',\n                  input_files['star_transcriptome.bam'],\n                  '--no-bam-output',\n                  '/'.join([input_files['rsem_index'], 'hg19']),\n                  'rsem']\n    docker_call(tool='rsem', tool_parameters=parameters, work_dir=work_dir,\n                dockerhub=univ_options['dockerhub'])\n    output_file = \\\n        job.fileStore.writeGlobalFile('/'.join([work_dir, 'rsem.isoforms.results']))\n    return output_file", "label": 1}
{"code": "func UnmarshalNamespace(data []byte, opts ...MarshalOption) (*Namespace, error) {\n\tif len(data) == 0 {\n\t\treturn nil, trace.BadParameter(\"missing namespace data\")\n\t}\n\n\tcfg, err := collectOptions(opts)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\t// always skip schema validation on namespaces unmarshal\n\t// the namespace is always created by teleport now\n\tvar namespace Namespace\n\tif err := utils.FastUnmarshal(data, &namespace); err != nil {\n\t\treturn nil, trace.BadParameter(err.Error())\n\t}\n\n\tif err := namespace.CheckAndSetDefaults(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\tif cfg.ID != 0 {\n\t\tnamespace.Metadata.ID = cfg.ID\n\t}\n\tif !cfg.Expires.IsZero() {\n\t\tnamespace.Metadata.Expires = &cfg.Expires\n\t}\n\n\treturn &namespace, nil\n}", "label": 5}
{"code": "def perform(job)\n      begin\n        if fork_per_job?\n          reconnect\n          run_hook :after_fork, job\n        end\n        job.perform\n      rescue Object => e\n        report_failed_job(job,e)\n      else\n        log_with_severity :info, \"done: #{job.inspect}\"\n      ensure\n        yield job if block_given?\n      end\n    end", "label": 4}
{"code": "function _populateMeta() {\n    self.meta = {\n      activeWatchInfo: Pebble.getActiveWatchInfo && Pebble.getActiveWatchInfo(),\n      accountToken: Pebble.getAccountToken(),\n      watchToken: Pebble.getWatchToken(),\n      userData: deepcopy(options.userData || {})\n    };\n  }", "label": 3}
{"code": "def create_for_locale\n      field_key = FieldKey.find_by_global_key(params[:i18n_key])\n      phrase = I18n::Backend::ActiveRecord::Translation.find_or_create_by(\n        key: field_key.global_key,\n      locale: params[:locale]\n)\n      unless phrase.value.present?\n        I18n.backend.reload!\n        phrase.value = params[:i18n_value]\n        phrase.save!\n      end\n      render json: { success: true }\n    end", "label": 4}
{"code": "func (a *HistoricalApi) availableFreeContainerMetrics(request *restful.Request, response *restful.Response) {\n\tkey := core.HistoricalKey{\n\t\tObjectType:    core.MetricSetTypeSystemContainer,\n\t\tNodeName:      request.PathParameter(\"node-name\"),\n\t\tContainerName: request.PathParameter(\"container-name\"),\n\t}\n\ta.processMetricNamesRequest(key, response)\n}", "label": 5}
{"code": "public double Function2D(double x, double y) {\n        double frequency = initFrequency;\n        double amplitude = initAmplitude;\n        double sum = 0;\n\n        // octaves\n        for (int i = 0; i < octaves; i++) {\n            sum += SmoothedNoise(x * frequency, y * frequency) * amplitude;\n\n            frequency *= 2;\n            amplitude *= persistence;\n        }\n        return sum;\n    }", "label": 0}
{"code": "function assert (validator, message) {\n\tmessage = messageBuilder(message || 'vet/utils/assert error!');\n\n\tif (isFunction(validator)) {\n\t\treturn function() {\n\t\t\tvar args = arguments;\n\t\t\tif (validator.apply(this, args)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthrow new Error(message.apply(this, args));\n\t\t\t}\n\t\t};\n\t} else if (!validator) {\n\t\tthrow new Error(message.apply(this));\n\t} else {\n\t\treturn true;\n\t}\n\n}", "label": 3}
{"code": "private static void reverse(int first, int last, Swapper swapper) {\r\n\t// no more needed since manually inlined\r\n\twhile (first < --last) {\r\n\t\tswapper.swap(first++,last);\r\n\t}\r\n}", "label": 0}
{"code": "def association(name, *options)\n      if block_given?\n        raise AssociationDefinitionError.new(\n          \"Unexpected block passed to '#{name}' association \"\\\n          \"in '#{@definition.name}' factory\",\n        )\n      else\n        declaration = Declaration::Association.new(name, *options)\n        @definition.declare_attribute(declaration)\n      end\n    end", "label": 4}
{"code": "def mkcol(path, options = {}, &block)\n      perform_request Net::HTTP::Mkcol, path, options, &block\n    end", "label": 4}
{"code": "function scale(progress) {\n  var to = (this.options.to !== undefined) ? this.options.to : 1;\n  var from = (this.options.from !== undefined) ? this.options.from : this.transforms.scale[0];\n  var scale = (to - from) * progress + from;\n\n  this.transforms.scale[0] = scale;\n  this.transforms.scale[1] = scale;\n}", "label": 3}
{"code": "def handle_control_command(command)\n      exit_reason = nil\n      if command.cancel_signal?\n        UI.verbose(\"received cancel signal shutting down, reason: #{command.reason}\")\n\n        # send an ack to the client to let it know we're shutting down\n        cancel_response = '{\"payload\":{\"status\":\"cancelled\"}}'\n        send_response(cancel_response)\n\n        exit_reason = :cancelled\n      elsif command.done_signal?\n        UI.verbose(\"received done signal shutting down\")\n\n        # client is already in the process of shutting down, no need to ack\n        exit_reason = :done\n      end\n\n      # if the command came in with a user-facing message, display it\n      if command.user_message\n        UI.important(command.user_message)\n      end\n\n      # currently all control commands should trigger a disconnect and shutdown\n      handle_disconnect(error: false, exit_reason: exit_reason)\n      return COMMAND_EXECUTION_STATE[:already_shutdown]\n    end", "label": 4}
{"code": "public static ArrayList<MtasTreeHit<?>> advanceMtasTree(int position,\n      IndexInput in, long ref, long objectRefApproxOffset) throws IOException {\n    ArrayList<MtasTreeHit<?>> list = new ArrayList<MtasTreeHit<?>>();\n    ArrayList<MtasTreeItem> checkList = new ArrayList<MtasTreeItem>();\n    AtomicBoolean isSinglePoint = new AtomicBoolean(false);\n    AtomicBoolean isStoreAdditonalId = new AtomicBoolean(false);\n    AtomicLong nodeRefApproxOffset = new AtomicLong(-1);\n    checkList.add(getMtasTreeItem(ref, isSinglePoint, isStoreAdditonalId,\n        nodeRefApproxOffset, in, objectRefApproxOffset));\n    ArrayList<Long> history = new ArrayList<Long>();\n    do {\n      MtasTreeItem checkItem = checkList.remove(checkList.size() - 1);\n      advanceMtasTree(checkItem, position, in, isSinglePoint,\n          isStoreAdditonalId, objectRefApproxOffset, list, nodeRefApproxOffset,\n          checkList);\n      history.add(checkItem.ref);\n      if (history.size() > 1000) {\n        throw new IOException(\n            \"ADVANCE \" + position + \" \" + checkList + \"\\n\" + history);\n      }\n    } while (checkList.size() > 0);\n    return list;\n  }", "label": 0}
{"code": "def verify?(params)\n      params = Utils.stringify_keys(params)\n      return false if params['sign_type'] != @sign_type\n\n      sign = params.delete('sign')\n      # sign_type does not use in notify sign\n      params.delete('sign_type')\n      string = params_to_string(params)\n      case @sign_type\n      when 'RSA'\n        ::Alipay::Sign::RSA.verify?(@alipay_public_key, string, sign)\n      when 'RSA2'\n        ::Alipay::Sign::RSA2.verify?(@alipay_public_key, string, sign)\n      else\n        raise \"Unsupported sign_type: #{@sign_type}\"\n      end\n    end", "label": 4}
{"code": "func (t *Text) SetAlignment(align Alignment) {\n\tif align != t.align {\n\t\tt.align = align\n\t\tt.PostEventWidgetContent(t)\n\t}\n}", "label": 5}
{"code": "public function projection($properties)\n    {\n        if (!is_array($properties)) {\n            $properties = [$properties];\n        }\n\n        foreach ($properties as $property) {\n            $this->query['projection'][] = [\n                'property' => $this->propertyName($property)\n            ];\n        }\n\n        return $this;\n    }", "label": 2}
{"code": "protected function createTwitterDriver()\n    {\n        $config = $this->app['config']['services.twitter'];\n\n        return new TwitterProvider(\n            $this->app['request'], new TwitterServer($this->formatConfig($config))\n        );\n    }", "label": 2}
{"code": "def explain(value = nil)\n      chain { criteria.update_request_options explain: (value.nil? ? true : value) }\n    end", "label": 4}
{"code": "function insert(outMap, inMap, length, index) {\n  // Move existing mappings\n  if (length) {\n    outMap._mappings.unsortedForEach(mapping => {\n      if (mapping.generatedLine > index) mapping.generatedLine += length;\n    });\n  }\n\n  // Add new mappings\n  if (inMap) {\n    const inConsumer = new SourceMapConsumer(inMap.toJSON());\n\n    inConsumer.eachMapping(mapping => {\n      outMap.addMapping({\n        source: mapping.source,\n        original: mapping.source == null\n          ? null\n          : {\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            },\n        generated: {\n          line: index + mapping.generatedLine - 1,\n          column: mapping.generatedColumn\n        }\n      });\n    });\n\n    inConsumer.sources.forEach((source, idx) => {\n      outMap.setSourceContent(source, inConsumer.sourcesContent[idx]);\n    });\n  }\n}", "label": 3}
{"code": "def _add_node(self, node, depth):\n        \"\"\"Add a node to the graph, and the stack.\"\"\"\n        self._topmost_node.add_child(node, bool(depth[1]))\n        self._stack.append((depth, node))", "label": 1}
{"code": "func (l *LiteBackend) showPragmas() error {\n\treturn l.inTransaction(l.ctx, func(tx *sql.Tx) error {\n\t\trow := tx.QueryRowContext(l.ctx, \"PRAGMA synchronous;\")\n\t\tvar syncValue string\n\t\tif err := row.Scan(&syncValue); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tvar timeoutValue string\n\t\trow = tx.QueryRowContext(l.ctx, \"PRAGMA busy_timeout;\")\n\t\tif err := row.Scan(&timeoutValue); err != nil {\n\t\t\treturn trace.Wrap(err)\n\t\t}\n\t\tl.Debugf(\"Synchronous: %v, busy timeout: %v\", syncValue, timeoutValue)\n\t\treturn nil\n\t})\n}", "label": 5}
{"code": "def flat_pmap(enumerable)\n      return to_enum(:flat_pmap, enumerable) unless block_given?\n      pmap(enumerable, &Proc.new).flatten(1)\n    end", "label": 4}
{"code": "def get_linked_version(doi):\n    \"\"\"\n    Get the original link behind the DOI.\n\n    :param doi: A canonical DOI.\n    :returns: The canonical URL behind the DOI, or ``None``.\n\n    >>> get_linked_version('10.1209/0295-5075/111/40005')\n    'http://stacks.iop.org/0295-5075/111/i=4/a=40005?key=crossref.9ad851948a976ecdf216d4929b0b6f01'\n    \"\"\"\n    try:\n        request = requests.head(to_url(doi))\n        return request.headers.get(\"location\")\n    except RequestException:\n        return None", "label": 1}
{"code": "protected void addArguments(FieldDescriptor field[])\r\n    {\r\n        for (int i = 0; i < field.length; i++)\r\n        {\r\n            ArgumentDescriptor arg = new ArgumentDescriptor(this);\r\n            arg.setValue(field[i].getAttributeName(), false);\r\n            this.addArgument(arg);\r\n        }\r\n    }", "label": 0}
{"code": "def server_static(filepath):\r\n    \"\"\"Handler for serving static files.\"\"\"\r\n    mimetype = \"image/svg+xml\" if filepath.endswith(\".svg\") else \"auto\"\r\n    return bottle.static_file(filepath, root=conf.StaticPath, mimetype=mimetype)", "label": 1}
{"code": "public function merge_array( $config ) {\n\t\tforeach ( $this->spec as $key => $details ) {\n\t\t\tif ( false !== $details['runtime'] && isset( $config[ $key ] ) ) {\n\t\t\t\t$value = $config[ $key ];\n\n\t\t\t\tif ( 'require' === $key ) {\n\t\t\t\t\t$value = \\WP_CLI\\Utils\\expand_globs( $value );\n\t\t\t\t}\n\n\t\t\t\tif ( $details['multiple'] ) {\n\t\t\t\t\tself::arrayify( $value );\n\t\t\t\t\t$this->config[ $key ] = array_merge( $this->config[ $key ], $value );\n\t\t\t\t} else {\n\t\t\t\t\t$this->config[ $key ] = $value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "label": 2}
{"code": "function isInSomeParsingContext() {\n            for (var kind = 0; kind < 26 /* Count */; kind++) {\n                if (parsingContext & (1 << kind)) {\n                    if (isListElement(kind, /*inErrorRecovery*/ true) || isListTerminator(kind)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "label": 3}
{"code": "def append_path(path)\n      self.config = hash_reassoc(config, :paths) do |paths|\n        path = File.expand_path(path, config[:root]).freeze\n        paths.push(path)\n      end\n    end", "label": 4}
{"code": "func ProgramRule(table Table, chain string, action Action, args []string) error {\n\tif Exists(table, chain, args...) != (action == Delete) {\n\t\treturn nil\n\t}\n\treturn RawCombinedOutput(append([]string{\"-t\", string(table), string(action), chain}, args...)...)\n}", "label": 5}
{"code": "function (parent) {\n\n            var renderer = this.renderer,\n              parentWrapper = parent || renderer,\n              parentNode = parentWrapper.element || renderer.box,\n              childNodes,\n              element = this.element,\n              zIndex = this.zIndex,\n              otherElement,\n              otherZIndex,\n              i,\n              inserted;\n\n            if (parent) {\n                this.parentGroup = parent;\n            }\n\n            // mark as inverted\n            this.parentInverted = parent && parent.inverted;\n\n            // build formatted text\n            if (this.textStr !== undefined) {\n                renderer.buildText(this);\n            }\n\n            // mark the container as having z indexed children\n            if (zIndex) {\n                parentWrapper.handleZ = true;\n                zIndex = pInt(zIndex);\n            }\n\n            // insert according to this and other elements' zIndex\n            if (parentWrapper.handleZ) { // this element or any of its siblings has a z index\n                childNodes = parentNode.childNodes;\n                for (i = 0; i < childNodes.length; i++) {\n                    otherElement = childNodes[i];\n                    otherZIndex = attr(otherElement, 'zIndex');\n                    if (otherElement !== element && (\n                          // insert before the first element with a higher zIndex\n                        pInt(otherZIndex) > zIndex ||\n                            // if no zIndex given, insert before the first element with a zIndex\n                        (!defined(zIndex) && defined(otherZIndex))\n\n                      )) {\n                        parentNode.insertBefore(element, otherElement);\n                        inserted = true;\n                        break;\n                    }\n                }\n            }\n\n            // default: append at the end\n            if (!inserted) {\n                parentNode.appendChild(element);\n            }\n\n            // mark as added\n            this.added = true;\n\n            // fire an event for internal hooks\n            if (this.onAdd) {\n                this.onAdd();\n            }\n\n            return this;\n        }", "label": 3}
{"code": "function stopDefaultBrowserBehavior(element, css_props) {\n    if(!css_props || !element || !element.style) {\n      return;\n    }\n\n    // with css properties for modern browsers\n    Hammer.utils.each(['webkit', 'khtml', 'moz', 'Moz', 'ms', 'o', ''], function(vendor) {\n      Hammer.utils.each(css_props, function(value, prop) {\n          // vender prefix at the property\n          if(vendor) {\n            prop = vendor + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n          }\n          // set the style\n          if(prop in element.style) {\n            element.style[prop] = value;\n          }\n      });\n    });\n\n    // also the disable onselectstart\n    if(css_props.userSelect == 'none') {\n      element.onselectstart = function() {\n        return false;\n      };\n    }\n\n    // and disable ondragstart\n    if(css_props.userDrag == 'none') {\n      element.ondragstart = function() {\n        return false;\n      };\n    }\n  }", "label": 3}
{"code": "function colorChanged(elem) {\n\t\tvar color = elem.getAttribute('stroke');\n\n\t\t$.each(mtypes, function(i, pos) {\n\t\t\tvar marker = getLinked(elem, 'marker-'+pos);\n\t\t\tif (!marker) {return;}\n\t\t\tif (!marker.attributes.se_type) {return;} // not created by this extension\n\t\t\tvar ch = marker.lastElementChild;\n\t\t\tif (!ch) {return;}\n\t\t\tvar curfill = ch.getAttribute('fill');\n\t\t\tvar curstroke = ch.getAttribute('stroke');\n\t\t\tif (curfill && curfill != 'none') {ch.setAttribute('fill', color);}\n\t\t\tif (curstroke && curstroke != 'none') {ch.setAttribute('stroke', color);}\n\t\t});\n\t}", "label": 3}
{"code": "public static base_responses delete(nitro_service client, dnsaaaarec resources[]) throws Exception {\n\t\tbase_responses result = null;\n\t\tif (resources != null && resources.length > 0) {\n\t\t\tdnsaaaarec deleteresources[] = new dnsaaaarec[resources.length];\n\t\t\tfor (int i=0;i<resources.length;i++){\n\t\t\t\tdeleteresources[i] = new dnsaaaarec();\n\t\t\t\tdeleteresources[i].hostname = resources[i].hostname;\n\t\t\t\tdeleteresources[i].ipv6address = resources[i].ipv6address;\n\t\t\t}\n\t\t\tresult = delete_bulk_request(client, deleteresources);\n\t\t}\n\t\treturn result;\n\t}", "label": 0}
{"code": "public static long count(nitro_service service, String vservername) throws Exception{\n\t\tsslvserver_sslciphersuite_binding obj = new sslvserver_sslciphersuite_binding();\n\t\tobj.set_vservername(vservername);\n\t\toptions option = new options();\n\t\toption.set_count(true);\n\t\tsslvserver_sslciphersuite_binding response[] = (sslvserver_sslciphersuite_binding[]) obj.get_resources(service,option);\n\t\tif (response != null) {\n\t\t\treturn response[0].__count;\n\t\t}\n\t\treturn 0;\n\t}", "label": 0}
{"code": "func (c *Client) Upload(ctx context.Context, src io.Reader, dst string, p soap.Upload, attr types.BaseGuestFileAttributes, force bool) error {\n\tvc := c.ProcessManager.Client()\n\n\tvar err error\n\n\tif p.ContentLength == 0 { // Content-Length is required\n\t\tswitch r := src.(type) {\n\t\tcase *bytes.Buffer:\n\t\t\tp.ContentLength = int64(r.Len())\n\t\tcase *bytes.Reader:\n\t\t\tp.ContentLength = int64(r.Len())\n\t\tcase *strings.Reader:\n\t\t\tp.ContentLength = int64(r.Len())\n\t\tcase *os.File:\n\t\t\tinfo, serr := r.Stat()\n\t\t\tif serr != nil {\n\t\t\t\treturn serr\n\t\t\t}\n\n\t\t\tp.ContentLength = info.Size()\n\t\t}\n\n\t\tif p.ContentLength == 0 { // os.File for example could be a device (stdin)\n\t\t\tbuf := new(bytes.Buffer)\n\n\t\t\tp.ContentLength, err = io.Copy(buf, src)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tsrc = buf\n\t\t}\n\t}\n\n\turl, err := c.FileManager.InitiateFileTransferToGuest(ctx, c.Authentication, dst, attr, p.ContentLength, force)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tu, err := c.FileManager.TransferURL(ctx, url)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn vc.Client.Upload(ctx, src, u, &p)\n}", "label": 5}
{"code": "public static base_response update(nitro_service client, aaaparameter resource) throws Exception {\n\t\taaaparameter updateresource = new aaaparameter();\n\t\tupdateresource.enablestaticpagecaching = resource.enablestaticpagecaching;\n\t\tupdateresource.enableenhancedauthfeedback = resource.enableenhancedauthfeedback;\n\t\tupdateresource.defaultauthtype = resource.defaultauthtype;\n\t\tupdateresource.maxaaausers = resource.maxaaausers;\n\t\tupdateresource.maxloginattempts = resource.maxloginattempts;\n\t\tupdateresource.failedlogintimeout = resource.failedlogintimeout;\n\t\tupdateresource.aaadnatip = resource.aaadnatip;\n\t\treturn updateresource.update_resource(client);\n\t}", "label": 0}
{"code": "func (c *Client) GetCertAuthorities(caType services.CertAuthType, loadKeys bool, opts ...services.MarshalOption) ([]services.CertAuthority, error) {\n\tif err := caType.Check(); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tout, err := c.Get(c.Endpoint(\"authorities\", string(caType)), url.Values{\n\t\t\"load_keys\": []string{fmt.Sprintf(\"%t\", loadKeys)},\n\t})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvar items []json.RawMessage\n\tif err := json.Unmarshal(out.Bytes(), &items); err != nil {\n\t\treturn nil, err\n\t}\n\tre := make([]services.CertAuthority, len(items))\n\tfor i, raw := range items {\n\t\tca, err := services.GetCertAuthorityMarshaler().UnmarshalCertAuthority(raw, services.SkipValidation())\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tre[i] = ca\n\t}\n\treturn re, nil\n}", "label": 5}
{"code": "def wday_offset(step_time, start_time)\n      return 0 if step_time == start_time\n\n      wday_validations = other_interval_validations.select { |v| v.type == :wday }\n      return 0 if wday_validations.none?\n\n      days = step_time.to_date - start_time.to_date\n      interval = base_interval_validation.validate(step_time, start_time).to_i\n      min_wday = wday_validations.map { |v| TimeUtil.normalize_wday(v.day, week_start) }.min\n      step_wday = TimeUtil.normalize_wday(step_time.wday, week_start)\n\n      days + interval - step_wday + min_wday\n    end", "label": 4}
{"code": "private function isFullyQualifiedName($type, $name)\n    {\n        if (!isset($this->regexes[$type])) {\n            throw new InvalidArgumentException(sprintf(\n                'Regex `%s` is not defined',\n                $type\n            ));\n        }\n        return (preg_match($this->regexes[$type], $name) === 1);\n    }", "label": 2}
{"code": "function isDeclarationOfFunctionExpression(s) {\n        if (s.valueDeclaration && s.valueDeclaration.kind === 218 /* VariableDeclaration */) {\n            var declaration = s.valueDeclaration;\n            return declaration.initializer && declaration.initializer.kind === 179 /* FunctionExpression */;\n        }\n        return false;\n    }", "label": 3}
{"code": "def apply_environment!(hook_context, env)\n      skipped_hooks = \"#{env['SKIP']} #{env['SKIP_CHECKS']} #{env['SKIP_HOOKS']}\".split(/[:, ]/)\n      only_hooks = env.fetch('ONLY') { '' }.split(/[:, ]/)\n      hook_type = hook_context.hook_class_name\n\n      if only_hooks.any? || skipped_hooks.include?('all') || skipped_hooks.include?('ALL')\n        @hash[hook_type]['ALL']['skip'] = true\n      end\n\n      only_hooks.select { |hook_name| hook_exists?(hook_context, hook_name) }.\n                 map { |hook_name| Overcommit::Utils.camel_case(hook_name) }.\n                 each do |hook_name|\n        @hash[hook_type][hook_name] ||= {}\n        @hash[hook_type][hook_name]['skip'] = false\n      end\n\n      skipped_hooks.select { |hook_name| hook_exists?(hook_context, hook_name) }.\n                    map { |hook_name| Overcommit::Utils.camel_case(hook_name) }.\n                    each do |hook_name|\n        @hash[hook_type][hook_name] ||= {}\n        @hash[hook_type][hook_name]['skip'] = true\n      end\n    end", "label": 4}
{"code": "def validate_exclusive_use_of_samesite_enforcement!(attribute)\n      if (intersection = (config[:samesite][:lax].fetch(attribute, []) & config[:samesite][:strict].fetch(attribute, []))).any?\n        raise CookiesConfigError.new(\"samesite cookie config is invalid, cookie(s) #{intersection.join(', ')} cannot be enforced as lax and strict\")\n      end\n    end", "label": 4}
{"code": "func (mr *MockMatcherMockRecorder) Matches(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Matches\", reflect.TypeOf((*MockMatcher)(nil).Matches), arg0)\n}", "label": 5}
{"code": "def edit(self, resource):\n        \"\"\"Edit a job.\n\n        :param resource: :class:`jobs.Job <jobs.Job>` object\n        :return: :class:`jobs.Job <jobs.Job>` object\n        :rtype: jobs.Job\n        \"\"\"\n        schema = JobSchema(exclude=('id', 'status', 'options', 'package_name', 'config_name', 'device_name', 'result_id', 'user_id', 'created', 'updated', 'automatic', 'run_at'))\n        json = self.service.encode(schema, resource)\n\n        schema = JobSchema()\n        resp = self.service.edit(self.base, resource.name, json)\n        return self.service.decode(schema, resp)", "label": 1}
{"code": "public static aaauser_aaagroup_binding[] get(nitro_service service, String username) throws Exception{\n\t\taaauser_aaagroup_binding obj = new aaauser_aaagroup_binding();\n\t\tobj.set_username(username);\n\t\taaauser_aaagroup_binding response[] = (aaauser_aaagroup_binding[]) obj.get_resources(service);\n\t\treturn response;\n\t}", "label": 0}
{"code": "public function success(): Response\n    {\n        Events::dispatch(Events::METHOD_CALLED, new Events\\MethodCalled('Alipay', 'Success', $this->gateway));\n\n        return Response::create('success');\n    }", "label": 2}
{"code": "func NewEventError(err error) *EventError {\n\treturn &EventError{t: time.Now(), err: err}\n}", "label": 5}
{"code": "protected static PropertyDescriptor findPropertyDescriptor(Class aClass, String aPropertyName)\r\n    {\r\n        BeanInfo info;\r\n        PropertyDescriptor[] pd;\r\n        PropertyDescriptor descriptor = null;\r\n\r\n        try\r\n        {\r\n            info = Introspector.getBeanInfo(aClass);\r\n            pd = info.getPropertyDescriptors();\r\n            for (int i = 0; i < pd.length; i++)\r\n            {\r\n                if (pd[i].getName().equals(aPropertyName))\r\n                {\r\n                    descriptor = pd[i];\r\n                    break;\r\n                }\r\n            }\r\n            if (descriptor == null)\r\n            {\r\n                /*\r\n\t\t\t\t * Daren Drummond: \tThrow here so we are consistent\r\n\t\t\t\t * \t\t\t\t\twith PersistentFieldDefaultImpl.\r\n\t\t\t\t */\r\n                throw new MetadataException(\"Can't find property \" + aPropertyName + \" in \" + aClass.getName());\r\n            }\r\n            return descriptor;\r\n        }\r\n        catch (IntrospectionException ex)\r\n        {\r\n            /*\r\n\t\t\t * Daren Drummond: \tThrow here so we are consistent\r\n\t\t\t * \t\t\t\t\twith PersistentFieldDefaultImpl.\r\n\t\t\t */\r\n            throw new MetadataException(\"Can't find property \" + aPropertyName + \" in \" + aClass.getName(), ex);\r\n        }\r\n    }", "label": 0}
{"code": "public void render(OutputStream outputStream, Format format, int dpi) throws PrintingException {\n\t\ttry {\n\t\t\tif (baos == null) {\n\t\t\t\tprepare();\n\t\t\t}\n\t\t\twriteDocument(outputStream, format, dpi);\n\t\t} catch (Exception e) { // NOSONAR\n\t\t\tthrow new PrintingException(e, PrintingException.DOCUMENT_RENDER_PROBLEM);\n\t\t}\n\t}", "label": 0}
{"code": "func (c *Client) GetSAMLConnectors(withSecrets bool) ([]services.SAMLConnector, error) {\n\tout, err := c.Get(c.Endpoint(\"saml\", \"connectors\"),\n\t\turl.Values{\"with_secrets\": []string{fmt.Sprintf(\"%t\", withSecrets)}})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar items []json.RawMessage\n\tif err := json.Unmarshal(out.Bytes(), &items); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tconnectors := make([]services.SAMLConnector, len(items))\n\tfor i, raw := range items {\n\t\tconnector, err := services.GetSAMLConnectorMarshaler().UnmarshalSAMLConnector(raw, services.SkipValidation())\n\t\tif err != nil {\n\t\t\treturn nil, trace.Wrap(err)\n\t\t}\n\t\tconnectors[i] = connector\n\t}\n\treturn connectors, nil\n}", "label": 5}
{"code": "func (c *Config) CheckAndSetDefaults() error {\n\tif c.Listener == nil {\n\t\treturn trace.BadParameter(\"missing parameter Listener\")\n\t}\n\tif c.Context == nil {\n\t\tc.Context = context.TODO()\n\t}\n\tif c.ReadDeadline == 0 {\n\t\tc.ReadDeadline = defaults.ReadHeadersTimeout\n\t}\n\tif c.Clock == nil {\n\t\tc.Clock = clockwork.NewRealClock()\n\t}\n\treturn nil\n}", "label": 5}
{"code": "def ref_data\n      r = request(:get, '/WebObjects/iTunesConnect.woa/ra/apps/version/ref')\n      data = parse_response(r, 'data')\n      Spaceship::Tunes::AppVersionRef.factory(data)\n    end", "label": 4}
{"code": "def normalized_userinfo\n      return nil unless self.userinfo\n      return @normalized_userinfo if defined?(@normalized_userinfo)\n      @normalized_userinfo ||= begin\n        current_user = self.normalized_user\n        current_password = self.normalized_password\n        if !current_user && !current_password\n          nil\n        elsif current_user && current_password\n          \"#{current_user}:#{current_password}\".dup\n        elsif current_user && !current_password\n          \"#{current_user}\".dup\n        end\n      end\n      # All normalized values should be UTF-8\n      if @normalized_userinfo\n        @normalized_userinfo.force_encoding(Encoding::UTF_8)\n      end\n      @normalized_userinfo\n    end", "label": 4}
{"code": "public Tree determineHead(Tree t, Tree parent) {\r\n    if (nonTerminalInfo == null) {\r\n      throw new RuntimeException(\"Classes derived from AbstractCollinsHeadFinder must\" + \" create and fill HashMap nonTerminalInfo.\");\r\n    }\r\n    if (t == null || t.isLeaf()) {\r\n      return null;\r\n    }\r\n    if (DEBUG) {\r\n      System.err.println(\"determineHead for \" + t.value());\r\n    }\r\n    \r\n    Tree[] kids = t.children();\r\n\r\n    Tree theHead;\r\n    // first check if subclass found explicitly marked head\r\n    if ((theHead = findMarkedHead(t)) != null) {\r\n      if (DEBUG) {\r\n        System.err.println(\"Find marked head method returned \" +\r\n                           theHead.label() + \" as head of \" + t.label());\r\n      }\r\n      return theHead;\r\n    }\r\n\r\n    // if the node is a unary, then that kid must be the head\r\n    // it used to special case preterminal and ROOT/TOP case\r\n    // but that seemed bad (especially hardcoding string \"ROOT\")\r\n    if (kids.length == 1) {\r\n      if (DEBUG) {\r\n        System.err.println(\"Only one child determines \" +\r\n                           kids[0].label() + \" as head of \" + t.label());\r\n      }\r\n      return kids[0];\r\n    }\r\n\r\n    return determineNonTrivialHead(t, parent);\r\n  }", "label": 0}
{"code": "public function setReplacementValue($var)\n    {\n        GPBUtil::checkMessage($var, \\Google\\Cloud\\Dlp\\V2\\Value::class);\n        $this->replacement_value = $var;\n\n        return $this;\n    }", "label": 2}
{"code": "function (interval) {\n    return _.find(notes, function (n) {\n      return root.transpose(interval).enharmonic(n);\n    });\n  }", "label": 3}
{"code": "def text_anchor(anchor)\n      Kernel.raise ArgumentError, \"Unknown anchor constant: #{anchor}\" unless ANCHOR_TYPE_NAMES.key?(anchor.to_i)\n      primitive \"text-anchor #{ANCHOR_TYPE_NAMES[anchor.to_i]}\"\n    end", "label": 4}
{"code": "def setup_logging(self):\n        \"\"\"Setup of application logging.\"\"\"\n        is_custom_logging = len(self.options.logging_config) > 0\n        is_custom_logging = is_custom_logging and os.path.isfile(self.options.logging_config)\n        is_custom_logging = is_custom_logging and not self.options.dry_run\n\n        if is_custom_logging:\n            Logger.configure_by_file(self.options.logging_config)\n        else:\n            logging_format = \"%(asctime)-15s - %(name)s - %(message)s\"\n            if self.options.dry_run:\n                logging_format = \"%(name)s - %(message)s\"\n            Logger.configure_default(logging_format, self.logging_level)", "label": 1}
{"code": "def identify_marker_genes_rf(self, labels=None, clusters=None,\n                                 n_genes=4000):\n        \"\"\"\n        Ranks marker genes for each cluster using a random forest\n        classification approach.\n\n        Parameters\n        ----------\n\n        labels - numpy.array or str, optional, default None\n            Cluster labels to use for marker gene identification. If None,\n            assumes that one of SAM's clustering algorithms has been run. Can\n            be a string (i.e. 'louvain_clusters', 'kmeans_clusters', etc) to\n            specify specific cluster labels in adata.obs.\n            \n        clusters - int or array-like, default None\n            A number or vector corresponding to the specific cluster ID(s)\n            for which marker genes will be calculated. If None, marker genes\n            will be computed for all clusters.\n\n        n_genes - int, optional, default 4000\n            By default, trains the classifier on the top 4000 SAM-weighted\n            genes.\n\n        \"\"\"\n        if(labels is None):\n            try:\n                keys = np.array(list(self.adata.obs_keys()))\n                lbls = self.adata.obs[ut.search_string(\n                    keys, '_clusters')[0][0]].get_values()\n            except KeyError:\n                print(\"Please generate cluster labels first or set the \"\n                      \"'labels' keyword argument.\")\n                return\n        elif isinstance(labels, str):\n            lbls = self.adata.obs[labels].get_values().flatten()\n        else:\n            lbls = labels\n\n        from sklearn.ensemble import RandomForestClassifier\n\n        markers = {}\n        if clusters == None:\n            lblsu = np.unique(lbls)\n        else:\n            lblsu = np.unique(clusters)\n\n        indices = np.argsort(-self.adata.var['weights'].values)\n        X = self.adata.layers['X_disp'][:, indices[:n_genes]].toarray()\n        for K in range(lblsu.size):\n            print(K)\n            y = np.zeros(lbls.size)\n\n            y[lbls == lblsu[K]] = 1\n\n            clf = RandomForestClassifier(n_estimators=100, max_depth=None,\n                                         random_state=0)\n\n            clf.fit(X, y)\n\n            idx = np.argsort(-clf.feature_importances_)\n\n            markers[lblsu[K]] = self.adata.uns['ranked_genes'][idx]\n        \n        if clusters is None:\n            self.adata.uns['marker_genes_rf'] = markers\n\n        return markers", "label": 1}
{"code": "def declared_caveat(key, value):\n    '''Returns a \"declared\" caveat asserting that the given key is\n    set to the given value.\n\n    If a macaroon has exactly one first party caveat asserting the value of a\n    particular key, then infer_declared will be able to infer the value, and\n    then the check will allow the declared value if it has the value\n    specified here.\n\n    If the key is empty or contains a space, it will return an error caveat.\n    '''\n    if key.find(' ') >= 0 or key == '':\n        return error_caveat('invalid caveat \\'declared\\' key \"{}\"'.format(key))\n    return _first_party(COND_DECLARED, key + ' ' + value)", "label": 1}
{"code": "public function register(): void\n    {\n        $this->commands($this->commands);\n\n        $this->app->singleton(Dashboard::class, function () {\n            return new Dashboard();\n        });\n\n        if (! Route::hasMacro('screen')) {\n            Route::macro('screen', function ($url, $screen, $name = null) {\n                /* @var \\Illuminate\\Routing\\Router $this */\n                return $this->any($url.'/{method?}/{argument?}', [$screen, 'handle'])\n                    ->name($name);\n            });\n        }\n\n        if (! defined('PLATFORM_PATH')) {\n            /*\n             * Get the path to the ORCHID Platform folder.\n             */\n            define('PLATFORM_PATH', realpath(__DIR__.'/../../../'));\n        }\n\n        $this->mergeConfigFrom(\n            realpath(PLATFORM_PATH.'/config/platform.php'), 'platform'\n        );\n    }", "label": 2}
{"code": "@SuppressWarnings(\"unchecked\")\r\n  public static <E, C extends Counter<E>> C scale(C c, double s) {\r\n    C scaled = (C) c.getFactory().create();\r\n    for (E key : c.keySet()) {\r\n      scaled.setCount(key, c.getCount(key) * s);\r\n    }\r\n    return scaled;\r\n  }", "label": 0}
{"code": "final void compress(final File backupFile,\n      final AppenderRollingProperties properties) {\n    if (this.isCompressed(backupFile)) {\n      LogLog.debug(\"Backup log file \" + backupFile.getName()\n          + \" is already compressed\");\n      return; // try not to do unnecessary work\n    }\n    final long lastModified = backupFile.lastModified();\n    if (0L == lastModified) {\n      LogLog.debug(\"Backup log file \" + backupFile.getName()\n          + \" may have been scavenged\");\n      return; // backup file may have been scavenged\n    }\n    final File deflatedFile = this.createDeflatedFile(backupFile);\n    if (deflatedFile == null) {\n      LogLog.debug(\"Backup log file \" + backupFile.getName()\n          + \" may have been scavenged\");\n      return; // an error occurred creating the file\n    }\n    if (this.compress(backupFile, deflatedFile, properties)) {\n      deflatedFile.setLastModified(lastModified);\n      FileHelper.getInstance().deleteExisting(backupFile);\n      LogLog.debug(\"Compressed backup log file to \" + deflatedFile.getName());\n    } else {\n      FileHelper.getInstance().deleteExisting(deflatedFile); // clean up\n      LogLog\n          .debug(\"Unable to compress backup log file \" + backupFile.getName());\n    }\n  }", "label": 0}
{"code": "def run_iqtree(phy, model, threads, cluster, node):\n    \"\"\"\n    run IQ-Tree\n    \"\"\"\n    # set ppn based on threads\n    if threads > 24:\n        ppn = 24\n    else:\n        ppn = threads\n    tree = '%s.treefile' % (phy)\n    if check(tree) is False:\n        if model is False:\n            model = 'TEST'\n        dir = os.getcwd()\n        command = 'iqtree-omp -s %s -m %s -nt %s -quiet' % \\\n                    (phy, model, threads)\n        if cluster is False:\n            p = Popen(command, shell = True)\n        else:\n            if node is False:\n               node = '1'\n            qsub = 'qsub -l nodes=%s:ppn=%s -m e -N iqtree' % (node, ppn)\n            command = 'cd /tmp; mkdir iqtree; cd iqtree; cp %s/%s .; %s; mv * %s/; rm -r ../iqtree' \\\n                    % (dir, phy, command, dir)\n            re_call = 'cd %s; %s --no-fast --iq' % (dir.rsplit('/', 1)[0], ' '.join(sys.argv))\n            p = Popen('echo \"%s;%s\" | %s' % (command, re_call, qsub), shell = True)\n        p.communicate()\n    return tree", "label": 1}
{"code": "func (a *AttrV2) Stat(info os.FileInfo) {\n\tswitch {\n\tcase info.IsDir():\n\t\ta.Type = FileTypeDirectory\n\tcase info.Mode()&os.ModeSymlink == os.ModeSymlink:\n\t\ta.Type = FileTypeSymlink\n\tdefault:\n\t\ta.Type = FileTypeRegular\n\t}\n\n\ta.Size = uint64(info.Size())\n\n\ta.Mask = AttrValidType | AttrValidSize\n\n\ta.sysStat(info)\n}", "label": 5}
{"code": "func displayKey(prefix, location string, key *os.File) error {\n\tdefer key.Seek(0, os.SEEK_SET)\n\n\tkr, err := openpgp.ReadArmoredKeyRing(key)\n\tif err != nil {\n\t\treturn errwrap.Wrap(errors.New(\"error reading key\"), err)\n\t}\n\n\tlog.Printf(\"prefix: %q\\nkey: %q\", prefix, location)\n\tfor _, k := range kr {\n\t\tstdout.Printf(\"gpg key fingerprint is: %s\", fingerToString(k.PrimaryKey.Fingerprint))\n\t\tfor _, sk := range k.Subkeys {\n\t\t\tstdout.Printf(\"    Subkey fingerprint: %s\", fingerToString(sk.PublicKey.Fingerprint))\n\t\t}\n\n\t\tfor n := range k.Identities {\n\t\t\tstdout.Printf(\"\\t%s\", n)\n\t\t}\n\t}\n\n\treturn nil\n}", "label": 5}
{"code": "public function state()\n    {\n        $end = $this->pathEnd();\n        return (isset($end['id']) || isset($end['name']))\n            ? self::STATE_NAMED\n            : self::STATE_INCOMPLETE;\n    }", "label": 2}
{"code": "def aria_selected_link_to(text, link, options = {})\n      link_to(\n        text,\n        link,\n        options.merge(\n          \"aria-selected\": is_active_link?(link, options[:aria_link_type] || :inclusive)\n        )\n      )\n    end", "label": 4}
{"code": "func (c *Client) DeleteSession(namespace, id string) error {\n\tif namespace == \"\" {\n\t\treturn trace.BadParameter(MissingNamespaceError)\n\t}\n\t_, err := c.Delete(c.Endpoint(\"namespaces\", namespace, \"sessions\", id))\n\treturn trace.Wrap(err)\n}", "label": 5}
{"code": "public static systemcollectionparam get(nitro_service service) throws Exception{\n\t\tsystemcollectionparam obj = new systemcollectionparam();\n\t\tsystemcollectionparam[] response = (systemcollectionparam[])obj.get_resources(service);\n\t\treturn response[0];\n\t}", "label": 0}
{"code": "public E argmax(Comparator<E> tieBreaker) {\r\n    int max = Integer.MIN_VALUE;\r\n    E argmax = null;\r\n    for (E key : keySet()) {\r\n      int count = getIntCount(key);\r\n      if (argmax == null || count > max || (count == max && tieBreaker.compare(key, argmax) < 0)) {\r\n        max = count;\r\n        argmax = key;\r\n      }\r\n    }\r\n    return argmax;\r\n  }", "label": 0}
{"code": "function _gpfInterfaceQueryTryIUnknown(interfaceSpecifier, queriedObject) {\n        if (_gpfInterfaceIsImplementedBy(gpf.interfaces.IUnknown, queriedObject)) {\n            return _gpfInterfaceQueryThroughIUnknown(interfaceSpecifier, queriedObject);\n        }\n    }", "label": 3}
{"code": "func (ipl *IPList) Lookup(ip net.IP) (r Range, ok bool) {\n\tif ipl == nil {\n\t\treturn\n\t}\n\t// TODO: Perhaps all addresses should be converted to IPv6, if the future\n\t// of IP is to always be backwards compatible. But this will cost 4x the\n\t// memory for IPv4 addresses?\n\tv4 := ip.To4()\n\tif v4 != nil {\n\t\tr, ok = ipl.lookup(v4)\n\t\tif ok {\n\t\t\treturn\n\t\t}\n\t}\n\tv6 := ip.To16()\n\tif v6 != nil {\n\t\treturn ipl.lookup(v6)\n\t}\n\tif v4 == nil && v6 == nil {\n\t\tr = Range{\n\t\t\tDescription: \"bad IP\",\n\t\t}\n\t\tok = true\n\t}\n\treturn\n}", "label": 5}
{"code": "def read_perseus(path_or_file, **kwargs):\n    \"\"\"\n    Read a Perseus-formatted matrix into a pd.DataFrame.\n    Annotation rows will be converted into a multi-index.\n\n    By monkey-patching the returned pd.DataFrame a `to_perseus`\n    method for exporting the pd.DataFrame is made available.\n\n    :param path_or_file: File path or file-like object\n    :param kwargs: Keyword arguments passed as-is to pandas.read_csv\n    :returns: The parsed data frame\n    \"\"\"\n    annotations = read_annotations(path_or_file, separator)\n    column_index = create_column_index(annotations)\n    if 'usecols' in kwargs:\n\t    usecols = kwargs['usecols']\n\t    if type(usecols[0]) is str:\n\t\t    usecols = sorted([list(column_index).index(x) for x in usecols])\n\t    column_index = column_index[usecols]\n    kwargs['dtype'] = dict(kwargs.get('dtype', {}), **annotations.get('dtype', {}))\n    kwargs['converters'] = dict(kwargs.get('converters', {}), **annotations.get('converters', {}))\n    df = pd.read_csv(path_or_file, sep=separator, comment='#', **kwargs)\n    df.columns = column_index\n    return df", "label": 1}
{"code": "private function query_spec( $args, $operator = 'AND' ) {\n\t\t$operator = strtoupper( $operator );\n\t\t$count    = count( $args );\n\t\t$filtered = array();\n\n\t\tforeach ( $this->spec as $key => $to_match ) {\n\t\t\t$matched = 0;\n\t\t\tforeach ( $args as $m_key => $m_value ) {\n\t\t\t\tif ( array_key_exists( $m_key, $to_match ) && $m_value === $to_match[ $m_key ] ) {\n\t\t\t\t\t$matched++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ( 'AND' === $operator && $matched === $count )\n\t\t\t\t|| ( 'OR' === $operator && $matched > 0 )\n\t\t\t\t|| ( 'NOT' === $operator && 0 === $matched ) ) {\n\t\t\t\t\t$filtered[ $key ] = $to_match;\n\t\t\t}\n\t\t}\n\n\t\treturn $filtered;\n\t}", "label": 2}
{"code": "function(delaySort)\n  {\n    var removed = AP.shift.apply( this );\n\n    this.trigger( Collection.Events.Remove, [this, removed, 0] );\n\n    if ( !delaySort )\n    {\n      this.sort( undefined, undefined, true );\n    }\n\n    return removed;\n  }", "label": 3}
{"code": "def bind_model_cls(self, model_cls):\n        \"\"\"Bind field to model class.\"\"\"\n        if self.model_cls:\n            raise errors.Error('\"{0}\" has been already bound to \"{1}\" and '\n                               'could not be rebound to \"{2}\"'.format(\n                                   self, self.model_cls, model_cls))\n        self.model_cls = model_cls\n        return self", "label": 1}
{"code": "def entrypoint(section, option):\n    \"\"\"\n    Returns the the entry point object given a section, option pair.\n\n    :param str section: The section name in the entry point collection\n    :param str option: The option name in the entry point collection\n    :return:  The entry point object if available.\n    \"\"\"\n    try:\n        return entrypoints(section)[option]\n    except KeyError:\n        raise KeyError('Cannot resolve type \"{}\" to a recognised vsgen \"{}\" type.'.format(option, section))", "label": 1}
{"code": "def filter_missing_rna(s2bins, bins2s, rna_cov):\n    \"\"\"\n    remove any bins that don't have 16S\n    \"\"\"\n    for bin, scaffolds in list(bins2s.items()):\n        c = 0\n        for s in scaffolds:\n            if s in rna_cov:\n                c += 1\n        if c == 0:\n            del bins2s[bin]\n    for scaffold, bin in list(s2bins.items()):\n        if bin not in bins2s:\n            del s2bins[scaffold]\n    return s2bins, bins2s", "label": 1}
{"code": "public boolean removeWriter(Object key, Object resourceId)\r\n    {\r\n        boolean result = false;\r\n        ObjectLocks objectLocks = null;\r\n        synchronized(locktable)\r\n        {\r\n            objectLocks = (ObjectLocks) locktable.get(resourceId);\r\n            if(objectLocks != null)\r\n            {\r\n                /**\r\n                 * MBAIRD, last one out, close the door and turn off the lights.\r\n                 * if no locks (readers or writers) exist for this object, let's remove\r\n                 * it from the locktable.\r\n                 */\r\n                LockEntry entry = objectLocks.getWriter();\r\n                if(entry != null && entry.isOwnedBy(key))\r\n                {\r\n                    objectLocks.setWriter(null);\r\n                    result = true;\r\n\r\n                    // no need to check if writer is null, we just set it.\r\n                    if(objectLocks.getReaders().size() == 0)\r\n                    {\r\n                        locktable.remove(resourceId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }", "label": 0}
{"code": "private void checkReadonlyAccessForNativePKs(FieldDescriptorDef fieldDef, String checkLevel)\r\n    {\r\n        if (CHECKLEVEL_NONE.equals(checkLevel))\r\n        {\r\n            return;\r\n        }\r\n\r\n        String access  = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_ACCESS);\r\n        String autoInc = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_AUTOINCREMENT);\r\n\r\n        if (\"database\".equals(autoInc) && !\"readonly\".equals(access))\r\n        {\r\n            LogHelper.warn(true,\r\n                           FieldDescriptorConstraints.class,\r\n                           \"checkAccess\",\r\n                           \"The field \"+fieldDef.getName()+\" in class \"+fieldDef.getOwner().getName()+\" is set to database auto-increment. Therefore the field's access is set to 'readonly'.\");\r\n            fieldDef.setProperty(PropertyHelper.OJB_PROPERTY_ACCESS, \"readonly\");\r\n        }\r\n    }", "label": 0}
{"code": "public function prependAttempt(callable $middleware, $name = null)\n    {\n        $this->add(self::ATTEMPT, $name, $middleware, true);\n    }", "label": 2}
{"code": "func GetHostPartIP(ip net.IP, mask net.IPMask) (net.IP, error) {\n\t// Find the effective starting of address and mask\n\tis, ms, err := compareIPMask(ip, mask)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot compute host portion ip address because %s\", err)\n\t}\n\n\t// Compute host portion\n\tout := GetIPCopy(ip)\n\tfor i := 0; i < len(mask[ms:]); i++ {\n\t\tout[is+i] &= ^mask[ms+i]\n\t}\n\n\treturn out, nil\n}", "label": 5}
